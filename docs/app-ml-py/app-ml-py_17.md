# éšæœºæŠ•å½±

> åŸæ–‡ï¼š[`geostatsguy.github.io/MachineLearningDemos_Book/MachineLearning_random_projection.html`](https://geostatsguy.github.io/MachineLearningDemos_Book/MachineLearning_random_projection.html)

Michael J. Pyrczï¼Œæ•™æˆï¼Œå¾·å…‹è¨æ–¯å¤§å­¦å¥¥æ–¯æ±€åˆ†æ ¡

[Twitter](https://twitter.com/geostatsguy) | [GitHub](https://github.com/GeostatsGuy) | [ç½‘ç«™](http://michaelpyrcz.com) | [Google Scholar](https://scholar.google.com/citations?user=QVZ20eQAAAAJ&hl=en&oi=ao) | [åœ°ç»Ÿè®¡å­¦ä¹¦ç±](https://www.amazon.com/Geostatistical-Reservoir-Modeling-Michael-Pyrcz/dp/0199731446) | [YouTube](https://www.youtube.com/channel/UCLqEr-xV-ceHdXXXrTId5ig) | [Python ä¸­åº”ç”¨åœ°ç»Ÿè®¡å­¦ç”µå­ä¹¦](https://geostatsguy.github.io/GeostatsPyDemos_Book/intro.html) | [Python ä¸­åº”ç”¨æœºå™¨å­¦ä¹ ç”µå­ä¹¦](https://geostatsguy.github.io/MachineLearningDemos_Book/) | [LinkedIn](https://www.linkedin.com/in/michael-pyrcz-61a648a1)

ç”µå­ä¹¦â€œPython ä¸­åº”ç”¨æœºå™¨å­¦ä¹ ï¼šåŠ¨æ‰‹æŒ‡å—åŠä»£ç â€çš„ä¸€ç« ã€‚

å°†æ­¤ç”µå­ä¹¦å¼•ç”¨å¦‚ä¸‹ï¼š

Pyrcz, M.J., 2024, *Python ä¸­åº”ç”¨æœºå™¨å­¦ä¹ ï¼šåŠ¨æ‰‹æŒ‡å—åŠä»£ç * [ç”µå­ä¹¦]. Zenodo. doi:10.5281/zenodo.15169138 ![DOI](https://doi.org/10.5281/zenodo.15169138)

æœ¬ä¹¦ä¸­çš„å·¥ä½œæµç¨‹ä»¥åŠæ›´å¤šå†…å®¹å¯åœ¨ä»¥ä¸‹é“¾æ¥æ‰¾åˆ°ï¼š

å°† MachineLearningDemos GitHub ä»“åº“å¼•ç”¨å¦‚ä¸‹ï¼š

Pyrcz, M.J., 2024, *MachineLearningDemos: Python æœºå™¨å­¦ä¹ æ¼”ç¤ºå·¥ä½œæµç¨‹ä»“åº“* (0.0.3) [è½¯ä»¶]. Zenodo. DOI: 10.5281/zenodo.13835312\. GitHub ä»“åº“ï¼š[GeostatsGuy/MachineLearningDemos](https://github.com/GeostatsGuy/MachineLearningDemos) ![DOI](https://zenodo.org/doi/10.5281/zenodo.13835312)

ä½œè€…ï¼šMichael J. Pyrcz

Â© ç‰ˆæƒæ‰€æœ‰ 2024ã€‚

æœ¬ç« æ˜¯å…³äº**éšæœºæŠ•å½±**çš„æ•™ç¨‹å’Œæ¼”ç¤ºã€‚

**YouTube è®²åº§**ï¼šæŸ¥çœ‹æˆ‘åœ¨ä»¥ä¸‹ä¸»é¢˜ä¸Šçš„è®²åº§ï¼š

+   [æœºå™¨å­¦ä¹ ç®€ä»‹](https://youtu.be/zOUM_AnI1DQ?si=wzWdJ35qJ9n8O6Bl)

+   [ç»´åº¦è¯…å’’ã€é™ç»´ã€ä¸»æˆåˆ†åˆ†æ](https://youtu.be/-to3JXiae9Y?si=W1j2CwR9t0t8hxIB)

+   [å¤šç»´å°ºåº¦åˆ†æå’ŒéšæœºæŠ•å½±](https://youtu.be/Yt0o8ukIOKU?si=_ri1NPwKVdhYzgO3)

è¿™äº›è®²åº§éƒ½æ˜¯æˆ‘ YouTube ä¸Šçš„[æœºå™¨å­¦ä¹ è¯¾ç¨‹](https://youtube.com/playlist?list=PLG19vXLQHvSC2ZKFIkgVpI9fCjkN38kwf&si=XonjO2wHdXffMpeI)çš„ä¸€éƒ¨åˆ†ï¼Œå…¶ä¸­åŒ…å«æœ‰è‰¯å¥½æ–‡æ¡£è®°å½•çš„ Python å·¥ä½œæµç¨‹å’Œäº¤äº’å¼ä»ªè¡¨æ¿ã€‚æˆ‘çš„ç›®æ ‡æ˜¯åˆ†äº«æ˜“äºè·å–ã€å¯æ“ä½œå’Œå¯é‡å¤çš„æ•™è‚²å†…å®¹ã€‚å¦‚æœä½ æƒ³çŸ¥é“æˆ‘çš„åŠ¨æœºï¼Œè¯·æŸ¥çœ‹[Michael çš„æ•…äº‹](https://michaelpyrcz.com/my-story)ã€‚

## éšæœºæŠ•å½±çš„åŠ¨æœº

å‡è®¾æˆ‘ä»¬éœ€è¦é€šè¿‡ä»$m$ä¸ªç‰¹å¾åˆ°$p$ä¸ªç‰¹å¾ï¼ˆå³ä½ç»´ç©ºé—´ï¼‰çš„æŠ•å½±æ¥å®ç°éå¸¸å¿«é€Ÿçš„é™ç»´ï¼Œ

$$ ğ‘, \quad \text{å…¶ä¸­} \quad ğ‘ << ğ‘š $$

åœ¨è¿™ç§æƒ…å†µä¸‹ï¼Œ

+   ç›®å‰æˆ‘ä»¬å¹¶æ²¡æœ‰æ‰€æœ‰æ•°æ®ï¼ˆä¾‹å¦‚ï¼Œå®æ—¶æ•°æ®ï¼‰ï¼Œå› æ­¤æˆ‘ä»¬æ— æ³•è®¡ç®—åæ–¹å·®çŸ©é˜µæˆ–ç›¸ä¼¼åº¦çŸ©é˜µ

+   ç”±äº $m$ çš„å¤§å°ï¼Œæˆ‘ä»¬æ— æ³•æ‰¿æ‹…è®¡ç®—æ­£äº¤å˜æ¢çš„æˆæœ¬

æˆ‘ä»¬èƒ½å¦é€šè¿‡éšæœºçº¿æ€§æŠ•å½±å°† $m$ ä¸ªç‰¹å¾è½¬æ¢åˆ°ä½ç»´çš„ $p$ï¼Ÿ

![](img/9ff1ace2c6fcc051cac02de9dd663851.png)

éšæœºæŠ•å½±çš„æ¦‚å¿µï¼Œä¸å¤šç»´å°ºåº¦åˆ†æç›¸å¯¹æ¯”ã€‚

å…¶ä¸­ $ğ‘‹_{1 \times m}$ æ˜¯ä¸€ä¸ªå…³äº $m$ ä¸ªç‰¹å¾çš„å•ä¸€æ•°æ®æ ·æœ¬ï¼Œ$ğ‘…_{p \times m}$ æ˜¯ä¸€ä¸ªéšæœºæŠ•å½±çŸ©é˜µï¼Œå¡«å……äº†éšæœºå€¼ï¼Œè€Œ $ğ‘‹_{p \times n}^{ğ‘…ğ‘ƒ}$ æ˜¯æŠ•å½±åˆ° $p$ ä¸ªç‰¹å¾çš„æ–°æ•°æ®ã€‚

## éšæœºæŠ•å½±

ä¸€ç§æ›¿ä»£ä¸»æˆåˆ†åˆ†æå’Œå¤šç»´å°ºåº¦åˆ†æçš„æ–¹æ³•ï¼Œå®ƒä¾èµ–äºä¸€ä¸ªéšæœºï¼ˆ$p \times n$ï¼‰æŠ•å½±çŸ©é˜µï¼Œ$ğ‘…_{p \times m}$ã€‚

+   æ‰€æœ‰å€¼éƒ½æ˜¯ç‹¬ç«‹çš„éšæœºå˜é‡ï¼Œé€šå¸¸æ˜¯æ ‡å‡†æ­£æ€åˆ†å¸ƒï¼Œ$N\left[0,1\right]$ã€‚

ä¸ºäº†é¿å…å¤±çœŸï¼ŒæŠ•å½± $ğ‘…_{p \times m}$ åº”è¯¥æ˜¯æ­£äº¤çš„ï¼Œä½†å¦‚ä¸Šæ‰€è¿°ï¼Œç¡®ä¿æ­£äº¤æ€§è®¡ç®—æˆæœ¬å¤ªé«˜ï¼Œä¸ºäº†ç†è§£è¿™æ˜¯å¦‚ä½•å·¥ä½œçš„ï¼Œæˆ‘ä»¬éœ€è¦äº†è§£ï¼Œ

+   **èµ«å¥‡-å°¼å°”æ£®ï¼ˆ1994ï¼‰** - é«˜ç»´ç©ºé—´ä¸­å­˜åœ¨å¤§é‡æ­£äº¤å‘é‡ï¼Œå¯èƒ½æ˜¯å‡†æ­£äº¤çš„

+   **çº¦ç¿°é€Š-æ—å¾·æ–¯ç‰¹æ‹‰æ–¯å¼•ç†ï¼ˆ1984ï¼‰** - é«˜ç»´ç©ºé—´ä¸­çš„ç‚¹å¯ä»¥ä»¥é«˜æ¦‚ç‡çº¿æ€§åµŒå…¥åˆ°ä½ç»´ç©ºé—´ä¸­ï¼Œè¿‘ä¼¼ä¿æŒæˆå¯¹è·ç¦»

## é«˜ç»´ç©ºé—´ä¸­çš„è¿‘æ­£äº¤å‘é‡

ç½—ä¼¯ç‰¹Â·èµ«å¥‡-å°¼å°”æ£®ï¼ˆ1994ï¼‰è¯æ˜äº†åœ¨é«˜ç»´ç©ºé—´ä¸­ï¼Œå­˜åœ¨æ¯”ä¸¥æ ¼æ­£äº¤æ–¹å‘å¤šå¾—å¤šçš„å‡ ä¹æ­£äº¤æ–¹å‘ã€‚

+   éšæœºçŸ©é˜µåœ¨é«˜ç»´ä¸­å¯èƒ½è¶³å¤Ÿæ¥è¿‘æ­£äº¤ã€‚

$$ ğ‘…_{mÃ—p}^ğ‘‡ ğ‘…_{pÃ—m} \approx ğ¼_{mÃ—m} $$

å…¶ä¸­ $I$ æ˜¯å•ä½çŸ©é˜µï¼Œ$\approx$ è¡¨ç¤ºè¿‘ä¼¼ç­‰äºå•ä½çŸ©é˜µã€‚

å¦‚æœç»´åº¦è¶³å¤Ÿå¤§ï¼Œå³é«˜ç»´ç©ºé—´ï¼Œæˆ‘ä»¬çš„éšæœºå‘é‡å°†è¶³å¤Ÿæ¥è¿‘æ­£äº¤ã€‚

+   éšç€ç»´åº¦çš„å¢åŠ ï¼Œç‰¹å¾çš„æ•°é‡ $ğ‘š$ï¼Œæ¦‚ç‡å¢åŠ 

## é«˜ç»´ç©ºé—´ä¸­æˆå¯¹è·ç¦»è¿‘ä¼¼çš„ä¿çœŸæ¦‚ç‡

è¿™ç§éšæœºæ–¹æ³•ä¹‹æ‰€ä»¥åœ¨å®è·µä¸­æœ‰æ•ˆï¼Œæ˜¯å› ä¸ºçº¦ç¿°é€Š-æ—å¾·æ–¯ç‰¹æ‹‰æ–¯å¼•ç†ï¼š

*åœ¨æ•°å­¦ä¸­ï¼Œçº¦ç¿°é€Š-æ—å¾·æ–¯ç‰¹æ‹‰æ–¯å¼•ç†æ˜¯å…³äºä»é«˜ç»´ç©ºé—´åˆ°ä½ç»´æ¬§å‡ é‡Œå¾—ç©ºé—´ä½å¤±çœŸåµŒå…¥çš„ä¸€ä¸ªç»“æœã€‚å¼•ç†è¡¨æ˜ï¼Œé«˜ç»´ç©ºé—´ä¸­çš„ä¸€å°éƒ¨åˆ†ç‚¹å¯ä»¥åµŒå…¥åˆ°ä¸€ä¸ªç»´åº¦ä½å¾—å¤šçš„ç©ºé—´ä¸­ï¼Œä½¿å¾—ç‚¹ä¹‹é—´çš„è·ç¦»å‡ ä¹ä¿æŒä¸å˜ã€‚ç”¨äºåµŒå…¥çš„æ˜ å°„è‡³å°‘æ˜¯ Lipschitz è¿ç»­çš„ï¼Œç”šè‡³å¯ä»¥å–ä¸ºæ­£äº¤æŠ•å½±ã€‚- æ¥è‡ªç»´åŸºç™¾ç§‘çš„æ–‡ç« ã€‚*

åœ¨é«˜ç»´ç©ºé—´ä¸­ï¼Œç‚¹å¯ä»¥çº¿æ€§åµŒå…¥åˆ°ä¸€ä¸ªç»´åº¦ä½å¾—å¤šçš„ç©ºé—´ä¸­ï¼Œä½¿å¾—ç‚¹ä¹‹é—´çš„è·ç¦»å‡ ä¹ä¿æŒä¸å˜ï¼ˆæˆ‘ä»¬å…è®¸æœ‰è¯¯å·®ï¼Œğœ€ï¼‰ã€‚

æˆ‘ä»¬å¯ä»¥æ ¹æ®æ•°æ®é›†çš„å¤§å°ï¼Œnï¼Œå’ŒæœŸæœ›çš„è¯¯å·®é™åˆ¶ï¼ŒÎµï¼Œä»¥åŠåŸºäºéšæœºæŠ•å½±çš„é«˜æ¦‚ç‡ï¼Œè®¡ç®—å‡ºå¯ä»¥æŠ•å½±çš„æœ€å°ç»´åº¦æ•°ï¼Œpï¼Œ

$$ ğ‘ > \frac{lnâ¡(ğ‘›)}{ğœ€Â²} $$

ä¾‹å¦‚ï¼Œå¯¹äºå…·æœ‰ 10%ï¼ˆ0.1ï¼‰æˆå¯¹è·ç¦»è¯¯å·®çš„ 1,000 ä¸ªæ•°æ®ï¼Œæˆ‘ä»¬å¯ä»¥éšæœºæŠ•å½±åˆ° 690 ç»´ã€‚

+   è¿™ä¸ªæœ€å°å€¼ä¸ä¾èµ–äºé—®é¢˜çš„åŸå§‹ç»´åº¦ï¼Œ$ğ‘š$ï¼

## åŠ è½½æ‰€éœ€çš„åº“

ä»¥ä¸‹ä»£ç åŠ è½½äº†æ‰€éœ€çš„åº“ã€‚è¿™äº›åº“åº”è¯¥å·²ç»ä¸ Anaconda 3 ä¸€èµ·å®‰è£…ã€‚

```py
ignore_warnings = True                                        # ignore warnings?
import numpy as np                                            # ndarrays for gridded data
import pandas as pd                                           # DataFrames for tabular data
import os                                                     # set working directory, run executables
import matplotlib.pyplot as plt                               # for plotting
from matplotlib.ticker import (MultipleLocator,AutoMinorLocator,NullLocator,FuncFormatter) # control of axes ticks
import matplotlib.patches as patches                          # add square to matrix plot
from scipy import stats                                       # summary statistics
import math                                                   # trigonometry etc.
import scipy.signal as signal                                 # kernel for moving window calculation
import random                                                 # for random numbers
import seaborn as sns                                         # for matrix scatter plots
from scipy import linalg                                      # for linear regression

from sklearn.random_projection import GaussianRandomProjection # random projection
from sklearn.random_projection import johnson_lindenstrauss_min_dim
from sklearn.random_projection import SparseRandomProjection
from sklearn.metrics.pairwise import euclidean_distances
from sklearn.preprocessing import StandardScaler              # standardize features
plt.rc('axes', axisbelow=True)                                # plot all grids below the plot elements
if ignore_warnings == True:                                   
    import warnings
    warnings.filterwarnings('ignore')
cmap = plt.cm.inferno                                         # color map
seed = 42                                                     # random number seed 
```

å¦‚æœæ‚¨é‡åˆ°åŒ…å¯¼å…¥é”™è¯¯ï¼Œæ‚¨å¯èƒ½éœ€è¦é¦–å…ˆå®‰è£…è¿™äº›åŒ…ä¸­çš„æŸäº›åŒ…ã€‚è¿™é€šå¸¸å¯ä»¥é€šè¿‡åœ¨ Windows ä¸Šæ‰“å¼€å‘½ä»¤çª—å£ç„¶åè¾“å…¥â€˜python -m pip install [package-name]â€™æ¥å®Œæˆã€‚æœ‰å…³ç›¸åº”åŒ…çš„æ–‡æ¡£ï¼Œå¯ä»¥è·å¾—æ›´å¤šå¸®åŠ©ã€‚

## å£°æ˜å‡½æ•°

æä¾›æ–¹ä¾¿çš„å‡½æ•°ï¼Œç”¨äºå‘æ•°å­—æ·»åŠ é€—å·ä»¥åŠå‘å›¾è¡¨æ·»åŠ ä¸»å‰¯ç½‘æ ¼çº¿ã€‚

```py
def comma_format(x, pos):
    return f'{int(x):,}'

def add_grid():                                            
    plt.gca().grid(True, which='major',linewidth = 1.0); plt.gca().grid(True, which='minor',linewidth = 0.2) # add y grids
    plt.gca().tick_params(which='major',length=7); plt.gca().tick_params(which='minor', length=4)
    plt.gca().xaxis.set_minor_locator(AutoMinorLocator()); plt.gca().yaxis.set_minor_locator(AutoMinorLocator()) # turn on minor ticks 
```

## è®¾ç½®å·¥ä½œç›®å½•

æˆ‘æ€»æ˜¯å–œæ¬¢è¿™æ ·åšï¼Œè¿™æ ·æˆ‘å°±ä¸ä¼šä¸¢å¤±æ–‡ä»¶ï¼Œå¹¶ä¸”å¯ä»¥ç®€åŒ–åç»­çš„è¯»å–å’Œå†™å…¥ï¼ˆé¿å…æ¯æ¬¡éƒ½åŒ…å«å®Œæ•´åœ°å€ï¼‰ã€‚

```py
#os.chdir("c:/PGE383")                                        # set the working directory 
```

## åŠ è½½æ•°æ®è¡¨

è¿™é‡Œæ˜¯åŠ è½½æˆ‘ä»¬çš„é€—å·åˆ†éš”æ•°æ®æ–‡ä»¶åˆ° Pandas DataFrame å¯¹è±¡çš„å‘½ä»¤ã€‚

```py
#df = pd.read_csv('unconv_MV_v4.csv')                         # load our data table
df = pd.read_csv(r'https://raw.githubusercontent.com/GeostatsGuy/GeoDataSets/master/unconv_MV_v4.csv')
df['TOC'] = np.where(df['TOC']<0.0, 0.0, df['TOC']) # set TOC < 0.0 as 0.0, otherwise leave the same 
```

å¯è§†åŒ– DataFrame å°†å¾ˆæœ‰ç”¨ï¼Œæˆ‘ä»¬å·²ç»åœ¨æœ¬æ¬¡æ¼”ç¤ºä¸­å­¦ä¹ äº†è¿™äº›æ–¹æ³•ï¼ˆ[`git.io/fNgRW`](https://git.io/fNgRW)ï¼‰ã€‚

æˆ‘ä»¬å¯ä»¥é€šè¿‡ä½¿ç”¨â€˜headâ€™ DataFrame æˆå‘˜å‡½æ•°ï¼ˆä»¥æ•´æ´çš„æ ¼å¼ï¼Œè§ä¸‹æ–‡ï¼‰æ¥é¢„è§ˆ DataFrameã€‚ä½¿ç”¨ head å‘½ä»¤æ—¶ï¼Œæ·»åŠ å‚æ•°â€˜n=13â€™ä»¥æŸ¥çœ‹æ•°æ®é›†çš„å‰ 13 è¡Œã€‚

```py
df.head(n=13)                                                 # we could also use this command for a table preview 
```

|  | äº• | å­” | æ¸— | åˆå§‹ | å²©è„† | TOC | VR | äº§é‡ |
| --- | --- | --- | --- | --- | --- | --- | --- | --- |
| 0 | 1 | 12.08 | 2.92 | 2.80 | 81.40 | 1.16 | 2.31 | 1695.360819 |
| 1 | 2 | 12.38 | 3.53 | 3.22 | 46.17 | 0.89 | 1.88 | 3007.096063 |
| 2 | 3 | 14.02 | 2.59 | 4.01 | 72.80 | 0.89 | 2.72 | 2531.938259 |
| 3 | 4 | 17.67 | 6.75 | 2.63 | 39.81 | 1.08 | 1.88 | 5288.514854 |
| 4 | 5 | 17.52 | 4.57 | 3.18 | 10.94 | 1.51 | 1.90 | 2859.469624 |
| 5 | 6 | 14.53 | 4.81 | 2.69 | 53.60 | 0.94 | 1.67 | 4017.374438 |
| 6 | 7 | 13.49 | 3.60 | 2.93 | 63.71 | 0.80 | 1.85 | 2952.812773 |
| 7 | 8 | 11.58 | 3.03 | 3.25 | 53.00 | 0.69 | 1.93 | 2670.933846 |
| 8 | 9 | 12.52 | 2.72 | 2.43 | 65.77 | 0.95 | 1.98 | 2474.048178 |
| 9 | 10 | 13.25 | 3.94 | 3.71 | 66.20 | 1.14 | 2.65 | 2722.893266 |
| 10 | 11 | 15.04 | 4.39 | 2.22 | 61.11 | 1.08 | 1.77 | 3828.247174 |
| 11 | 12 | 16.19 | 6.30 | 2.29 | 49.10 | 1.53 | 1.86 | 5095.810104 |
| 12 | 13 | 16.82 | 5.42 | 2.80 | 66.65 | 1.17 | 1.98 | 4091.637316 |

æ­¤æ•°æ®é›†åŒ…å«æ¥è‡ª 200 å£éå¸¸è§„äº•çš„ç‰¹å¾ï¼ŒåŒ…æ‹¬ï¼š

1.  äº•ç´¢å¼•

1.  å¹³å‡å­”éš™ç‡ï¼ˆ%ï¼‰

1.  æ¸—é€ç‡ï¼ˆmDï¼‰

1.  å£°é˜»æŠ—ï¼ˆkg/m2s*10â¶ï¼‰

1.  å²©è„†æ¯”ï¼ˆ%ï¼‰

1.  æ€»æœ‰æœºç¢³ï¼ˆ%ï¼‰

1.  ç»ç’ƒå…‰æ³½ç‡ï¼ˆ%ï¼‰

1.  æ ‡å‡†åŒ–åˆå§‹äº§é‡ 90 å¤©å¹³å‡ï¼ˆMCFPDï¼‰ã€‚

æ³¨æ„ï¼Œæ•°æ®é›†æ˜¯åˆæˆçš„ï¼Œä½†å…·æœ‰ç°å®èŒƒå›´å’Œä¸€èˆ¬çš„å¤šå˜é‡å…³ç³»ã€‚

æ’åºç‰¹å¾æ˜¯ä¸€é¡¹çœŸæ­£åŠªåŠ›å»ç†è§£ç‰¹å¾åŠå…¶ç›¸äº’ä¹‹é—´å…³ç³»çš„å·¥ä½œã€‚æˆ‘ä»¬å°†ä»åŸºæœ¬çš„æ•°æ®å¯è§†åŒ–å¼€å§‹ï¼Œç„¶åè½¬å‘æ›´å¤æ‚çš„æ–¹æ³•ï¼Œå¦‚åç›¸å…³å’Œé€’å½’ç‰¹å¾æ¶ˆé™¤ã€‚

## æ‘˜è¦ç»Ÿè®¡

è®©æˆ‘ä»¬æ£€æŸ¥æˆ‘ä»¬æ•°æ®çš„æ‘˜è¦ç»Ÿè®¡ä¿¡æ¯ã€‚

```py
df.describe().transpose()                                     # display summary statistics 
```

|  | count | mean | std | min | 25% | 50% | 75% | max |
| --- | --- | --- | --- | --- | --- | --- | --- | --- |
| Well | 200.0 | 100.500000 | 57.879185 | 1.000000 | 50.750000 | 100.500000 | 150.250000 | 200.000000 |
| Por | 200.0 | 14.991150 | 2.971176 | 6.550000 | 12.912500 | 15.070000 | 17.402500 | 23.550000 |
| Perm | 200.0 | 4.330750 | 1.731014 | 1.130000 | 3.122500 | 4.035000 | 5.287500 | 9.870000 |
| AI | 200.0 | 2.968850 | 0.566885 | 1.280000 | 2.547500 | 2.955000 | 3.345000 | 4.630000 |
| Brittle | 200.0 | 48.161950 | 14.129455 | 10.940000 | 37.755000 | 49.510000 | 58.262500 | 84.330000 |
| TOC | 200.0 | 0.991950 | 0.478264 | 0.000000 | 0.617500 | 1.030000 | 1.350000 | 2.180000 |
| VR | 200.0 | 1.964300 | 0.300827 | 0.930000 | 1.770000 | 1.960000 | 2.142500 | 2.870000 |
| Prod | 200.0 | 3864.407081 | 1553.277558 | 839.822063 | 2686.227611 | 3604.303506 | 4752.637555 | 8590.384044 |

æ‘˜è¦ç»Ÿè®¡æ˜¯æ•°æ®æ£€æŸ¥çš„å…³é”®ç¬¬ä¸€æ­¥ã€‚

+   è¿™åŒ…æ‹¬æ¯ä¸ªç‰¹å¾çš„ï¼ˆéç©ºï¼‰æœ‰æ•ˆå€¼çš„æ•°é‡ï¼ˆcount ä»æ¯ä¸ªå˜é‡çš„æ€»æ•°ä¸­ç§»é™¤äº†æ‰€æœ‰ np.NaNï¼‰ã€‚

+   æˆ‘ä»¬å¯ä»¥çœ‹åˆ°ä¸€èˆ¬çš„è¡Œä¸ºï¼Œå¦‚ä¸­å¿ƒè¶‹åŠ¿ã€å‡å€¼å’Œåˆ†æ•£æ€§ã€æ–¹å·®ã€‚

+   æˆ‘ä»¬å¯ä»¥è¯†åˆ«å‡ºé—®é¢˜ï¼Œå¦‚è´Ÿå€¼ã€æç«¯å€¼ä»¥åŠè¶…å‡ºæ¯ä¸ªå±æ€§å¯èƒ½å€¼èŒƒå›´çš„å€¼ã€‚

+   æˆ‘ä»¬è¿˜å¯ä»¥ä¸ºç»˜å›¾å»ºç«‹ç‰¹å¾èŒƒå›´ã€‚æˆ‘ä»¬å¯ä»¥ä½¿ç”¨å¦‚ä¸‹ä»£ç ç›´æ¥ä»æ•°æ®ä¸­è®¡ç®—ç‰¹å¾èŒƒå›´ï¼š

```py
Pormin = np.min(df['Por'].values)          # extract ndarray of data table column
Pormax = np.max(df['Por'].values)          # and calculate min and max 
```

ä½†è¿™ä¸ä¼šå¯¼è‡´æ˜“äºç†è§£çš„è‰²æ¡å’Œè½´åˆ»åº¦ï¼Œè®©æˆ‘ä»¬é€‰æ‹©æ–¹ä¾¿çš„æ•´æ•°ã€‚æˆ‘ä»¬è¿˜å°†å£°æ˜ç‰¹å¾æ ‡ç­¾ä»¥æ–¹ä¾¿ç»˜å›¾ã€‚

```py
pormin = 6.0; pormax = 24.0; porname = 'Porosity (%)'; portitle = 'Porosity'
permmin = 0.0; permmax = 10; permname = 'Permeability (mD)'; permtitle = 'Permeability'                
AImin = 1.0; AImax = 5.0; AIname = 'Acoustic Impedance (kg/m2s*10â¶)'; AItitle = 'Acoustic Impedance'
brmin = 10.0; brmax = 85.0; brname = 'Brittleness Ratio (%)'; brtitle = 'Brittleness'
TOCmin = 0.0; TOCmax = 2.2; TOCname = 'Total Organic Carbon (%)'; TOCtitle = 'Total Organic Carbon' 
VRmin = 0.9; VRmax = 2.9; VRname = 'Vitrinite Reflectance (%)'; VRtitle = 'Vitrinite Reflectance'
prodmin = 500.0; prodmax = 9000.0; prodname = 'Normalized Initial Production (MCFPD)'; prodtitle = 'Normalized Initial Production' 
```

æ•°æ®çœ‹èµ·æ¥ç›¸å½“ä¸é”™ï¼Œä¸ºäº†ç®€æ´èµ·è§ï¼Œæˆ‘ä»¬è·³è¿‡å¼‚å¸¸å€¼æ£€æµ‹ã€‚è®©æˆ‘ä»¬ä½¿ç”¨ Seaborn åŒ…çš„çŸ©é˜µæ•£ç‚¹å›¾æŸ¥çœ‹åˆ†å¸ƒã€‚

```py
sns.pairplot(df,vars=['Por','Perm','AI','Brittle','TOC','VR','Prod'],markers='o',plot_kws={'alpha': 0.2})
plt.subplots_adjust(left=0.0, bottom=0.0, right=0.6, top=0.6, wspace=0.3, hspace=0.2); plt.show() 
```

![_images/d82e98fd3f20b062e5af7a1166a4e2e974afd596af23ad51bb6ea0c6f780ddce.png](img/95fb79f6de153d43d36030d365b24d3e.png)

## ç‰¹å¾æ ‡å‡†åŒ–

ç”±äºæˆ‘ä»¬çš„æ¨¡å‹ä½¿ç”¨çš„æ˜¯å·®å¼‚åº¦ï¼ˆç±»ä¼¼äºç‰¹å¾ç©ºé—´ä¸­çš„è·ç¦»ï¼‰åº¦é‡ï¼Œæˆ‘ä»¬éœ€è¦æ ‡å‡†åŒ–ç‰¹å¾ã€‚

```py
features = ['Por','Perm','AI','Brittle','TOC','VR']
x = df.loc[:,features].values
mu = np.mean(x, axis=0)
sd = np.std(x, axis=0)
xs = StandardScaler().fit_transform(x)

ns_features = []
for i in range(0,len(features)):
    df['NS_'+features[i]] = xs[:,i]
    ns_features.append('NS_'+features[i]) 

df.head(n=13) 
```

|  | Well | Por | Perm | AI | Brittle | TOC | VR | Prod | NS_Por | NS_Perm | NS_AI | NS_Brittle | NS_TOC | NS_VR |
| --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- |
| 0 | 1 | 12.08 | 2.92 | 2.80 | 81.40 | 1.16 | 2.31 | 1695.360819 | -0.982256 | -0.817030 | -0.298603 | 2.358297 | 0.352257 | 1.152048 |
| 1 | 2 | 12.38 | 3.53 | 3.22 | 46.17 | 0.89 | 1.88 | 3007.096063 | -0.881032 | -0.463751 | 0.444147 | -0.141332 | -0.213702 | -0.280931 |
| 2 | 3 | 14.02 | 2.59 | 4.01 | 72.80 | 0.89 | 2.72 | 2531.938259 | -0.327677 | -1.008148 | 1.841224 | 1.748113 | -0.213702 | 2.518377 |
| 3 | 4 | 17.67 | 6.75 | 2.63 | 39.81 | 1.08 | 1.88 | 5288.514854 | 0.903875 | 1.401098 | -0.599240 | -0.592585 | 0.184565 | -0.280931 |
| 4 | 5 | 17.52 | 4.57 | 3.18 | 10.94 | 1.51 | 1.90 | 2859.469624 | 0.853263 | 0.138561 | 0.373409 | -2.640962 | 1.085907 | -0.214280 |
| 5 | 6 | 14.53 | 4.81 | 2.69 | 53.60 | 0.94 | 1.67 | 4017.374438 | -0.155597 | 0.277556 | -0.493133 | 0.385839 | -0.108895 | -0.980758 |
| 6 | 7 | 13.49 | 3.60 | 2.93 | 63.71 | 0.80 | 1.85 | 2952.812773 | -0.506505 | -0.423211 | -0.068704 | 1.103161 | -0.402355 | -0.380906 |
| 7 | 8 | 11.58 | 3.03 | 3.25 | 53.00 | 0.69 | 1.93 | 2670.933846 | -1.150962 | -0.753324 | 0.497200 | 0.343268 | -0.632930 | -0.114305 |
| 8 | 9 | 12.52 | 2.72 | 2.43 | 65.77 | 0.95 | 1.98 | 2474.048178 | -0.833795 | -0.932859 | -0.952930 | 1.249322 | -0.087933 | 0.052320 |
| 9 | 10 | 13.25 | 3.94 | 3.71 | 66.20 | 1.14 | 2.65 | 2722.893266 | -0.587484 | -0.226301 | 1.310688 | 1.279831 | 0.310334 | 2.285102 |
| 10 | 11 | 15.04 | 4.39 | 2.22 | 61.11 | 1.08 | 1.77 | 3828.247174 | 0.016483 | 0.034314 | -1.324305 | 0.918687 | 0.184565 | -0.647507 |
| 11 | 12 | 16.19 | 6.30 | 2.29 | 49.10 | 1.53 | 1.86 | 5095.810104 | 0.404506 | 1.140483 | -1.200514 | 0.066556 | 1.127830 | -0.347581 |
| 12 | 13 | 16.82 | 5.42 | 2.80 | 66.65 | 1.17 | 1.98 | 4091.637316 | 0.617075 | 0.630834 | -0.298603 | 1.311759 | 0.373218 | 0.052320 |

## æ•°æ®å‡†å¤‡

è®©æˆ‘ä»¬ä»è¿ç»­çš„äº§é‡ä¸­åˆ›å»ºä¸€ä¸ªæœ‰åºç‰¹å¾ï¼š

1.  ä½

1.  ä¸­ç­‰

1.  é«˜

1.  éå¸¸é«˜

äº§é‡ç‡ã€‚è¿™å°†å¸®åŠ©æˆ‘ä»¬å¯è§†åŒ–ç»“æœï¼Œæˆ‘ä»¬å¯ä»¥æŸ¥çœ‹ä¸åŒäº§é‡æ°´å¹³çš„äº•è¢«æŠ•å½±åˆ°å„ç§ä½ç»´ç©ºé—´ä¸­ï¼Œä½¿ç”¨å¤šç»´ç¼©æ”¾ã€‚

```py
bins = [0,2500,5000,7500,10000]                # assign the production bins (these are the fence posts)
labels = ['low', 'med', 'high', 'vhigh']       # assign the labels
category = pd.cut(df['Prod'],bins,labels=labels)     # make the 1D array with the labels for our data
df['tProd'] = category                                # add the new ordinal production feature to our DataFrames 
df.head()
dpalette = sns.color_palette("rocket_r",n_colors = 4)
palette = sns.color_palette("rocket") 
```

è®©æˆ‘ä»¬çœ‹çœ‹æˆ‘ä»¬ä¸‰ä¸ªç‰¹å¾å’Œäº§é‡æ°´å¹³çš„çŸ©é˜µæ•£ç‚¹å›¾ã€‚

```py
plot = sns.pairplot(df[ns_features + ['tProd']],markers='o',hue = 'tProd', palette = dpalette,diag_kws={'edgecolor':'black'},plot_kws=dict(s=50, edgecolor="black", linewidth=0.5))

plt.subplots_adjust(left=0.0, bottom=0.0, right=1.5, top=1.5, wspace=0.3, hspace=0.2)
plt.show() 
```

![_images/88023e2fe485fa10c6d95a886b783b2fbba0d51476bfbbaea540a357171cf53f.png](img/361d301ea20bab27b890f9dc5260164c.png)

## éšæœºæŠ•å½±

è®©æˆ‘ä»¬æ¼”ç¤ºéšæœºæŠ•å½±çš„ä½¿ç”¨ã€‚

+   ç”±äºä½ç»´æ€§ï¼Œå¯¹äºæŸäº›éšæœºç§å­ï¼Œæ‚¨å°†çœ‹åˆ°ç›¸å½“ç³Ÿç³•çš„æ€§èƒ½

```py
n_components = 6; seed = 73058
rp = GaussianRandomProjection(n_components=n_components,random_state = seed)

dists = euclidean_distances(df[ns_features], squared=False).ravel()
nonzero = dists != 0   # select only non-identical samples pairs
dists = dists[nonzero]

projected_data = rp.fit_transform(df[ns_features])
projected_dists = euclidean_distances(projected_data, squared=False).ravel()[nonzero]

plt.subplot(221)
plt.scatter(dists,projected_dists,c='darkorange',alpha=0.6,edgecolor = 'black')
plt.arrow(0,0,200,200,width=0.02,color='black',head_length=0.0,head_width=0.0)
plt.xlim(0,15); plt.ylim(0,15); add_grid()
plt.xlabel("Pairwise Distance: original space"); plt.ylabel("Pairwise Distance: projected space")
plt.title("Pairwise Distance: Projected to %d Components" % n_components)

rates = projected_dists / dists
print("Distance Ratio, mean: %0.2f, standard deviation %0.2f." % (np.mean(rates), np.std(rates)))

plt.subplot(222)
plt.hist(rates, bins=50, range=(0., 2.),color = 'darkorange', alpha = 0.6, edgecolor='k')
plt.xlabel("Distance Ratio: projected / original"); plt.ylabel("Frequency"); add_grid()
plt.title("Pairwise Distance: Projected to %d Components" % n_components)

plt.subplot(223)
plt.hist(dists, bins=50, range=(0., 15.),color = 'darkorange', alpha = 0.6, edgecolor='k')
plt.xlabel("Pairwise Distance"); plt.ylabel("Frequency"); add_grid()
plt.title("Pairwise Distance: Original Data")

plt.subplot(224)
plt.hist(projected_dists, bins=50, range=(0., 15.),color = 'darkorange', alpha = 0.6, edgecolor='k')
plt.xlabel("Pairwise Distance"); plt.ylabel("Frequency"); add_grid()
plt.title("Pairwise Distance: Projected to %d Components" % n_components)

plt.subplots_adjust(left=0.0, bottom=0.0, right=2.0, top=2.1, wspace=0.2, hspace=0.2); plt.show() 
```

```py
Distance Ratio, mean: 0.83, standard deviation 0.16. 
```

![_images/9d381e4fb7046bb5ea95413bbcb76d715648c0783488f14ad9ea4a0c6ebf4ee0.png](img/b97660935d743314d8384f5fbdb20615.png)

æ£€æŸ¥éšæœºæŠ•å½±çŸ©é˜µçš„æ­£äº¤æ€§ã€‚

+   é€šè¿‡è®¡ç®—å’Œæ˜¾ç¤º $R_p^T R_p$ï¼Œå¦‚æœå®ƒæ˜¯æ­£äº¤çš„ï¼Œå®ƒåº”è¯¥æ˜¯ä¸€ä¸ªä¸¥æ ¼å¯¹è§’çŸ©é˜µ

```py
orthogonal_check = np.dot(rp.components_.T, rp.components_)

fig, ax = plt.subplots()
cax = ax.imshow(orthogonal_check,cmap=plt.cm.grey,vmin=-1,vmax=1.0,interpolation='None',zorder=1)
#cbar = plt.colorbar(); cbar.set_label('Value')

matrix_size = orthogonal_check.shape[0]  # Assuming the matrix is square (m x m)
square_size = 1  # Each square has size 1x1

for i in range(matrix_size):
    # Add a square around each diagonal element
    square = patches.Rectangle((i - 0.5, i - 0.5),square_size,square_size,linewidth=3, edgecolor='white', facecolor='none')
    ax.add_patch(square)

# Add a colorbar
cbar = fig.colorbar(cax)
cbar.set_label('Value', rotation=90, labelpad=15)  # Set label for colorbar

plt.title(r'Orthogonal Check, $R_p^T R_p$')
plt.xlabel('Columns'); plt.ylabel('Rows')
plt.subplots_adjust(left=0.0, bottom=0.0, right=1.0, top=1.0, wspace=0.2, hspace=0.3); plt.show() 
```

```py
---------------------------------------------------------------------------
AttributeError  Traceback (most recent call last)
Cell In[13], line 4
  1 orthogonal_check = np.dot(rp.components_.T, rp.components_)
  3 fig, ax = plt.subplots()
----> 4 cax = ax.imshow(orthogonal_check,cmap=plt.cm.grey,vmin=-1,vmax=1.0,interpolation='None',zorder=1)
  5 #cbar = plt.colorbar(); cbar.set_label('Value')
  7 matrix_size = orthogonal_check.shape[0]  # Assuming the matrix is square (m x m)

AttributeError: module 'matplotlib.cm' has no attribute 'grey' 
```

![_images/b939873a0ebfe0d1abe1e7218ce8f485bb698d87d0fd5a003af297c5e30b4bbf.png](img/fb33fb692e076e2c71f895be6dd85b6c.png)

## æ·»åŠ æ›´å¤šåŠŸèƒ½

æˆ‘ä»¬çœ‹åˆ°ï¼Œå¯¹äº m = 6ï¼Œæˆ‘ä»¬æ²¡æœ‰çœ‹åˆ°æ˜¾è‘—çš„é™ç»´ã€‚è®©æˆ‘ä»¬å®ä¾‹åŒ–ä¸€ä¸ªæ›´å¤§çš„æ¨¡å‹ã€‚

+   å°† $m$ è®¾ç½®å¾—å¾ˆå¤§ï¼Œå³ $m \ge 100$

+   å°† $p$ è®¾ç½®ä¸º $m$ çš„åˆç†æ¯”ä¾‹ï¼Œä¾‹å¦‚ $\frac{2}{3}$ åˆ° $\frac{1}{2}$

ç”±äºæˆ‘ä»¬æ²¡æœ‰è®¿é—®ä»»æ„å¤§å°çš„æ•°æ®é›†ï¼Œè®©æˆ‘ä»¬éšæœºç”Ÿæˆå®ƒã€‚

+   æ ‡å‡†æ­£æ€åˆ†å¸ƒï¼Œé«˜ç»´å¤šé«˜æ–¯åˆ†å¸ƒï¼Œæ‰€æœ‰å‡å€¼ä¸º 0ï¼Œæ–¹å·®ä¸º 1.0

+   ç‰¹å¾ä¹‹é—´çš„éšæœºç›¸å…³æ€§

+   æˆ‘ä»¬ä½¿ç”¨ç‰¹å¾å€¼åˆ†è§£ï¼Œå°†è´Ÿå€¼æˆ–é›¶ç‰¹å¾å€¼è®¾ç½®ä¸ºå°çš„æ­£å€¼ï¼Œä»¥ç¡®ä¿ç›¸å…³çŸ©é˜µæ˜¯æ­£åŠå®šçš„

```py
m = 100                                                       # number of dimensions
n_samples = 1000                                              # number of samples

np.random.seed(seed = seed)                                   # set the random seed
mean_vector = np.zeros(m)                                     # mean vector (zero mean for all variables)

random_matrix = np.random.rand(m, m)                          # step 1: generate a random matrix 
correlation_matrix = np.dot(random_matrix, random_matrix.T)   # step 2: create a symmetric correlation matrix
correlation_matrix = (correlation_matrix + correlation_matrix.T) / 2 # step 3: symmetrize the correlation matrix (ensures the matrix is symmetric)
np.fill_diagonal(correlation_matrix, 1)                       # step 4: normalize to have ones on the diagonal (this ensures unit variances)

# Ensure the covariance matrix is positive semi-definite using eigendecomposition
eigvals, eigvecs = np.linalg.eigh(correlation_matrix)         # eigendecomposition of the correlation matrix
eigvals = np.maximum(eigvals, 1e-6)                           # set any negative eigenvalues to a small positive value
cov_matrix = eigvecs @ np.diag(eigvals) @ eigvecs.T           # reconstruct the covariance matrix

big_data = np.random.multivariate_normal(mean_vector, cov_matrix, size=n_samples) # step 6: generate the multi-dimensional Gaussian dataset
df_big_data = pd.DataFrame(big_data, columns=[f"Dim_{i+1}" for i in range(m)]) # convert the data into a pandas DataFrame 
```

è¿™ä»½æ•°æ®ç»´åº¦å¤ªé«˜ï¼Œä¸æ–¹ä¾¿å¯è§†åŒ–ï¼Œè®©æˆ‘ä»¬ç»§ç»­ä½¿ç”¨éšæœºæŠ•å½±ã€‚

```py
n_components = 5; seed = 73058
rp_big = GaussianRandomProjection(n_components=n_components,random_state = seed)

dists = euclidean_distances(df_big_data, squared=False).ravel()
nonzero = dists != 0   # select only non-identical samples pairs
dists = dists[nonzero]

projected_data = rp_big.fit_transform(df_big_data)
projected_dists = euclidean_distances(projected_data, squared=False).ravel()[nonzero]

plt.subplot(121)
plt.scatter(dists,projected_dists,c='red',alpha=0.2,edgecolor = 'black')
plt.arrow(0,0,10000,10000,width=0.02,color='black',head_length=0.0,head_width=0.0)
plt.xlabel("Pairwise Distance: original space")
plt.ylabel("Pairwise Distance: projected space")
plt.title("Pairwise Distance: Projected to %d Components" % n_components)
plt.xlim([0,400]); plt.ylim([0,400]); add_grid()

rates = projected_dists / dists
print("Distance Ratio, mean: %0.2f, standard deviation %0.2f." % (np.mean(rates), np.std(rates)))

plt.subplot(122)
plt.hist(rates, bins=50, range=(0., 2.),color = 'red', alpha = 0.2, edgecolor='k')
plt.xlabel("Distance Ratio: projected / original"); plt.ylabel("Frequency"); add_grid()
plt.title("Pairwise Distance: Projected to %d Components" % n_components)

plt.subplots_adjust(left=0.0, bottom=0.0, right=2.0, top=1.0, wspace=0.2, hspace=0.3); plt.show() 
```

```py
Distance Ratio, mean: 0.95, standard deviation 0.02. 
```

![å›¾ç‰‡](img/9e5d080e00dc637a851d8dfb22c425df.png)

æ£€æŸ¥éšæœºæŠ•å½±çŸ©é˜µçš„æ­£äº¤æ€§ã€‚

+   é€šè¿‡è®¡ç®—å’Œæ˜¾ç¤º $R_p^T R_p$ï¼Œå¦‚æœå®ƒæ˜¯æ­£äº¤çš„ï¼Œå®ƒåº”è¯¥æ˜¯ä¸€ä¸ªä¸¥æ ¼å¯¹è§’çŸ©é˜µ

æ³¨æ„ï¼Œ$R_p$ ä¸æ˜¯æ–¹é˜µï¼Œå®ƒæ˜¯ $p \times m$ï¼Œæ‰€ä»¥æˆ‘ä»¬å®é™…ä¸Šæ˜¯åœ¨æ£€æŸ¥åˆ—æ­£äº¤æ€§ï¼Œ$R_p^T R_p$

+   æˆ‘ä»¬æ­£åœ¨æ£€æŸ¥çš„æ˜¯é™ç»´åçš„æŠ•å½±æ˜¯å¦å½¢æˆä¸€ä¸ªæ­£äº¤åŸº

+   ä»ä¸Šé¢æ¥çœ‹ $R_p^T$ æ˜¯ $m \times p$ å’Œ $R_p$ æ˜¯ $p \times m$ï¼Œæ‰€ä»¥ $R_p^T R_p$ æ˜¯ $m \times m$

```py
orthogonal_check_big = np.dot(rp_big.components_.T, rp_big.components_)
fig, ax = plt.subplots()
cax = ax.imshow(orthogonal_check_big,cmap=plt.cm.grey,vmin=-1,vmax=1.5,interpolation='None',zorder=1)

matrix_size = orthogonal_check.shape[0]                       # assuming the matrix is square (m x m)
square_size = 1                                               # each square has size 1x1

cbar = fig.colorbar(cax); cbar.set_label('Value', rotation=90, labelpad=15) 

plt.title(r'Orthogonal Check, $R_p^T R_p$'); plt.xlabel('Columns'); plt.ylabel('Rows')
plt.subplots_adjust(left=0.0, bottom=0.0, right=1.0, top=1.0, wspace=0.2, hspace=0.3); plt.show() 
```

![å›¾ç‰‡](img/7f0d011d72830b71ea8a9544642b5b1e.png)

## æ·»åŠ æ›´å¤šç‰¹å¾

è®©æˆ‘ä»¬å°è¯•ä¸€ä¸ªæ›´å¤§çš„ç»´åº¦ï¼Œä½¿ç”¨ä¸€ä¸ªå•ç‹¬çš„ä»£ç å—ã€‚

```py
m = 1000                                                      # number of dimensions
n_samples = 1000                                              # number of samples
n_components = 200                                            # number of components 
seed = 73058                                                  # random seed

np.random.seed(seed = seed)                                   # set the random seed
mean_vector = np.zeros(m)                                     # mean vector (zero mean for all variables)

random_matrix = np.random.rand(m, m)                          # step 1: generate a random matrix 
correlation_matrix = np.dot(random_matrix, random_matrix.T)   # step 2: create a symmetric correlation matrix
correlation_matrix = (correlation_matrix + correlation_matrix.T) / 2 # step 3: symmetrize the correlation matrix (ensures the matrix is symmetric)
np.fill_diagonal(correlation_matrix, 1)                       # step 4: normalize to have ones on the diagonal (this ensures unit variances)

# Ensure the covariance matrix is positive semi-definite using eigendecomposition
eigvals, eigvecs = np.linalg.eigh(correlation_matrix)         # eigendecomposition of the correlation matrix
eigvals = np.maximum(eigvals, 1e-6)                           # set any negative eigenvalues to a small positive value
cov_matrix = eigvecs @ np.diag(eigvals) @ eigvecs.T           # reconstruct the covariance matrix

very_big_data = np.random.multivariate_normal(mean_vector, cov_matrix, size=n_samples) # step 6: generate the multi-dimensional Gaussian dataset
df_very_big_data = pd.DataFrame(very_big_data, columns=[f"Dim_{i+1}" for i in range(m)]) # convert the data into a pandas DataFrame

rp_very_big = GaussianRandomProjection(n_components=n_components,random_state = seed)

dists = euclidean_distances(df_very_big_data, squared=False).ravel()
nonzero = dists != 0                                          # select only non-identical samples pairs
dists = dists[nonzero]

projected_data = rp_very_big.fit_transform(df_very_big_data)
projected_dists = euclidean_distances(projected_data, squared=False).ravel()[nonzero]

plt.subplot(121)
plt.scatter(dists,projected_dists,c='red',alpha=0.2,edgecolor = 'black')
plt.arrow(0,0,10000,10000,width=0.02,color='black',head_length=0.0,head_width=0.0)
plt.xlabel("Pairwise Distance: original space")
plt.ylabel("Pairwise Distance: projected space")
plt.title("Pairwise Distance: Projected to %d Components" % n_components)
plt.xlim([0,400]); plt.ylim([0,400]); add_grid()

orthogonal_check_very_big = np.dot(rp_very_big.components_.T, rp_very_big.components_)

plt.subplot(122)
im = plt.imshow(orthogonal_check_very_big,cmap=plt.cm.grey,vmin=-1,vmax=1.5,interpolation='None',zorder=1)
matrix_size = orthogonal_check.shape[0]                       # assuming the matrix is square (m x m)
square_size = 1                                               # each square has size 1x1
cbar = fig.colorbar(im); cbar.set_label('Value', rotation=90, labelpad=15) 
plt.title(r'Orthogonal Check, $R_p^T R_p$'); plt.xlabel('Columns'); plt.ylabel('Rows')

plt.subplots_adjust(left=0.0, bottom=0.0, right=2.0, top=1.0, wspace=0.2, hspace=0.3); plt.show() 
```

![å›¾ç‰‡](img/11e2a354bd1b2543a20f9194cee52d96.png)

## è¯„è®º

è¿™æ˜¯å¯¹éšæœºæŠ•å½±çš„åŸºæœ¬å¤„ç†ã€‚å¯ä»¥åšå’Œè®¨è®ºçš„è¿˜æœ‰å¾ˆå¤šï¼Œæˆ‘æœ‰å¾ˆå¤šæ›´å¤šçš„èµ„æºã€‚æŸ¥çœ‹æˆ‘çš„[å…±äº«èµ„æºæ¸…å•](https://michaelpyrcz.com/my-resources)ä»¥åŠæœ¬ç« å¼€å¤´ YouTube è®²åº§é“¾æ¥ä¸­çš„èµ„æºé“¾æ¥ï¼Œè§†é¢‘æè¿°ä¸­åŒ…å«èµ„æºé“¾æ¥ã€‚

æˆ‘å¸Œæœ›è¿™æœ‰æ‰€å¸®åŠ©ï¼Œ

*è¿ˆå…‹å°”*

## å…³äºä½œè€…

![å›¾ç‰‡](img/eb709b2c0a0c715da01ae0165efdf3b2.png)

å¾·å…‹è¨æ–¯å¤§å­¦å¥¥æ–¯æ±€åˆ†æ ¡ 40 è‹±äº©æ ¡å›­å†…ï¼Œè¿ˆå…‹å°”Â·çš®å°”èŒ¨æ•™æˆçš„åŠå…¬å®¤ã€‚

è¿ˆå…‹å°”Â·çš®å°”èŒ¨æ˜¯[ç§‘å…‹é›·å°”å·¥ç¨‹å­¦é™¢](https://cockrell.utexas.edu/faculty-directory/alphabetical/p)å’Œ[æ°å…‹é€Šåœ°çƒç§‘å­¦å­¦é™¢](https://www.jsg.utexas.edu/researcher/michael_pyrcz/)çš„æ•™æˆï¼Œåœ¨[å¾·å…‹è¨æ–¯å¤§å­¦å¥¥æ–¯æ±€åˆ†æ ¡](https://www.utexas.edu/)ï¼Œåœ¨é‚£é‡Œä»–ç ”ç©¶å¹¶æ•™æˆåœ°ä¸‹ã€ç©ºé—´æ•°æ®åˆ†æã€åœ°ç»Ÿè®¡å­¦å’Œæœºå™¨å­¦ä¹ ã€‚è¿ˆå…‹å°”è¿˜æ˜¯ï¼Œ

+   [èƒ½æºåˆ†æ](https://fri.cns.utexas.edu/energy-analytics)æ–°ç”Ÿç ”ç©¶é¡¹ç›®çš„é¦–å¸­ç ”ç©¶å‘˜ï¼Œä»¥åŠè‡ªç„¶ç§‘å­¦é™¢æœºå™¨å­¦ä¹ å®éªŒå®¤çš„æ ¸å¿ƒæ•™å‘˜

+   [è®¡ç®—æœºä¸åœ°çƒç§‘å­¦](https://www.sciencedirect.com/journal/computers-and-geosciences/about/editorial-board)çš„å‰¯ç¼–è¾‘ï¼Œä»¥åŠå›½é™…æ•°å­¦åœ°çƒç§‘å­¦åä¼šçš„[æ•°å­¦åœ°çƒç§‘å­¦](https://link.springer.com/journal/11004/editorial-board)è‘£äº‹ä¼šæˆå‘˜ã€‚

è¿ˆå…‹å°”å·²ç»æ’°å†™äº†è¶…è¿‡ 70 ç¯‡[åŒè¡Œè¯„å®¡çš„å‡ºç‰ˆç‰©](https://scholar.google.com/citations?user=QVZ20eQAAAAJ&hl=en)ï¼Œä¸€ä¸ªç”¨äºç©ºé—´æ•°æ®åˆ†æçš„[Python åŒ…](https://pypi.org/project/geostatspy/)ï¼Œåˆè‘—äº†ä¸€æœ¬å…³äºç©ºé—´æ•°æ®åˆ†æçš„æ•™ç§‘ä¹¦ã€Šåœ°ç»Ÿè®¡å­¦å‚¨å±‚å»ºæ¨¡ã€‹ï¼ˆ[Geostatistical Reservoir Modeling](https://www.amazon.com/Geostatistical-Reservoir-Modeling-Michael-Pyrcz/dp/0199731446)ï¼‰ï¼Œå¹¶æ˜¯ä¸¤æœ¬æ–°è¿‘å‘å¸ƒçš„ç”µå­ä¹¦çš„ä½œè€…ï¼Œåˆ†åˆ«æ˜¯ã€ŠPython ä¸­åº”ç”¨åœ°ç»Ÿè®¡å­¦ï¼šGeostatsPy å®è·µæŒ‡å—ã€‹ï¼ˆ[Applied Geostatistics in Python: a Hands-on Guide with GeostatsPy](https://geostatsguy.github.io/GeostatsPyDemos_Book/intro.html)ï¼‰å’Œã€ŠPython ä¸­åº”ç”¨æœºå™¨å­¦ä¹ ï¼šå¸¦ä»£ç çš„å®è·µæŒ‡å—ã€‹ï¼ˆ[Applied Machine Learning in Python: a Hands-on Guide with Code](https://geostatsguy.github.io/MachineLearningDemos_Book/intro.html)ï¼‰ã€‚

è¿ˆå…‹å°”çš„æ‰€æœ‰å¤§å­¦è®²åº§éƒ½å¯åœ¨ä»–çš„[YouTube é¢‘é“](https://www.youtube.com/@GeostatsGuyLectures)ä¸Šæ‰¾åˆ°ï¼Œé™„æœ‰ 100 å¤šä¸ª Python äº¤äº’å¼ä»ªè¡¨æ¿å’Œ 40 å¤šä¸ªå­˜å‚¨åº“ä¸­çš„è¯¦ç»†å·¥ä½œæµç¨‹é“¾æ¥ï¼Œè¿™äº›å­˜å‚¨åº“ä½äºä»–çš„[GitHub è´¦æˆ·](https://github.com/GeostatsGuy)ï¼Œä»¥æ”¯æŒä»»ä½•æ„Ÿå…´è¶£çš„å­¦ç”Ÿå’Œåœ¨èŒä¸“ä¸šäººå£«ï¼Œæä¾›æŒç»­æ›´æ–°çš„å†…å®¹ã€‚æƒ³äº†è§£æ›´å¤šå…³äºè¿ˆå…‹å°”çš„å·¥ä½œå’Œå…±äº«æ•™è‚²èµ„æºï¼Œè¯·è®¿é—®ä»–çš„ç½‘ç«™ã€‚

## æƒ³ä¸€èµ·å·¥ä½œå—ï¼Ÿ

å¸Œæœ›è¿™äº›å†…å®¹å¯¹é‚£äº›æƒ³äº†è§£æ›´å¤šå…³äºåœ°ä¸‹å»ºæ¨¡ã€æ•°æ®åˆ†æä¸æœºå™¨å­¦ä¹ çš„äººæœ‰æ‰€å¸®åŠ©ã€‚å­¦ç”Ÿå’Œåœ¨èŒä¸“ä¸šäººå£«éƒ½æ¬¢è¿å‚ä¸ã€‚

+   æƒ³é‚€è¯·æˆ‘åˆ°è´µå…¬å¸è¿›è¡ŒåŸ¹è®­ã€è¾…å¯¼ã€é¡¹ç›®å®¡æŸ¥ã€å·¥ä½œæµç¨‹è®¾è®¡ä»¥åŠ/æˆ–å’¨è¯¢ï¼Ÿæˆ‘å¾ˆä¹æ„æ‹œè®¿å¹¶ä¸æ‚¨åˆä½œï¼

+   æ„Ÿå…´è¶£åˆä½œã€æ”¯æŒæˆ‘çš„ç ”ç©¶ç”Ÿç ”ç©¶æˆ–æˆ‘çš„åœ°ä¸‹æ•°æ®åˆ†æä¸æœºå™¨å­¦ä¹ è”ç›Ÿï¼ˆå…±åŒè´Ÿè´£äººæ˜¯çº¦ç¿°Â·ç¦æ–¯ç‰¹æ•™æˆï¼‰ï¼Ÿæˆ‘çš„ç ”ç©¶å°†æ•°æ®åˆ†æã€éšæœºå»ºæ¨¡å’Œæœºå™¨å­¦ä¹ ç†è®ºä¸å®è·µç›¸ç»“åˆï¼Œä»¥å¼€å‘æ–°çš„æ–¹æ³•å’Œå·¥ä½œæµç¨‹ï¼Œå¢åŠ ä»·å€¼ã€‚æˆ‘ä»¬æ­£åœ¨è§£å†³å…·æœ‰æŒ‘æˆ˜æ€§çš„åœ°ä¸‹é—®é¢˜ï¼

+   æ‚¨å¯ä»¥é€šè¿‡ mpyrcz@austin.utexas.edu è”ç³»æˆ‘ã€‚

æˆ‘æ€»æ˜¯ä¹äºè®¨è®ºï¼Œ

*è¿ˆå…‹å°”*

è¿ˆå…‹å°”Â·çš®å°”å¥‡ï¼Œåšå£«ï¼ŒP.Eng. æ•™æˆï¼Œå¾·å…‹è¨æ–¯å¤§å­¦å¥¥æ–¯æ±€åˆ†æ ¡ Cockrell å·¥ç¨‹å­¦é™¢å’Œ Jackson åœ°çƒç§‘å­¦å­¦é™¢

æ›´å¤šèµ„æºå¯åœ¨ä»¥ä¸‹é“¾æ¥è·å–ï¼š[Twitter](https://twitter.com/geostatsguy) | [GitHub](https://github.com/GeostatsGuy) | [ç½‘ç«™](http://michaelpyrcz.com) | [Google Scholar](https://scholar.google.com/citations?user=QVZ20eQAAAAJ&hl=en&oi=ao) | [åœ°ç»Ÿè®¡å­¦ä¹¦ç±](https://www.amazon.com/Geostatistical-Reservoir-Modeling-Michael-Pyrcz/dp/0199731446) | [YouTube](https://www.youtube.com/channel/UCLqEr-xV-ceHdXXXrTId5ig) | [Python ä¸­åº”ç”¨åœ°ç»Ÿè®¡å­¦ç”µå­ä¹¦](https://geostatsguy.github.io/GeostatsPyDemos_Book/intro.html) | [Python ä¸­åº”ç”¨æœºå™¨å­¦ä¹ ç”µå­ä¹¦](https://geostatsguy.github.io/MachineLearningDemos_Book/) | [LinkedIn](https://www.linkedin.com/in/michael-pyrcz-61a648a1)

## éšæœºæŠ•å½±çš„åŠ¨æœº

å‡è®¾æˆ‘ä»¬éœ€è¦é€šè¿‡ä» $m$ ä¸ªç‰¹å¾ï¼ˆå³é«˜ç»´ç©ºé—´ï¼‰åˆ° $p$ ä¸ªç‰¹å¾ï¼ˆå³ä½ç»´ç©ºé—´ï¼‰çš„æŠ•å½±æ¥å®ç°éå¸¸å¿«é€Ÿçš„ç»´åº¦é™ä½ï¼Œ

$$ ğ‘, \quad \text{å…¶ä¸­} \quad ğ‘ << ğ‘š $$

åœ¨è¿™ç§æƒ…å†µä¸‹ï¼Œ

+   æˆ‘ä»¬ç°åœ¨æ²¡æœ‰æ‰€æœ‰æ•°æ®ï¼ˆä¾‹å¦‚ï¼Œå®æ—¶æ•°æ®ï¼‰ï¼Œå› æ­¤æˆ‘ä»¬æ— æ³•è®¡ç®—åæ–¹å·®çŸ©é˜µæˆ–å·®å¼‚çŸ©é˜µ

+   ç”±äº $m$ çš„å¤§å°ï¼Œæˆ‘ä»¬æ— æ³•æ‰¿æ‹…è®¡ç®—æ­£äº¤å˜æ¢çš„æˆæœ¬

æˆ‘ä»¬èƒ½å¦é€šè¿‡éšæœºçº¿æ€§æŠ•å½±å°† $m$ ä¸ªç‰¹å¾è½¬æ¢åˆ°ä½ç»´ $p$ï¼Ÿ

![](img/9ff1ace2c6fcc051cac02de9dd663851.png)

éšæœºæŠ•å½±çš„æ¦‚å¿µï¼Œä¸å¤šç»´å°ºåº¦ç›¸æ¯”ã€‚

å…¶ä¸­ $ğ‘‹_{1 \times m}$ æ˜¯ $m$ ä¸ªç‰¹å¾ä¸Šçš„å•ä¸ªæ•°æ®æ ·æœ¬ï¼Œ$ğ‘…_{p \times m}$ æ˜¯ä¸€ä¸ªéšæœºæŠ•å½±çŸ©é˜µï¼Œå¡«å……äº†éšæœºå€¼ï¼Œè€Œ $ğ‘‹_{p \times n}^{ğ‘…ğ‘ƒ}$ æ˜¯æŠ•å½±åˆ° $p$ ä¸ªç‰¹å¾çš„æ–°æ•°æ®ã€‚

## éšæœºæŠ•å½±

ä¸€ç§æ›¿ä»£ä¸»æˆåˆ†åˆ†æå’Œå¤šç»´å°ºåº¦åˆ†æçš„æ–¹æ³•ï¼Œå®ƒä¾èµ–äºä¸€ä¸ªéšæœº ($p \times n$) æŠ•å½±çŸ©é˜µï¼Œ$ğ‘…_{p \times m}$ã€‚

+   æ‰€æœ‰å€¼éƒ½æ˜¯ç‹¬ç«‹çš„éšæœºå˜é‡ï¼Œé€šå¸¸æ˜¯æ ‡å‡†æ­£æ€åˆ†å¸ƒï¼Œ$N\left[0,1\right]$ã€‚

ä¸ºäº†é¿å…å¤±çœŸï¼ŒæŠ•å½± $ğ‘…_{p \times m}$ åº”è¯¥æ˜¯æ­£äº¤çš„ï¼Œä½†å¦‚ä¸Šæ‰€è¿°ï¼Œç¡®ä¿æ­£äº¤æ€§è®¡ç®—æˆæœ¬å¤ªé«˜ï¼Œä¸ºäº†ç†è§£è¿™æ˜¯å¦‚ä½•å·¥ä½œçš„ï¼Œæˆ‘ä»¬éœ€è¦äº†è§£ï¼Œ

+   **Hercht-Neilsen (1994)** - é«˜ç»´ç©ºé—´ä¸­å­˜åœ¨å¤§é‡æ­£äº¤å‘é‡ï¼Œå¯èƒ½æ˜¯å‡†æ­£äº¤çš„ã€‚

+   **Johnson-Lindenstrauss å¼•ç†ï¼ˆ1984ï¼‰** - é«˜ç»´ç©ºé—´ä¸­çš„ç‚¹å¯ä»¥ä»¥é«˜æ¦‚ç‡çº¿æ€§åµŒå…¥åˆ°ä½ç»´ç©ºé—´ä¸­ï¼Œå¹¶ä¸”è¿‘ä¼¼ä¿æŒæˆå¯¹è·ç¦»ã€‚

## é«˜ç»´ç©ºé—´ä¸­çš„è¿‘ä¼¼æ­£äº¤å‘é‡

Robert Hercht-Neilsen (1994) è¯æ˜äº†åœ¨é«˜ç»´ç©ºé—´ä¸­ï¼Œè¿‘ä¼¼æ­£äº¤çš„æ–¹å‘æ•°é‡è¿œå¤šäºä¸¥æ ¼æ­£äº¤çš„æ–¹å‘ã€‚

+   åœ¨é«˜ç»´ä¸­ï¼ŒéšæœºçŸ©é˜µå¯èƒ½è¶³å¤Ÿæ¥è¿‘æ­£äº¤ã€‚

$$ ğ‘…_{mÃ—p}^ğ‘‡ ğ‘…_{pÃ—m} \approx ğ¼_{mÃ—m} $$

å…¶ä¸­ $I$ æ˜¯å•ä½çŸ©é˜µï¼Œ$\approx$ è¡¨ç¤ºè¿‘ä¼¼ç­‰äºå•ä½çŸ©é˜µã€‚

å¦‚æœç»´åº¦è¶³å¤Ÿå¤§ï¼Œå³é«˜ç»´ç©ºé—´ï¼Œæˆ‘ä»¬çš„éšæœºå‘é‡å°†è¶³å¤Ÿæ¥è¿‘æ­£äº¤ã€‚

+   éšç€ç»´åº¦çš„å¢åŠ ï¼Œç‰¹å¾çš„æ•°é‡ $ğ‘š$ çš„æ¦‚ç‡ä¹Ÿä¼šå¢åŠ ã€‚

## é«˜ç»´ç©ºé—´ä¸­æˆå¯¹è·ç¦»è¿‘ä¼¼ä¿æŒçš„æ¦‚ç‡

è¿™ç§éšæœºæ–¹æ³•ä¹‹æ‰€ä»¥åœ¨å®è·µä¸­æœ‰æ•ˆï¼Œæ˜¯å› ä¸º Johnson-Lindenstrauss å¼•ç†ï¼š

*åœ¨æ•°å­¦ä¸­ï¼ŒJohnson-Lindenstrauss å¼•ç†æ˜¯å…³äºä»é«˜ç»´ç©ºé—´åˆ°ä½ç»´æ¬§å‡ é‡Œå¾—ç©ºé—´ä½å¤±çœŸåµŒå…¥çš„ç»“æœã€‚å¼•ç†è¡¨æ˜ï¼Œé«˜ç»´ç©ºé—´ä¸­çš„ä¸€å°éƒ¨åˆ†ç‚¹å¯ä»¥åµŒå…¥åˆ°ä½ç»´ç©ºé—´ä¸­ï¼Œä½¿å¾—ç‚¹ä¹‹é—´çš„è·ç¦»å‡ ä¹å¾—åˆ°ä¿ç•™ã€‚ç”¨äºåµŒå…¥çš„æ˜ å°„è‡³å°‘æ˜¯ Lipschitz çš„ï¼Œç”šè‡³å¯ä»¥å–ä¸ºæ­£äº¤æŠ•å½±ã€‚* - ç»´åŸºç™¾ç§‘æ–‡ç« ã€‚

åœ¨é«˜ç»´ç©ºé—´ä¸­çš„ç‚¹å¯ä»¥ä»¥å‡ ä¹ä¿ç•™ç‚¹ä¹‹é—´è·ç¦»çš„æ–¹å¼çº¿æ€§åµŒå…¥åˆ°ä½ç»´ç©ºé—´ä¸­ï¼ˆæˆ‘ä»¬å…è®¸è¯¯å·®ï¼Œğœ€ï¼‰

æˆ‘ä»¬å¯ä»¥æ ¹æ®æ•°æ®é›†çš„å¤§å° ğ‘› å’Œæ‰€éœ€çš„è¯¯å·®é™åˆ¶ ğœ€ï¼Œè®¡ç®—å‡ºåŸºäºéšæœºæŠ•å½±ï¼Œä»¥é«˜æ¦‚ç‡æŠ•å½±çš„æœ€å°ç»´åº¦æ•° ğ‘ï¼Œ

$$ ğ‘ > \frac{lnâ¡(ğ‘›)}{ğœ€Â²} $$

ä¾‹å¦‚ï¼Œå¯¹äºå…·æœ‰ 10% å¯¹è·è¯¯å·®ï¼ˆ0.1ï¼‰çš„ 1000 ä¸ªæ•°æ®ï¼Œæˆ‘ä»¬å¯ä»¥éšæœºæŠ•å½±åˆ° 690 ç»´ã€‚

+   è¿™ä¸ªæœ€å°å€¼ä¸ä¾èµ–äºé—®é¢˜çš„åŸå§‹ç»´åº¦æ€§ï¼Œ$ğ‘š$ï¼

## åŠ è½½æ‰€éœ€çš„åº“

ä»¥ä¸‹ä»£ç åŠ è½½æ‰€éœ€çš„åº“ã€‚è¿™äº›åº“åº”è¯¥å·²ç»ä¸ Anaconda 3 ä¸€èµ·å®‰è£…ã€‚

```py
ignore_warnings = True                                        # ignore warnings?
import numpy as np                                            # ndarrays for gridded data
import pandas as pd                                           # DataFrames for tabular data
import os                                                     # set working directory, run executables
import matplotlib.pyplot as plt                               # for plotting
from matplotlib.ticker import (MultipleLocator,AutoMinorLocator,NullLocator,FuncFormatter) # control of axes ticks
import matplotlib.patches as patches                          # add square to matrix plot
from scipy import stats                                       # summary statistics
import math                                                   # trigonometry etc.
import scipy.signal as signal                                 # kernel for moving window calculation
import random                                                 # for random numbers
import seaborn as sns                                         # for matrix scatter plots
from scipy import linalg                                      # for linear regression

from sklearn.random_projection import GaussianRandomProjection # random projection
from sklearn.random_projection import johnson_lindenstrauss_min_dim
from sklearn.random_projection import SparseRandomProjection
from sklearn.metrics.pairwise import euclidean_distances
from sklearn.preprocessing import StandardScaler              # standardize features
plt.rc('axes', axisbelow=True)                                # plot all grids below the plot elements
if ignore_warnings == True:                                   
    import warnings
    warnings.filterwarnings('ignore')
cmap = plt.cm.inferno                                         # color map
seed = 42                                                     # random number seed 
```

å¦‚æœæ‚¨é‡åˆ°åŒ…å¯¼å…¥é”™è¯¯ï¼Œæ‚¨å¯èƒ½é¦–å…ˆéœ€è¦å®‰è£…è¿™äº›åŒ…ä¸­çš„æŸäº›åŒ…ã€‚è¿™é€šå¸¸å¯ä»¥é€šè¿‡åœ¨ Windows ä¸Šæ‰“å¼€å‘½ä»¤çª—å£ç„¶åè¾“å…¥â€˜python -m pip install [package-name]â€™æ¥å®Œæˆã€‚æœ‰å…³ç›¸åº”åŒ…çš„æ–‡æ¡£ä¸­æä¾›äº†æ›´å¤šå¸®åŠ©ã€‚

## å£°æ˜å‡½æ•°

æ–¹ä¾¿çš„å‡½æ•°ï¼Œç”¨äºå‘æ•°å­—æ·»åŠ é€—å·ï¼Œä»¥åŠå‘å›¾è¡¨æ·»åŠ ä¸»å‰¯ç½‘æ ¼çº¿ã€‚

```py
def comma_format(x, pos):
    return f'{int(x):,}'

def add_grid():                                            
    plt.gca().grid(True, which='major',linewidth = 1.0); plt.gca().grid(True, which='minor',linewidth = 0.2) # add y grids
    plt.gca().tick_params(which='major',length=7); plt.gca().tick_params(which='minor', length=4)
    plt.gca().xaxis.set_minor_locator(AutoMinorLocator()); plt.gca().yaxis.set_minor_locator(AutoMinorLocator()) # turn on minor ticks 
```

## è®¾ç½®å·¥ä½œç›®å½•

æˆ‘æ€»æ˜¯å–œæ¬¢è¿™æ ·åšï¼Œä»¥å…ä¸¢å¤±æ–‡ä»¶ï¼Œå¹¶ç®€åŒ–åç»­çš„è¯»å–å’Œå†™å…¥ï¼ˆé¿å…æ¯æ¬¡éƒ½åŒ…å«å®Œæ•´åœ°å€ï¼‰ã€‚

```py
#os.chdir("c:/PGE383")                                        # set the working directory 
```

## åŠ è½½è¡¨æ ¼æ•°æ®

è¿™æ˜¯å°†æˆ‘ä»¬çš„é€—å·åˆ†éš”æ•°æ®æ–‡ä»¶åŠ è½½åˆ° Pandas DataFrame å¯¹è±¡ä¸­çš„å‘½ä»¤ã€‚

```py
#df = pd.read_csv('unconv_MV_v4.csv')                         # load our data table
df = pd.read_csv(r'https://raw.githubusercontent.com/GeostatsGuy/GeoDataSets/master/unconv_MV_v4.csv')
df['TOC'] = np.where(df['TOC']<0.0, 0.0, df['TOC']) # set TOC < 0.0 as 0.0, otherwise leave the same 
```

å¯è§†åŒ– DataFrame å°†å¾ˆæœ‰ç”¨ï¼Œæˆ‘ä»¬å·²ç»åœ¨æœ¬æ¬¡æ¼”ç¤ºä¸­å­¦ä¹ äº†è¿™äº›æ–¹æ³• ([`git.io/fNgRW`](https://git.io/fNgRW))ã€‚

æˆ‘ä»¬å¯ä»¥é€šè¿‡ä½¿ç”¨â€˜headâ€™ DataFrame æˆå‘˜å‡½æ•°æ¥é¢„è§ˆ DataFrameï¼ˆæ ¼å¼æ•´æ´ï¼Œè§ä¸‹æ–‡ï¼‰ã€‚ä½¿ç”¨ head å‘½ä»¤æ—¶ï¼Œæ·»åŠ å‚æ•°â€˜n=13â€™ä»¥æŸ¥çœ‹æ•°æ®é›†çš„å‰ 13 è¡Œã€‚

```py
df.head(n=13)                                                 # we could also use this command for a table preview 
```

|  | Well | Por | Perm | AI | Brittle | TOC | VR | Prod |
| --- | --- | --- | --- | --- | --- | --- | --- | --- |
| 0 | 1 | 12.08 | 2.92 | 2.80 | 81.40 | 1.16 | 2.31 | 1695.360819 |
| 1 | 2 | 12.38 | 3.53 | 3.22 | 46.17 | 0.89 | 1.88 | 3007.096063 |
| 2 | 3 | 14.02 | 2.59 | 4.01 | 72.80 | 0.89 | 2.72 | 2531.938259 |
| 3 | 4 | 17.67 | 6.75 | 2.63 | 39.81 | 1.08 | 1.88 | 5288.514854 |
| 4 | 5 | 17.52 | 4.57 | 3.18 | 10.94 | 1.51 | 1.90 | 2859.469624 |
| 5 | 6 | 14.53 | 4.81 | 2.69 | 53.60 | 0.94 | 1.67 | 4017.374438 |
| 6 | 7 | 13.49 | 3.60 | 2.93 | 63.71 | 0.80 | 1.85 | 2952.812773 |
| 7 | 8 | 11.58 | 3.03 | 3.25 | 53.00 | 0.69 | 1.93 | 2670.933846 |
| 8 | 9 | 12.52 | 2.72 | 2.43 | 65.77 | 0.95 | 1.98 | 2474.048178 |
| 9 | 10 | 13.25 | 3.94 | 3.71 | 66.20 | 1.14 | 2.65 | 2722.893266 |
| 10 | 11 | 15.04 | 4.39 | 2.22 | 61.11 | 1.08 | 1.77 | 3828.247174 |
| 11 | 12 | 16.19 | 6.30 | 2.29 | 49.10 | 1.53 | 1.86 | 5095.810104 |
| 12 | 13 | 16.82 | 5.42 | 2.80 | 66.65 | 1.17 | 1.98 | 4091.637316 |

æ­¤æ•°æ®é›†åŒ…å«æ¥è‡ª 200 ä¸ªéå¸¸è§„äº•çš„ç‰¹å¾ï¼š

1.  äº•æŒ‡æ•°

1.  äº•å¹³å‡å­”éš™ç‡ï¼ˆ%ï¼‰

1.  æ¸—é€ç‡ï¼ˆmDï¼‰

1.  å£°é˜»æŠ—ï¼ˆkg/m2s*10â¶ï¼‰

1.  å‰ªåˆ‡æ¯”ï¼ˆ%ï¼‰

1.  æ€»æœ‰æœºç¢³ï¼ˆ%ï¼‰

1.  ç»ç’ƒè´¨åå°„ç‡ï¼ˆ%ï¼‰

1.  æ ‡å‡†åŒ–åˆå§‹ç”Ÿäº§ 90 å¤©å¹³å‡ï¼ˆMCFPDï¼‰ã€‚

æ³¨æ„ï¼Œæ•°æ®é›†æ˜¯åˆæˆçš„ï¼Œä½†å…·æœ‰ç°å®èŒƒå›´å’Œä¸€èˆ¬çš„å¤šå˜é‡å…³ç³»ã€‚

æ’åºç‰¹å¾å®é™…ä¸Šæ˜¯ä¸€é¡¹ç†è§£ç‰¹å¾åŠå…¶ç›¸äº’å…³ç³»çš„åŠªåŠ›ã€‚æˆ‘ä»¬å°†ä»åŸºæœ¬æ•°æ®å¯è§†åŒ–å¼€å§‹ï¼Œç„¶åè½¬å‘æ›´å¤æ‚çš„æ–¹æ³•ï¼Œå¦‚åç›¸å…³å’Œé€’å½’ç‰¹å¾æ¶ˆé™¤ã€‚

## æ‘˜è¦ç»Ÿè®¡

è®©æˆ‘ä»¬æ£€æŸ¥ä¸€ä¸‹æˆ‘ä»¬æ•°æ®çš„æ‘˜è¦ç»Ÿè®¡ä¿¡æ¯ã€‚

```py
df.describe().transpose()                                     # display summary statistics 
```

|  | è®¡æ•° | å¹³å‡å€¼ | æ ‡å‡†å·® | æœ€å°å€¼ | 25% | 50% | 75% | æœ€å¤§å€¼ |
| --- | --- | --- | --- | --- | --- | --- | --- | --- |
| äº• | 200.0 | 100.500000 | 57.879185 | 1.000000 | 50.750000 | 100.500000 | 150.250000 | 200.000000 |
| å­” | 200.0 | 14.991150 | 2.971176 | 6.550000 | 12.912500 | 15.070000 | 17.402500 | 23.550000 |
| Perm | 200.0 | 4.330750 | 1.731014 | 1.130000 | 3.122500 | 4.035000 | 5.287500 | 9.870000 |
| äººå·¥æ™ºèƒ½ | 200.0 | 2.968850 | 0.566885 | 1.280000 | 2.547500 | 2.955000 | 3.345000 | 4.630000 |
| å‰ªåˆ‡ | 200.0 | 48.161950 | 14.129455 | 10.940000 | 37.755000 | 49.510000 | 58.262500 | 84.330000 |
| TOC | 200.0 | 0.991950 | 0.478264 | 0.000000 | 0.617500 | 1.030000 | 1.350000 | 2.180000 |
| VR | 200.0 | 1.964300 | 0.300827 | 0.930000 | 1.770000 | 1.960000 | 2.142500 | 2.870000 |
| äº§ | 200.0 | 3864.407081 | 1553.277558 | 839.822063 | 2686.227611 | 3604.303506 | 4752.637555 | 8590.384044 |

æ‘˜è¦ç»Ÿè®¡æ˜¯æ•°æ®æ£€æŸ¥çš„å…³é”®ç¬¬ä¸€æ­¥ã€‚

+   è¿™åŒ…æ‹¬æ¯ä¸ªç‰¹å¾çš„åˆæ³•ï¼ˆéç©ºï¼‰å€¼çš„æ•°é‡ï¼ˆè®¡æ•°ä»æ¯ä¸ªå˜é‡çš„æ€»æ•°ä¸­ç§»é™¤äº†æ‰€æœ‰ np.NaNï¼‰ã€‚

+   æˆ‘ä»¬å¯ä»¥çœ‹åˆ°ä¸€èˆ¬çš„è¡Œä¸ºï¼Œå¦‚ä¸­å¿ƒè¶‹åŠ¿ã€å¹³å‡å€¼å’Œåˆ†æ•£æ€§ã€æ–¹å·®ã€‚

+   æˆ‘ä»¬å¯ä»¥è¯†åˆ«å‡ºå…·æœ‰è´Ÿå€¼ã€æç«¯å€¼ä»¥åŠæ¯ä¸ªå±æ€§å¯èƒ½å€¼èŒƒå›´ä¹‹å¤–çš„å€¼çš„é—®é¢˜ã€‚

+   æˆ‘ä»¬è¿˜å¯ä»¥ä¸ºç»˜å›¾å»ºç«‹ç‰¹å¾èŒƒå›´ã€‚æˆ‘ä»¬å¯ä»¥ä½¿ç”¨å¦‚ä¸‹ä»£ç ç›´æ¥ä»æ•°æ®ä¸­è®¡ç®—ç‰¹å¾èŒƒå›´ï¼š

```py
Pormin = np.min(df['Por'].values)          # extract ndarray of data table column
Pormax = np.max(df['Por'].values)          # and calculate min and max 
```

ä½†æ˜¯ï¼Œè¿™ä¸ä¼šå¯¼è‡´æ˜“äºç†è§£çš„è‰²æ¡å’Œè½´åˆ»åº¦ï¼Œè®©æˆ‘ä»¬é€‰æ‹©æ–¹ä¾¿çš„æ•´æ•°ã€‚æˆ‘ä»¬è¿˜å°†å£°æ˜ç‰¹å¾æ ‡ç­¾ä»¥æ–¹ä¾¿ç»˜å›¾ã€‚

```py
pormin = 6.0; pormax = 24.0; porname = 'Porosity (%)'; portitle = 'Porosity'
permmin = 0.0; permmax = 10; permname = 'Permeability (mD)'; permtitle = 'Permeability'                
AImin = 1.0; AImax = 5.0; AIname = 'Acoustic Impedance (kg/m2s*10â¶)'; AItitle = 'Acoustic Impedance'
brmin = 10.0; brmax = 85.0; brname = 'Brittleness Ratio (%)'; brtitle = 'Brittleness'
TOCmin = 0.0; TOCmax = 2.2; TOCname = 'Total Organic Carbon (%)'; TOCtitle = 'Total Organic Carbon' 
VRmin = 0.9; VRmax = 2.9; VRname = 'Vitrinite Reflectance (%)'; VRtitle = 'Vitrinite Reflectance'
prodmin = 500.0; prodmax = 9000.0; prodname = 'Normalized Initial Production (MCFPD)'; prodtitle = 'Normalized Initial Production' 
```

æ•°æ®çœ‹èµ·æ¥ç›¸å½“è‰¯å¥½ï¼Œä¸ºäº†ç®€æ´èµ·è§ï¼Œæˆ‘ä»¬è·³è¿‡å¼‚å¸¸å€¼æ£€æµ‹ã€‚è®©æˆ‘ä»¬ä½¿ç”¨ Seaborn åŒ…çš„çŸ©é˜µæ•£ç‚¹å›¾æŸ¥çœ‹åˆ†å¸ƒã€‚

```py
sns.pairplot(df,vars=['Por','Perm','AI','Brittle','TOC','VR','Prod'],markers='o',plot_kws={'alpha': 0.2})
plt.subplots_adjust(left=0.0, bottom=0.0, right=0.6, top=0.6, wspace=0.3, hspace=0.2); plt.show() 
```

![å›¾ç‰‡](img/95fb79f6de153d43d36030d365b24d3e.png)

## ç‰¹å¾æ ‡å‡†åŒ–

ç”±äºæˆ‘ä»¬çš„æ¨¡å‹ä½¿ç”¨çš„æ˜¯å·®å¼‚åº¦ï¼ˆç±»ä¼¼äºç‰¹å¾ç©ºé—´ä¸­çš„è·ç¦»ï¼‰åº¦é‡ï¼Œæˆ‘ä»¬éœ€è¦æ ‡å‡†åŒ–ç‰¹å¾ã€‚

```py
features = ['Por','Perm','AI','Brittle','TOC','VR']
x = df.loc[:,features].values
mu = np.mean(x, axis=0)
sd = np.std(x, axis=0)
xs = StandardScaler().fit_transform(x)

ns_features = []
for i in range(0,len(features)):
    df['NS_'+features[i]] = xs[:,i]
    ns_features.append('NS_'+features[i]) 

df.head(n=13) 
```

|  | äº• | æ¸—é€ç‡ | æ¸—é€ç‡ | AI | è„†æ€§ | TOC | VR | ç”Ÿäº§ | NS_Por | NS_Perm | NS_AI | NS_Brittle | NS_TOC | NS_VR |
| --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- |
| 0 | 1 | 12.08 | 2.92 | 2.80 | 81.40 | 1.16 | 2.31 | 1695.360819 | -0.982256 | -0.817030 | -0.298603 | 2.358297 | 0.352257 | 1.152048 |
| 1 | 2 | 12.38 | 3.53 | 3.22 | 46.17 | 0.89 | 1.88 | 3007.096063 | -0.881032 | -0.463751 | 0.444147 | -0.141332 | -0.213702 | -0.280931 |
| 2 | 3 | 14.02 | 2.59 | 4.01 | 72.80 | 0.89 | 2.72 | 2531.938259 | -0.327677 | -1.008148 | 1.841224 | 1.748113 | -0.213702 | 2.518377 |
| 3 | 4 | 17.67 | 6.75 | 2.63 | 39.81 | 1.08 | 1.88 | 5288.514854 | 0.903875 | 1.401098 | -0.599240 | -0.592585 | 0.184565 | -0.280931 |
| 4 | 5 | 17.52 | 4.57 | 3.18 | 10.94 | 1.51 | 1.90 | 2859.469624 | 0.853263 | 0.138561 | 0.373409 | -2.640962 | 1.085907 | -0.214280 |
| 5 | 6 | 14.53 | 4.81 | 2.69 | 53.60 | 0.94 | 1.67 | 4017.374438 | -0.155597 | 0.277556 | -0.493133 | 0.385839 | -0.108895 | -0.980758 |
| 6 | 7 | 13.49 | 3.60 | 2.93 | 63.71 | 0.80 | 1.85 | 2952.812773 | -0.506505 | -0.423211 | -0.068704 | 1.103161 | -0.402355 | -0.380906 |
| 7 | 8 | 11.58 | 3.03 | 3.25 | 53.00 | 0.69 | 1.93 | 2670.933846 | -1.150962 | -0.753324 | 0.497200 | 0.343268 | -0.632930 | -0.114305 |
| 8 | 9 | 12.52 | 2.72 | 2.43 | 65.77 | 0.95 | 1.98 | 2474.048178 | -0.833795 | -0.932859 | -0.952930 | 1.249322 | -0.087933 | 0.052320 |
| 9 | 10 | 13.25 | 3.94 | 3.71 | 66.20 | 1.14 | 2.65 | 2722.893266 | -0.587484 | -0.226301 | 1.310688 | 1.279831 | 0.310334 | 2.285102 |
| 10 | 11 | 15.04 | 4.39 | 2.22 | 61.11 | 1.08 | 1.77 | 3828.247174 | 0.016483 | 0.034314 | -1.324305 | 0.918687 | 0.184565 | -0.647507 |
| 11 | 12 | 16.19 | 6.30 | 2.29 | 49.10 | 1.53 | 1.86 | 5095.810104 | 0.404506 | 1.140483 | -1.200514 | 0.066556 | 1.127830 | -0.347581 |
| 12 | 13 | 16.82 | 5.42 | 2.80 | 66.65 | 1.17 | 1.98 | 4091.637316 | 0.617075 | 0.630834 | -0.298603 | 1.311759 | 0.373218 | 0.052320 |

## æ•°æ®å‡†å¤‡

è®©æˆ‘ä»¬ä»è¿ç»­çš„ç”Ÿäº§ä¸­åˆ›å»ºä¸€ä¸ªæœ‰åºç‰¹å¾ï¼š

1.  ä½

1.  ä¸­ç­‰

1.  é«˜

1.  éå¸¸é«˜

ç”Ÿäº§ç‡ã€‚è¿™æœ‰åŠ©äºæˆ‘ä»¬åœ¨è¿›è¡Œè¿‡ç¨‹ä¸­å¯è§†åŒ–ç»“æœï¼Œæˆ‘ä»¬å¯ä»¥æŸ¥çœ‹ä¸åŒç”Ÿäº§æ°´å¹³çš„æ°´äº•ï¼Œè¿™äº›æ°´äº•è¢«æŠ•å½±åˆ°å„ç§ä½ç»´ç©ºé—´ä¸­ï¼Œä½¿ç”¨å¤šç»´å°ºåº¦ã€‚

```py
bins = [0,2500,5000,7500,10000]                # assign the production bins (these are the fence posts)
labels = ['low', 'med', 'high', 'vhigh']       # assign the labels
category = pd.cut(df['Prod'],bins,labels=labels)     # make the 1D array with the labels for our data
df['tProd'] = category                                # add the new ordinal production feature to our DataFrames 
df.head()
dpalette = sns.color_palette("rocket_r",n_colors = 4)
palette = sns.color_palette("rocket") 
```

è®©æˆ‘ä»¬çœ‹çœ‹æˆ‘ä»¬ 3 ä¸ªç‰¹å¾å’Œäº§é‡æ°´å¹³çš„çŸ©é˜µæ•£ç‚¹å›¾ã€‚

```py
plot = sns.pairplot(df[ns_features + ['tProd']],markers='o',hue = 'tProd', palette = dpalette,diag_kws={'edgecolor':'black'},plot_kws=dict(s=50, edgecolor="black", linewidth=0.5))

plt.subplots_adjust(left=0.0, bottom=0.0, right=1.5, top=1.5, wspace=0.3, hspace=0.2)
plt.show() 
```

![_images/88023e2fe485fa10c6d95a886b783b2fbba0d51476bfbbaea540a357171cf53f.png](img/361d301ea20bab27b890f9dc5260164c.png)

## éšæœºæŠ•å½±

è®©æˆ‘ä»¬æ¼”ç¤ºéšæœºæŠ•å½±çš„ä½¿ç”¨ã€‚

+   åœ¨ä½ç»´åº¦çš„æ¡ä»¶ä¸‹ï¼Œå¯¹äºæŸäº›éšæœºç§å­ï¼Œä½ å°†çœ‹åˆ°ç›¸å½“å·®çš„æ€§èƒ½

```py
n_components = 6; seed = 73058
rp = GaussianRandomProjection(n_components=n_components,random_state = seed)

dists = euclidean_distances(df[ns_features], squared=False).ravel()
nonzero = dists != 0   # select only non-identical samples pairs
dists = dists[nonzero]

projected_data = rp.fit_transform(df[ns_features])
projected_dists = euclidean_distances(projected_data, squared=False).ravel()[nonzero]

plt.subplot(221)
plt.scatter(dists,projected_dists,c='darkorange',alpha=0.6,edgecolor = 'black')
plt.arrow(0,0,200,200,width=0.02,color='black',head_length=0.0,head_width=0.0)
plt.xlim(0,15); plt.ylim(0,15); add_grid()
plt.xlabel("Pairwise Distance: original space"); plt.ylabel("Pairwise Distance: projected space")
plt.title("Pairwise Distance: Projected to %d Components" % n_components)

rates = projected_dists / dists
print("Distance Ratio, mean: %0.2f, standard deviation %0.2f." % (np.mean(rates), np.std(rates)))

plt.subplot(222)
plt.hist(rates, bins=50, range=(0., 2.),color = 'darkorange', alpha = 0.6, edgecolor='k')
plt.xlabel("Distance Ratio: projected / original"); plt.ylabel("Frequency"); add_grid()
plt.title("Pairwise Distance: Projected to %d Components" % n_components)

plt.subplot(223)
plt.hist(dists, bins=50, range=(0., 15.),color = 'darkorange', alpha = 0.6, edgecolor='k')
plt.xlabel("Pairwise Distance"); plt.ylabel("Frequency"); add_grid()
plt.title("Pairwise Distance: Original Data")

plt.subplot(224)
plt.hist(projected_dists, bins=50, range=(0., 15.),color = 'darkorange', alpha = 0.6, edgecolor='k')
plt.xlabel("Pairwise Distance"); plt.ylabel("Frequency"); add_grid()
plt.title("Pairwise Distance: Projected to %d Components" % n_components)

plt.subplots_adjust(left=0.0, bottom=0.0, right=2.0, top=2.1, wspace=0.2, hspace=0.2); plt.show() 
```

```py
Distance Ratio, mean: 0.83, standard deviation 0.16. 
```

![_images/9d381e4fb7046bb5ea95413bbcb76d715648c0783488f14ad9ea4a0c6ebf4ee0.png](img/b97660935d743314d8384f5fbdb20615.png)

æ£€æŸ¥éšæœºæŠ•å½±çŸ©é˜µçš„æ­£äº¤æ€§ã€‚

+   é€šè¿‡è®¡ç®—å’Œæ˜¾ç¤º $R_p^T R_p$ï¼Œå¦‚æœæ­£äº¤ï¼Œå®ƒåº”è¯¥æ˜¯ä¸€ä¸ªä¸¥æ ¼å¯¹è§’çŸ©é˜µ

```py
orthogonal_check = np.dot(rp.components_.T, rp.components_)

fig, ax = plt.subplots()
cax = ax.imshow(orthogonal_check,cmap=plt.cm.grey,vmin=-1,vmax=1.0,interpolation='None',zorder=1)
#cbar = plt.colorbar(); cbar.set_label('Value')

matrix_size = orthogonal_check.shape[0]  # Assuming the matrix is square (m x m)
square_size = 1  # Each square has size 1x1

for i in range(matrix_size):
    # Add a square around each diagonal element
    square = patches.Rectangle((i - 0.5, i - 0.5),square_size,square_size,linewidth=3, edgecolor='white', facecolor='none')
    ax.add_patch(square)

# Add a colorbar
cbar = fig.colorbar(cax)
cbar.set_label('Value', rotation=90, labelpad=15)  # Set label for colorbar

plt.title(r'Orthogonal Check, $R_p^T R_p$')
plt.xlabel('Columns'); plt.ylabel('Rows')
plt.subplots_adjust(left=0.0, bottom=0.0, right=1.0, top=1.0, wspace=0.2, hspace=0.3); plt.show() 
```

```py
---------------------------------------------------------------------------
AttributeError  Traceback (most recent call last)
Cell In[13], line 4
  1 orthogonal_check = np.dot(rp.components_.T, rp.components_)
  3 fig, ax = plt.subplots()
----> 4 cax = ax.imshow(orthogonal_check,cmap=plt.cm.grey,vmin=-1,vmax=1.0,interpolation='None',zorder=1)
  5 #cbar = plt.colorbar(); cbar.set_label('Value')
  7 matrix_size = orthogonal_check.shape[0]  # Assuming the matrix is square (m x m)

AttributeError: module 'matplotlib.cm' has no attribute 'grey' 
```

![å›¾ç‰‡](img/fb33fb692e076e2c71f895be6dd85b6c.png)

## æ·»åŠ æ›´å¤šåŠŸèƒ½

æˆ‘ä»¬çœ‹åˆ°ï¼Œå¯¹äº $m = 6$ï¼Œæˆ‘ä»¬æ²¡æœ‰çœ‹åˆ°æ˜¾è‘—çš„ç»´åº¦é™ä½ã€‚è®©æˆ‘ä»¬å®ä¾‹åŒ–ä¸€ä¸ªæ›´å¤§çš„æ¨¡å‹ã€‚

+   å°† $m$ è®¾ç½®å¾—å¾ˆå¤§ï¼Œå³ $m \ge 100$

+   å°† $p$ è®¾ç½®ä¸º $m$ çš„åˆç†æ¯”ä¾‹ï¼Œä¾‹å¦‚ $\frac{2}{3}$ åˆ° $\frac{1}{2}$

ç”±äºæˆ‘ä»¬æ²¡æœ‰è®¿é—®ä»»æ„å¤§çš„æ•°æ®é›†ï¼Œè®©æˆ‘ä»¬éšæœºç”Ÿæˆå®ƒã€‚

+   æ ‡å‡†æ­£æ€åˆ†å¸ƒï¼Œé«˜ç»´å¤šé«˜æ–¯åˆ†å¸ƒï¼Œæ‰€æœ‰å‡å€¼ä¸º 0ï¼Œæ–¹å·®ä¸º 1.0

+   ç‰¹å¾ä¹‹é—´çš„éšæœºç›¸å…³æ€§

+   æˆ‘ä»¬ä½¿ç”¨ç‰¹å¾å€¼åˆ†è§£ï¼Œå°†è´Ÿæˆ–é›¶ç‰¹å¾å€¼è®¾ç½®ä¸ºå°çš„æ­£æ•°ï¼Œä»¥ç¡®ä¿ç›¸å…³çŸ©é˜µæ˜¯æ­£åŠå®šçš„

```py
m = 100                                                       # number of dimensions
n_samples = 1000                                              # number of samples

np.random.seed(seed = seed)                                   # set the random seed
mean_vector = np.zeros(m)                                     # mean vector (zero mean for all variables)

random_matrix = np.random.rand(m, m)                          # step 1: generate a random matrix 
correlation_matrix = np.dot(random_matrix, random_matrix.T)   # step 2: create a symmetric correlation matrix
correlation_matrix = (correlation_matrix + correlation_matrix.T) / 2 # step 3: symmetrize the correlation matrix (ensures the matrix is symmetric)
np.fill_diagonal(correlation_matrix, 1)                       # step 4: normalize to have ones on the diagonal (this ensures unit variances)

# Ensure the covariance matrix is positive semi-definite using eigendecomposition
eigvals, eigvecs = np.linalg.eigh(correlation_matrix)         # eigendecomposition of the correlation matrix
eigvals = np.maximum(eigvals, 1e-6)                           # set any negative eigenvalues to a small positive value
cov_matrix = eigvecs @ np.diag(eigvals) @ eigvecs.T           # reconstruct the covariance matrix

big_data = np.random.multivariate_normal(mean_vector, cov_matrix, size=n_samples) # step 6: generate the multi-dimensional Gaussian dataset
df_big_data = pd.DataFrame(big_data, columns=[f"Dim_{i+1}" for i in range(m)]) # convert the data into a pandas DataFrame 
```

è¿™äº›æ•°æ®ç»´åº¦å¤ªé«˜ï¼Œä¸æ–¹ä¾¿å¯è§†åŒ–ï¼Œè®©æˆ‘ä»¬ç»§ç»­ä½¿ç”¨éšæœºæŠ•å½±ã€‚

```py
n_components = 5; seed = 73058
rp_big = GaussianRandomProjection(n_components=n_components,random_state = seed)

dists = euclidean_distances(df_big_data, squared=False).ravel()
nonzero = dists != 0   # select only non-identical samples pairs
dists = dists[nonzero]

projected_data = rp_big.fit_transform(df_big_data)
projected_dists = euclidean_distances(projected_data, squared=False).ravel()[nonzero]

plt.subplot(121)
plt.scatter(dists,projected_dists,c='red',alpha=0.2,edgecolor = 'black')
plt.arrow(0,0,10000,10000,width=0.02,color='black',head_length=0.0,head_width=0.0)
plt.xlabel("Pairwise Distance: original space")
plt.ylabel("Pairwise Distance: projected space")
plt.title("Pairwise Distance: Projected to %d Components" % n_components)
plt.xlim([0,400]); plt.ylim([0,400]); add_grid()

rates = projected_dists / dists
print("Distance Ratio, mean: %0.2f, standard deviation %0.2f." % (np.mean(rates), np.std(rates)))

plt.subplot(122)
plt.hist(rates, bins=50, range=(0., 2.),color = 'red', alpha = 0.2, edgecolor='k')
plt.xlabel("Distance Ratio: projected / original"); plt.ylabel("Frequency"); add_grid()
plt.title("Pairwise Distance: Projected to %d Components" % n_components)

plt.subplots_adjust(left=0.0, bottom=0.0, right=2.0, top=1.0, wspace=0.2, hspace=0.3); plt.show() 
```

```py
Distance Ratio, mean: 0.95, standard deviation 0.02. 
```

![å›¾ç‰‡](img/9e5d080e00dc637a851d8dfb22c425df.png)

æ£€æŸ¥éšæœºæŠ•å½±çŸ©é˜µçš„æ­£äº¤æ€§ã€‚

+   é€šè¿‡è®¡ç®—å’Œæ˜¾ç¤º $R_p^T R_p$ï¼Œå¦‚æœæ­£äº¤ï¼Œå®ƒåº”è¯¥æ˜¯ä¸€ä¸ªä¸¥æ ¼å¯¹è§’çŸ©é˜µ

æ³¨æ„ï¼Œ$R_p$ ä¸æ˜¯æ–¹é˜µï¼Œå®ƒæ˜¯ $p \times m$ï¼Œæ‰€ä»¥æˆ‘ä»¬å®é™…ä¸Šæ˜¯åœ¨æ£€æŸ¥åˆ—æ­£äº¤æ€§ï¼Œ$R_p^T R_p$

+   æˆ‘ä»¬æ­£åœ¨æ£€æŸ¥é™ä½çš„ç»´åº¦æŠ•å½±æ˜¯å¦å½¢æˆä¸€ä¸ªæ­£äº¤åŸº

+   ä»ä¸Šé¢çš„ $R_p^T$ æ˜¯ $m \times p$ï¼Œè€Œ $R_p$ æ˜¯ $p \times m$ï¼Œæ‰€ä»¥ $R_p^T R_p$ æ˜¯ $m \times m$

```py
orthogonal_check_big = np.dot(rp_big.components_.T, rp_big.components_)
fig, ax = plt.subplots()
cax = ax.imshow(orthogonal_check_big,cmap=plt.cm.grey,vmin=-1,vmax=1.5,interpolation='None',zorder=1)

matrix_size = orthogonal_check.shape[0]                       # assuming the matrix is square (m x m)
square_size = 1                                               # each square has size 1x1

cbar = fig.colorbar(cax); cbar.set_label('Value', rotation=90, labelpad=15) 

plt.title(r'Orthogonal Check, $R_p^T R_p$'); plt.xlabel('Columns'); plt.ylabel('Rows')
plt.subplots_adjust(left=0.0, bottom=0.0, right=1.0, top=1.0, wspace=0.2, hspace=0.3); plt.show() 
```

![å›¾ç‰‡](img/7f0d011d72830b71ea8a9544642b5b1e.png)

## æ·»åŠ æ›´å¤šåŠŸèƒ½

è®©æˆ‘ä»¬å°è¯•ä¸€ä¸ªæ›´å¤§çš„ç»´åº¦ï¼Œä½¿ç”¨å•ä¸ªä»£ç å—ã€‚

```py
m = 1000                                                      # number of dimensions
n_samples = 1000                                              # number of samples
n_components = 200                                            # number of components 
seed = 73058                                                  # random seed

np.random.seed(seed = seed)                                   # set the random seed
mean_vector = np.zeros(m)                                     # mean vector (zero mean for all variables)

random_matrix = np.random.rand(m, m)                          # step 1: generate a random matrix 
correlation_matrix = np.dot(random_matrix, random_matrix.T)   # step 2: create a symmetric correlation matrix
correlation_matrix = (correlation_matrix + correlation_matrix.T) / 2 # step 3: symmetrize the correlation matrix (ensures the matrix is symmetric)
np.fill_diagonal(correlation_matrix, 1)                       # step 4: normalize to have ones on the diagonal (this ensures unit variances)

# Ensure the covariance matrix is positive semi-definite using eigendecomposition
eigvals, eigvecs = np.linalg.eigh(correlation_matrix)         # eigendecomposition of the correlation matrix
eigvals = np.maximum(eigvals, 1e-6)                           # set any negative eigenvalues to a small positive value
cov_matrix = eigvecs @ np.diag(eigvals) @ eigvecs.T           # reconstruct the covariance matrix

very_big_data = np.random.multivariate_normal(mean_vector, cov_matrix, size=n_samples) # step 6: generate the multi-dimensional Gaussian dataset
df_very_big_data = pd.DataFrame(very_big_data, columns=[f"Dim_{i+1}" for i in range(m)]) # convert the data into a pandas DataFrame

rp_very_big = GaussianRandomProjection(n_components=n_components,random_state = seed)

dists = euclidean_distances(df_very_big_data, squared=False).ravel()
nonzero = dists != 0                                          # select only non-identical samples pairs
dists = dists[nonzero]

projected_data = rp_very_big.fit_transform(df_very_big_data)
projected_dists = euclidean_distances(projected_data, squared=False).ravel()[nonzero]

plt.subplot(121)
plt.scatter(dists,projected_dists,c='red',alpha=0.2,edgecolor = 'black')
plt.arrow(0,0,10000,10000,width=0.02,color='black',head_length=0.0,head_width=0.0)
plt.xlabel("Pairwise Distance: original space")
plt.ylabel("Pairwise Distance: projected space")
plt.title("Pairwise Distance: Projected to %d Components" % n_components)
plt.xlim([0,400]); plt.ylim([0,400]); add_grid()

orthogonal_check_very_big = np.dot(rp_very_big.components_.T, rp_very_big.components_)

plt.subplot(122)
im = plt.imshow(orthogonal_check_very_big,cmap=plt.cm.grey,vmin=-1,vmax=1.5,interpolation='None',zorder=1)
matrix_size = orthogonal_check.shape[0]                       # assuming the matrix is square (m x m)
square_size = 1                                               # each square has size 1x1
cbar = fig.colorbar(im); cbar.set_label('Value', rotation=90, labelpad=15) 
plt.title(r'Orthogonal Check, $R_p^T R_p$'); plt.xlabel('Columns'); plt.ylabel('Rows')

plt.subplots_adjust(left=0.0, bottom=0.0, right=2.0, top=1.0, wspace=0.2, hspace=0.3); plt.show() 
```

![å›¾ç‰‡](img/11e2a354bd1b2543a20f9194cee52d96.png)

## è¯„è®º

è¿™æ˜¯å¯¹éšæœºæŠ•å½±çš„åŸºæœ¬å¤„ç†ã€‚å¯ä»¥åšå’Œè®¨è®ºçš„è¿˜æœ‰å¾ˆå¤šï¼Œæˆ‘æœ‰å¾ˆå¤šæ›´å¤šçš„èµ„æºã€‚æŸ¥çœ‹æˆ‘çš„[å…±äº«èµ„æºæ¸…å•](https://michaelpyrcz.com/my-resources)ä»¥åŠæœ¬ç« å¼€å¤´å¸¦æœ‰èµ„æºé“¾æ¥çš„ YouTube è®²åº§é“¾æ¥ã€‚

æˆ‘å¸Œæœ›è¿™æœ‰æ‰€å¸®åŠ©ï¼Œ

*è¿ˆå…‹å°”*

## å…³äºä½œè€…

![å›¾ç‰‡](img/eb709b2c0a0c715da01ae0165efdf3b2.png)

å¾·å…‹è¨æ–¯å¤§å­¦å¥¥æ–¯æ±€åˆ†æ ¡çš„ 40 è‹±äº©æ ¡å›­å†…ï¼Œè¿ˆå…‹å°”Â·çš®å°”å¥‡æ•™æˆçš„åŠå…¬å®¤ã€‚

è¿ˆå…‹å°”Â·çš®å°”å¥‡æ˜¯å¾·å…‹è¨æ–¯å¤§å­¦å¥¥æ–¯æ±€åˆ†æ ¡[ç§‘å…‹é›·å°”å·¥ç¨‹å­¦é™¢](https://cockrell.utexas.edu/faculty-directory/alphabetical/p)å’Œ[æ°å…‹é€Šåœ°çƒç§‘å­¦å­¦é™¢](https://www.jsg.utexas.edu/researcher/michael_pyrcz/)çš„æ•™æˆï¼Œä»–åœ¨é‚£é‡Œç ”ç©¶æ•™å­¦åœ°ä¸‹ã€ç©ºé—´æ•°æ®åˆ†æã€åœ°ç»Ÿè®¡å­¦å’Œæœºå™¨å­¦ä¹ ã€‚è¿ˆå…‹å°”è¿˜æ˜¯ï¼Œ

+   è¯¥[èƒ½æºåˆ†æ](https://fri.cns.utexas.edu/energy-analytics)æ–°ç”Ÿç ”ç©¶é¡¹ç›®çš„è´Ÿè´£äººï¼Œä»¥åŠå¾·å…‹è¨æ–¯å¤§å­¦å¥¥æ–¯æ±€åˆ†æ ¡è‡ªç„¶ç§‘å­¦å­¦é™¢æœºå™¨å­¦ä¹ å®éªŒå®¤çš„æ ¸å¿ƒæ•™å‘˜

+   [ã€Šè®¡ç®—æœºä¸åœ°çƒç§‘å­¦ã€‹(https://www.sciencedirect.com/journal/computers-and-geosciences/about/editorial-board)]çš„å‰¯ç¼–è¾‘ï¼Œä»¥åŠå›½é™…æ•°å­¦åœ°çƒç§‘å­¦åä¼š[ã€Šæ•°å­¦åœ°çƒç§‘å­¦ã€‹(https://link.springer.com/journal/11004/editorial-board)]çš„è‘£äº‹ä¼šæˆå‘˜ã€‚

è¿ˆå…‹å°”å·²ç»æ’°å†™äº†è¶…è¿‡ 70 ç¯‡[åŒè¡Œè¯„å®¡çš„å‡ºç‰ˆç‰©](https://scholar.google.com/citations?user=QVZ20eQAAAAJ&hl=en)ï¼Œä¸€ä¸ªç”¨äºç©ºé—´æ•°æ®åˆ†æçš„[Python åŒ…](https://pypi.org/project/geostatspy/)ï¼Œåˆè‘—äº†ä¸€æœ¬å…³äºç©ºé—´æ•°æ®åˆ†æçš„æ•™ç§‘ä¹¦ã€Š[åœ°è´¨ç»Ÿè®¡å­¦å‚¨å±‚å»ºæ¨¡](https://www.amazon.com/Geostatistical-Reservoir-Modeling-Michael-Pyrcz/dp/0199731446)ã€‹ï¼Œå¹¶æ˜¯ä¸¤æœ¬æœ€è¿‘å‘å¸ƒçš„ç”µå­ä¹¦çš„ä½œè€…ï¼Œåˆ†åˆ«æ˜¯[ã€ŠPython ä¸­çš„åº”ç”¨åœ°è´¨ç»Ÿè®¡å­¦ï¼šGeostatsPy å®è·µæŒ‡å—ã€‹(https://geostatsguy.github.io/GeostatsPyDemos_Book/intro.html)å’Œã€ŠPython ä¸­çš„åº”ç”¨æœºå™¨å­¦ä¹ ï¼šå¸¦ä»£ç çš„å®è·µæŒ‡å—ã€‹(https://geostatsguy.github.io/MachineLearningDemos_Book/intro.html)ã€‚

è¿ˆå…‹å°”çš„æ‰€æœ‰å¤§å­¦è®²åº§éƒ½å¯åœ¨ä»–çš„[YouTube é¢‘é“](https://www.youtube.com/@GeostatsGuyLectures)ä¸Šæ‰¾åˆ°ï¼Œå…¶ä¸­åŒ…å« 100 å¤šä¸ª Python äº¤äº’å¼ä»ªè¡¨æ¿å’Œ 40 å¤šä¸ªå­˜å‚¨åº“ä¸­çš„è¯¦ç»†å·¥ä½œæµç¨‹ï¼Œè¿™äº›å­˜å‚¨åº“ä½äºä»–çš„[GitHub è´¦æˆ·](https://github.com/GeostatsGuy)ï¼Œä»¥æ”¯æŒä»»ä½•æ„Ÿå…´è¶£çš„å­¦ç”Ÿå’Œåœ¨èŒä¸“ä¸šäººå£«ã€‚è¦äº†è§£æ›´å¤šå…³äºè¿ˆå…‹å°”çš„å·¥ä½œå’Œå…±äº«æ•™è‚²èµ„æºï¼Œè¯·è®¿é—®ä»–çš„ç½‘ç«™ã€‚

## æƒ³ä¸€èµ·å·¥ä½œå—ï¼Ÿ

æˆ‘å¸Œæœ›è¿™ä¸ªå†…å®¹å¯¹é‚£äº›æƒ³äº†è§£æ›´å¤šå…³äºåœ°ä¸‹å»ºæ¨¡ã€æ•°æ®åˆ†æå’Œå­¦ä¹ æœºå™¨å­¦ä¹ çš„äººæœ‰æ‰€å¸®åŠ©ã€‚å­¦ç”Ÿå’Œåœ¨èŒä¸“ä¸šäººå£«éƒ½æ¬¢è¿å‚åŠ ã€‚

+   æƒ³é‚€è¯·æˆ‘åˆ°è´µå…¬å¸è¿›è¡ŒåŸ¹è®­ã€è¾…å¯¼ã€é¡¹ç›®å®¡æŸ¥ã€å·¥ä½œæµç¨‹è®¾è®¡å’Œ/æˆ–å’¨è¯¢å—ï¼Ÿæˆ‘å¾ˆä¹æ„æ‹œè®¿å¹¶ä¸æ‚¨ä¸€èµ·å·¥ä½œï¼

+   æ„Ÿå…´è¶£åˆä½œã€æ”¯æŒæˆ‘çš„ç ”ç©¶ç”Ÿç ”ç©¶æˆ–æˆ‘çš„åœ°ä¸‹æ•°æ®åˆ†æä¸æœºå™¨å­¦ä¹ è”ç›Ÿï¼ˆå…±åŒè´Ÿè´£äººæ˜¯çº¦ç¿°Â·ç¦æ–¯ç‰¹æ•™æˆï¼‰å—ï¼Ÿæˆ‘çš„ç ”ç©¶å°†æ•°æ®åˆ†æã€éšæœºå»ºæ¨¡å’Œæœºå™¨å­¦ä¹ ç†è®ºä¸å®è·µç›¸ç»“åˆï¼Œä»¥å¼€å‘æ–°çš„æ–¹æ³•å’Œå·¥ä½œæµç¨‹ï¼Œå¢åŠ ä»·å€¼ã€‚æˆ‘ä»¬æ­£åœ¨è§£å†³å…·æœ‰æŒ‘æˆ˜æ€§çš„åœ°ä¸‹é—®é¢˜ï¼

+   æ‚¨å¯ä»¥é€šè¿‡ mpyrcz@austin.utexas.edu è”ç³»åˆ°æˆ‘ã€‚

æˆ‘æ€»æ˜¯å¾ˆé«˜å…´è®¨è®ºï¼Œ

*è¿ˆå…‹å°”*

è¿ˆå…‹å°”Â·çš®å°”å¥‡å…¹ï¼Œåšå£«ï¼Œå·¥ç¨‹å¸ˆï¼Œå¾·å…‹è¨æ–¯å¤§å­¦å¥¥æ–¯æ±€åˆ†æ ¡ Cockrell å·¥ç¨‹å­¦é™¢å’Œ Jackson åœ°çƒç§‘å­¦å­¦é™¢æ•™æˆ

æ›´å¤šèµ„æºå¯åœ¨ä»¥ä¸‹é“¾æ¥æ‰¾åˆ°ï¼š[Twitter](https://twitter.com/geostatsguy) | [GitHub](https://github.com/GeostatsGuy) | [ç½‘ç«™](http://michaelpyrcz.com) | [Google Scholar](https://scholar.google.com/citations?user=QVZ20eQAAAAJ&hl=en&oi=ao) | [åœ°ç»Ÿè®¡å­¦ä¹¦ç±](https://www.amazon.com/Geostatistical-Reservoir-Modeling-Michael-Pyrcz/dp/0199731446) | [YouTube](https://www.youtube.com/channel/UCLqEr-xV-ceHdXXXrTId5ig) | [Python ä¸­åº”ç”¨åœ°ç»Ÿè®¡å­¦ç”µå­ä¹¦](https://geostatsguy.github.io/GeostatsPyDemos_Book/intro.html) | [Python ä¸­åº”ç”¨æœºå™¨å­¦ä¹ ç”µå­ä¹¦](https://geostatsguy.github.io/MachineLearningDemos_Book/) | [LinkedIn](https://www.linkedin.com/in/michael-pyrcz-61a648a1)
