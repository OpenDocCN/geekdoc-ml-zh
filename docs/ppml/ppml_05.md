# 第三章 变量类型和数据结构

> 原文：[`ppml.dev/types-structures.html`](https://ppml.dev/types-structures.html)

在探索机器学习系统构建的基础组件时，我们强调不同类型的硬件被优化以与存储在特定格式的数据和模型一起工作。两者都是复杂的实体，由各种元素组成，这些元素被组织成*数据结构*，如数据框（表示表格数据）或标准化的模型格式如 ONNX（ONNX 2021）。这些数据结构内部的各个元素是特定*类型*的*变量*，例如整数、浮点数和字符串。

在本章中，我们回顾了第二章中提到的变量类型，以及字符串表示，并讨论了为什么对于不同类型的数据选择一个而不是另一个的可能原因（第 3.1 节）。然后我们给出了一些变量在数据结构中组织的显著例子，如向量（第 3.2.1 节）、列表（第 3.2.2 节）和矩阵（第 3.2.3 节）。不同的变量类型选择（第 3.3 节）和数据结构选择（第 3.4 节）在硬件支持方面以及机器学习算法在它们上操作的计算复杂度方面都代表了不同的权衡，正如我们在第二章中看到的，我们将在第四章中讨论。

## 3.1 变量类型

机器学习软件主要处理的是我们建模的数据的数学表示。图像可以用每个像素的颜色通道的值来表示；文本可以编码成字符串，然后转换成特定单词的频率；传感器数据记录为时间序列。我们可以用不同类型的变量存储它们，每种变量都有其优缺点，我们将在第 3.3 节中讨论。

### 3.1.1 整数

整数变量可以用来表示自然数（\(\mathbb{N}\)）或整数数（\(\mathbb{Z}\)）。它们通常用来表示布尔变量作为*指示器*（也称为*虚拟变量*）如下。

![](img/4fb7610c15d4c942edbb576525b2157e.png)

更普遍地，它们可以用来给有限集提供数值表示，通过将每个元素映射到不同的整数。

![](img/c1e62830c60b87282430c1bc8318fba5.png)

在 C 中的枚举或在 R 中的因子正是以这种方式构建的，以最小化内存使用。然而，这种数字表示不适合对离散变量进行建模，因为它使得参数估计依赖于元素和整数之间的特定映射。⁷ 相反，我们将离散变量映射到它们的*单热编码*：⁸ 集合中的每个元素都被分配一个指示变量，如果观察到该元素，则该变量取值为 1，否则为 0。

![图片](img/5d2db59281f543994669c64e9b01050d.png)

我们想要表示的元素数量决定了每个整数将使用多少位内存：\(n\)位允许有 \(2^n\) 个不同的值。一个位就足以表示布尔值，尽管在实践中，它通常至少使用 1 个字节来存储。一个包含\(k\)个元素的有限集可以用\(\log_2 k\)位表示：单热编码通过使用指示变量来绕过这个限制，但代价是使用更多的内存。

自然数和整数不能完全由整数变量表示：那将需要无限数量的位。因此，编程语言提供了不同大小的整数变量，例如 8 位、16 位、32 位和 64 位。这些大小都是 8 位的倍数，因为处理器被优化以处理字节。整数变量的大小决定了它可以表示的最大数字。例如，在 32 位中我们可以表示的最大（*无符号*）自然数是 \(2^{32} - 1 \approx 4.29 \times 10⁹\)，而最大的（*有符号*）整数是 \(\pm 2^{31} - 1 \approx \pm 2.14 \times 10^{9}\)，因为 1 位被保留用于编码符号。（如果该位设置为 0，则该数被认为是正数。）超出此范围的数字被称为*溢出*，意味着它们的位表示大于整数变量的大小，因此超出了为该变量保留的内存。

为了举例，考虑将自然数 3134 表示为 16 位无符号整数变量。

![图片](img/0928beb318cbdbc3da5ed86cbb81d2ce.png)

很容易验证这种表示与“自然”表示等价，它们只是使用了不同的基数：\[\begin{equation*} 2¹ + 2² + 2³ + 2⁴ + 2⁵ + 2^{10} + 2^{11} = 3134. \end{equation*}\] 16 位可以表示的最大数字是 \(2^{16} - 1 = 65535\)，而 3134 远小于这个数字：我们可以很容易地看到表示 4 个最大的 2 的幂（\(2^{15}\)，\(2^{14}\)，\(2^{13}\)和\(2^{12}\)）的 4 个最高有效位都是零。现在考虑一个更大的数字：247586。

![图片](img/70be4fcf3e6f53c305e5cdb47849431d.png)

再次，我们可以很容易地验证 \[\begin{equation*} 2¹ + 2⁵ + 2⁸ + 2⁹ + 2^{10} + 2^{14} + 2^{15} + 2^{16} + 2^{17} = 247586. \end{equation*}\]

不幸的是，247586 大于 65535，无法用 16 位表示。如果我们尝试将其存储在 16 位中，会发生溢出：整数变量将只包含 16 个**最低有效位**，代表从\(2⁰\)到\(2^{15}\)的幂。对应于\(2^{16}\)和\(2^{17}\)的位将被静默丢弃，整数变量将包含数字 \[\begin{equation*} 2¹ + 2⁵ + 2⁸ + 2⁹ + 2^{10} + 2^{14} + 2^{15} = 50978. \end{equation*}\]

在有符号整数的情况下，溢出的位将覆盖符号位，导致整数变量存储的数字可能在符号和绝对值上都是不正确的。再次考虑数字 247586，这次表示为一个 16 位有符号整数变量。

![](img/1bd802543062fb519ba05462ed1f1c34.png)

二进制表示的前 15 位被正确存储，对应于\(2^{15}\)的位覆盖了符号位，而对应于\(2^{16}\)和\(2^{17}\)的最后两位再次被静默丢弃。因此，整数变量将包含数字 \[\begin{equation*} - (2¹ + 2⁵ + 2⁸ + 2⁹ + 2^{10} + 2^{14}) = -18210. \end{equation*}\]

作为规则的例外，R 使用给定精度的最大负有符号整数来表示缺失的整数值（`NA`）。在 Python 中，Pandas 使用掩码数组来达到相同的目的，并保留一个单独的布尔变量来指示整数是否为缺失值（表示为`pandas.NA`）。NumPy 不支持整数变量的缺失值。

除了范围限制之外，整数变量允许**精确的计算机算术**：它们的位表示与二进制下整数和自然数的数学表示相一致，因此没有舍入或精度损失。

### 3.1.2 浮点数

浮点变量用于表示实数（\(\mathbb{R}\)）和复数（\(\mathbb{C}\)），前者用一个变量表示，后者用两个（一个表示实部，一个表示虚部）。每个变量由四个部分组成：**符号** \(S\)、**偏移量**或**偏移** \(O\)、**指数** \(E\) 和**尾数** \(M\)。实数 \(x\) 的浮点表示为 \[\begin{equation*} x = (-1)^S * (1 + M) 2^{E + O}. \end{equation*}\] 变量的总位数通常是 16、32 或 64 位，通常称为**半精度**、**单精度**、**双精度**。分配给指数（加上偏移量后）和尾数的位数取决于所使用的编码；符号始终存储在一个位中。在 IEEE 754 标准中定义的变量（Overton 2001）保留：

| **精度** | **指数** | **尾数** |
| --- | --: | --: |
| 半精度（16 位） | 5 位 | 10 位 |
| 单精度（32 位） | 8 位 | 23 位 |
| 双精度（64 位） | 11 位 | 52 位 |

偏移值的计算公式为 \(O = 2^{|E| - 1} - 1\)，其中 \(|E|\) 是指数的位数。

在开发 TPUs 的过程中，谷歌提出的替代“大脑”格式通常大小为 16 位，被称为“bfloat16”。它的工作方式与 IEEE 754 浮点数相同，因此我们不再进一步讨论；唯一的区别是它为指数分配了 8 位，为尾数分配了 7 位。

这在二进制表示中意味着什么？以数字 435.25 为例。在通常的科学记数法中，以 10 为基数，我们可以将其写成 \(4.3525 \times 10²\)。如果我们以 2 为基数做同样的事情，科学记数法变为 \(1.7001953125 \times 2⁸\)。指数是 \(8\)，尾数是 \(0.7001953125\)。作为一个半精度浮点变量，435.25 的二进制表示如下：

![](img/9a2d64045472ae45c5aeea4e31b91cf5.png)

偏移值添加后存储指数：\[\begin{equation*} 8 + (2^{5 - 1} - 1) = 23 = 2⁰ + 2¹ + 2² + 2⁴. \end{equation*}\] 结果数字被视为无符号数，无论原始指数是正数还是负数。如果符号存储在变量的最高有效位中，则使用偏移调整指数，并将尾数存储在最低有效位中，我们只需通过比较它们的二进制表示来比较浮点数，这可以通过硬件指令高效完成。

尾数 \[\begin{equation*} 2^{-1} + 2^{-3} + 2^{-4} + 2^{-7} + 2^{-8} + 2^{-10} = 0.7001953, \end{equation*}\] 与 \(0.7001953125\) 相差 \(1.25 \times 10^{-8}\)。这种差异被称为由尾数位数精度限制产生的 *浮点误差*。唯一可以精确表示的数字是那些可以分解为指数和尾数中可用的 2 的幂的数字。这显然排除了所有具有无限位数的数字，例如 \(\pi\)、\(e\) 或 \(1/3\)。

浮点数的范围是多少？我们可以表示的最大数（正数或负数）受指数大小的限制：使用 \(|E|\) 位，我们可以表示多达 \(2^{|E|}\) 个指数。偏移确保可用的指数在从 \(-2^{|E| - 1} - 2\) 到 \(2^{|E| - 1} - 1\) 的正负数之间平均分配，这是由于偏移的存在。

| **精度** | **最小指数** | **最大指数** |
| --- | --: | --: |
| half | \(-(2^{4} - 2) = -14\) | \(2^{4} - 1 = 15\) |
| single | \(-(2^{7} - 2) = -126\) | \(2^{7} - 1 = 127\) |
| double | \(-(2^{10} - 2) = -1022\) | \(2^{10} - 1 = 1023\) |

这个范围比理论上可能包含的 \(2^{|E|}\) 值要小，因为一些位组合被保留用于特殊类别的数字：

+   零使用指数字段和尾数填充 0 位来编码。

+   正无穷和负无穷（`+Inf`，`-Inf`）使用指数字段填充 1 位和尾数填充 0 位来编码。

+   不可表示的数字（通常表示为 `NaN`）使用指数字段填充 1 位和至少一个非零位来编码。在尾数中使用的不同位模式用于不同类型的不可表示数字：最常见的是缺失值标识符 `NA`。通常，`NaN` 是由于除以零或尝试将数学函数应用于其域外的值而产生的，例如，对负数取对数。

+   亚正常数，即太小而不能用可用指数的二进制科学记数法表示的数字。换句话说，它们的起始指数小于最小可用指数。它们使用指数字段填充 0 位来编码。这些数字的精度降低，因为它们实际上只使用了部分尾数。例如，\(2^{-10} \times 2^{-14} \approx 5.96 \times 10^{-8}\) 在半精度中表示如下：

![图片](img/5e99bc399ccb5d3c2411b7aea644d999.png)

浮点数舍入有多粗糙？对于任何给定的精度，这取决于数字的大小。正如我们在上面的例子中所看到的，尾数只能编码这么多有效数字：半精度的 \(\log_{10}(2^{10}) \approx 3\) 位数字，单精度的 \(\log_{10}(2^{23}) \approx 7\) 位，双精度的 \(\log_{10}(2^{51}) \approx 16\) 位。这实际上创建了一个可以精确表示的值网格，任何其他数字都四舍五入到最接近的可以精确表示的数字或 `+Inf`/`-Inf`。随着指数的增大，网格在绝对值上变得更加粗糙。考虑一个像 0.0002 这样对于半精度变量来说很小的数字：

![图片](img/b9bb7a7170667c44853d8921c3a78e29.png)

指数是 \[\begin{equation*} -13 + (2^{5 - 1} - 1) = 2¹ \end{equation*}\]，尾数是 \[\begin{equation*} 2^{-1} + 2^{-3} + 2^{-7} + 2^{-8} + 2^{-9} = 0.638671875, \end{equation*}\]，这给出 \[\begin{equation*} 1.638671875 \times 2^{-13} \approx 0.000200033. \end{equation*}\] 通过添加 \(2^{-10}\) 来增加这个数的最小可能量，并通过相同数量的减少来减少它，这表明可以用半精度表示的最近数字是 \(\approx 0.000200033 \pm 1.19 \times 10^{-7}\)。

现在考虑一个相对较大的数字（对于半精度）如 10002：

![图片](img/6d21e052a7bdf6dde92199a309492390.png)

指数是 \[\begin{equation*} 13 + (2^{5 - 1} - 1) = 28 = 2² + 2³ + 2⁴ \end{equation*}\] 并且尾数是 \[\begin{equation*} 2^{-3} + 2^{-4} + 2^{-5} + 2^{-9} = 0.220703125, \end{equation*}\] 这给出 \(1.220703125 \times 2^{13} = 10000\)。可以表示为半精度的最接近的数字是 9992 和 10008：介于它们之间的所有数字都被舍入。这给 10000 周围留下了一个\(\pm 8\)的区间。对于足够大的数字，浮点变量甚至无法不进行舍入就表示整数！

我们如何控制由浮点数舍入引入的错误？错误在操作过程中会累积，与输入大小相比，机器学习模型通常执行大量的操作。（更多内容请参阅第四章。）幸运的是，概率论和统计学在历史上已经标准化了计算，使其在对数尺度上工作，从而使闭式数学推导更容易。使用浮点数的对数变换可以降低大数溢出到`+Inf`/`-Inf`或小数四舍五入到零的可能性。在具有非正常浮点数表示的数字的情况下，我们也保留了更好的精度，因为它们的对数不会是非正常的。这在将大量对数概率相加的常见情况下尤为重要。使用相同尺度（即，它们有相似的指数）的数字也有助于避免精度灾难性的损失。当操作涉及尺度非常不同的数字时，浮点数舍入的粒度差异可能导致结果具有无法接受的大误差，尽管所有操作数都是准确的。作为一个极端的例子，考虑将 10002 和 0.0002 相加：结果将是 10000，这是半精度中最接近的浮点数！类似的问题还有*灾难性消去*，这可能在减去两个非常接近的浮点数时发生。

与整数算术不同，浮点数算术由于浮点数舍入的影响而不精确。涉及浮点变量的操作结果可能与它们实现的数学操作以多种方式不同，即使在常见场景中也是如此。可以通过一个简单的递归来说明这一点，例如 \[\begin{align*} x_0 = 4, x_1 = 4.25, x_{n + 1} = 108 - \left(815 - \frac{1500}{x_{n - 1}}\right) \frac{1}{x_n}, \end{align*}\] 在双精度下收敛到 100，尽管在\(\mathbb{R}\)中的真正极限是 5（Rump 2020b)。即使所有操作数都可以精确表示，这种情况也可能发生，如(Rump 2020a)中证明的那样。这种差异的一些影响包括：

+   应该相等的数字并不相等。我们应该始终使用一个与我们所使用的浮点精度相关的容差来比较数字。在 R 中，默认值是最小可表示数的平方根，可以通过 `sqrt(.Machine$double.eps)` 获取。

```py
sqrt(2) *  sqrt(2) ==  2
```

```py
## [1] FALSE
```

```py
all.equal(sqrt(2) *  sqrt(2), 2, tol = sqrt(.Machine$double.eps))
```

```py
## [1] TRUE
```

+   相反，不应该相等的数字最终可能会相等。

```py
1e99 ==  1e99 +  1
```

```py
## [1] TRUE
```

```py
1 -  1e-20 ==  1
```

```py
## [1] TRUE
```

+   即使数学运算或函数是可交换的或/和结合的，操作执行的顺序也很重要。将代码结构化，以便关键计算只实现一次，从而确保操作始终以相同的顺序执行，是防止此类问题的最佳方式。

```py
print(0.6 +  0.7 +  0.8, digits = 20)
```

```py
## [1] 2.0999999999999996447
```

```py
print(0.8 +  0.7 +  0.6, digits = 20)
```

```py
## [1] 2.1000000000000000888
```

+   操作执行的顺序也很重要，因为中间结果可能会下溢到零或上溢到 `+Inf`/`-Inf`，除非我们重新排序操作以防止这种情况发生。

+   在处理多变量分布或大量数据点经常出现的小概率时，以对数尺度工作是最好的选择。否则，最终结果可能会下溢到零。

```py
probs =  runif(10², min = 10^-6, max = 10^-3)
sqrt(prod(probs))
```

```py
## [1] 0
```

```py
exp(0.5 *  sum(log(probs)))
```

```py
## [1] 1.33e-169
```

### 3.1.3 字符串

字符串是以二进制形式编码的字符序列，并存储到变量中。它们的二进制格式各不相同，但在 Linux 和 MacOS X 上通常是 UTF-8，在 Windows 上通常是 UTF-16。两者都是 Unicode 标准（Unicode 2021），它们使用 1 到 4 个字节来编码每个字符，并支持许多字母表、数学符号和象形文字，如表情符号。

在机器学习软件的背景下，字符串通常仅在自然语言处理（NLP）应用中作为输入数据出现。在其他环境中，它们被用作集合中项目的可读性标签，并且可以使用整数来表示，正如我们在第 3.1.1 节中看到的。实际上，即使在 NLP 中，它们最终也会被赋予数值表示，以便将它们输入到诸如 word2vec (Rong 2014)、GLOVE (Pennington, Socher, and Manning 2014) 和 BERT (Devlin et al. 2019) 这样的算法中。在 NLP 中，字符串也会进行预处理，考虑到它们的含义以及它们的语法和句法属性，以方便后续分析。例如：

+   不增加句子意义的常见单词，通常称为 *stopwords*，被移除以减少数据的维度。

+   单词可以被 *stemmed*，也就是说，通过去除后缀和前缀将不同的单词还原到它们的共同词干，以识别哪些实际上是相同的单词。

+   单词可以被 *tagged* 以表示它们的句法角色。

+   单词可以通过将所有字符转换为小写，有时通过去除重音和变音符号来 *normalised*。在 UTF-8 和 UTF-16 中，复杂、组合的字符可以以不同的方式编码，将它们转换为它们的 *canonical form* 对于正确识别唯一的单词是至关重要的。

+   可以移除非信息性的额外字符，如标点符号、连字符和数字。缩写词和首字母缩略词可以扩展，以明确它们对应的单词。同样，表情符号可以用文本描述来替换。

对这些主题的详细讨论超出了本书的范围，我们建议读者参考如（Aggarwal 2018）等专著，以及 Spacy（Explosion 2021）和 NLTK（NLTK Team 2021）等相关软件库的文档。

## 3.2 数据结构

数据结构是组织一个或多个类型变量以有效和高效处理的一种特定方式。不同的数据结构将适用于不同的操作或不同的算法。我们将在第 3.4 节和后面的第四章中进一步讨论这两个方面，用空间和时间复杂度来表征内存和计算效率。在这里，我们只涵盖那些对机器学习软件基础性的数据结构，并建议读者参考其他优秀资源（Brass 2008；Cormen 2013）以获得对该主题更广泛的了解。

为什么使用数据结构？首先，它们通过允许我们抽象出基本变量操作（否则这些操作将在不同的地方反复实现）来使代码更加紧凑。因此，我们的代码将更加清晰，并且很可能出现更少的错误。其次，数据结构告诉软件特定组变量如何组合在一起，无论是从它们在内存中的布局，还是从我们对它们的操作来看。这使得我们编写的软件能够编译或解释（见第 6.1 节）以高效地处理数据结构中的变量。第三，特定组变量属于一起的信息将对开发我们代码的开发者有用。这些变量可能描述单个数学对象或现实世界实体的部分，它们可能具有相同的语义意义，或者它们可能附加了可用于解释和调试目的的元数据：所有这些都是在阅读和开发代码时需要了解的有用事实。

### 3.2.1 向量和列表

机器学习软件中最基本的数据结构是**向量**和**列表**。两者都可以包含任何类型的变量，并且由它们的**长度**（它们包含的元素数量）定义。它们的概念结构如图 3.1 所示。

![向量（左）和列表（右）的逻辑结构和内存布局的示意图。](img/21f8ba5543c0ba4d0732b529111bfe86.png)

图 3.1：向量（左）和列表（右）的逻辑结构和内存布局的示意图。

向量是**同构**的数据结构，它包含相同类型变量的序列。变量按顺序存储在单个内存块中，因此可以使用指向其第一个元素的**指针**来访问向量（指针本身是一个包含内存地址的变量）。读取向量中存储的变量是微不足道的，因为所有元素在内存中占用相同数量的字节：第\(i\)个元素位于第一个元素的内存地址加上\(i\)乘以变量类型大小。整个向量的复制也是微不足道的，因为它存储为一个单独的内存块。对于向量中相邻的变量子集也是如此。

另一方面，列表是**异构**的数据结构，可以包含不同类型的元素。它们本质上充当指向任意数据结构或变量类型的指针的向量。因此，列表中的每个元素可以是任何东西：某种类型的单个变量、任意长度的向量、第二个列表、矩阵等。然而，这意味着访问列表的元素不太简单，因为我们需要定位每个元素并单独访问它。然而，复制列表和子集它可能更容易：如果我们不需要修改其元素的内容，我们只需复制（全部或部分）指向元素的指针以创建一个新的列表。这被称为**浅拷贝**，可以显著减少内存使用。然而，如果我们需要在新的列表中稍后修改这些元素，我们必须复制元素本身，以避免更改它们所附加的原始列表。同时复制列表及其元素称为**深拷贝**。相比之下，在一般情况下，子集向量需要深拷贝。浅拷贝仅在复制整个向量或子集相邻元素切片时才可行。

将变量存储到向量中使得**向量化**计算成为可能：一个函数可以独立应用于向量的每个元素，可能利用硬件的 SIMD 和 FMA 指令来实现指令级和数据级并行性，正如我们在第 2.2 节中讨论的那样。如果函数的返回值是标量，结果可以保存在长度相同的第二个向量中。否则，结果可以保存在密集矩阵（第 3.2.3 节）或数据框（第 3.2.2 节）中，其中每一行或每一列都包含单个输入元素的返回值。使用线程级并行性，列表也可以进行向量化计算，假设函数可以处理列表中存储的所有变量类型。其输出将存储在第二个列表中，无论每个输出是否为标量。

### 3.2.2 使用数据框表示数据

数据框是一种*异构*的二维数据结构，具有可能不同类型的列。其主要任务是存储表格数据和相关的元数据，例如列名和行名。在 Julia（DataFrame.jl）和 Python（Pandas 和 Scikit-Learn（Scikit-learn Developers 2022））中的实现受到了 R 数据框的强烈启发：它们在语义上只有细微的差异。最显著的是，在 R 和 Julia 中对两个数据框的操作将按位置匹配单元格（无论行名和列名），而在 Python 中则按行名和列名匹配（无论单元格位置）。

![表格数据（右下角）编码为数据框（左，上）的示意图。](img/5f584445c8c6e64e3d25eec8eb938cc9.png)

图 3.2：表格数据的示意图（右下角）编码为数据框（左，上）。

数据框的基本结构是列表：表格数据中的每一列都是一个向量，它作为元素存储，并带有其自己的元数据，如图 3.2 所示。因此，每一列都存储在单独的内存块中，不同列中可以存储的变量类型没有限制。此外，数据框通常包含其维度和行标签以及列标签作为元数据，这使得我们可以像访问表格一样访问其内容。维度是数据框的行数和列数。列的标签（在 R 中称为“列名”）可以用来通过名称而不是通过数据框中的位置访问它们，这提高了代码的可读性，从而提高了我们的调试能力。它还使代码对数据布局不变。行的标签（“行名”在 R 中）具有相同的功能，但使用得不太频繁：在常见的假设数据点是独立且同分布的情况下，通常没有实际用途。

数据框使得对列的操作变得高效。创建一个包含列子集的新数据框就像子集化一个列表，额外步骤是按需携带行和列标签。可以通过浅拷贝高效地复制它。向数据框中添加列的过程类似：我们执行一个浅拷贝到一个新的数据框中，该数据框有一个空槽，我们可以插入存储列值的向量。对数据框的每一列应用函数可以矢量化并并行执行，对于通用函数，可以为每一列调用适当的方法。

然而，在大多数情况下，对行的操作效率不高。添加或删除数据点需要修改每一列的长度，这很可能会涉及将选择的数据点复制到新分配的适当长度的向量中。

### 3.2.3 稠密和稀疏矩阵

矩阵是一种**同质**的二维数据结构，它包含一个由相同类型的变量组成的网格，这些变量按行和列排列。它是表示线性代数中同名数学对象的编程结构。矩阵可以是**密集**的或**稀疏**的。密集矩阵的大部分元素都是信息性的（即非零单元格），因此必须存储在数据结构中。另一方面，稀疏矩阵的大部分元素都等于零，因此我们可以通过只存储少数非零元素的位置和值来节省大量的内存。在讨论计算复杂性的同时，我们将在第 4.5.2 节中介绍这两种类型矩阵在速度和内存使用之间的权衡。

在 Python 中，密集矩阵作为多维数组的特例以及向量（Harris 等人 2020）在 NumPy 中实现。在 R 中也是如此。在这两种情况下，编码多维数组的结构包括数组的第一个元素的**指针**；元素的**变量类型**；以及数组的**维度**，这决定了其形状（图 3.3）。元素的维度和变量类型决定了**步长**：在给定维度上前进到下一个元素时在内存中跳过的字节数。它们在 NumPy 中预先计算并存储，但在 R 中不是这样。另一方面，R 数组包含其维度的标签（在矩阵的情况下是行和列的名称）。元素作为向量存储，通常在**列主序**中：矩阵的列从最左边开始连接。

![一个密集矩阵的示意图（左），编码为以列主序格式存储变量的多维数组（右）](img/1e7a82e4cfe3f8a0799d3e4ca549f856.png)

图 3.3：一个密集矩阵的示意图（左），编码为以列主序格式存储变量的多维数组（右）。

在 C 语言中，将密集矩阵存储为列的列表，或存储为行的列表是常见的，但在高级语言中则较少见，在这些语言中，我们可以使用数据框来达到相同的目的。

多维数组将它们的维度作为元数据存储的事实允许对其元素执行三种类型的操作。第一种是向量化操作，其中函数单独应用于每个元素。第二种是在 Python 和 Julia 中称为**广播**，在 R 中称为**回收**：当函数在具有不同维度的两个数组上操作时，较短的数组被重复（即，虚拟连接到自身）以使操作数的形状相匹配。第三种是**边缘化**或**缩减**：通过求和或平均等方式聚合数组的一个或多个维度的元素，从而产生一个维度更少的第二个数组。

在 R 中，稀疏矩阵通过 Matrix 包（Bates 和 Maechler 2021）支持，而在 Python 中通过 SciPy 包（Virtanen 等人 2020）支持。为了简洁，我们将仅详细说明两种包中最广泛使用的 *压缩稀疏列* 数据结构。考虑图 3.4 中所示的稀疏矩阵及其来自 Matrix 包的压缩表示。数据结构中的三个向量从上到下包含：每列的 *起始* 和 *结束索引* (\(C\))，矩阵中每个非零单元格的 *行* (\(R\)) 和其 *值* (\(V\))。这种表示假设非零单元格按位置顺序存储，从左上角单元格开始，在同一列内向下移动，并从左到右考虑列。

![稀疏矩阵（左）及其压缩稀疏列（右）格式表示的示意图。](img/dd1cef84f415d779187ba250d16f5dc9.png)

图 3.4：稀疏矩阵（左）及其压缩稀疏列（右）格式表示的示意图。

假设，例如，我们想从数据结构中读取矩阵中单元格 (2, 3) 的值。所需的步骤是：

1.  使用 \(C\) 中的列分隔符来找到要读取的 \(R\) 和 \(V\) 的哪个子集。矩阵的第 \(i\) 列从存储在 \(C\) 的第 \(i\) 个元素中的索引开始（\(C[3] = 3\)），并在存储在 \((i + 1)\) 个元素中的索引结束（\(C[4] = 5\)），这是下一列开始的地方。这意味着第三列中有 \(5 - 3 = 2\) 个非零元素。如果起始和结束索引相同，则该列中没有非零单元格。

1.  我们读取存储在 \(R[3]\) 和 \(R[4]\) 中的两个行坐标。

    1.  如果我们没有找到我们正在寻找的行坐标，则该单元格的值为零。

    1.  否则，单元格的值将存储在具有与行坐标相同索引的 \(V\) 元素中。在我们的例子中，第三列非零元素的行坐标是 \(R[3] = 2\) 和 \(R[4] = 3\)。行坐标 \(2\) 在 \(R[3]\) 中，因此我们可以从 \(V[3]\) 读取相应的单元格值。

稀疏矩阵的其他数据结构包括 *压缩行列*，它与上述结构相同，只是 \(R\) 和 \(C\) 的角色相反，以及 *坐标列表*（称为“三元组格式”），它直接在 \(R\) 和 \(C\) 中存储行和列坐标。

## 3.3 为工作选择正确的变量类型

在第 3.1.2 节中用于表示实数的浮点格式比第 3.1.1 节中用于整数变量的定点格式结构更复杂。直观上，这可能会让人想到相同的操作在整数变量上比在浮点变量上更有效率。但通常并非如此，原因有两个。首先，像 Python 和 R 这样的高级语言有额外的检查来处理整数溢出。在 R 中，整数使用 32 位存储，当它们溢出时，要么被替换为 `NaN`，要么转换为双精度浮点变量。在基本的 Python 中，整数使用 *任意精度* 存储：它们的大小会根据需要扩展，以防止溢出。Pandas (McKinney 2017) 的整数变量大小为 64 位，而 NumPy (Harris et al. 2020) 提供了 8、16、32 和 64 位的整数变量：两者都可以溢出，并且与 R 不同，不会用 `NaN` 替换。以下是在 R 中的向量内积基准测试示例：

```py
library(microbenchmark)
floats.vec1 =  rnorm(2 *  10⁷)
floats.vec2 =  rnorm(2 *  10⁷)
integers.vec1 =  sample(10, 2 *  10⁷, replace = TRUE)
integers.vec2 =  sample(10, 2 *  10⁷, replace = TRUE)

microbenchmark(integers.vec1 %*%  integers.vec2,
 floats.vec1 %*%  floats.vec2, times = 200)
```

在第七代英特尔酷睿处理器上，平均而言，使用整数向量的内积比使用双精度浮点向量的内积慢 196.7%。Python 和 NumPy 中的相同基准测试结果如下，结果相似：使用整数向量的内积慢 40.5%。

```py
import timeit
import numpy as np

ITERATION = 200

float_vector1 = np.random.normal(0, 1, 2 * pow(10, 7))
float_vector2 = np.random.normal(0, 1, 2 * pow(10, 7))

int_vector1 = np.random.choice(10, size=2 * pow(10, 7))
int_vector2 = np.random.choice(10, size=2 * pow(10, 7))

def product_int():
 np.dot(int_vector1, int_vector2)

def product_float():
 np.dot(float_vector1, float_vector2)

print("Inner product with int by", ITERATION, "iteration, avg:",
 np.mean(timeit.repeat(
 repeat=ITERATION,
 stmt=product_int,
 number=1)))

print("Inner product with float by", ITERATION, "iteration, avg:",
 np.mean(timeit.repeat(
 repeat=ITERATION,
 stmt=product_float,
 number=1)))
```

其次，从第 2.1.1 节中可以看出，近年来，人们投入了大量努力来提高对浮点数的硬件支持。CPU、GPU 和 TPU 都已经优化，以尽可能多地使用 SIMD 和 FMA 指令来处理单精度和双精度浮点变量，就像它们已经优化来处理整数变量一样，如果不是更多。因此，根据可用的硬件和编译器利用这些硬件的能力，使用浮点变量在低级语言中可能会导致代码运行更快。然而，对于特定的机器学习软件来说，这是否会成为现实取决于所使用的硬件和软件的确切组合，并且只能通过基准测试来确认。匹配软件和硬件在第 2.2 节和第 2.4 节中被视为一个关键点。

变量的尺寸也很重要：我们在第 2.1.2 节中看到了更快的内存形式通常更小，以及在不同类型的内存之间复制数据如何影响操作强度。我们应该始终选择我们能够用 SIMD 和 FMA 硬件指令处理的整数或浮点变量中最小尺寸，并且这个范围足够大，可以表示我们正在处理的数据。这种影响在简单的 Python 基准测试中也很明显：将向量的浮点数和整数变量的尺寸从 64 位（默认值）减少到 32 位，然后减少到 16 位，在标准化运行时间中产生了有趣的模式。

| **变量类型** | **64 位** | **32 位** | **16 位** |
| --- | --: | --: | --: |
| 浮点数 | 100% | 54.1% | 887.1% |
| 整数 | 100% | 62.2% | 61.6% |

将浮点数和整数变量的尺寸从 64 位减少到 32 位，可以按预期将内积的速度提高 1.5-2 倍。将变量的尺寸进一步减少到 16 位，对于整数变量来说只提供了微小的收益，但出人意料的是，将浮点变量的速度减慢了近 9 倍。这是一个强烈的迹象，表明我们无法像处理相同尺寸的整数一样利用 SIMD 和 FMA 指令！

在浮点变量的情况下，尺寸的重要性更大。正如我们在第 3.1.2 节中提到的，精度越小，浮点误差可能越大。它们还会随着每个操作而传播，并相互累积。这对于参与算法大多数步骤的变量来说可能成为一个关键问题，例如用于计算一系列值之和或积的 *累加变量*，以及那些与其他计算量一起缩放到预定义范围的变量。经典统计学中的一个例子是计算两个向量之间的经验相关系数：

1.  我们计算每个向量的平均值，并将其存储在两个累加变量中。

1.  我们通过将每个向量的平均值的平方差相加来计算每个向量的方差，这些平均值存储在另外两个累加变量中。

1.  我们对差异的叉积做同样的处理来计算协方差，这是一个额外的累加变量。

1.  我们将协方差除以方差乘积的平方根。

每个这些步骤都可能累积足够大的误差，从而产生一个相关系数，要么大于 1，要么小于-1。浮点误差会累积并从均值传播到方差和协方差，影响最终通过存储这些值的累加变量进行的除法操作。在这种情况下，我们应该用比它们所累积的变量更高的精度来存储累加变量，以限制单个操作误差的幅度：例如，我们应该将存储在单精度中的数字的平均值存储为双精度变量。使用 FMA 指令也可能有所帮助，因为我们已在第 2.1.1 节中提到，它们在更高的精度上操作，并且只对最终结果进行舍入。选择累加数字的尺度也可能有所帮助，因为它可以保持所有变量在一个不太可能溢出或下溢的范围内。保持所有变量在同一尺度上还可以防止精度灾难性的损失，尤其是在乘法和除法中。这就是为什么许多数值软件都在对数尺度上工作：大数减小幅度，不太容易溢出或丢失精度，而小数则变成大负数，而不是下溢或丢失精度。

最后但同样重要的是，在某些应用中，由于法律原因，浮点舍入可能不可接受，尤其是在金融和会计领域。可以使用定点整数代替，按照惯例，最小的货币单位（比如说，0.01 的 1/100）被用作单位值。在商业世界中，这种方法的罕见开源示例是 Oanda 的 libfixed（Oanda 2018）库。

## 3.4 为任务选择合适的数据结构

数据结构的选择可能比变量类型的选择影响更大，因为它决定了内存访问模式。操作强度关键取决于有效的内存使用和访问，正如我们在第 2.1.2 节和第 2.2 节中讨论的那样。

如果我们需要反复对列表进行子集操作，例如，因为我们需要处理它们的值的组合或排列，列表可能比向量更节省内存。如果浅拷贝是可以接受的，列表复制起来也更快，因为我们不需要为它们的元素分配内存并复制它们。如果浅拷贝不可接受，那么向量复制起来更快，因为所有元素都存储为单个内存块，并且可以单个操作进行复制。而且它们并不比向量内存效率低，因为它们的大小由它们的长度决定。实际上，列表比向量使用更多的内存，因为除了包含元素本身外，它们还包含指向每个元素的指针：如果元素总体较小，这种差异可能是显著的。这些考虑对于优化性能很重要，因为它们会影响内存延迟，这在第 2.1.2 和 2.2 节中讨论过。

我们可以对数据框和矩阵进行类似的考虑，因为数据框本质上表现为列表，其元素是存储在表格数据中的变量列。

理想情况下，我们应该根据机器学习管道中使用的库和其他软件中使用的哪些数据结构来选择我们在代码中使用的哪种数据结构。如果管道的不同部分以不同的方式编码数据和模型，我们将被迫在它们之间进行转换，这既低效又增加了内存使用。例如，R 通常将数据导入为数据框。然而，为许多模型提供动力的底层 BLAS 和 LAPACK 代码（其中所有线性回归都属于此类）要求数据以列主序格式存储为密集矩阵。将数据框转换为矩阵需要按列将所有数据复制到单个内存块中，这加倍了内存使用并浪费了处理器时间。

我们在选择数据结构时，也应该基于使用它们的算法如何访问其内容。应该将一起处理的数据存储在一起，以便算法尽可能少地进行单独的内存访问。例如，如果我们主要处理表格数据的整个列，那么数据框是理想的，因为单个列可以作为一个单独的内存块高效地从内存中读取。然而，如果我们需要以各种组合处理单个行，数据框会使内存访问非常低效，因为每一行中的每个变量都存储在单独的内存块中，并且我们需要访问所有变量来读取每一行。如果数据是同质的，将它们存储在以行主序存储单元格的密集矩阵中是更好的选择。

### 参考文献

Aggarwal, C. C. 2018\. *文本机器学习*. Springer.

Bates, D. 和 M. Maechler. 2021\. *矩阵：稀疏和密集矩阵类和方法*. [`cran.r-project.org/web/packages/Matrix/`](https://cran.r-project.org/web/packages/Matrix/).

Brass, P. 2008. *高级数据结构*。剑桥大学出版社。

Cormen, T. H. 2013. *算法解锁*。麻省理工学院出版社。

Devlin, J., M.-W. Chang, K. Lee, and K. Toutanova. 2019. “BERT：用于语言理解的预训练深度双向变换器。” 在 *北美计算语言学协会（NAACL-HLT）年度会议论文集* 中，4171–86.

Explosion. 2021. *Spacy：工业级自然语言处理*。[`spacy.io/`](https://spacy.io/).

Harris, C. R., K. J. Millman, Stéfan J. van der Walt, R. Gommers, P. Virtanen, D. Cournapeau, E. Wieser, 等人. 2020. “使用 NumPy 进行数组编程。” *自然* 585 (7285): 357–62.

McKinney, W. 2017. *Python 数据分析*。第 2 版。O’Reilly。

NLTK 团队. 2021. *NLTK：自然语言工具包*。[`www.nltk.org/`](https://www.nltk.org/).

Oanda. 2018. *适用于金融应用的 C++定点数数学库*。[`github.com/oanda/libfixed`](https://github.com/oanda/libfixed).

ONNX. 2021. *开放神经网络交换*。[`github.com/onnx/onnx`](https://github.com/onnx/onnx).

Overton, M. L. 2001. *使用 IEEE 浮点算术进行数值计算*。SIAM。

Pennington, J., R. Socher, and C. Manning. 2014. “Glove：全局词向量表示。” 在 *2014 年实证自然语言处理会议（EMNLP）论文集* 中，1532–43.

Rong, X. 2014. “Word2vec 参数学习解释。” *arXiv 预印本 arXiv:1411.2738*.

Rump, S. M. 2020a. “关于有限精度中收敛到错误极限的递归的补充。” *电子数值分析交易* 52: 571–75.

Rump, S. 2020b. “关于有限精度中收敛到错误极限的递归。” *电子数值分析交易* 52: 358–69.

Scikit-learn 开发者. 2022. *Scikit-learn：Python 机器学习*。[`scikit-learn.org/`](https://scikit-learn.org/).

Unicode. 2021. *Unicode 技术文档*。[`www.unicode.org/main.html`](https://www.unicode.org/main.html).

Virtanen, P., R. Gommers, T. E. Oliphant, M. Haberland, T. Reddy, D. Cournapeau, E. Burovski, 等人. 2020. “SciPy 1.0：Python 科学计算的基石算法。” *自然方法* 17: 261–72.

* * *

1.  如果我们在回归模型中使用颜色，"绿色"对响应的影响将是"红色"的两倍，这显然没有意义，因为与颜色相关的数字是任意的。↩︎

1.  One-hot 编码是统计学中所谓的*对比*的一个特例。由于它们是共线的，我们通常在使用模型之前删除一个。↩︎
