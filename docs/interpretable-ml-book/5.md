# 第五章 模型不可知论方法

将解释与机器学习模型分离（=模型不可知解释方法）具有一些优势（Ribeiro、Singh 和 Guestrin，2016 年）。模型不可知解释方法相对于模型特定解释方法的最大优势在于其灵活性。当解释方法可以应用于任何模型时，机器学习开发人员可以自由使用他们喜欢的任何机器学习模型。任何建立在机器学习模型解释之上的东西，例如图形或用户界面，也会独立于底层的机器学习模型。通常，不只是一个模型，而是对许多类型的机器学习模型进行评估以解决一个任务，并且在比较模型的可解释性时，更容易使用模型不可知论解释，因为相同的方法可用于任何类型的模型。

模型不可知论解释方法的一个替代方法是仅使用，与其他机器学习模型相比，这种方法通常有一个很大的缺点，即预测性能会丢失，并且您只能使用一种模型。另一种选择是使用特定于模型的解释方法。这样做的缺点是它也将您绑定到一个模型类型，并且很难切换到其他类型。

模型不可知论解释系统的理想方面是（Ribeiro、Singh 和 Guestrin，2016 年）：

•  模型灵活性：解释方法可以与任何机器学习模型一起使用，如随机森林和深层神经网络。

•  解释的灵活性：你不局限于某种形式的解释。在某些情况下，使用线性公式可能很有用，而在其他情况下，使用具有重要特征的图形可能很有用。

•  表示灵活性：解释系统应该能够使用不同的特征表示作为被解释的模型。对于使用抽象词嵌入向量的文本分类器，最好使用单个词的存在进行解释。

大局

让我们从高层次上看一下模型不可知论的可解释性。我们通过收集数据来捕捉世界，并通过学习使用机器学习模型来预测（任务的）数据来进一步抽象世界。可解释性只是帮助人们理解的另一层。

图 5.1：可解释机器学习的大画面。现实世界在以解释的形式到达人类之前经历了许多层次。

最底层是世界。这可以说是自然本身，就像人体的生物学和它对药物的反应一样，但也可以说是更抽象的东西，比如房地产市场。世界层包含所有可以观察到的和感兴趣的东西。最终，我们想了解这个世界并与之互动。

第二层是数据层。我们必须将世界数字化，使之能被计算机处理，也能存储信息。数据层包含来自图像、文本、表格数据等的任何内容。

通过对基于数据层的机器学习模型进行拟合，得到了黑盒模型层。机器学习算法利用来自现实世界的数据进行学习，以做出预测或找到结构。

黑盒模型层之上是可解释方法层，它帮助我们处理机器学习模型的不透明度。特定诊断最重要的特征是什么？为什么金融交易被归类为欺诈？

最后一层被人占据。看！这一个向你挥手，因为你正在阅读这本书，并帮助提供更好的黑盒模型的解释！人类最终是解释的消费者。

这种多层抽象也有助于理解统计学家和机器学习实践者在方法上的差异。统计学家处理数据层，例如规划临床试验或设计调查。他们跳过黑盒模型层，直接进入可解释性方法层。机器学习专家也处理数据层，例如收集皮肤癌图像的标记样本或爬行维基百科。然后他们训练一个黑匣子机器学习模型。跳过可解释性方法层，人类直接处理黑箱模型预测。可解释的机器学习融合了统计学家和机器学习专家的工作，这很好。

当然，这张图并不能捕捉到一切：数据可能来自模拟。黑匣子模型还输出预测，这些预测甚至可能无法到达人类，但只提供其他机器，等等。但总的来说，理解可解释性如何成为机器学习模型之上的新层是一个有用的抽象。

![img](file:///C:/Users/ADMINI~1/AppData/Local/Temp/msohtmlclip1/01/clip_image001.gif)

1。Ribeiro、Marco Tulio、Sameer Singh 和 Carlos Guestrin。“机器学习的模型不可知论可解释性”，ICML 机器学习中的人类可解释性研讨会。（2016 年）。

5.1 部分相关图（PDP）

偏相关图（简称 pdp 或 pd 图）显示了一个或两个特征对机器学习模型预测结果的边际效应（J.H.Friedman 2001）。部分相关图可以显示目标和特征之间的关系是线性的、单调的还是更复杂的。例如，当应用于线性回归模型时，偏相关图总是显示线性关系。

回归的偏相关函数定义为：

\[\Hat F X（X S）=E X C \ Left[\Hat F（X S，X C \ Right]=\Int\Hat F（X S，X C）D\MathBB P（X C）]

（x_s）是绘制部分依赖函数的特征，而（x_c）是机器学习模型中使用的其他特征。通常情况下，集合 S 中只有一个或两个特征。S 中的特征是那些我们想知道对预测的影响的特征。特征向量（x_s）和（x_c）组合构成了整个特征空间 x。部分依赖性通过将机器学习模型输出边缘化在集合 c 中特征的分布上起作用，以便函数显示我们感兴趣的集合 s 中特征之间的关系。以及预测的结果。通过对其他特性的边缘化，我们得到了一个仅依赖于 S 中特性的函数，与包含的其他特性的交互。

通过计算训练数据中的平均值，即蒙特卡罗方法，估计部分函数（即：

\[\hat f x（x s）=\frac 1 n \ sum i=1 f（x（i）c）部分函数告诉我们特征的给定值对预测的平均边际影响是什么。在这个公式中，（x^（i）c）是数据集中我们不感兴趣的特性的实际特性值，n 是数据集中的实例数。PDP 的一个假设是，C 中的特征与 S 中的特征不相关。如果违反此假设，则为部分相关图计算的平均值将包括非常不可能或甚至不可能的数据点（见缺点）。

对于机器学习模型输出概率的分类，部分依赖图显示给定不同特征值的特定类在 S 中的概率。处理多个类的简单方法是为每个类绘制一条线或图。

部分相关图是一种全局方法：该方法考虑了所有实例，并给出了特征与预测结果的全局关系的说明。

分类特征

到目前为止，我们只考虑了数值特征。对于分类特征，部分依赖性很容易计算。对于每个类别，我们通过强制所有数据实例具有相同的类别来获得 PDP 估计。例如，如果我们查看自行车租赁数据集并对季节的部分依赖关系图感兴趣，我们会得到 4 个数字，每个季节一个。为了计算“夏季”的值，我们将所有数据实例的季节替换为“夏季”，并对预测进行平均。

5.1.1 示例

实际上，特征集通常只包含一个或最多两个特征，因为一个特征生成二维图，两个特征生成三维图。除此之外的一切都很棘手。即使是 2D 纸或显示器上的 3D 也已经很有挑战性了。

让我们回到回归示例，在该示例中我们预测首先我们拟合了机器学习模型，然后分析了部分依赖关系。在这种情况下，我们拟合了一个随机森林来预测自行车的数量，并使用偏相关图来可视化模型所了解的关系。天气特征对预测自行车数量的影响如下图所示。

图 5.2：自行车数量预测模型和温度、湿度和风速的 PDPS。最大的差别可以在温度上看到。温度越高，租的自行车越多。这种趋势上升到 20 摄氏度，然后在 30 摄氏度时变平并略有下降。X 轴上的标记表示数据分布。

对于温暖但不太热的天气，该模型预测平均有大量租用自行车。当湿度超过 60%时，潜在的骑自行车的人越来越不愿意租自行车。此外，风越大，人们喜欢骑车的次数就越少，这是有道理的。有趣的是，当风速从 25 公里/小时增加到 35 公里/小时时，自行车租赁量的预测值不会下降，但培训数据不多，因此机器学习模型可能无法对该范围进行有意义的预测。至少凭直觉，我预计自行车的数量会随着风速的增加而减少，特别是当风速很高的时候。

为了说明具有分类特征的部分依赖关系图，我们研究了季节特征对自行车租赁预测的影响。

图 5.3：自行车数量预测模型和季节的 PDP。出乎意料的是，所有的季节都表现出同样的效果，只有在春季，该模型预测自行车租赁量会减少。

我们还计算了的部分依赖性。这一次，我们根据风险因素对一个女人是否会患上宫颈癌进行了随机森林预测。我们计算并可视化随机森林癌症概率对不同特征的部分依赖性：

图 5.4：基于年龄和使用激素避孕药的年龄的癌症概率的 pdps。对于年龄而言，pdp 显示 40 岁之前的概率很低，40 岁之后的概率增加。激素避孕药使用年限越长，预测的癌症风险就越高，尤其是 10 年后。对于这两个特征，没有多少具有大值的数据点可用，因此这些区域的 PD 估计不太可靠。

我们还可以同时看到两个特性的部分依赖性：

图 5.5：癌症概率的 pdp 以及年龄和怀孕次数的相互作用。图中显示 45 岁时癌症发病率增加。对于 25 岁以下的女性，与 0 个或 2 个以上怀孕的女性相比，1 个或 2 个怀孕的女性预测癌症风险更低。但在得出结论时要小心：这可能只是一种相关性，而不是因果关系！

5.1.2 优势

部分相关图的计算是直观的：如果我们强制所有数据点假设该特征值，则特定特征值的部分相关函数表示平均预测。根据我的经验，外行人通常很快就能理解 PDP 的概念。

如果计算 PDP 的特征与其他特征不相关，则 PDP 完美地表示该特征如何影响平均预测。在不相关的情况下，解释是清楚的：偏相关图显示了当 j-th 特性改变时，数据集中的平均预测是如何变化的。当特性相关时，它就更复杂了，参见缺点。

部分依赖图易于实现。

部分相关图的计算有一个因果解释。我们介入了

描述并测量预测中的变化。在此过程中，我们分析了特征与预测之间的因果关系。这种关系是模型的因果关系——因为我们明确地将结果建模为特征的函数——但不一定是真实世界的结果！

5.1.3 缺点

偏相关函数中的实际最大特征数是 2。这不是 PDP 的错误，而是二维表示（纸张或屏幕）的错误，也是我们无法想象超过 3 个维度的错误。

某些局部放电图不显示特征分布。忽略分布可能会产生误导，因为您可能会高估几乎没有数据的区域。这个问题很容易通过显示 RUG（X 轴上数据点的指示器）或柱状图来解决。

独立性假设是 PD 图的最大问题。假设计算部分依赖性的特征与其他特征不相关。例如，假设你想预测一个人走路的速度，考虑到这个人的体重和身高。对于其中一个特征的部分依赖性，例如高度，我们假设其他特征（重量）与高度不相关，这显然是一个错误的假设。为了计算某一高度（例如 200 cm）的 PDP，我们对重量的边际分布进行平均，其中可能包括 50 kg 以下的重量，这对于 2 米长的人来说是不现实的。换言之：当特征相关时，我们在特征分布区域中创建新的数据点，其中实际概率非常低（例如，不太可能有人身高 2 米，但体重小于 50 千克）。解决这个问题的一个方法是使用条件而不是边际分布的短 ALE 图。

异质效应可能被隐藏，因为 PD 图只显示平均边际效应。假设对于一个特征，一半的数据点与预测呈正相关——特征值越大，预测越大——另一半的数据点与预测呈负相关——特征值越小，预测越大。pd 曲线可以是一条水平线，因为数据集的两部分的效果可以相互抵消。然后得出结论，该特性对预测没有影响。通过绘制而不是聚合线，我们可以发现异构效果。

5.1.4 软件和备选方案

有许多 R 包可以实现 PDP。我在示例中使用了 IML 包，但也有 PDP 或 DALEX。在 python 中，你可以使用 skater。

本书中介绍的 PDP 替代方案有：

![img](file:///C:/Users/ADMINI~1/AppData/Local/Temp/msohtmlclip1/01/clip_image002.gif)

\1.    贪婪函数近似：梯度增强机〉，《统计年鉴》（2001）：1189-1232。

\2.    赵、清远和特雷弗·黑斯迪。“黑匣子模型的因果解释”，《商业与经济统计杂志》即将出版。（2017 年）。

5.2 个人条件期望（ICE）

单个条件期望（ICE）图为每个实例显示一行，显示当某个特性更改时实例的预测如何更改。

特征平均效果的部分依赖图是一种全局方法，因为它不关注特定实例，而是关注总体平均值。对于单个数据实例，等价于 PDP 的方法称为单个条件期望（ICE）图（Goldstein 等人 2017。冰图分别显示了预测对每个实例的特征的依赖性，与部分依赖图中的一条线相比，每个实例产生一条线。pdp 是冰层的平均线。一条线（和一个实例）的值可以通过保持所有其他功能相同来计算，通过将该功能的值替换为网格中的值来创建该实例的变体，并使用这些新创建的实例的黑盒模型进行预测。结果是一组具有来自网格的特征值和相应预测的点。

观察个人期望而不是部分依赖有什么意义？部分依赖图可以掩盖由交互创建的异构关系。PDP 可以向您展示特征和预测之间的平均关系。只有当计算 PDP 的功能与其他功能之间的交互较弱时，这才有效。在相互作用的情况下，冰图将提供更多的洞察。

一个更正式的定义：在冰区中，对于每一个实例，在（x  123;（i），x c ^；（（i）；）125\ \123;（i）\（x（i）125\\\\\\125\\（（125;（i）i）\\\），而\（x^（i）c）保持不变。

5.2.1 示例

让我们回到，看看每个实例的预测如何与特性“年龄”相关联。我们将分析一个随机森林，该森林预测一个给定危险因素的妇女患癌症的可能性。在我们已经看到的癌症概率在 50 岁左右增加，但这对数据集中的每个女人都是真的吗？冰图显示，对于大多数女性来说，年龄效应遵循 50 岁时的平均增长模式，但也有一些例外：对于少数年轻时具有高预测概率的女性，预测的癌症概率不会随年龄变化太大。

图 5.6：按年龄划分的宫颈癌概率冰点图。每一行代表一个女人。对于大多数女性来说，随着年龄的增长，预测癌症的可能性也会增加。对于一些癌症预测概率在 0.4 以上的女性来说，在更高的年龄段预测变化不大。

下一个图显示了的冰层图。基础预测模型是一个随机森林。

图 5.7：根据天气条件预测自行车租赁的冰层图。在偏相关图中也可以观察到同样的效果。

所有曲线似乎都遵循相同的过程，因此没有明显的相互作用。这意味着，PDP 已经很好地总结了显示的特征和预测的自行车数量之间的关系。

## 5.2.1.1 中心冰层图

冰层图有一个问题：有时很难判断冰层曲线在个体之间是否不同，因为它们从不同的预测开始。一个简单的解决方案是将曲线集中在特征的某个点上，只显示预测到该点的差异。生成的图称为中心冰图（C-ICE）。将曲线锚定在特征的下端是一个不错的选择。新曲线定义为：

\[\Hat（i）=\Hat（i）-\MathBF 1 \Hat F（x，x（i）c）]

其中\（\mathbf 1 \）是具有适当数量尺寸（通常为一个或两个）的 1 的矢量，其中\（\hat f \）是拟合模型，x 是锚定点。a

## 5.2.1.2 示例

例如，以宫颈癌冰点图作为年龄，并以观察到的最年轻年龄为中心：

图 5.8：根据年龄预测癌症概率的中心冰层图。行在 14 岁时固定为 0。与 14 岁相比，大多数女性的预测值在 45 岁之前保持不变，直到预测的概率增加。

中心冰图使比较单个实例的曲线更容易。如果我们不希望看到预测值的绝对变化，而是预测值与特征范围的固定点之间的差异，那么这一点很有用。

让我们来看看自行车租赁预测的中心冰区：

图 5.9：根据天气条件预测的自行车数量的中心冰层图。这些线显示了预测值与各自特征值在观测最小值时的预测值之间的差异。

## 5.2.1.3 衍生冰图

另一种使从视觉上更容易发现异质性的方法是观察预测函数相对于特征的个别导数。生成的图称为衍生冰图（dice）。函数（或曲线）的导数告诉您是否发生了变化以及它们发生的方向。利用导数冰层图，很容易发现特征值的范围，在该范围内，黑匣子预测（至少某些）实例会发生变化。如果分析的特征（x_s）和其他特征（x_c）之间没有相互作用，那么预测函数可以表示为：

\[\hat f（x）=\hat f（x s，x c）=g（x s）+h（x c），\quad\text with \ quad\frac \ delta\hat（x）\ delta x=g'（x s）]

如果没有相互作用，个别偏导数在所有情况下都应该是相同的。如果它们不同，那是由于相互作用，并且在 D-冰图中可见。除了显示预测函数导数相对于 S 中特征的个别曲线外，显示导数的标准差有助于突出 S 中特征中估计导数中具有异质性的区域。导数冰层图需要很长的时间来计算，这是相当不切实际的。

5.2.2 优势

个体条件期望曲线比部分依赖图更直观。如果我们改变感兴趣的特性，一行代表一个实例的预测。

与部分依赖图不同，冰曲线可以揭示异质关系。

5.2.3 缺点

冰曲线只能有意义地显示一个特征，因为两个特征需要绘制多个覆盖曲面，并且在绘图中看不到任何内容。

冰曲线与 PDPS 有着相同的问题：如果感兴趣的特征与其他特征相关，那么根据联合特征分布，直线上的某些点可能是无效的数据点。

如果绘制了许多冰的曲线，绘图可能会变得过于拥挤，您将看不到任何东西。解决方案：要么在线条中添加一些透明度，要么只绘制线条的示例。

在冰区，要看到平均值可能不容易。这有一个简单的解决方案：将单个条件期望曲线与部分依赖图结合起来。

5.2.4 软件和备选方案

冰图在 R 包 IML（用于这些示例）、冰箱和 PDP 中实现。另一个和冰非常相似的 R 包是康迪斯。

![img](file:///C:/Users/ADMINI~1/AppData/Local/Temp/msohtmlclip1/01/clip_image003.gif)

\1.    Goldstein、Alex 等。“窥视黑盒子：用个体条件期望图可视化统计学习”，《计算和图形统计杂志》24.1（2015）：44-65。

\2.    Goldstein、Alex 等。“包装‘冰箱’”（2017 年）。

5.3 累积局部效应（ALE）图

累积局部效应描述特征如何平均影响机器学习模型的预测。ALE 图是部分依赖图（PDP）的一种快速、无偏的替代方法。

我建议首先阅读，因为它们更容易理解，而且两种方法都有相同的目标：都描述了一个特性如何平均地影响预测。在下面的部分中，我想让您相信，当特性相关时，部分依赖关系图有一个严重的问题。

5.3.1 动机和直觉

如果机器学习模型的特征是相关的，那么部分依赖图就不可信。计算与其他特征强相关的特征的部分相关图涉及对实际中不太可能出现的人工数据实例的平均预测。这会对估计的特征效果产生很大的偏差。想象一下，计算机器学习模型的部分依赖图，该模型根据房间数量和居住面积大小预测房屋的价值。我们对生活区对预测值的影响感兴趣。作为提醒，部分依赖图的方法是：1）选择功能。2）定义网格。3）每个网格值：a）用网格值替换特征，b）平均预测。4）绘制曲线。为了计算 PDP 的第一个网格值（比如 30 米），我们将两个实例的居住面积都替换为 30 米，即使是有 10 个房间的房屋。在我看来，这房子很不寻常。2 部分依赖图将这些不切实际的房屋包含在特征效果估计中，并假装一切都很好。下图说明了两个相关特性，以及偏相关绘图方法如何平均不太可能的实例的预测。

图 5.10：强相关特征 x1 和 x2。为了计算 x1 在 0.75 时的特征效果，pdp 将所有实例的 x1 替换为 0.75，错误地假设 x2 在 x1 时的分布=

0.75 与 x2（垂直线）的边缘分布相同。这导致不太可能的 x1 和 x2 组合（例如，x1=0.75 时 x2=0.2），PDP 使用这些组合计算平均效应。

我们能做些什么来得到一个关于特征相关性的特征效果估计呢？我们可以对特性的条件分布取平均值，也就是说，在网格值为 x1 时，我们用类似的 x1 值对实例的预测取平均值。使用条件分布计算特征效果的解决方案称为边际图或 M 图（混淆名称，因为它们基于条件分布，而不是边际分布）。等等，我有没有答应过你谈一下艾尔的阴谋？M 图不是我们正在寻找的解决方案。为什么 M 图不能解决我们的问题？如果我们将所有房屋的预测平均为 30 米左右，我们估计了居住面积和房间数量的 2 个综合效应，因为它们之间存在相关性。假设居住面积对房屋的预测价值没有影响，只有房间的数量有影响。M 图仍然显示，由于房间数量随着居住面积的增加而增加，因此居住面积的大小会增加预测值。下面的图表显示了两个相关的特性 MPLOT 是如何工作的。

图 5.11：强相关特征 x1 和 x2。条件分布上的 M 图平均值。这里 x2 在 x1=0.75 时的条件分布。局部预测的平均值会导致混合两种特征的影响。

M 图避免对不可能的数据实例进行平均预测，但它们混合了特征的影响和所有相关特征的影响。ALE 图通过计算（也基于特征的条件分布）预测差异而不是平均值来解决这个问题。对于 30 m 处的居住面积的影响，ALE 方法使用了所有约 30 m 的房屋，得到假设这些房屋为 31 m 的 2 个模型预测减去假设它们为 2 29 m 的预测。这给了我们生活区的纯粹效果，而不是混合 2 个相关特征的效果。使用差异会阻碍其他功能的效果。下图提供了如何计算 ALE 图的直观性。

图 5.12：与 x2 相关的特性 x1 的 ALE 计算。首先，我们将特征划分为间隔（垂直线）。对于区间中的数据实例（点），我们用区间的上下限（水平线）代替特征，计算预测的差异。这些差异随后被累积并集中，形成 ALE 曲线。

要总结每种类型的图（pdp、m、ale）如何计算某个特征在某个网格值 v 下的效果：

部分依赖图：“让我展示一下当每个数据实例的该特性值为 V 时，模型平均预测的内容。我忽略值 v 是否对所有数据实例都有意义。”

M-plots：“让我向您展示该模型对数据实例的平均预测，这些数据实例的值接近该特性的 v。影响可能是由于该功能，也可能是由于相关功能。”

ale plots：“让我演示一下，对于该窗口中的数据实例，模型预测是如何在围绕 v 的特性的一个小“窗口”中发生变化的。”

5.3.2 理论

pd、m 和 ale 图在数学上有什么不同？这三种方法的共同点是，它们将复杂的预测函数 f 简化为仅依赖一（或两）个特征的函数。这三种方法都通过平均其他特征的影响来降低函数，但它们在计算预测的平均值或预测的差异以及在边际分布或条件分布上是否进行平均值方面存在差异。

部分依赖图平均预测超过边际分布。

\开始 123;   123; 123; X X X 123; C x_c \结束对齐*\]

这是预测函数 f 的值，在特征值\（x_s\）处，对\（x_c\）中的所有特征取平均值。平均是指计算集合 C 中特征的边际期望 E，它是通过概率分布加权的预测的积分。听起来很奇怪，但是要计算边缘分布上的预期值，我们只需获取所有数据实例，强制它们对集合 S 中的特性具有特定的网格值，并平均此操作数据集的预测值。这个过程确保我们对特征的边缘分布进行平均。

M 图对条件分布的预测进行平均。

\[\begin align*\hat f x s，m（x s）&=e x c x u s \ left[\hat f（x s，x c）x s=x s \ right]\

\&=\int_x_c \hat_f（x_s，x_c）\mathbb_p（x_c_x_s）d_x_c\end_align*\]

与 PDP 相比唯一的变化是，我们根据感兴趣的特征的每个网格值来平均预测，而不是假设每个网格值的边际分布。在实践中，这意味着我们必须定义一个邻域，例如计算 30 米对预测房屋价值的影响，我们可以将所有房屋的预测平均为 28 到 32 米 2。

ALE 图平均预测中的变化，并在网格上进行累积（稍后的计算将详细介绍）。

\[\begin align*\hat f x s，ale（x s）=&\int z 0,1 x e x u c x u s \ left[\hat f s（x s，x c）|

x_s=z_s \right]dz_s-\text 常数\\\ \\\ \ x U s \\    123; 123;  f \美国，x U c \\123;  \123; \123; 123; \\123; \123 d z_s-\text 常量\结束对齐*\]

该公式揭示了 M 图的三个差异。首先，我们平均预测的变化，而不是预测本身。这种变化被定义为梯度（但在随后的实际计算中，被一个区间内预测的差异所取代）。

\[\hat f ^s（x_s，x_c）=\frac \ delta \hat f（x_s，x_c）\ delta x_u s \]

第二个差异是 z 上的附加积分，我们在集合 s 中积累了特征范围内的局部梯度，这给了我们特征对预测的影响。对于实际的计算，z 被一个区间网格代替，在这个网格中我们计算预测的变化。ALE 方法不直接求预测的平均值，而是计算特征 S 的预测差异，并将特征 S 上的导数整合在一起以估计效果。嗯，听起来很愚蠢。派生和集成通常会相互抵消，比如先减去，然后再加上相同的数字。为什么这里有意义？导数（或区间差）隔离了感兴趣特征的影响，并阻止了相关特征的影响。

ALE 图与 M 图的第三个区别是我们从结果中减去一个常数。此步骤将 ALE 图居中，以便对数据的平均影响为零。

还有一个问题：并不是所有的模型都有一个梯度，例如随机森林没有梯度。但是正如您将看到的，实际的计算没有梯度，而是使用间隔。让我们更深入地探讨 ALE 图的估计。

5.3.3 估算

首先，我将描述如何估计 ALE 图的单个数值特征，随后是两个数值特征和单个分类特征。为了估计局部效应，我们将特征划分为多个区间，并计算预测的差异。此过程近似于渐变，也适用于没有渐变的模型。

首先，我们估计非中心效应：

\[\hat \tilde f j，ale（x）=\sum k=1 ^ k j（x）\frac 1 n j（k）\ sum i:x（i）\ in n u j（k）

\左[F（Z K，J，X ^（I）\集减）-F（Z K-1，J，X ^（I）\集减 J）\右]\]

让我们把这个公式分解，从右边开始。这个名称累积的局部效果很好地反映了这个公式的所有单个组成部分。ALE 方法的核心是计算预测中的差异，因此我们用网格值 Z 替换感兴趣的特征。预测中的差异是特征在特定间隔内对单个实例的影响。右边的总和将所有实例的影响相加，并将其作为邻域（n_j（k））显示在公式中。我们将此和除以此间隔中的实例数，得到此间隔预测的平均差。间隔中的平均值包含在名称 ale 中的术语 local 中。左和符号意味着我们在所有间隔中积累平均效果。例如，位于第三个间隔中的特征值的（未确定的）ALE 是第一个间隔、第二个间隔和第三个间隔的效果之和。ALE 中累积的单词反映了这一点。

这个效果居中，所以平均效果为零。

\  \123;（x）-\ frc \ \ \\123; \\ 123;（i）j）]

与数据的平均预测值相比，ALE 值可以解释为某一特定值下特征的主要影响。例如，当 j-th 特征值为 3 时，ale 估计值为-2（x_j=3），则预测值比平均预测值低 2。

特征分布的分位数用作定义间隔的网格。使用分位数可以确保在每个间隔中有相同数量的数据实例。分位数的缺点是间隔的长度可能非常不同。如果感兴趣的特性是非常偏斜的，这可能会导致一些奇怪的 ALE 图，例如许多低值和只有几个非常高的值。

## 两个特征相互作用的 ALE 图

ALE 图还可以显示两个特征的交互作用。计算原理与单个特征相同，但我们使用矩形单元而不是间隔，因为我们必须将效果累积为二维。除了调整总体平均效果外，我们还调整了这两个特征的主要效果。这意味着两个特征的 ALE 估计二阶效应，而不包括特征的主要效应。换句话说，两个特征的 ALE 只显示了这两个特征的附加交互效果。我把 2dale 图的公式留给你，因为它们很长，读起来很不愉快。如果你对这个计算感兴趣，我可以参考这篇论文，公式（13）–（16）。我将依靠可视化来发展二阶 ALE 计算的直觉。

图 5.13:2d-ALE 的计算。我们在这两个功能上放置一个网格。在每个网格单元中，我们计算内所有实例的二阶差。我们首先用单元格角的值替换 x1 和 x2 的值。如果 a、b、c 和 d 代表“角点”——操作实例的预测（如图中所示），则二阶差为（d-c）-（b-a）。每个单元的平均 2ndorder 差在网格上累积并居中。

在前面的图中，由于相关性，许多单元格是空的。在 ALE 图中，可以使用灰显或暗显框来可视化。或者，您可以用最近的非空单元的 ALE 估计替换空单元缺少的 ALE 估计。

由于两个特征的 ALE 估计仅显示了特征的二阶效应，因此解释需要特别注意。二阶效应是在考虑了特征的主要影响后，特征的附加交互效应。假设两个特征不相互作用，但每个特征对预测结果都有线性影响。在每个特征的一维 ALE 图中，我们可以看到一条直线作为估计的 ALE 曲线。但是当我们绘制二维 ALE 估计时，它们应该接近于零，因为二阶效应只是交互作用的附加效应。ALE 图和 PD 图在这方面有所不同：PDP 始终显示总效果，ALE 图显示一阶或二阶效果。这些是不依赖于基础数学的设计决策。你可以减去部分依赖图中的低阶效应得到纯的主效应或二阶效应，或者，你可以通过避免减去低阶效应得到总 ALE 图的估计值。

累积的局部效应也可以针对任意高阶（三个或多个特征的相互作用）进行计算，但如中所述，只有至多两个特征是有意义的，因为更高的相互作用无法可视化，甚至无法有意义地解释。

## 分类特征的 ALE

根据定义，累积局部效果方法需要特征值具有顺序，因为该方法在特定方向上累积效果。分类特征没有任何自然顺序。为了计算分类特征的 ALE 图，我们必须以某种方式创建或找到一个顺序。分类的顺序影响着累积局部效应的计算和解释。

一种解决方案是根据类别的相似性根据其他特征对其进行排序。两个类别之间的距离是每个要素距离的总和。特征距离比较了这两类中的累积分布，也称为 Kolmogorovsmirnov 距离（对于数值特征）或相对频率表（对于分类特征）。一旦我们有了所有类别之间的距离，我们就使用多维尺度将距离矩阵减少到一维距离度量。这给了我们一个基于相似性的分类顺序。

为了更清楚地说明这一点，这里有一个例子：假设我们有两个分类特征“季节”和“天气”，以及一个数字特征“温度”。对于第一个分类特征（季节），我们要计算销售业绩。该功能分为“春”、“夏”、“秋”、“冬”。我们开始计算“春季”和“夏季”之间的距离。距离是特征温度和天气之间距离的总和。对于温度，我们以所有季节“春季”的实例为例，计算经验累积分布函数，并对季节“夏季”的实例做同样的计算，并用 Kolmogorov-Smirnov 统计量测量它们的距离。对于天气特征，我们计算所有“春季”实例的每种天气类型的概率，对“夏季”实例进行相同的计算，并求出概率分布中的绝对距离。如果“春季”和“夏季”的温度和天气差异很大，则总类别距离较大。我们对其他季节对重复该过程，并通过多维缩放将生成的距离矩阵减少到单个维度。

5.3.4 示例

让我们看看 ALE 计划的实施。我构建了一个部分依赖图失效的场景。该场景由一个预测模型和两个强相关特征组成。预测模型主要是一个线性回归模型，但是在这两个我们从未观察到的特征的组合中做了一些奇怪的事情。

图 5.14：两个特征和预测结果。模型预测两个特征（阴影背景）的总和，但如果 x1 大于 0.7 且 x2 小于 0.3，则模型始终预测 2。该区域远离数据分布（点云），不影响模型的性能，也不影响模型的解释。

这是一个现实的，相关的场景吗？训练模型时，学习算法将现有训练数据实例的损失降至最低。奇怪的事情可能发生在培训数据的分布之外，因为模型不会因为在这些领域做奇怪的事情而受到惩罚。离开数据分布被称为外推法，也可以用来愚弄机器学习模型，如中所述。在我们的小示例中，可以看到与 ALE 图相比，部分依赖图的行为。

图 5.15：使用 pdp（上排）和 ale（下排）计算的特征效果比较。PDP 估计值受数据分布之外模型的奇怪行为（图中的陡跳）的影响。ALE 图正确识别了机器学习模型在特征和预测之间存在线性关系，忽略了没有数据的区域。

但看到我们的模型在 x1>0.7 和 x2<0.3 时表现得很奇怪，这不是很有趣吗？是的，也不是。因为这些数据实例在物理上可能是不可能的，或者至少是极不可能的，所以研究这些实例通常是不相关的。但是，如果您怀疑您的测试分布可能略有不同，并且某些实例实际上在这个范围内，那么在计算特性效果时包含这个区域将是很有趣的。但是，必须有意识地决定是否包括我们尚未观察到数据的区域，并且它不应该是选择方法（如 PDP）的副作用。如果您怀疑模型稍后将用于不同分布的数据，我建议使用 ALE 图并模拟您期望的数据分布。

转向一个真实的数据集，让我们根据天气和白天来预测，并检查 ALE 图是否真的像承诺的那样工作。我们训练一个回归树来预测一天内租用自行车的数量，并使用 ALE 图来分析温度、相对湿度和风速对预测的影响。让我们看看 ALE 的情节是怎么说的：

图 5.16：基于温度、湿度和风速的自行车预测模型的 ALE 图。温度对预测有很大影响。平均预测值随着温度的升高而升高，但再次下降到 25 摄氏度以上。湿度有负面影响：当湿度超过 60%时，相对湿度越高，预测值越低。风速对预测影响不大。

让我们来看看温度、湿度、风速和所有其他特征之间的关系。由于数据也包含分类特征，所以我们不能只使用皮尔逊相关系数，这只在两个特征都是数值的情况下才有效。相反，我训练一个线性模型来预测温度，例如，基于作为输入的其他特征之一。然后我测量线性模型中的另一个特征解释了多少方差，并取平方根。如果另一个特征是数值的，则结果等于标准皮尔逊相关系数的绝对值。但是这种基于模型的“方差解释”方法（也称为方差分析，它代表方差分析）即使其他特征是分类的也可以工作。“方差解释”的测量值总是在 0（无关联）和 1（温度可以从另一个特征完美预测）之间。我们计算了温度、湿度和风速随其他特征的变化。解释的方差（相关性）越高，PD 图的问题（潜在）就越多。下图显示了天气特征与其他特征的关联程度。

图 5.17：当我们训练一个线性模型时，温度、湿度和风速与所有特征之间的相关性的强度，根据解释的方差量进行测量。

例如温度预测和季节特征。对于温度，我们观察到——不足为奇——与季节和月份有很高的相关性。湿度与天气状况有关。

这种相关性分析表明，我们可能会遇到部分依赖图的问题，特别是温度特征。好吧，你自己看看：

图 5.18：温度、湿度和风速的 PDPS。与 ALE 地块相比，

在高温或高湿度条件下，预测的自行车数量减少较小。PDP 使用所有数据实例来计算高温的影响，即使它们是，例如，“冬季”季节的实例。ALE 图更可靠。

下一步，让我们看看 ALE 图对于分类特征的作用。月份是一个分类特征，我们要分析它对自行车预测数量的影响。可以说，月份已经有了一定的顺序（1 月到 12 月），但是让我们试着看看如果我们先按相似性重新排序类别，然后计算影响会发生什么。根据其他特征（如温度或是否为假日）按每月天数的相似性排列月份。

图 5.19：分类特征月的 ALE 图。月份是根据它们之间的相似性来排序的，基于按月分布的其他特性。我们观察到，1 月、3 月和 4 月，尤其是 12 月和 11 月，对预计租用自行车数量的影响比其他月份要小。

由于许多特征与天气有关，月份顺序强烈反映了月份之间的天气是多么相似。所有较冷的月份都在左侧（2 月至 4 月），较温暖的月份则在右侧（10 月至 8 月）。请记住，相似性计算中也包含了非天气特征，例如，假日的相对频率与计算月份之间相似性的温度具有相同的权重。

接下来，我们考虑了湿度和温度对自行车预测数量的二阶效应。记住，二阶效应是两个特征的附加交互效应，不包括主要效应。这意味着，例如，在二阶 ALE 图中，您将看不到高湿度导致预测自行车数量平均较低的主要影响。

图 5.20：湿度和温度对预测租用自行车数量的二阶效应的 ALE 图。当已经考虑到主要影响时，较浅的阴影表示高于平均值，较深的阴影表示低于平均值的预测。该图揭示了温度和湿度之间的相互作用：湿热天气增加了预测。在寒冷和潮湿的天气下，预测的自行车数量会受到额外的负面影响。

请记住，湿度和温度的两个主要影响都表明，预测的自行车数量在非常炎热和潮湿的天气会减少。在湿热天气中，温度和湿度的综合效应不是主要效应的总和，而是大于总和。为了强调纯二阶效应（刚才看到的二维 ALE 图）和总效应之间的区别，让我们来看看偏相关图。PDP 显示了综合效应，综合了平均预测、两个主要效应和二阶效应（交互作用）。

图 5.21：温度和湿度对预测自行车数量的总影响的 PDP。与仅显示交互的二维 ALE 图相比，该图结合了每个特征的主要效果及其交互效果。

如果你只对交互感兴趣，你应该考虑二阶效应，因为总效应将主要效应混合到图中。但是，如果您想知道这些特性的组合效果，您应该看看总效果（PDP 显示）。例如，如果您想知道 30 摄氏度和 80%湿度下自行车的预期数量，可以直接从 2dpd 中读取。如果您想从 ALE 图中读取相同的内容，您需要查看三个图：温度、湿度和温度+湿度的 ALE 图，还需要了解总体平均预测。在两个特征没有交互作用的场景中，这两个特征的总效果图可能会产生误导，因为它可能显示出复杂的景观，暗示了一些交互作用，但它只是两个主要影响的产物。二阶效应会立即表明没有相互作用。

现在的自行车够多了，我们来看看分类任务。我们训练一个随机森林来预测基于风险因素的概率。我们将两个特征的累积局部效应可视化：

图 5.22：年龄和年龄与激素避孕药对宫颈癌预测概率影响的 ALE 图。对于年龄特征，ALE 图显示，到 40 岁时，预测的癌症概率平均较低，之后会增加。激素避孕药使用年限与 8 年后预测的癌症风险较高相关。

接下来，我们来看看怀孕次数和年龄之间的相互作用。

图 5.23：妊娠次数和年龄的二级效应 ALE 图。对情节的解释有点不确定，显示了什么似乎是过度适合。例如，该图显示了 18-20 岁和 3 个以上怀孕（癌症概率增加 5 个百分点）时的奇怪模型行为。在这组年龄和怀孕次数的数据中，女性并不多（实际数据显示为点），因此在培训过程中，该模型不会因女性犯错误而受到严重惩罚。

5.3.5 优势

ALE 图是无偏的，这意味着当特征相关时它们仍然有效。部分依赖图在这种情况下失败，因为它们被边缘化了不太可能或甚至是物理上不可能的特征值组合。

ALE 图的计算速度比 PDP 快，并且使用 O（N）进行缩放，因为可能的最大间隔数是每个实例具有一个间隔的实例数。PDP 需要 n 倍的网格点估计数。对于 20 个网格点，PDP 需要比最坏情况下 ALE 图多 20 倍的预测，其中使用的间隔与实例相同。

ALE 图的解释是清楚的：在给定值的条件下，改变特征对预测的相对影响可以从 ALE 图中读出。ALE 图的中心为零。这使得他们的解释很好，因为 ALE 曲线的每一点的值与平均预测值是不同的。二维 ALE 图只显示交互：如果两个功能不交互，则图中不显示任何内容。

总之，在大多数情况下，我更喜欢 ALE 图而不是 PDP，因为特性通常在某种程度上是相关的。

5.3.6 缺点

ALE 情节可能会变得有点不稳定（许多小的起伏），间隔时间很长。在这种情况下，减少间隔数会使估计更稳定，但也会使预测模型变得更平滑，并隐藏一些真正的复杂性。没有完美的解决方案来设置间隔的数量。如果数字太小，ALE 图可能不太准确。如果数字太高，曲线可能会变得不稳定。

与 PDP 不同，ALE 图不伴有冰曲线。对于 PDP 来说，ICE 曲线是很好的，因为它们可以揭示特征效果的异质性，这意味着一个特征的效果对于数据的子集是不同的。对于 ALE 图，只能按间隔检查实例之间的效果是否不同，但每个间隔都有不同的实例，因此它与 ICE 曲线不同。

二阶 ALE 估计在整个特征空间中具有不同的稳定性，这是不以任何方式可视化的。其原因是，对一个单元中局部效果的每个估计都使用不同数量的数据实例。因此，所有的估计都有不同的准确性（但它们仍然是最好的估计）。这个问题存在于一个不太严重的主效应 ALE 图版本中。由于使用分位数作为网格，所有间隔中的实例数都是相同的，但在某些区域会有许多短间隔，ALE 曲线将由更多的估计组成。但对于可以占整个曲线很大一部分的长间隔，实例相对较少。例如，这发生在宫颈癌预测 ALE 图中。

二阶效应图解释起来有点烦人，因为你总是要记住主要效应。将热图解读为这两个特征的总效应是很有诱惑力的，但它只是交互作用的附加效应。纯粹的二阶效应对于发现和探索相互作用是很有趣的，但是对于解释这种效应是什么样子，我认为把主要效应整合到情节中更有意义。

与部分依赖图相比，ALE 图的实现更为复杂，也更不直观。

即使 ALE 图在相关特征的情况下没有偏差，但当特征强相关时，解释仍然困难。因为如果它们之间有很强的相关性，那么分析同时改变两个特性而不是孤立地改变这两个特性的效果是有意义的。这种缺点并不是针对 ALE 图，而是一个具有强相关特征的一般问题。

如果特征不相关，计算时间也不成问题，则 PDP 稍好，因为它们更容易理解，并且可以与冰曲线一起绘制。

缺点列表已经变得相当长了，但是不要被我使用的词的数量愚弄：作为经验法则：使用 ALE 而不是 PDP。

5.3.7 实施和备选方案

我有没有提到这一点，并且是另一种选择？=）

据我所知，ALE 绘图目前仅在 R 中实现，一次由发明家自己实现，一次由

![img](file:///C:/Users/ADMINI~1/AppData/Local/Temp/msohtmlclip1/01/clip_image002.gif)

1。可视化黑盒监督学习模型中预测变量的影响〉，《ARXIV 预印本：1612.08468》（2016）。

5.4 特征交互

当特征在预测模型中相互作用时，由于一个特征的影响取决于另一个特征的值，因此预测不能表示为特征效果的总和。亚里士多德的谓词“整体大于各部分之和”适用于相互作用的存在。

5.4.1 特征交互？

如果机器学习模型基于两个特征进行预测，我们可以将预测分解为四个术语：常量项、第一个特征项、第二个特征项和两个特征之间的交互项。

两个特征之间的相互作用是在考虑到个别特征的影响后，通过改变特征发生的预测变化。

例如，模型使用房屋大小（大或小）和位置（好或坏）作为特征来预测房屋的价值，从而得出四个可能的预测：

位置大小预测

好大 300000 好小 200000 坏大 250000 坏小 150000

我们将模型预测分解为以下几个部分：一个常量项（150000）、大小特征的影响（+100000，如果大；+0，如果小）和位置的影响（+50000，如果好；+0，如果坏）。这种分解完全解释了模型预测。没有交互作用，因为模型预测是大小和位置的单一特征效应的总和。当你把一个小房子变大的时候，不管位置如何，预测总是增加 10 万。另外，不管大小，一个好位置和一个坏位置的预测差异是 50000。

现在我们来看一个交互示例：

位置大小预测

好大 400000 好小 200000 坏大 250000 坏小 150000

我们将预测表分解为以下几部分：一个常量项（150000）、大小特征的影响（+100000 表示大，+0 表示小），以及位置的影响（+50000 表示好，+0 表示坏）。对于这张表，我们需要一个额外的交互术语：如果房子很大并且位置好，则+100000。这是大小和位置之间的相互作用，因为在这种情况下，大房子和小房子的预测差异取决于位置。

估计交互强度的一种方法是测量预测的变化在多大程度上取决于特征的交互作用。这项测量被称为 H 统计，由 Friedman 和 Popescu（2008）介绍。

5.4.2 理论：弗里德曼 H 统计量

我们将处理两种情况：首先，一种双向交互度量，它告诉我们模型中的两个特征是否相互作用，以及扩展到什么程度；其次，一种全面交互度量，它告诉我们模型中的特征是否与所有其他 FEA 相互作用，以及扩展到什么程度。好的。理论上，可以测量任意数量特征之间的任意交互，但这两种情况是最有趣的。

如果两个特征不相互作用，我们可以分解如下（假设部分相关函数以零为中心）：

\[pd_j k（x_j，x_k）=pd_j（x_j）+pd_k（x_k）\]

其中（pd_j k（x_j，x_k）是两个功能的双向部分依赖函数，以及\（pd_j（x_j）和\（pd_k（x_k））单个功能的部分依赖函数。

同样，如果一个特征与其他特征没有交互作用，我们可以将预测函数\（\hat f（x））表示为部分依赖函数的和，其中第一个和仅依赖于 j，第二个和依赖于除 j 以外的所有其他特征：

\[\Hat f（x）=Pd（x j）+Pd-j（x-j）\]

其中\（pd-j（x-j））是依赖于除 jth 特性之外的所有特性的部分依赖函数。

这种分解表示部分依赖（或完全预测）函数，没有相互作用（特征 J 和 K 之间，或分别是 J 和所有其他特征）。在下一步中，我们测量了观察到的偏相关函数和没有相互作用的分解函数之间的差异。我们计算部分依赖（测量两个特征之间的相互作用）或整个函数（测量特征与所有其他特征之间的相互作用）输出的方差。交互作用（观察到的和没有交互作用的 pd 之间的差异）解释的方差量用作交互强度统计。如果完全没有交互作用，则统计值为 0；如果用偏相关函数的和解释了\（pd jk \）或\（\hat f \）的所有方差，则统计值为 1。两个特征之间的交互统计量为 1 意味着每个单独的 pd 函数都是常数，对预测的影响只来自于交互作用。

从数学上讲，弗里德曼和波佩斯库提出的特征 j 和 k 之间相互作用的 h-统计量是：

\[H^2_{jk}=\sum_{i=1}^n\left[PD_{jk}(x_{j}^{(i)},x_k^{(i)})-PD_j(x_j^{(i)})-PD_k(x_{k}^{(i)}) \right]^2/\sum_{i=1}^n{PD}^2_{jk}(x_j^{(i)},x_k^{(i)})\]

同样适用于测量特征 J 是否与任何其他特征相互作用的情况，即测量特征 J 是否与任何其他特征相互作用，即[H^2 123; i=1 ^n\left[\hat（x（i）（i）123;（i））-pd \123;-j（（（u i=1 ^n\hat f ^2（x ^（i））\]

H 统计量的评估成本很高，因为它在所有数据点上迭代，并且在每个点上，必须评估部分依赖性，而这反过来又对所有 N 个数据点进行评估。在最坏的情况下，我们需要 2n 调用机器学习模型预测函数来计算双向 H-2 统计（j vs.k）和 3n 计算总 H 统计（j vs.all）。为了加快计算速度，我们可以从 n 个数据点进行 2 次采样。这有增加偏相关估计方差的缺点，使得 H 统计量不稳定。因此，如果您使用采样来减少计算负担，请确保采样足够的数据点。

弗里德曼和波佩斯库还提出了一个检验统计来评估 H 统计与零是否有显著差异。无效假设是没有相互作用。要在零假设下生成交互统计，必须能够调整模型，使其在特征 j 和 k 或所有其他项之间没有交互。这不可能适用于所有类型的模型。因此，这个测试是特定于模型的，而不是不可知模型的，因此这里没有介绍。

如果预测是概率的话，交互强度统计也可以应用于分类设置中。

5.4.3 示例

让我们看看在实践中交互的特性是什么样的！我们测量了支持向量机中的特征交互强度，它根据天气和日历特征预测特征的数量。下图显示了特征交互 H 统计：

图 5.24：预测自行车租赁的支持向量机的每个特征与所有其他特征的交互强度（H 统计）。总体而言，特征之间的交互作用非常弱（低于每个特征解释的方差的 10%）。

在下一个例子中，我们计算分类问题的交互统计。我们分析了随机森林特征之间的相互作用，并给出了一些风险因素。

图 5.25:a 的每个特征与所有其他特征的交互强度（H 统计）

随机森林预测宫颈癌的概率。激素避孕药的使用年限与其他特征的相对相互作用效应最高，其次是怀孕次数。

在查看每个特征与所有其他特征的特征交互之后，我们可以选择其中一个特征，并深入了解所选特征与其他特征之间的所有双向交互。

图 5.26：怀孕次数与其他特征之间的双向互动强度（H 统计）。怀孕次数和年龄之间有很强的相互作用。

5.4.4 优势

相互作用的 H 统计量通过偏相关分解有一个基本理论。

H 统计量有一个有意义的解释：交互作用被定义为由交互作用解释的方差份额。

由于统计数据是无量纲的，并且总是在 0 和 1 之间，所以它在特性上甚至在模型上都是可比较的。

统计数据检测各种交互，不管它们的具体形式如何。

利用 H 统计量，还可以分析任意更高的交互作用，如 3 个或更多特征之间的交互强度。

5.4.5 缺点

你会注意到的第一件事是：交互 H 统计需要很长的时间来计算，因为它的计算成本很高。

计算包括估计边际分布。如果我们不使用所有的数据点，这些估计值也有一定的差异。这意味着，当我们对点进行采样时，各个运行的估计值也不同，结果可能不稳定。我建议重复 H 统计计算几次，看看您是否有足够的数据来获得稳定的结果。

不清楚交互作用是否显著大于 0。我们需要进行一个统计测试，但是这个测试在模型不可知的版本中还没有（现在）可用。

在检验问题上，当 H 统计量足够大时，我们很难认为相互作用“强”。

H 统计量告诉我们相互作用的强度，但它并不能告诉我们相互作用的样子。这就是目的。一个有意义的工作流是测量交互强度，然后为您感兴趣的交互创建二维部分依赖关系图。

如果输入是像素，则不能有意义地使用 H 统计。因此，该方法对图像分类器没有实际意义。

交互统计是在我们可以独立洗牌特征的假设下工作的。如果这些特征关联性很强，那么就违反了这个假设，我们集成了在现实中不太可能出现的特征组合。这和偏相关图的问题是一样的。一般来说，你不能说这会导致高估或低估。

有时结果是奇怪的，对于小的模拟不能产生预期的结果。但这更像是一个奇闻轶事。

5.4.6 实施

对于本书中的示例，我使用了 R 包 IML，它在上可用，而开发版本在上也有其他的实现，它们集中在特定的模型上：R 包实现和 H 统计。R 包实现了梯度增强模型和 H 统计。

5.4.7 备选方案

H 统计并不是衡量相互作用的唯一方法：

Hooker（2004）提出的变量交互网络（VIN）是一种将预测函数分解为主要效应和特征交互的方法。然后将功能之间的交互视为一个网络。不幸的是，目前还没有可用的软件。

Greenwell 等人（2018）基于部分依赖性的特征交互测量了两个特征之间的交互。这种方法测量一个特征在另一个特征的不同固定点上的重要性（定义为部分依赖函数的方差）。如果差异很大，那么这些特性就相互作用，如果是零，它们就不相互作用。包上有相应的 R 包 VIP，还包括部分依赖图和特征重要性。

![img](file:///C:/Users/ADMINI~1/AppData/Local/Temp/msohtmlclip1/01/clip_image001.gif)

\1.    Friedman、Jerome H 和 Bogdan E Popescu。“通过规则集合进行预测性学习。”应用统计学的名称。Jstor，916–54。（2008 年）。

\2.    贾尔斯·胡克。“发现黑盒函数中的加性结构”，《Tenthacm-Sigkdd 知识发现和数据挖掘国际会议论文集》。（2004 年）。

\3.    Greenwell、Brandon M、Bradley C.Boehmke 和 Andrew J.McCarthy。“简单有效的基于模型的可变重要性度量”，arxiv 预印 arxiv:1805.04755（2018）。

[↩](https://christophm.github.io/interpretable-ml-book/interaction.html#fnref34)

5.5 特征重要性

特征的重要性在于，在对特征值进行排序后，模型的预测误差增大，从而破坏了特征与真实结果之间的关系。

5.5.1 理论

这个概念非常简单：我们通过计算模型在排列特征后预测误差的增加来衡量特征的重要性。如果改变一个特征的值会增加模型的误差，那么这个特征是“重要的”，因为在这种情况下，模型依赖于该特征来进行预测。如果改变一个特征的值使模型误差保持不变，那么它就“不重要”，因为在这种情况下，模型忽略了预测的特征。Breiman（2001 年）对随机森林引入排列特征重要性测量。基于这一观点，Fisher、Rudin 和 Dominici（2018）提出了一个功能重要性的模型不可知论版本，并将其称为模型依赖。他们还介绍了关于特征重要性的更先进的思想，例如考虑到许多预测模型可能很好地预测数据的（特定于模型的）版本。他们的论文值得一读。

基于 Fisher、Rudin 和 Dominici（2018）的排列特征重要性算法：

输入：训练模型 F，特征矩阵 X，目标向量 Y，误差测量 L（Y，F）。

\1.    估计原始模型误差 eorig=l（y，f（x））（例如均方误差）

\2.    对于每个特征 j=1，…，p do：

通过在数据 X 中排列特征 j 生成特征矩阵 xperm。这打破了特征 j 与真实结果 y 之间的关联。

根据排列数据的预测，估计误差 eperm=l（y，f（xperm））。

计算排列特征重要性 fi=ej 排列/eorig。或者，可以使用差异：fi=ej perm-eorig

\3.    按降序 FI 对功能进行排序。

Fisher、Rudin 和 Dominici（2018）在他们的论文中建议将数据集分成两半，并交换两半的特征 j 的值，而不是排列特征 j。如果你考虑的话，这与排列特征 j 完全相同。如果需要更准确的估计，可以通过将每个实例与其他实例（除了自身）的特征 j 值配对来估计排列特征 j 的错误。这为您提供了一个大小为 n（n-1）的数据集来估计排列错误，并且需要大量的计算时间。我只能推荐使用 n（n-1）-方法，如果你真的想得到非常准确的估计。

5.5.2 我应该计算培训或测试数据的重要性吗？

我没有明确的答案。

回答有关培训或测试数据的问题涉及到什么特性重要的基本问题。理解基于训练的特性重要性与基于测试数据的特性重要性之间的区别的最佳方法是一个“极端”的例子。我训练了一个支持向量机来预测给定 50 个随机特征（200 个实例）的连续随机目标结果。“随机”是指目标结果独立于 50 个特征。这就像根据最新的彩票号码预测明天的温度。如果模型“学习”了任何关系，那么它就太合适了。事实上，SVM 确实在训练数据上做了过多的调整。训练数据的平均绝对误差（简称：MAE）为 0.29，测试数据的平均绝对误差（简称：MAE）为 0.82，这也是预测平均结果为 0（MAE 为 0.78）的最佳可能模型的误差。换句话说，SVM 模型是垃圾。对于这个过度安装的 SVM 的 50 个特性，您期望的特性重要性值是多少？零，因为没有任何功能有助于改进未公开测试数据的性能？或者，不管所学的关系是否归纳为未看到的数据，导入是否反映了模型对每个特性的依赖程度？让我们来看看培训和测试数据的特征重要性的分布是如何不同的。

图 5.27：按数据类型划分的特征重要性值分布。对一个具有 50 个随机特征和 200 个实例的回归数据集进行了 SVM 训练。支持向量机对数据进行了超拟合：基于训练数据的特征重要性显示出许多重要的特征。根据未公开的测试数据计算，特征重要性接近 1 的比率（=不重要）。

我不清楚这两个结果中哪一个更可取。因此，我将尝试为这两个版本做一个案例，让你自己决定。

## 测试数据案例

这是一个简单的例子：基于训练数据的模型错误估计是垃圾->功能重要性依赖于模型错误估计->基于训练数据的功能重要性是垃圾。实际上，这是你在机器学习中学到的第一件事：如果你在模型训练的同一个数据上测量模型误差（或性能），那么测量通常过于乐观，这意味着模型的工作效果似乎比实际情况要好得多。由于排列特征的重要性依赖于模型误差的测量，所以我们应该使用看不见的测试数据。基于训练数据的特征重要性使得我们错误地认为特征对于预测是重要的，而事实上，模型只是过拟合，特征根本不重要。

## 培训数据案例

使用培训数据的论据有些难以表述，但与使用测试数据的论据一样具有说服力。我们再看看我们的垃圾 SVM。根据训练数据，最重要的功能是 x42。让我们看一下特性 X42 的部分依赖关系图。部分相关图显示了模型输出如何根据特征的变化而变化，而不依赖于泛化误差。不管 PDP 是用训练数据还是测试数据计算的。

图 5.28:x42 功能的 PDP，根据训练数据，根据功能重要性，它是最重要的功能。该图显示了 SVM 如何依赖此功能进行预测。

该图清楚地表明，支持向量机已经学会了依赖特征 X42 进行预测，但根据基于测试数据的特征重要性（1.04），这并不重要。根据训练数据，重要性为 1.21，反映出模型已经学会使用这一特性。基于训练数据的特征重要性告诉我们哪些特征对模型很重要，因为在这个意义上，模型的预测依赖于这些特征。

作为使用培训数据的案例的一部分，我想介绍一个反对测试数据的论点。在实践中，您希望使用所有的数据来训练您的模型，最终获得最佳可能的模型。这意味着没有留下未使用的测试数据来计算特性的重要性。当您想要估计模型的泛化错误时，也会遇到同样的问题。如果将（嵌套的）交叉验证用于特性重要性估计，那么您会遇到这样的问题：特性重要性不是在具有所有数据的最终模型上计算的，而是在具有可能表现不同的数据子集的模型上计算的。

最后，您需要决定您是想知道模型在多大程度上依赖于每个特性来进行预测（->训练数据），还是该特性在多大程度上有助于模型在未知数据上的性能（->测试数据）。据我所知，目前还没有关于培训与测试数据问题的研究。它需要比我的“垃圾 SVM”示例更彻底的检查。我们需要更多的研究和使用这些工具的经验来获得更好的理解。

接下来，我们将看一些例子。我基于训练数据的重要性计算，因为我必须选择一个训练数据，并且使用训练数据需要少几行代码。

5.5.3 示例和解释

我展示了分类和回归的例子。

## 宫颈癌（分类）

我们拟合一个随机森林模型进行预测。我们测量误差增加 1-AUC（1 减去 ROC 曲线下的面积）。与模型误差增加 1 倍（无变化）相关的特征对于预测宫颈癌并不重要。

图 5.29：随机森林预测宫颈癌各特征的重要性。最重要的特征是年龄。置换年龄导致 1-AUC 增加 5.17 倍。

最重要的特征是年龄与排列后误差增加 5.17 有关。

## 自行车共享（回归）

我们拟合了一个支持向量机模型来预测给定的天气条件和日历信息。作为误差测量，我们使用平均绝对误差。

图 5.30：使用支持向量机预测自行车计数时每个功能的重要性。最重要的是临时工，最不重要的是假期。

5.5.4 优势

很好的解释：特征的重要性是当特征的信息被破坏时，模型误差的增加。

功能重要性提供了对模型行为的高度压缩的全局洞察。

使用误差比而不是误差差的一个积极方面是，在不同的问题上，特征重要性度量是可比较的。

重要性度量自动考虑与其他功能的所有交互。通过排列功能，您还可以破坏与其他功能的交互效果。这意味着排列特征的重要性同时考虑了主特征效应和交互效应对模型性能的影响。这也是一个缺点，因为两个特性之间交互的重要性包含在两个特性的重要性度量中。这意味着特性导入不等于总性能下降，但总和更大。只有在特征之间没有交互作用的情况下，如线性模型中，重要的东西才会大致相加。

排列特征重要性不需要重新训练模型。其他一些方法建议删除特征，重新训练模型，然后比较模型错误。由于机器学习模型的再培训需要很长时间，“只有”排列一个特性可以节省很多时间。对具有特征子集的模型进行再培训的重要性方法乍一看似乎很直观，但是具有减少数据的模型对于特征重要性来说毫无意义。我们对固定模型的特征重要性感兴趣。使用缩减的数据集重新训练将创建一个

不同于我们感兴趣的型号。假设您训练一个稀疏线性模型（使用 lasso），该模型具有固定数量的非零权重特征。数据集有 100 个特性，您可以将非零权重的数量设置为 5。您将分析其中一个具有非零权重的特性的重要性。删除该功能并重新导入模型。模型性能保持不变，因为另一个同样好的特性得到非零权重，您的结论是该特性并不重要。另一个例子：模型是一个决策树，我们分析了选择作为第一个分割的特征的重要性。删除该功能并重新导入模型。由于选择了另一个特性作为第一个拆分，所以整棵树可能非常不同，这意味着我们比较（可能）完全不同的树的错误率，以确定该特性对其中一棵树的重要性。

5.5.5 缺点

不清楚您是否应该使用培训或测试数据来计算特性的重要性。

排列特征重要性与模型的误差有关。这并不是天生的坏，但在某些情况下不是你需要的。在某些情况下，您可能更愿意知道一个特性的模型输出变化有多大，而不考虑它对性能的意义。例如，您希望了解当有人操纵特性时，模型的输出有多健壮。在这种情况下，您将不感兴趣的是，当一个特性被排列时，模型性能会下降多少，但是每个特性解释了模型的输出方差有多少。当模型很好地概括（即，它不过度拟合）时，模型方差（由特征解释）和特征重要性有很强的相关性。

你需要获得真正的结果。如果有人只向您提供模型和未标记的数据，而不是真正的结果，那么您就无法计算排列特征的重要性。

排列特征的重要性取决于对特征的梳理，这增加了测量的随机性。当排列重复时，结果可能大不相同。重复排列和对重要度量值求平均值超过重复次数会使度量值稳定，但会增加计算时间。

如果特征是相关的，排列特征的重要性可能会受到不现实的数据实例的影响。问题与：当两个或多个特征相关时，特征排列产生不太可能的数据实例。当它们是正相关的（比如一个人的身高和体重）并且我改变了其中一个特征时，我创建了新的实例，这些实例不太可能，甚至在身体上是不可能的（例如 2 米重 30 公斤的人），但是我使用这些新实例来衡量重要性。换言之，对于相关特征的排列特征重要性，我们考虑了当我们将特征与现实中永远不会观察到的值交换时，模型性能会降低多少。检查特征是否强相关，如果是，请注意特征重要性的解释。

另一个棘手的问题是：添加相关特征可以通过在两个特征之间拆分重要性来降低相关特征的重要性。让我给你举一个我所说的“分裂”特征重要性的例子：我们想预测下雨的可能性，并将前一天早上 8 点的温度作为特征，以及其他不相关的特征。我训练了一个随机森林，结果发现温度是最重要的特征，一切都很好，第二天晚上我睡得很好。现在想象另一个场景，在其中我将上午 9:00 的温度作为一个与上午 8:00 的温度强相关的特征。如果我已经知道上午 8 点的温度，那么上午 9 点的温度不会给我提供更多的信息。但是拥有更多的功能总是很好的，对吧？我训练了一个具有两个温度特征和不相关特征的随机森林。一些树木在随机的森林中会在上午 8 点的温度下生长，另一些则在上午 9 点的温度下生长，另一些则是同时生长，另一些则没有。两个温度特征在一起比以前的单个温度特征更重要，但不是在重要特征列表的顶部，每个温度现在处于中间。通过引入一个相关的特性，我将最重要的特性从重要性阶梯的顶端踢到了平庸。一方面这很好，因为它只是反映了底层机器学习模型的行为，这里是随机森林。上午 8 点的温度变得不那么重要了，因为模型现在也可以依赖于上午 9 点的测量。另一方面，它使特征重要性的解释变得相当困难。假设您想要检查这些特性的测量误差。检查费用昂贵，您决定只检查最重要的 3 个功能。在第一种情况下，您将检查温度，在第二种情况下，您将不包括任何温度特性，因为它们现在具有相同的重要性。尽管重要性值在模型行为级别上可能是有意义的，但是如果您有相关的特性，则会令人困惑。

5.5.6 软件和备选方案

例子中使用了 IML R 包。dalex r 包和 python skater 模块还实现了模型不可知排列特性的重要性。

一种称为自适应特征重要性算法的算法，用于为重要性提供 p 值。

![img](file:///C:/Users/ADMINI~1/AppData/Local/Temp/msohtmlclip1/01/clip_image002.gif)

\1.    《随机森林》，机器学习 45（1）。斯普林格：5-32（2001）。

\2.    Fisher、Aaron、Cynthia Rudin 和 Francesca Dominici。“从‘Rashomon’的角度来看，模型类依赖：任何机器学习模型类的可变重要性度量。”（2018 年）。

5.6 全球代理

全局代理模型是一个可解释的模型，它经过训练以近似黑箱模型的预测。我们可以通过解释代理模型得出关于黑盒模型的结论。通过使用更多的机器学习来解决机器学习的可解释性！

5.6.1 理论

代理模型也用于工程：如果感兴趣的结果昂贵、耗时或难以测量（例如，因为它来自复杂的计算机模拟），则可以使用廉价、快速的结果代理模型。工程中使用的替代模型和可解释机器学习中使用的替代模型的区别在于，基础模型是机器学习模型（而不是模拟），并且替代模型必须是可解释的。（可解释的）替代模型的目的是尽可能准确地近似基础模型的预测，同时可解释。替代模型的概念可以在不同的名称下找到：近似模型、元模型、响应面模型、仿真器……

关于这个理论：实际上没有太多的理论需要理解代理模型。我们希望在 g 可解释的约束下，尽可能接近我们的黑箱预测函数 f 和代替品模型预测函数 g。对于函数 g，可以使用任何可解释的模型，例如来自的模型。

例如线性模型：

\[g（x）=\beta+\beta x+\ldots+\beta x p\]或决策树：

\[g（x）=\sum m=1 ^mc i \ x \ in r m \

训练代理模型是一种模型不可知方法，因为它不需要任何关于黑盒模型内部工作的信息，只需要访问数据和预测函数。如果将底层机器学习模型替换为另一个模型，您仍然可以使用代理方法。黑盒模型类型和代理模型类型的选择是分离的。

执行以下步骤以获取代理模型：

\1.    选择一个数据集 X。它可以是用于培训黑盒模型的同一个数据集，也可以是来自同一分发版的新数据集。甚至可以根据应用程序选择数据的子集或点网格。

\2.    对于选定的数据集 X，获取黑盒模型的预测。

\3.    选择可解释的模型类型（线性模型、决策树…）。

\4.    在数据集 X 及其预测上训练可解释模型。

\5.    祝贺你！现在您有了一个代理模型。

\6.    测量代理模型复制黑盒模型预测的效果。

\7.    解释代理模型。

您可能会发现代理模型的方法有一些额外的步骤或稍有不同，但一般的想法通常如本文所述。

测量代理复制黑盒模型的一种方法是 R 平方测量：

\[r^2=1-\frac sse sst=1-\frac \ sum i=1 ^n（\hat y（i）-\hat（i））^2 sum i=1 ^n（\hat y

^（i）-\bar \hat y）^2 \]

其中\（\hat y（i）\）是对代理模型第 i 个实例的预测，其中\（\hat（i）\）黑箱模型的预测，以及\（\bar \ hat y）黑箱模型预测的平均值。SSE 代表平方和误差，SST 代表平方和总误差。R 平方测度可以解释为代理模型捕获的方差百分比。如果 r 平方接近 1（=低 SSE），那么可解释模型非常接近黑箱模型的行为。如果可解释模型非常接近，您可能希望用可解释模型替换复杂模型。如果 r 平方接近 0（=高 SSE），则可解释模型无法解释黑盒模型。

注意，我们没有讨论底层黑盒模型的模型性能，

也就是说，它在预测实际结果时表现得好坏。黑盒模型的性能在训练代理模型中不起作用。代理模型的解释仍然有效，因为它声明了模型而不是真实世界。但是，当然，如果黑盒模型不好，对替代模型的解释就变得无关紧要了，因为黑盒模型本身就是无关紧要的。

我们还可以基于原始数据的子集构建一个代理模型，或者重新计算实例。通过这种方式，我们改变了代理模型输入的分布，从而改变了解释的焦点（然后它不再是真正的全局性的）。如果我们用特定的数据实例对数据进行局部加权（实例越接近所选实例，它们的权重越高），我们就得到一个局部代理模型，它可以解释实例的个别预测。阅读 5.6.2 示例中有关本地模型的更多信息

为了演示代理模型，我们考虑回归和分类示例。

首先，我们训练一个支持向量机来预测给定的天气和日历信息。由于支持向量机的解释性不强，因此我们用购物车决策树训练一个代理作为可解释模型来近似支持向量机的行为。

图 5.31：代理树的终端节点，它近似于自行车租赁数据集上训练的支持向量机的预测。节点中的分布表明，当温度高于 13 摄氏度时，以及当 2 年内的某一天晚些时候（临界点为 435 天），代理树预测租用自行车的数量会更高。

代理模型的 r 平方（方差解释）为 0.77，这意味着它很好地近似了底层的黑箱行为，但并不完美。如果合适的话，我们可以扔掉支持向量机，用树代替。

在我们的第二个例子中，我们预测随机森林的概率。再次，我们用原始数据集训练决策树，但将随机森林的预测作为结果，而不是数据中的真实类（健康与癌症）。

图 5.32：一个代理树的终端节点，它近似于一个随机森林对宫颈癌数据集的预测。节点中的计数显示节点中黑盒模型分类的频率。

代理模型的 r 平方（方差解释）为 0.2，这意味着它不能很好地近似随机森林，在得出复杂模型的结论时，我们不应该过度解释树。

5.6.3 优势

代理模型方法是灵活的：可以使用来自的任何模型。这也意味着您不仅可以交换可解释模型，还可以交换底层的黑盒模型。假设您创建了一些复杂的模型，并将其解释给公司中的不同团队。一个团队熟悉线性模型，另一个团队可以理解决策树。您可以为原始黑盒模型训练两个代理模型（线性模型和决策树），并提供两种解释。如果你找到一个性能更好的黑盒模型，你不需要改变你的解释方法，因为你可以使用同一类的代理模型。

我认为这种方法是非常直观和直接的。这意味着它很容易实现，也很容易向不熟悉数据科学或机器学习的人解释。

使用 r 平方度量，我们可以很容易地度量我们的代理模型在近似黑箱预测方面有多好。

5.6.4 缺点

您必须知道，您得出的结论是关于模型的，而不是关于数据的，因为代理模型从未看到真正的结果。

目前还不清楚 R 平方的最佳截止点是什么，以便确信代理模型与黑盒模型足够接近。解释了 80%的差异？50%？99%？

我们可以测量代理模型与黑盒模型之间的距离。让我们假设我们不是很接近，而是足够接近。对于数据集的一个子集，可解释模型可能非常接近，但对于另一个子集，可解释模型可能存在很大差异。在这种情况下，对简单模型的解释对所有数据点都不一样好。

作为代理选择的可解释模型有其所有的优点和缺点。

有些人认为，一般来说，没有本质上可解释的模型（甚至包括线性模型和决策树），甚至有一个可解释性的错觉也是危险的。如果你同意这个观点，那么这个方法当然不适合你。

5.6.5 软件

我使用 IML R 包作为例子。如果您可以训练机器学习模型，那么您应该能够自己实现代理模型。简单地训练一个可解释的模型来预测黑箱模型的预测。

5.7 局部替代物（石灰）

局部代理模型是可解释的模型，用于解释黑盒机器学习模型的个别预测。局部可解释模型不可知论解释（LIME）是作者提出的一种局部替代模型的具体实现。代理模型被训练为近似底层黑盒模型的预测。Lime 没有培训全球替代模型，而是专注于培训本地替代模型来解释个人预测。

这个想法很直观。首先，忘记培训数据，想象一下你只有黑匣子模型，在那里你可以输入数据点并得到模型的预测。你可以随时探测盒子。您的目标是了解为什么机器学习模型

一定的预测。Lime 测试当您将数据的变化输入机器学习模型时，预测会发生什么。Lime 生成一个新的数据集，该数据集由排列的样本和黑箱模型的相应预测组成。在这个新的数据集上，Lime 然后训练一个可解释的模型，该模型通过采样实例与相关实例的接近程度来加权。可解释模型可以是例如或中的任何内容。学习模型应该是机器学习模型局部预测的一个很好的近似值，但它不一定是一个好的全局近似值。这种精度也称为局部保真度。

在数学上，具有可解释性约束的局部替代模型可以表示为：

\[\text 解释（x）=\arg\min g \ in g l（f，g，\pi x）+\omega（g）\]

举例来说，x 的解释模型是 g 模型（例如线性回归模型），该模型最小化损失 l（例如均方误差），该模型测量解释与原始模型 f（例如 xgboost 模型）的预测的接近程度，而模型复杂性（ω（g））保持在较低水平（例如。g.喜欢较少的功能）。G 是一系列可能的解释，例如所有可能的线性回归模型。邻近度度量\（\pi_x\）定义了我们在解释时考虑到的实例 x 周围的邻居有多大。实际上，石灰只能优化损失部分。用户必须确定复杂性，例如通过选择线性回归模型可能使用的最大特征数。

培训本地代理模型的方法：

•  选择您感兴趣的实例，对其黑盒预测进行解释。

•  扰乱你的数据集，得到这些新点的黑匣子预测。

•  根据新样品与相关实例的接近程度对其进行称重。

•  在数据集上训练加权的、可解释的模型。

•  通过解释局部模型来解释预测。

例如，在和中的当前实现中，可以选择线性回归作为可解释的代理模型。事先，您必须选择 k，即您希望在可解释模型中具有的功能的数量。K 越低，解释模型就越容易。较高的 k 值可能产生高保真度的模型。有几种方法可以训练具有 K 特征的模型。一个好的选择是一个具有高正则化参数\（\lambda\）的 lasso 模型生成一个没有任何特性的模型。通过用一个接一个的缓慢下降的\（\lambda\）重新训练 lasso 模型，这些特性得到了不同于零的重量估计。如果有 K

功能在模型中，您已达到所需的功能数量。其他策略是向前或向后选择特性。这意味着您要么从完整的模型（=包含所有特性）开始，要么从只有截距的模型开始，然后测试添加或删除哪个特性会带来最大的改进，直到达到具有 k 特性的模型为止。

如何获得数据的变化？这取决于数据类型，可以是文本、图像或表格数据。对于文本和图像，解决方案是打开或关闭单个单词或超级像素。在表格数据的情况下，Lime 通过单独干扰每个特征，从正态分布中提取特征的平均值和标准偏差来创建新的样本。

5.7.1 表格数据用石灰

表格数据是以表格形式出现的数据，每一行代表一个实例，每一列代表一个特性。石灰样品不是在感兴趣的情况下采集的，而是从培训数据的质量中心采集的，这是有问题的。但是，它增加了一些样本点预测结果与感兴趣的数据点不同的可能性，并且莱姆至少可以学到一些解释。

最好直观地解释采样和本地模型培训的工作原理：

图 5.33：表格数据的石灰算法。a）随机森林预测，给出特征 x1 和 x2。预测类：1（深色）或 0（浅色）。b）兴趣实例（大点）和从正态分布（小点）中采样的数据。c）为相关实例附近的点指定更高的权重。d）网格的符号显示了从加权样本中本地学习的模型的分类。白线表示决策边界（P（class=1）=0.5）。

像往常一样，魔鬼在细节上。在一个点周围定义一个有意义的邻域是困难的。Lime 目前使用指数平滑内核来定义邻域。平滑内核是一个函数，它接受两个数据实例并返回一个邻近度量。内核宽度决定了邻域的大小：一个较小的内核宽度意味着一个实例必须非常接近于影响本地模型，一个较大的内核宽度意味着距离较远的实例也会影响模型。如果你看一下，你会发现它使用了指数平滑内核（在标准化数据上），内核宽度是训练数据列数的平方根的 0.75 倍。它看起来像是一行无辜的代码，但它就像一头大象坐在你的客厅里，旁边是你从祖父母那里得到的好瓷器。最大的问题是我们没有找到最佳内核或宽度的好方法。而 0.75 是从哪里来的呢？在某些情况下，您可以通过更改内核宽度来轻松地转换您的解释，如下图所示：

图 5.34：实例 x=1.6 的预测说明。黑匣子模型的预测取决于一个单一的特征，显示为一条粗线，数据的分布显示为地毯。计算了三种不同核宽的局部代理模型。所得到的线性回归模型取决于内核宽度：对于 x=1.6，特征是否有负的、正的或没有影响？

该示例仅显示一个功能。在高维特征空间中，情况会变得更糟。距离测量是否应平等对待所有特征也很不清楚。功能 x1 的距离单位是否与功能 x2 的距离单位相同？距离测量是非常任意的，不同维度的距离（又称特征）可能根本无法比较。

## 5.7.1.1 示例

让我们看一个具体的例子。我们回到并将预测问题转化为一个分类：在考虑到自行车租赁随着时间的推移变得越来越流行的趋势后，我们想知道某一天租赁的自行车数量是否会高于或低于趋势线。你也可以将“高于”解释为高于自行车平均数，但要根据趋势进行调整。

首先，我们在分类任务中训练一个有 100 棵树的随机森林。根据天气和日历信息，租赁自行车的数量将在哪一天高于无趋势平均值？

创建的解释具有两个功能。针对具有不同预测类的两个实例训练的稀疏局部线性模型的结果：

图 5.35：自行车租赁数据集两个实例的石灰说明。气温升高和天气状况良好对预测有积极影响。X 轴显示特征效果：权重乘以实际特征值。

从图中可以清楚地看出，分类特征比数字特征更容易解释。一种解决方案是将数字特征分类到容器中。

5.7.2 文本用石灰

文本的石灰与表格数据的石灰不同。数据变化的产生方式不同：

从原始文本开始，通过从原始文本中随机删除单词来创建新文本。数据集用每个字的二进制特性表示。如果包含相应的单词，则功能为 1；如果已删除，则功能为 0。

## 5.7.2.1 示例

在本例中，我们将其分类为垃圾邮件或普通邮件。

黑盒模型是一种基于文档词矩阵训练的深层决策树。每个注释是一个文档（=一行），每个列是给定单词的出现次数。短决策树很容易理解，但在这种情况下，树很深。此外，代替这棵树，可能有一个反复出现的神经网络或支持向量机训练的字嵌入（抽象向量）。让我们看看这个数据集的两条注释和相应的类（1 表示垃圾邮件，0 表示普通注释）：

## 内容类

帕西是个好人 0

173 圣诞歌曲请访问我的频道！；1）

下一步是创建本地模型中使用的数据集的一些变体。例如，其中一条评论的一些变化：

## 为圣诞节而来的探视频道！；）探针重量

21 0 1 1 0 0 1 0.17 0.57

30 1 1 1 1 0 1 0.17 0.71

41 0 0 1 1 1 0.99 0.71

51 0 1 1 1 1 0.99 0.86

60 1 1 1 0 0 1 0.17 0.57

每列对应句子中的一个词。每行都是一个变体，1 表示单词是此变体的一部分，0 表示单词已被删除。其中一个变奏曲的对应句子是“圣诞歌拜访我的；）”。“prob”列显示每个句子变化的垃圾邮件预测概率。“权重”列显示变化与原句的接近程度，计算为 1 减去被删除的词的比例，例如，如果 7 个词中有 1 个被删除，接近程度为 1-1/7=0.86。

下面是两个句子（一个垃圾邮件，一个没有垃圾邮件），它们的估计局部权重由 Lime 算法找到：

## caseblabel_probfeature feature_weight

1 0.1701170 好 0.000000

1 0.1701170 A 0.000000

1           0.1701170 为 0.000000

2           0.9939024 频道！6.180747 年

0.000000 为 2 0.9939024

2 0.9939024；）0.000000

“频道”一词表示垃圾邮件的可能性很高。对于非垃圾邮件注释，没有估计非零权重，因为无论删除哪个单词，预测类都保持不变。

5.7.3 图像用石灰

这一部分是由维伦娜·霍恩施密德写的。

图像的石灰与表格数据和文本的石灰不同。直观地说，干扰单个像素没有多大意义，因为许多多个像素对一个类有贡献。随机改变单个像素可能不会改变太多的预测。因此，通过将图像分割为“超级像素”并关闭或打开超级像素，可以创建图像的变化。超级像素是具有相似颜色的互连像素，可以通过将每个像素替换为用户定义的颜色（如灰色）来关闭超级像素。用户还可以指定在每个排列中关闭超像素的概率。

## 5.7.3.1 示例

由于图像解释的计算速度相当慢，因此包含了一个预先计算的示例，我们还将使用它来显示该方法的输出。解释可以直接显示在图像样本上。因为每个图像可以有几个预测标签（按概率排序），所以我们可以解释前 n 个标签。在下面的图片中，前三个预测是电吉他、原声吉他和拉布拉多。

图 5.36：谷歌的初始神经网络对图像分类前三类的石灰解释。示例取自石灰纸（Ribeiro 等人，2016）。

第一种情况的预测和解释是非常合理的。电吉他的第一个预测当然是错误的，但解释表明神经网络的行为仍然是合理的，因为识别出的图像部分表明这可能是电吉他。

5.7.4 优势

即使您替换了底层机器学习模型，您仍然可以使用相同的本地可解释模型进行解释。假设观察解释的人最了解决策树。因为您使用本地代理模型，所以您可以使用决策树作为解释，而不必实际使用决策树来进行预测。例如，您可以使用 SVM。如果结果证明 XGBoost 模型工作得更好，那么您可以替换 SVM，并将其用作决策树来解释预测。

本地代理模型受益于培训和解释可解释模型的文献和经验。

当使用套索或短树时，产生的解释很短（=选择性），可能具有对比性。因此，他们做到了。这就是为什么我在接受解释的人是外行或时间很少的人的应用程序中看到了更多的石灰。对于完整的属性来说，这是不够的，所以我在法规遵从性场景中看不到石灰，在这些场景中，法律可能要求您完全解释一个预测。此外，对于调试机器学习模型，有所有的原因而不是少数是有用的。

Lime 是少数几种适用于表格数据、文本和图像的方法之一。

保真度度量（可解释模型与黑箱预测的近似程度）使我们很好地了解了可解释模型在解释感兴趣的数据实例附近的黑箱预测方面的可靠性。

石灰是用 python（and）和 r（and）实现的，并且非常容易使用。

使用本地代理模型创建的解释可以使用原始模型以外的其他功能。与其他方法相比，这可能是一个很大的优势，尤其是在原始特性无法进行解释的情况下。文本分类器可以依靠抽象的单词嵌入作为特征，但解释可以基于句子中单词的存在或不存在。回归模型可以依赖某些属性的不可解释转换，但可以使用原始属性创建解释。

5.7.5 缺点

在使用表格数据时，正确定义邻域是一个很大的、尚未解决的问题。在我看来，这是石灰最大的问题，也是我建议只小心使用石灰的原因。对于每个应用程序，您必须尝试不同的内核设置，并亲自查看解释是否有意义。不幸的是，这是我能给出的找到好的内核宽度的最佳建议。

在当前石灰的实施中，可以改进取样。数据点从高斯分布中取样，忽略特征之间的相关性。这可能导致不太可能的数据点，然后可以用来学习本地解释模型。

解释模型的复杂性必须提前定义。这只是一个小小的抱怨，因为最终用户必须定义忠诚度和稀疏度之间的折衷。

另一个真正大的问题是解释的不稳定性。作者在一篇文章中指出，在模拟环境中，两个非常接近的点的解释有很大的不同。而且，根据我的经验，如果你重复取样过程，那么得出的解释可能会不同。不稳定意味着很难相信解释，你应该非常挑剔。

结论：以石灰为具体实施对象的局部替代模型具有很好的应用前景。但该方法仍处于开发阶段，需要解决许多问题才能安全应用。

![img](file:///C:/Users/ADMINI~1/AppData/Local/Temp/msohtmlclip1/01/clip_image003.gif)

\1.    Ribeiro、Marco Tulio、Sameer Singh 和 Carlos Guestrin。“我为什么要相信你？：解释任何分类器的预测〉，《第 22 届 ACM Sigkdd 知识发现和数据挖掘国际会议论文集》。ACM（2016 年）。

\2.    Alvarez Melis、David 和 Tommi S.Jaakkola。“关于解释方法的稳健性”，ARXIV 预印 ARXIV:1806.08049（2018）。

5.8 夏普利值

一个预测可以通过假设实例的每个特征值都是一个“玩家”来解释，在一个预测是支出的游戏中。沙普利值——来自联合博弈理论的一种方法——告诉我们如何在特征之间公平地分配“支出”。

5.8.1 总体思路

假设以下情况：

你已经训练了一个机器学习模型来预测公寓价格。对于某个公寓，它预测 30 万欧元，你需要解释一下这个预测。公寓面积为 50 米，2 楼为 IS2，附近有公园，禁止养猫：

图 5.37：一套 5000 万平方米的公寓，附近有公园和禁猫区，预计价格为 2 300000 欧元。我们的目标是解释这些特征值如何对预测做出贡献。

所有公寓的平均预测值为 31 万欧元。与平均预测相比，每个特征值对预测的贡献有多大？

对于线性回归模型，答案很简单。每个特征的效果是特征的权重乘以特征值。这仅仅是因为模型的线性度。对于更复杂的模型，我们需要一个不同的解决方案。例如，建议本地模型来估计效果。另一种解决方案来自合作博弈理论：沙普利值，由沙普利（1953）创造，是一种根据玩家对总支出的贡献分配支出给玩家的方法。玩家在联盟中合作，并从这种合作中获得一定的收益。

玩家？游戏？支出？机器学习预测和可解释性有什么联系？“游戏”是数据集单个实例的预测任务。“增益”是这个实例的实际预测减去所有实例的平均预测。“玩家”是实例的特征值，它们协同工作以获得收益（=预测某个值）。在我们的公寓示例中，功能值“公园附近”、“禁止猫”、“50 区”和“2 楼”共同实现了 300000 欧元的预测。我们的目标是解释实际预测（300000 欧元）和平均预测（310000 欧元）之间的差异：差异-10000 欧元。

答案可能是：附近的公园捐款 3 万欧元；50 号的捐款 1 万欧元；2 楼的捐款 0 欧元；禁止猫捐款 5 万欧元。捐款总计 10000 欧元，最终预测减去平均预测房价。

我们如何计算一个特性的夏普利值？

沙普利值是特征值在所有可能的联合体中的平均边际贡献。现在全部清除？

在下图中，我们评估了当添加到附近公园和 50 号大小的联盟中时，禁止猫功能值的贡献。我们通过从数据中随机抽取另一套公寓，并将其值用于楼层特征，模拟出只有附近的公园、Catbaned 和 50 号才是一个联合体。二楼的价值被随机抽取的一楼所取代，然后我们预测这个组合的公寓价格（310000 欧元）。在第二步中，我们将禁止加入联盟的猫从随机抽取的公寓中删除，将其替换为允许/禁止使用的猫功能的随机值。在这个例子中，它被加泰罗尼亚化了，但它可能又被禁止了。我们预测附近公园联盟和 50 号（32 万欧元）的公寓价格。禁止使用猫的捐款为 31 万欧元-32 万欧元=10 万欧元。这个估计值取决于作为 cat 和 floor 特征值的“捐赠者”的随机抽取公寓的值。如果我们重复这个抽样步骤并平均贡献，我们将得到更好的估计。

图 5.38：一个重复的样本来估计当加入附近公园和 50 区联盟时禁止猫对预测的贡献。

我们对所有可能的联盟重复这个计算。沙普利值是所有可能联盟的边际贡献的平均值。计算时间随特征个数呈指数增长。保持计算时间可控的一个解决方案是只计算可能联合的几个样本的贡献。

下图显示了确定禁用的 cat 的 shapley 值所需的所有特征值组合。第一行显示没有任何特征值的联合。第二行、第三行和第四行显示了不同的联盟，联盟规模不断扩大，以“”分隔。总之，以下联盟是可能的：

•  没有功能值

•  停在附近

•  尺寸-50

•  二楼

•  附近停车+50 码

•  附近停车+二楼

•  尺寸-50+二楼

•  将车停在+50+二楼附近。

对于每一个联合体，我们计算出有或无特征值 cat 被禁止的预测公寓价格，并利用差异得到边际贡献。沙普利值是边际贡献的（加权）平均值。我们用公寓数据集中的随机特征值替换不在组合中的特征值，以从机器学习模型中获得预测。

图 5.39：计算 cat 禁止特征值的精确 shapley 值所需的所有 8 个联合。

如果我们估计所有特征值的沙普利值，我们得到预测值在特征值之间的完整分布（减去平均值）。

5.8.2 示例和解释

特征值 j 的 shapley 值的解释是：与数据集的平均预测相比，第 j 个特征的值对这个特定实例的预测有贡献。

沙普利值适用于分类（如果我们处理概率）和回归。

我们使用 shapley 值分析随机森林模型预测的预测：

图 5.40：宫颈癌数据集中女性的夏普利值。预测值为 0.53，这名妇女的癌症概率比平均预测值 0.03 高 0.51。诊断出的性病数量增加的概率最大。贡献之和产生实际和平均预测之间的差异（0.51）。

我们还训练了一个随机森林，根据天气和日历信息，预测一天租用自行车的数量。为特定日期的随机森林预测创建的解释：

图 5.41:285 天的沙普利值。预计有 2475 辆出租自行车，这一天比平均预计的 4516 辆低-2041 辆。天气状况和湿度的影响最大，负向贡献最大。这一天的温度有一个积极的贡献。沙普利值之和产生实际和平均预测的差异（-2041）。

注意正确地解释夏普利值：夏普利值是一个特征值对不同组合预测的平均贡献。当我们从模型中删除特征时，shapley 值并不是预测的差异。

5.8.3 详细的夏普利值

本节将更深入地探讨对好奇读者的夏普利值的定义和计算。如果您对技术细节不感兴趣，请跳过本节，直接转到“优缺点”。

我们对每个特征如何影响数据点的预测感兴趣。在线性模型中，很容易计算个体效应。以下是一个数据实例的线性模型预测的样子：

\[\hat f（x）=\beta+\beta 1 x 1+ldots+\beta p x p \]

其中 x 是要计算其贡献的实例。每个\（x_j\）都是一个特征值，j=1，…，p.（\beta_j\）是与特征 j 相对应的权重。

第 j 个特征对预测的贡献（phi-j）为 123;f（x）（x）的预测，其贡献为（f j j x j-e（\βj  123; 123; j j 123; j j \125；）\]

其中\（e（\beta jx j）是特征 j 的平均效应估计值。贡献是特征效应减去平均效应的差额。好极了！现在我们知道每个特性对预测的贡献有多大。如果我们在一个实例中合计所有特性贡献，结果如下：

\[\begin align*\ sum j=1 ^ p \ phi j（\hat f）=&\sum j=1 ^p（\beta j x j-e（\beta j x j））。\

\（\beta U 0+\sum j=1 \125;^p\beta j x_j）-（\beta U 0+\sum j=1 \^ 123; 123; 123; 123;  123; 123; 123; \123; j \）e（\beta  123; \\\\]

这是数据点 x 的预测值减去平均预测值。功能贡献可以是负的。

我们能为任何型号的汽车做同样的工作吗？将它作为一个模型不可知论工具是很好的。由于在其他模型类型中我们通常没有类似的权重，所以我们需要一个不同的解决方案。

帮助来自意想不到的地方：合作博弈论。沙普利值是一种计算任何机器学习模型单个预测的特征贡献的解决方案。

## 5.8.3.1 夏普利值

沙普利值通过 S 中玩家的值函数 val 定义。

特征值的沙普利值是其对支出的贡献，对所有可能的特征值组合进行加权和求和：

\[\phi_j（val）=\sum_s\ substeq\ x_1，\ldots，x_p \setminus\ x_j\ \frac s！\左（P-S-1\右）！{p！}

\左（Val\左（S\杯\ X\ J\右）-Val（S\右）\]

其中 s 是模型中使用的特征的子集，x 是要解释的实例的特征值的向量，p 是特征的数量。\（val_x（s）是对集合 S 中的特征值的预测，这些特征值在集合 S 中未包含的特征上被边缘化：

\[val x（s）=\int \hat f（x 1，\ldots，x p）d \mathbb p x \notin s-e x（\hat（f（x））\]

实际上，您对不包含 S 的每个功能执行多个集成。具体示例：机器学习模型使用 4 个功能 x1、x2、x3 和 x4，我们评估由功能值 x1 和 x3 组成的联盟 S 的预测：

\[val_{x}(S)=val_{x}(\{x_{1},x_{3}\})=\int_{\mathbb{R}}\int_{\mathbb{R}}\hat{f} (x_{1},X_{2},x_{3},X_{4})d\mathbb{P}_{X_2X_4}-E_X(\hat{f}(X))\] This looks similar to the feature contributions in the linear model!

不要被“值”这个词的许多用法混淆：特征值是一个特征和实例的数值或分类值；沙普利值是对预测的特征贡献；价值函数是玩家联盟的支付函数（特征值）。

沙普利值是唯一满足属性效率、对称性、虚拟性和可加性的属性方法，可以看作是公平支出的定义。

## 效率

特征贡献必须加上 x 和平均值的预测差异。\[\sum\nolimits_j=1 ^p\phi_j=\hat f（x）-e_x（\hat f（x））\]

## 对称性

如果两个特征值 j 和 k 对所有可能的联合贡献相等，那么它们的贡献应该相同。如果

\[VAL（S\ CUP\ X\ U J\）=VAL（S\ CUP\ X\ U K\）\]所有

\[s\ substeq \ x 1，\ldots，x p \ setminus \ x j，x k \]然后

\[\phi_j=\phi_k_ \]

## 笨蛋

不改变预测值的特征 j（无论添加到哪个特征值组合中）的夏普利值应为 0。如果

\[VAL（S \杯\ X \ U J \）=VAL（S）所有

\[s\ substeq \ x 1、\ldots、x p \]然后

\[\phi_j=0\]

## 可加性

对于一个组合付款 val+val 的游戏，沙普利值如下：+\[\phi_j+\phi_j^+\]

假设您训练了一个随机森林，这意味着预测是许多决策树的平均值。可加性属性保证对于特征值，可以分别计算每棵树的夏普利值，对其进行平均，并获得随机林的特征值的夏普利值。

## 5.8.3.2 直觉

理解 shapley 值的直观方法如下所示：特征值按随机顺序输入房间。房间中的所有功能值都参与游戏（=有助于预测）。特征值的 shapley 值是当特征值加入时，房间中已经存在的联盟收到的预测的平均变化。

## 5.8.3.3 估计沙普利值

所有可能的特征值组合（集合）都必须使用或不使用第 j 个特征来计算精确的沙普利值。对于多个特征，随着更多特征的添加，可能的联合数呈指数级增加，这个问题的确切解决方案会变得有问题。Strumbelj 等人（2014）提出蒙特卡罗采样近似值：

\[\Hat \Phi+J

其中，x 的预测是 x 的预测，但随机数个特征值被随机数据点 z 的特征值替换为随机数个特征值，除了特征 j 的各自值之外，x 矢量与（x ^ f \\（x ^（x ^ \  ^ m \）也是从样本 X 中提取，每一个新实例都是一种“弗兰肯斯坦怪物”，由两个实例组合而成。

单特征值的近似夏普利估计：

•  输出：第 j 个特征值的夏普利值

•  要求：迭代次数 m，兴趣实例 x，特征索引 j，数据矩阵 x，机器学习模型 f

•  对于所有 m=1，…，m：

从数据矩阵 X 中绘制随机实例 Z

选择特征值的随机排列 o

订单实例 x:\（x_o=（x（1），\ldots，x（j），\ldots，x（p））\）

订单实例 Z:\（Z_o=（Z（1），\ldots，Z（j），\ldots，Z（p））\）

构建两个新实例

具有特征 J:\（X+J=（X（1），\ldots，X（J-1），X（J），Z（J+1），\ldots，Z（P））

无特征 J:\（X-J=（X（1），\ldots，X（J-1），Z（J），Z（J+1），\ldots，Z（P））

计算边际贡献：（\phi_j^ m=\hat f（x+j）-\hat f（x-j））

•  计算夏普利值的平均值为：

首先，选择感兴趣的实例 x、特征 j 和迭代次数 m。对于每个迭代，从数据中选择一个随机实例 z，并生成特征的随机顺序。通过组合来自感兴趣的实例 x 和示例 z 的值，创建了两个新实例。第一个实例\（x+j \）是感兴趣的实例，但功能 j 的值之前（包括值）的所有值都由示例 z 的功能值替换。第二个实例\（x-j \）是相似的，但所有的值都按之前的顺序排列，但不包括用样本 z 中特征 j 的值替换的特征 j。从黑匣子中预测的差异计算出来：

\[\phi_j^ m=\hat f（x^m+j）-\hat f（x^m-j）\]

所有这些差异均为平均值，结果如下：

\[\phi_j（x）=\frac 1 m \ sum m=1 ^m\phi_j^ m \]

通过 x 的概率分布隐式地对样本进行平均。

必须对每个特征重复此过程，才能获得所有的夏普利值。

5.8.4 优势

预测和平均预测之间的差异在实例的特征值（shapley 值的效率属性）之间是公平分布的。此属性将 shapley 值与其他方法（如）区分开来。石灰不能保证预测在各特征之间是公平分布的。沙普利值可能是提供完整解释的唯一方法。在法律要求可解释性的情况下（如欧盟的“解释权”），沙普利值可能是唯一合法的方法，因为它基于一个坚实的理论，并公平地分配影响。我不是律师，所以这只反映了我对要求的直觉。

shapley 值允许进行对比解释。您可以将预测与整个数据集的平均预测进行比较，而不是将其与子集或甚至单个数据点进行比较。这种对比也是当地模特如莱姆所没有的。

沙普利值是唯一具有坚实理论的解释方法。公理——效率、对称性、哑性、可加性——给出了一个合理的解释基础。像 Lime 这样的方法假定机器学习模型的局部线性行为，但是没有理论解释为什么这会起作用。

把预测解释为特征值所玩的游戏，真是让人吃惊。

5.8.5 缺点

沙普利值需要大量的计算时间。在 99.9%的实际问题中，只有近似解是可行的。精确计算沙普利值的计算成本很高，因为有两种可能的特征值组合，并且必须通过绘制随机实例来模拟 AK 特征的“缺失”，这会增加沙普利值估计的方差。对联合体的指数数进行抽样，限制迭代次数 m，减少 m 可以减少计算时间，但增加了沙普利值的方差。对于迭代次数没有很好的经验法则，m.m 应该足够大以精确估计沙普利值，但是足够小以在合理的时间内完成计算。应该可以根据切尔诺夫边界选择 m，但我没有看到任何关于机器学习预测的沙普利值的论文。

沙普利值可能会被误解。特征值的沙普利值不是从模型训练中去除特征后预测值的差值。沙普利值的解释是：给定当前的一组特征值，特征值对实际预测和平均预测之间的差异的贡献就是估计的沙普利值。

如果您寻求稀疏解释（包含很少特性的解释），则 shapley 值是错误的解释方法。使用 shapley 值方法创建的解释始终使用所有功能。人类喜欢有选择性的解释，比如石灰。石灰可能是解释外行人必须处理的更好的选择。另一个解决方案是由 Lundberg 和 Lee（2016 年）提出的，它基于沙普利值，但也可以提供很少的功能解释。

shapley 值为每个特征返回一个简单的值，但没有像 lime 这样的预测模型。这意味着它不能用于对投入变化预测的变化做出声明，例如：“如果我一年多赚 300 欧元，我的信用评分将增加 5 分。”

另一个缺点是，如果要计算新数据实例的 shapley 值，则需要访问数据。访问预测函数是不够的，因为您需要用随机抽取的数据实例中的值替换感兴趣实例的部分。只有当您可以创建看起来像真实数据实例但不是来自培训数据的实际实例的数据实例时，才能避免这种情况。

与许多其他基于排列的解释方法一样，沙普利值方法在特征相关时会遇到不现实的数据实例。为了模拟联合中缺少特征值，我们将特征边缘化。这是通过从特征的边缘分布中抽取值来实现的。只要这些功能是独立的，就可以了。当特性是依赖的，那么我们可能会对这个实例没有意义的特性值进行采样。但是我们将使用这些来计算特性的夏普利值。据我所知，对于沙普利的价值观，没有研究这意味着什么，也没有关于如何解决它的建议。一种解决方案可能是将相关特征排列在一起，并为它们获得一个相互的沙普利值。或者，可能需要调整采样过程来考虑特征的依赖性。

5.8.6 软件和备选方案

沙普利值在 IML R 包中实现。

shap 是 shapley 值的另一种形式，在 python 包 shap 中实现。shap 将 shapley 值方法转化为一个优化问题，并使用一个特殊的核函数来度量数据实例的接近性。shap 的结果是稀疏的（许多 shapley 值估计为零），这是与经典 shapley 值最大的区别。

另一种方法叫做分解，它在分解 R 包中实现。分解还显示了每个特征对预测的贡献，但是逐步计算它们。让我们重用这个游戏类比：我们从一个空团队开始，添加对预测贡献最大的特性值，然后迭代直到添加所有特性值。每个特性值贡献多少取决于“团队”中已经存在的各自特性值，这是细分方法的最大缺点。它比沙普利值法更快，对于没有交互作用的模型，结果是相同的。

![img](file:///C:/Users/ADMINI~1/AppData/Local/Temp/msohtmlclip1/01/clip_image001.gif)

\1.    劳埃德 S.沙普利，“n 人博弈的价值”，《博弈论的贡献》2.28（1953）：307-317。

\2.    _Trumbelj、Erik 和 Igor Kononenko。“用特征贡献解释预测模型和个人预测”，《知识与信息系统》41.3（2014）：647-665。

\3.    伦德伯格，斯科特和苏在李。“模型预测解释方法的意外统一”，ARXIV 预印 ARXIV:1611.07478（2016）。

\4.    Staniak、Mateusz 和 Przemyslaw Biecek。“使用实时和分解包的模型预测说明”，ARXIV 预印 ARXIV:1804.01955（2018）。