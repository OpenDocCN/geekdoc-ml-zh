<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.1//EN"
  "http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd">

<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<title>Operator overloading</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1>Operator overloading</h1>
<blockquote>原文：<a href="https://rust-exercises.com/100-exercises/04_traits/03_operator_overloading.html">https://rust-exercises.com/100-exercises/04_traits/03_operator_overloading.html</a></blockquote>
                        
<p>Now that we have a basic understanding of what traits are, let's circle back to <strong>operator overloading</strong>.
Operator overloading is the ability to define custom behavior for operators like <code>+</code>, <code>-</code>, <code>*</code>, <code>/</code>, <code>==</code>, <code>!=</code>, etc.</p>
<h2 id="operators-are-traits"><a class="header" href="#operators-are-traits">Operators are traits</a></h2>
<p>In Rust, operators are traits.<br/>
For each operator, there is a corresponding trait that defines the behavior of that operator.
By implementing that trait for your type, you <strong>unlock</strong> the usage of the corresponding operators.</p>
<p>For example, the <a href="https://doc.rust-lang.org/std/cmp/trait.PartialEq.html"><code>PartialEq</code> trait</a> defines the behavior of
the <code>==</code> and <code>!=</code> operators:</p>
<pre><code class="language-rust">// The `PartialEq` trait definition, from Rust's standard library
// (It is *slightly* simplified, for now)
pub trait PartialEq {
    // Required method
    //
    // `Self` is a Rust keyword that stands for 
    // "the type that is implementing the trait"
    fn eq(&amp;self, other: &amp;Self) -&gt; bool;

    // Provided method
    fn ne(&amp;self, other: &amp;Self) -&gt; bool { ... }
}</code></pre>
<p>When you write <code>x == y</code> the compiler will look for an implementation of the <code>PartialEq</code> trait for the types of <code>x</code> and <code>y</code>
and replace <code>x == y</code> with <code>x.eq(y)</code>. It's syntactic sugar!</p>
<p>This is the correspondence for the main operators:</p>
<div class="table-wrapper"><table><thead><tr><th>Operator</th><th>Trait</th></tr></thead><tbody>
<tr><td><code>+</code></td><td><a href="https://doc.rust-lang.org/std/ops/trait.Add.html"><code>Add</code></a></td></tr>
<tr><td><code>-</code></td><td><a href="https://doc.rust-lang.org/std/ops/trait.Sub.html"><code>Sub</code></a></td></tr>
<tr><td><code>*</code></td><td><a href="https://doc.rust-lang.org/std/ops/trait.Mul.html"><code>Mul</code></a></td></tr>
<tr><td><code>/</code></td><td><a href="https://doc.rust-lang.org/std/ops/trait.Div.html"><code>Div</code></a></td></tr>
<tr><td><code>%</code></td><td><a href="https://doc.rust-lang.org/std/ops/trait.Rem.html"><code>Rem</code></a></td></tr>
<tr><td><code>==</code> and <code>!=</code></td><td><a href="https://doc.rust-lang.org/std/cmp/trait.PartialEq.html"><code>PartialEq</code></a></td></tr>
<tr><td><code>&lt;</code>, <code>&gt;</code>, <code>&lt;=</code>, and <code>&gt;=</code></td><td><a href="https://doc.rust-lang.org/std/cmp/trait.PartialOrd.html"><code>PartialOrd</code></a></td></tr>
</tbody></table>
</div>
<p>Arithmetic operators live in the <a href="https://doc.rust-lang.org/std/ops/index.html"><code>std::ops</code></a> module,
while comparison ones live in the <a href="https://doc.rust-lang.org/std/cmp/index.html"><code>std::cmp</code></a> module.</p>
<h2 id="default-implementations"><a class="header" href="#default-implementations">Default implementations</a></h2>
<p>The comment on <code>PartialEq::ne</code> states that "<code>ne</code> is a provided method".<br/>
It means that <code>PartialEq</code> provides a <strong>default implementation</strong> for <code>ne</code> in the trait definition—the <code>{ ... }</code> elided
block in the definition snippet.<br/>
If we expand the elided block, it looks like this:</p>
<pre><code class="language-rust">pub trait PartialEq {
    fn eq(&amp;self, other: &amp;Self) -&gt; bool;

    fn ne(&amp;self, other: &amp;Self) -&gt; bool {
        !self.eq(other)
    }
}</code></pre>
<p>It's what you expect: <code>ne</code> is the negation of <code>eq</code>.<br/>
Since a default implementation is provided, you can skip implementing <code>ne</code> when you implement <code>PartialEq</code> for your type.
It's enough to implement <code>eq</code>:</p>
<pre><code class="language-rust">struct WrappingU8 {
    inner: u8,
}

impl PartialEq for WrappingU8 {
    fn eq(&amp;self, other: &amp;WrappingU8) -&gt; bool {
        self.inner == other.inner
    }
    
    // No `ne` implementation here
}</code></pre>
<p>You are not forced to use the default implementation though.
You can choose to override it when you implement the trait:</p>
<pre><code class="language-rust">struct MyType;

impl PartialEq for MyType {
    fn eq(&amp;self, other: &amp;MyType) -&gt; bool {
        // Custom implementation
    }

    fn ne(&amp;self, other: &amp;MyType) -&gt; bool {
        // Custom implementation
    }
}</code></pre>
<h2 id="exercise"><a class="header" href="#exercise">Exercise</a></h2>
<p>The exercise for this section is located in <a href="https://github.com/mainmatter/100-exercises-to-learn-rust/tree/main/exercises/04_traits/03_operator_overloading"><code>04_traits/03_operator_overloading</code></a></p>

                        
</body>
</html>