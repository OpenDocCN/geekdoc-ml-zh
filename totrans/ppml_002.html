<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.1//EN"
  "http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd">

<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<title>Syntax</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1>Syntax</h1>
<blockquote>åŽŸæ–‡ï¼š<a href="https://rust-exercises.com/100-exercises/01_intro/01_syntax.html">https://rust-exercises.com/100-exercises/01_intro/01_syntax.html</a></blockquote>
                        
<div class="warning">
<p>Don't jump ahead!<br/>
Complete the exercise for the previous section before you start this one.<br/>
It's located in <code>exercises/01_intro/00_welcome</code>, in the <a href="https://github.com/mainmatter/100-exercises-to-learn-rust">course GitHub's repository</a>.<br/>
Use <a href="/100-exercises/01_intro/00_welcome#wr-the-workshop-runner"><code>wr</code></a> to start the course and verify your solutions.</p>
</div>
<p>The previous task doesn't even qualify as an exercise, but it already exposed you to quite a bit of Rust <strong>syntax</strong>.
We won't cover every single detail of Rust's syntax used in the previous exercise.
Instead, we'll cover <em>just enough</em> to keep going without getting stuck in the details.<br/>
One step at a time!</p>
<h2 id="comments"><a class="header" href="#comments">Comments</a></h2>
<p>You can use <code>//</code> for single-line comments:</p>
<pre><code class="language-rust">// This is a single-line comment
// Followed by another single-line comment</code></pre>
<h2 id="functions"><a class="header" href="#functions">Functions</a></h2>
<p>Functions in Rust are defined using the <code>fn</code> keyword, followed by the function's name, its input parameters, and its
return type.
The function's body is enclosed in curly braces <code>{}</code>.</p>
<p>In previous exercise, you saw the <code>greeting</code> function:</p>
<pre><code class="language-rust">// `fn` &lt;function_name&gt; ( &lt;input params&gt; ) -&gt; &lt;return_type&gt; { &lt;body&gt; }
fn greeting() -&gt; &amp;'static str {
    // TODO: fix me ðŸ‘‡
    "I'm ready to __!"
}</code></pre>
<p><code>greeting</code> has no input parameters and returns a reference to a string slice (<code>&amp;'static str</code>).</p>
<h3 id="return-type"><a class="header" href="#return-type">Return type</a></h3>
<p>The return type can be omitted from the signature if the function doesn't return anything (i.e. if it returns <code>()</code>,
Rust's unit type).
That's what happened with the <code>test_welcome</code> function:</p>
<pre><code class="language-rust">fn test_welcome() {
    assert_eq!(greeting(), "I'm ready to learn Rust!");
}</code></pre>
<p>The above is equivalent to:</p>
<pre><code class="language-rust">// Spelling out the unit return type explicitly
//                   ðŸ‘‡
fn test_welcome() -&gt; () {
    assert_eq!(greeting(), "I'm ready to learn Rust!");
}</code></pre>
<h3 id="returning-values"><a class="header" href="#returning-values">Returning values</a></h3>
<p>The last expression in a function is implicitly returned:</p>
<pre><code class="language-rust">fn greeting() -&gt; &amp;'static str {
    // This is the last expression in the function
    // Therefore its value is returned by `greeting`
    "I'm ready to learn Rust!"
}</code></pre>
<p>You can also use the <code>return</code> keyword to return a value early:</p>
<pre><code class="language-rust">fn greeting() -&gt; &amp;'static str {
    // Notice the semicolon at the end of the line!
    return "I'm ready to learn Rust!";
}</code></pre>
<p>It is considered idiomatic to omit the <code>return</code> keyword when possible.</p>
<h3 id="input-parameters"><a class="header" href="#input-parameters">Input parameters</a></h3>
<p>Input parameters are declared inside the parentheses <code>()</code> that follow the function's name.<br/>
Each parameter is declared with its name, followed by a colon <code>:</code>, followed by its type.</p>
<p>For example, the <code>greet</code> function below takes a <code>name</code> parameter of type <code>&amp;str</code> (a "string slice"):</p>
<pre><code class="language-rust">// An input parameter
//        ðŸ‘‡
fn greet(name: &amp;str) -&gt; String {
    format!("Hello, {}!", name)
}</code></pre>
<p>If there are multiple input parameters, they must be separated with commas.</p>
<h3 id="type-annotations"><a class="header" href="#type-annotations">Type annotations</a></h3>
<p>Since we've been mentioned "types" a few times, let's state it clearly: Rust is a <strong>statically typed language</strong>.<br/>
Every single value in Rust has a type and that type must be known to the compiler at compile-time.</p>
<p>Types are a form of <strong>static analysis</strong>.<br/>
You can think of a type as a <strong>tag</strong> that the compiler attaches to every value in your program. Depending on the
tag, the compiler can enforce different rulesâ€”e.g. you can't add a string to a number, but you can add two numbers
together.
If leveraged correctly, types can prevent whole classes of runtime bugs.</p>
<h2 id="exercise"><a class="header" href="#exercise">Exercise</a></h2>
<p>The exercise for this section is located in <a href="https://github.com/mainmatter/100-exercises-to-learn-rust/tree/main/exercises/01_intro/01_syntax"><code>01_intro/01_syntax</code></a></p>

                        
</body>
</html>