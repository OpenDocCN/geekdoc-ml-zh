- en: Fallibility
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 原文：[https://rust-exercises.com/100-exercises/05_ticket_v2/06_fallibility.html](https://rust-exercises.com/100-exercises/05_ticket_v2/06_fallibility.html)
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'Let''s revisit the `Ticket::new` function from the previous exercise:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: As soon as one of the checks fails, the function panics. This is not ideal,
    as it doesn't give the caller a chance to **handle the error**.
  prefs: []
  type: TYPE_NORMAL
- en: It's time to introduce the `Result` type, Rust's primary mechanism for error
    handling.
  prefs: []
  type: TYPE_NORMAL
- en: '[The `Result` type](#the-result-type)'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The `Result` type is an enum defined in the standard library:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'It has two variants:'
  prefs: []
  type: TYPE_NORMAL
- en: '`Ok(T)`: represents a successful operation. It holds `T`, the output of the
    operation.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Err(E)`: represents a failed operation. It holds `E`, the error that occurred.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Both `Ok` and `Err` are generic, allowing you to specify your own types for
    the success and error cases.
  prefs: []
  type: TYPE_NORMAL
- en: '[No exceptions](#no-exceptions)'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Recoverable errors in Rust are **represented as values**.
  prefs: []
  type: TYPE_NORMAL
- en: They're just an instance of a type, being passed around and manipulated like
    any other value. This is a significant difference from other languages, such as
    Python or C#, where **exceptions** are used to signal errors.
  prefs: []
  type: TYPE_NORMAL
- en: Exceptions create a separate control flow path that can be hard to reason about.
  prefs: []
  type: TYPE_NORMAL
- en: You don't know, just by looking at a function's signature, if it can throw an
    exception or not. You don't know, just by looking at a function's signature, **which**
    exception types it can throw.
  prefs: []
  type: TYPE_NORMAL
- en: You must either read the function's documentation or look at its implementation
    to find out.
  prefs: []
  type: TYPE_NORMAL
- en: 'Exception handling logic has very poor locality: the code that throws the exception
    is far removed from the code that catches it, and there''s no direct link between
    the two.'
  prefs: []
  type: TYPE_NORMAL
- en: '[Fallibility is encoded in the type system](#fallibility-is-encoded-in-the-type-system)'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Rust, with `Result`, forces you to **encode fallibility in the function's signature**.
  prefs: []
  type: TYPE_NORMAL
- en: If a function can fail (and you want the caller to have a shot at handling the
    error), it must return a `Result`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'That''s the big advantage of `Result`: it makes fallibility explicit.'
  prefs: []
  type: TYPE_NORMAL
- en: Keep in mind, though, that panics exist. They aren't tracked by the type system,
    just like exceptions in other languages. But they're meant for **unrecoverable
    errors** and should be used sparingly.
  prefs: []
  type: TYPE_NORMAL
- en: '[Exercise](#exercise)'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The exercise for this section is located in [`05_ticket_v2/06_fallibility`](https://github.com/mainmatter/100-exercises-to-learn-rust/tree/main/exercises/05_ticket_v2/06_fallibility)
  prefs: []
  type: TYPE_NORMAL
