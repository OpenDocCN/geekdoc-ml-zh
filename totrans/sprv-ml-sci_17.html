<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.1//EN"
  "http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd">

<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<title>11  Robustness</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1>11  Robustness</h1>
<blockquote>原文：<a href="https://ml-science-book.com/robustness.html">https://ml-science-book.com/robustness.html</a></blockquote>

<header id="title-block-header" class="quarto-title-block default"><nav class="quarto-page-breadcrumbs quarto-title-breadcrumbs d-none d-lg-block" aria-label="breadcrumb"><ol class="breadcrumb"><li class="breadcrumb-item"><a href="./part-two.html">Integrating Machine Learning Into Science</a></li><li class="breadcrumb-item"><a href="./robustness.html"><span class="chapter-number">11</span>  <span class="chapter-title">Robustness</span></a></li></ol></nav>
<div class="quarto-title">

</div>



<div class="quarto-title-meta">

    
  
    
  </div>
  


</header>


<p>Machine learning systems should not only work under laboratory conditions – they should work in the wild! And yes, we mean that in the true sense of the word.</p>
<p>Imagine you are an animal ecologist studying the diversity and conservation of species in the Serengeti. You know that machine learning systems allow you to identify, count, and even describe animals from images alone, as illustrated in <a href="#fig-robustness-intro-example" class="quarto-xref">Figure <span>11.1</span></a>. There are tons of motion sensor cameras throughout the Serengeti. Together with the predictions by the machine learning model of Norouzzadeh et al. <span class="citation" data-cites="norouzzadeh2018automatically"><a href="references.html#ref-norouzzadeh2018automatically" role="doc-biblioref">[1]</a></span>, you’ll soon have an amazing dataset to tackle your research questions.</p>
<div id="fig-robustness-intro-example" class="quarto-float quarto-figure quarto-figure-center anchored">
<figure class="quarto-float quarto-float-fig figure">
<div aria-describedby="fig-robustness-intro-example-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
<img src="../Images/1b6eeabd840fafe8550cb7483f7d5f2d.png" class="img-fluid figure-img" style="width:65.0%" data-original-src="https://ml-science-book.com/images/robustness_intro_example.jpg"/>
</div>
<figcaption class="quarto-float-caption-bottom quarto-float-caption quarto-float-fig" id="fig-robustness-intro-example-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
Figure 11.1: The image was taken by motion sensor cameras in the Serengeti and shows wildlife animals. The machine learning model by <span class="citation" data-cites="norouzzadeh2018automatically"><a href="references.html#ref-norouzzadeh2018automatically" role="doc-biblioref">[1]</a></span> correctly identifies, counts, and describes the animals in the image. Used with permission from <span class="citation" data-cites="norouzzadeh2018automatically"><a href="references.html#ref-norouzzadeh2018automatically" role="doc-biblioref">[1]</a></span>.
</figcaption>
</figure>
</div>
<p>Norouzzadeh et al. <span class="citation" data-cites="norouzzadeh2018automatically"><a href="references.html#ref-norouzzadeh2018automatically" role="doc-biblioref">[1]</a></span> have indeed done an impressive job with their machine learning model: Their ensemble of trained convolutional neural networks (CNN) achieves 94.9% accuracy on the Snapshot Serengeti dataset <span class="citation" data-cites="swanson2015snapshot"><a href="references.html#ref-swanson2015snapshot" role="doc-biblioref">[2]</a></span> – that is a comparable performance to human labelers. Sounds like a reliable tool to build your research on, right?</p>
<div id="fig-robustness-adversarial" class="quarto-float quarto-figure quarto-figure-center anchored">
<figure class="quarto-float quarto-float-fig figure">
<div aria-describedby="fig-robustness-adversarial-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
<img src="../Images/e695aa72e1eff8dd242f83347bf5a1bc.png" class="img-fluid figure-img" style="width:65.0%" data-original-src="https://ml-science-book.com/images/robustness-adversarial.jpg"/>
</div>
<figcaption class="quarto-float-caption-bottom quarto-float-caption quarto-float-fig" id="fig-robustness-adversarial-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
Figure 11.2: The image looks the same as in <a href="#fig-robustness-intro-example" class="quarto-xref">Figure <span>11.1</span></a>, but now the model is completely wrong in all aspects. Figure modified with permission from <span class="citation" data-cites="norouzzadeh2018automatically"><a href="references.html#ref-norouzzadeh2018automatically" role="doc-biblioref">[1]</a></span>.
</figcaption>
</figure>
</div>
<p>To human eyes, <a href="#fig-robustness-adversarial" class="quarto-xref">Figure <span>11.2</span></a> is the same image as <a href="#fig-robustness-intro-example" class="quarto-xref">Figure <span>11.1</span></a>, but for the model, it is not. The model gets it all wrong now: the species, the count, and even the description. What has happened? The image is a so-called <em>adversarial example</em>. All current machine learning models, especially image classifiers, are susceptible to such well-engineered variations in the input that are imperceptible to the human eye but lead the prediction model astray. But Norouzzadeh et al. <span class="citation" data-cites="norouzzadeh2018automatically"><a href="references.html#ref-norouzzadeh2018automatically" role="doc-biblioref">[1]</a></span> didn’t do anything wrong. Quite the contrary! The paper is a role model for machine learning in science:</p>
<ul>
<li>They explain in detail how they deal with class imbalances in the data and target leaks (see <a href="generalization.html" class="quarto-xref"><span>Chapter 7</span></a>), which can occur because the camera sensors take three photos in succession.</li>
<li>They take into account label noise and conduct confidence thresholding (see <a href="uncertainty.html" class="quarto-xref"><span>Chapter 12</span></a>).</li>
<li>They report overall performance and class performance (see <a href="reporting.html" class="quarto-xref"><span>Chapter 14</span></a>) and provide usable open-source code (see <a href="reproducibility.html" class="quarto-xref"><span>Chapter 13</span></a>).</li>
</ul>
<p>Still, what should we make of the fact that machine learning models are not robust to adversarial examples?</p>
<p>Adversarial examples have kicked off the robustness debate in machine learning <span class="citation" data-cites="szegedy2013intriguing"><a href="references.html#ref-szegedy2013intriguing" role="doc-biblioref">[3]</a></span>, and we will explore their occurrence in some detail at the end of this chapter <a href="#sec-adversarials" class="quarto-xref"><span>Section 11.7</span></a>. But not any image would fool the animal classifier, the model performs quite well on real images taken in the wild.</p>
<p>We believe that scientists should not get sleepless nights from deceiving artificial input data that never occurs in practice. In science, there is usually no adversary that deceives your model – except perhaps Reviewer 2. As you will see in this chapter, there are many more profound robustness issues in machine learning that should worry you!</p>
<div class="raven-box">
<p>Machine learning not only found its way into science, but its products became global bestsellers. Krarah’s former Ph.D. students wanted to get their piece of the pie and turn the tornado prediction idea into a startup. But there was a problem. While the original model worked perfectly in their home territory, it was useless in other countries. They asked Rattle for a workshop to teach them about robust machine learning.</p>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="../Images/64baa97d2bd638bb96a8409a8b05c841.png" class="img-fluid quarto-figure quarto-figure-center figure-img" style="width:50.0%" data-original-src="https://ml-science-book.com/images/raven-robustness.jpg"/></p>
</figure>
</div>
</div>
<section id="what-does-robustness-mean" class="level2" data-number="11.1">
<h2 data-number="11.1" class="anchored" data-anchor-id="what-does-robustness-mean"><span class="header-section-number">11.1</span> What does robustness mean?</h2>
<p>In everyday language, robustness is a property of a single entity. A washing machine can be robust if it works for many years without trouble. A person can be robust if she can handle many situations competently. However, this leaves open what robustness is really about except for functioning well in general.</p>
<p>To detect robustness problems and solve them systematically, you need a language that allows you to operationalize <em>robustness</em> <span class="citation" data-cites="freiesleben2023beyond"><a href="references.html#ref-freiesleben2023beyond" role="doc-biblioref">[4]</a></span>:</p>
<ul>
<li><strong>Robustness target</strong> is the thing that should be robust. For example, you may be interested in how robust the performance of the animal classifier is.</li>
<li><strong>Robustness modifier</strong> is the thing with respect to which the robustness target should be robust. For example, this could be the images on which you apply your animal classifier.</li>
<li><strong>Modifier domain</strong> specifies the relevant changes in the modifier to which the target should be robust. For example, this could be changes in the background lighting of the images.</li>
<li><strong>Target tolerance</strong> specifies how much the target is allowed to change if the modifier changes within the modifier domain. For example, you might be fine if the model performance decreases a bit for images with a darker background as long as the performance does not drop drastically.</li>
</ul>
<p>So what does robustness mean?</p>
<blockquote class="blockquote">
<p><strong>Definition:</strong> A robustness target is robust with respect to a modifier if relevant interventions to the modifier within the domain do not lead to greater changes than specified by the target tolerance.</p>
</blockquote>
<p>We can now talk in a more nuanced way about robustness. For example, the wildlife image classifier performance (robustness target) is relatively robust to changes in the lighting conditions when taking the images (relevant interventions). However, it is less robust to targeted modifications (irrelevant interventions) on the input pixels. Ultimately, to judge whether your model is suitable for a specific application, you have to check if it is robust to relevant interventions on modifiers. This forces you to think about the changes you expect to occur in deployment!</p>
</section>
<section id="auditing-and-robustifying-strategies" class="level2" data-number="11.2">
<h2 data-number="11.2" class="anchored" data-anchor-id="auditing-and-robustifying-strategies"><span class="header-section-number">11.2</span> Auditing and robustifying strategies</h2>
<p>Broadly speaking, robustness researchers have to adopt two different perspectives:</p>
<ul>
<li><strong>Auditing:</strong> Is your model performance robust to relevant modifier changes? For example, you can check how the animal classifier performs when you darken the background of the test data.</li>
<li><strong>Robustifying strategies:</strong> What can you change in data collection and model selection to make your model more robust to relevant modifier changes? For example, if you train your model with more images taken at night, your model will generally perform better in this environment.</li>
</ul>
<p>Both aspects are interacting. You may audit the model and detect potential robustness weaknesses. To mitigate these weaknesses, you apply robustifying strategies. But what should you audit for?</p>
</section>
<section id="understand-data-distribution-shifts" class="level2" data-number="11.3">
<h2 data-number="11.3" class="anchored" data-anchor-id="understand-data-distribution-shifts"><span class="header-section-number">11.3</span> Understand data distribution shifts</h2>
<p>In practice, the most crucial modifier is the data. Your training data may stem from one source, but when you now deploy your model, the data may look entirely different. There are different <em>sources</em> of data distribution shifts:</p>
<ul>
<li><strong>Natural shifts</strong> occur because the natural conditions change. If you think of the animal classifier, you have to deal with:
<ul>
<li>varying weather or lighting conditions,</li>
<li>changes in the flora and fauna over time, or</li>
<li>new camera sensors placed at novel locations.</li>
</ul></li>
<li><strong>Performative shifts</strong> are induced by the model itself and its effects on the data. Imagine a model that predicts which diseases a person will develop based on their behavior. Provided with these predictions, the person may change her behavior and thus invalidate the prediction.</li>
<li><strong>Adversarial shifts</strong> occur due to attackers who modify the data. An example is given in <a href="#fig-robustness-adversarial" class="quarto-xref">Figure <span>11.2</span></a>.</li>
</ul>
<p>For natural scientists, the most important distribution shifts are natural distribution shifts, whereas social scientists must care just as much about performative shifts. Adversarial shifts are more of a problem in business or industry applications but less so in science.</p>
<div id="fig-robustness-different-conditions" class="quarto-float quarto-figure quarto-figure-center anchored">
<figure class="quarto-float quarto-float-fig figure">
<div aria-describedby="fig-robustness-different-conditions-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
<img src="../Images/3d6665fe6a243bcff7ebaab917cd3d1c.png" class="img-fluid figure-img" style="width:100.0%" data-original-src="https://ml-science-book.com/images/robustness_different_conditions.jpeg"/>
</div>
<figcaption class="quarto-float-caption-bottom quarto-float-caption quarto-float-fig" id="fig-robustness-different-conditions-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
Figure 11.3: The example shows different natural conditions under which the model is expected to perform well, such as pictures taken from afar, close, or at night. Used with permission from <span class="citation" data-cites="norouzzadeh2018automatically"><a href="references.html#ref-norouzzadeh2018automatically" role="doc-biblioref">[1]</a></span>.
</figcaption>
</figure>
</div>
<p>You can also distinguish different <em>types</em> of data distribution shifts. Data in supervised machine learning is described as pairs <span class="math inline">\((x^{(i)}, y^{(i)})_{i=1, \ldots, n}\)</span> sampled from an underlying distribution <span class="math inline">\(\mathbb{P}(X,Y)\)</span>, where <span class="math inline">\(X:=(X_1,\dots,X_p)\)</span> describes the input features and <span class="math inline">\(Y\)</span> the target variable. We can express the different types of data distribution shifts directly through the distributions of <span class="math inline">\(X\)</span> and <span class="math inline">\(Y\)</span>:</p>
<ul>
<li><strong>Covariate shift</strong> describes a case where the distribution <span class="math inline">\(\mathbb{P}(X)\)</span> has changed. In the example above, a covariate shift can occur if a camera was previously in the open sun but is now in the shade of a plant.</li>
<li><strong>Label shift</strong> describes a case where the distribution <span class="math inline">\(\mathbb{P}(Y)\)</span> has changed. The installation of a new camera in the previously ignored riverine forests in the Serengeti, for example, will lead to many more hippos being observed.</li>
<li><strong>Concept shift</strong> describes a case where the conditional distribution <span class="math inline">\(\mathbb{P}(Y\mid X)\)</span> has changed. In the example of wildlife, this can happen when there is a new categorization of species; previously there is only the gazelle category, but afterward it is subdivided into Grant’s gazelle, Thomson’s gazelle, and so on.</li>
</ul>
<p>Again, understanding what type of distribution shift you face can be vital for robustifying your model. But before we come to robustifying strategies, let’s first look into robustness audits.</p>
</section>
<section id="strategies-to-audit-for-robustness" class="level2" data-number="11.4">
<h2 data-number="11.4" class="anchored" data-anchor-id="strategies-to-audit-for-robustness"><span class="header-section-number">11.4</span> Strategies to audit for robustness</h2>
<p>Has the distribution shift already occurred? Or are you only anticipating a distribution shift? This determines which audit you can perform:</p>
<ul>
<li><strong>Post-hoc audit:</strong> The distribution shift has occurred already. You have collected new data after the shift and can evaluate the quality of your model on this data. In the wildlife example, you may have only trained your model with data from the dry season, and now, in the middle of the wet season, you want to evaluate the model’s performance.</li>
<li><strong>Anticipatory audit:</strong> The distribution shift has not yet occurred. So you have no data about the expected changes. For example, if you are in the dry season and want to predict how your model will work in the wet season.</li>
</ul>
<section id="post-hoc-audit" class="level3" data-number="11.4.1">
<h3 data-number="11.4.1" class="anchored" data-anchor-id="post-hoc-audit"><span class="header-section-number">11.4.1</span> Post-hoc audit</h3>
<p>A post-hoc audit is comparably simple – just analyze your model performance on your data. For example, you might want to compare the model performance between dry (pre-shift) and wet season data (post-shift).<a href="#fn1" class="footnote-ref" id="fnref1" role="doc-noteref"><sup>1</sup></a></p>
<p><strong>Understand whether and how the data differs</strong></p>
<p>But how can you even recognize that the distribution has shifted? You need to constantly monitor your data and check the data properties. For tabular data, there are a variety of summary statistics like the mean values, standard deviations, ranges, or correlation coefficients. The situation is similar for text, where you have word frequencies, word lengths, similarity of word embeddings, cosine similarity, or text sentiment. When these statistics start to vary, your distribution shift alarm bells should ring. For image data, we lack good summary statistics. Instead, eyeballing data samples through time taking into account domain knowledge can be more effective.</p>
<p>There are also modality-independent automated strategies for detecting data distribution shifts – called <em>out-of-distribution (OOD) detection</em> <span class="citation" data-cites="yang2021generalized"><a href="references.html#ref-yang2021generalized" role="doc-biblioref">[5]</a></span>. We discuss them below in <a href="#sec-OOD" class="quarto-xref"><span>Section 11.5.2</span></a>.</p>
<p><strong>Analyze the different errors</strong></p>
<p>Just as important as understanding the distribution shift itself is understanding how it affects model performance. Comparing performance before and after the shift is only the tip of the iceberg of a proper audit. False positive or false negative rates may also differ, and you could have contextual preferences for either bounding false positives or false negatives. Similarly, we recommend to group and compare errors across output classes.</p>
<p><strong>Interpretation methods can point to the sources of errors</strong></p>
<p>Interpretation methods (see <a href="interpretability.html" class="quarto-xref"><span>Chapter 9</span></a>) give you insight into the features on which the model relies upon and how these features impact model performance. Feature attribution techniques, for example, allow you to analyze the attention of image classifiers for specific predictions. You should be alerted if the model classifies Grant Gazelles by looking at the background rather than the animals <span class="citation" data-cites="ribeiroWhyShouldTrust2016"><a href="references.html#ref-ribeiroWhyShouldTrust2016" role="doc-biblioref">[6]</a></span>. If you deal with tabular data, you may compare global feature importances based on data before against after the distribution shift.</p>
</section>
<section id="anticipatory-audit" class="level3" data-number="11.4.2">
<h3 data-number="11.4.2" class="anchored" data-anchor-id="anticipatory-audit"><span class="header-section-number">11.4.2</span> Anticipatory audit</h3>
<p>An anticipatory robustness audit is more demanding than a post-hoc audit. The shift has not occurred yet – so you have no data from after the shift. You need to specify the shift qualitatively based on the sources and types of shifts above. To also quantify the effect of an anticipated shift on model performance, you additionally have to generate synthetic data that reflects the shift.</p>
<p><strong>Specify the shift qualitatively</strong></p>
<p>What shift do you expect, a natural or a performative shift? Is it a shift in covariates, in labels, or even in concepts? Be careful to specify the shift correctly. For example, auditing your model for adversarial robustness in a non-adversarial setting is pointless. Consult your domain knowledge! What aspects of your domain do you expect to vary and to which of the above types of shifts do they belong? Think back to our wildlife example: researchers are aware that there are relevant seasonal effects on the Serengeti environment and its wild inhabitants.</p>
<p><strong>Generate (semi-)synthetic data and systematically test your model on it</strong></p>
<p>To perform a quantitative audit, you need data that reflects the distribution shift. But because you don’t observe but only anticipate the shift, you have to generate data synthetically. You have to translate your qualitative knowledge about the shift into a way to generate data. We discuss various strategies to generate data below in <a href="#sec-dataAugmentation" class="quarto-xref"><span>Section 11.5.3</span></a>, for example, image filters allow you to turn day data into night data (see <a href="#fig-robustness-transformations" class="quarto-xref">Figure <span>11.4</span></a>).</p>
<p>Suppose you have created a synthetic dataset, does this mean you finally reached the point you start at in a post-hoc audit? Yes and no, there remain two big differences: 1. You already have a profound understanding of the data because you generated it. 2. The insights your synthetic data offer depend on your assumptions about the shift.</p>
<p><strong>Interpretation methods allow you to anticipate shifts</strong></p>
<p>Interpretation methods allow you to perform an audit without specifying the expected distribution shift or synthetic data. Instead, you simply analyze your pre-distribution shift data in a more explorative way, e.g. if feature attribution methods indicate that the model relies on background features like trees to classify an animal, this could mean that the model performs worse under varying background conditions. This alerts you to both the potentially dangerous distribution shift (changes in background) and the reason why your model is failing (reliance on background). Similarly, if a spurious feature has a large feature importance, your model may fail in settings where this feature varies; A COVID risk predictor trained in Munich that relies on street names is likely to fail in Paris. Finally, feature effect methods such as individual conditional effect curves (ICE) and counterfactual explanations describe model behavior in relevant counterfactual scenarios.</p>
<div class="callout callout-style-default callout-note callout-titled">
<div class="callout-header d-flex align-content-center">
<div class="callout-icon-container">
<i class="callout-icon"/>
</div>
<div class="callout-title-container flex-fill">
Context matters in robustness audits
</div>
</div>
<div class="callout-body-container callout-body">
<p>What you need to audit your model for, depends heavily on the application context. The wildlife model, which acts as a labeling tool, requires less extensive auditing than machine learning-based medical diagnosis. What audits are needed depends on the risks of errors, the instability of the environment, and other domain characteristics. For high-risk applications like in medicine, there are often additional legal requirements, such as those set out in European AI legislation and in medical device regulations.</p>
</div>
</div>
</section>
</section>
<section id="strategies-to-robustify-your-model" class="level2" data-number="11.5">
<h2 data-number="11.5" class="anchored" data-anchor-id="strategies-to-robustify-your-model"><span class="header-section-number">11.5</span> Strategies to robustify your model</h2>
<p>Say your audit has shown that your model is not robust to relevant distribution shifts. How can you robustify it? This is a list of common robustifying strategies, ordered by their position in the machine learning pipeline. Each of the strategies is discussed in more detail below:</p>
<ol type="1">
<li><strong>Control the source:</strong> Some shifts are under the control of the model authority. For example, the purchase of a new brand of camera sensor can lead to greater distribution shifts than sticking with the old brand.</li>
<li><strong>Filter out-of-distribution data:</strong> You could train a second model to filter out data that significantly differs from the training data. For example, the machine learning model should not provide predictions for animals that are not included in the training set, leaving these cases for human labelers.</li>
<li><strong>Gather data representative of the shift:</strong> You may gather additional (real or synthetic) data that accounts for the shift. For instance, one could use image filters to augment wet season data using dry season data.</li>
<li><strong>Carefully select and construct features:</strong> The lack of robustness in your model may be due to its reliance on incorrect features or improper feature encoding. For instance, by removing the image background, shifts in the background will no longer affect the model’s performance.</li>
<li><strong>Choose inductive biases wisely:</strong> Some shifts can be accounted for by adjusting your modeling assumptions (see <a href="domain.html" class="quarto-xref"><span>Chapter 8</span></a>). For counting animals, you may choose an architecture that generalizes to high animal counts like sequential subtizing <span class="citation" data-cites="chattopadhyay2017counting"><a href="references.html#ref-chattopadhyay2017counting" role="doc-biblioref">[7]</a></span>.</li>
<li><strong>Transfer learning to obtain robust representations:</strong> Often, your model is sensitive to distribution shifts because its learned representations overfit the training data. In such cases, <em>transfer learning</em> – reusing representations learned by other models trained on the same data modality – can help. Norouzzadeh et al. <span class="citation" data-cites="norouzzadeh2018automatically"><a href="references.html#ref-norouzzadeh2018automatically" role="doc-biblioref">[1]</a></span> demonstrate that transferring representations from common image classifiers increases the data efficiency of the wildlife classifier.</li>
</ol>
<p>The strategies you should choose to robustify your model should be informed by your audit. If you caused the distribution shift yourself, you might be able to control the shift. When your model performs poorly only on rare anomalies, filtering out these cases might be the best approach. If the distribution shift is unavoidable and causes a significant performance drop, the most common strategy is to augment your data and retrain the model. If the distribution shift is unavoidable but data augmentation is difficult, you may need to engineer features, adjust the modeling assumptions, or use transfer learning.</p>
<section id="control-the-source" class="level3" data-number="11.5.1">
<h3 data-number="11.5.1" class="anchored" data-anchor-id="control-the-source"><span class="header-section-number">11.5.1</span> Control the source</h3>
<p>It is usually not like distribution shifts are just happening and there is nothing you can do about them. You often have an active role – you caused the distribution shift by an action. You installed a camera sensor from a different brand and suddenly the performance drops? You put food next to the camera to spot more animals and suddenly your animal count bound reaches its limits? In some cases, rather than adapting the data or the model, it can be smarter to tackle the very source of the shift. You must enact control to guarantee a stable environment, e.g. by using only cameras from the same brand.</p>
<p>But not all distribution shifts are within your control. You cannot keep the Serengeti in the wet season all year. Other sources you can control but not without unwanted side effects: You can create stable lighting conditions around the camera, but this can attract or repel certain animals.</p>
</section>
<section id="sec-OOD" class="level3" data-number="11.5.2">
<h3 data-number="11.5.2" class="anchored" data-anchor-id="sec-OOD"><span class="header-section-number">11.5.2</span> Filter out-of-distribution data</h3>
<p>There will always be data that presents a challenge for your model. Especially data that is very different from the training data. Out-of-distribution (OOD) detectors enable you to filter out data on which your model would perform substantially worse. These data can then be handled separately, e.g. by a human labeler. Thereby, OOD detection robustifies overall performance in deployment. However, OOD detectors only act as filters; they do not help with substantial distribution shifts.</p>
<p>How to find out if a data point is OOD? With OOD detectors! Sometimes people further differentiate between methods designed to detect <em>anomalies</em> (rare data from different distributions), <em>novelties</em> (data from a shifting distribution), or <em>outliers</em> (rare data within training distribution) <span class="citation" data-cites="ruff2021unifying yang2021generalized"><a href="references.html#ref-yang2021generalized" role="doc-biblioref">[5]</a>, <a href="references.html#ref-ruff2021unifying" role="doc-biblioref">[8]</a></span>. Here, we focus on OOD detection more generally. There are four different approaches <span class="citation" data-cites="yang2021generalized"><a href="references.html#ref-yang2021generalized" role="doc-biblioref">[5]</a></span>:</p>
<ul>
<li><strong>Classification-based methods</strong> phrase OOD detection as a classification problem. Some classification-based methods require data labeled as within and outside of the distribution. Others leverage uncertainty-aware classifiers and label data with high classification uncertainty as OOD.</li>
<li><strong>Density-based methods</strong> model explicitly the probability density of the training data. Data whose density lies below a certain threshold is labeled as OOD.</li>
<li><strong>Distance-based methods</strong> calculate the difference of a given data point to the centroid or prototypes in a dataset. Data whose distance surpasses a certain threshold is labeled OOD.</li>
<li><strong>Reconstruction-based methods</strong> use autoencoder methods to detect OOD data. Data with higher reconstruction error are labeled as OOD.</li>
</ul>
<p>To get an overview of all the different types of OOD detectors check out the review papers by <span class="citation" data-cites="ruff2021unifying"><a href="references.html#ref-ruff2021unifying" role="doc-biblioref">[8]</a></span>, <span class="citation" data-cites="yang2021generalized"><a href="references.html#ref-yang2021generalized" role="doc-biblioref">[5]</a></span>, and <span class="citation" data-cites="chalapathy2019deep"><a href="references.html#ref-chalapathy2019deep" role="doc-biblioref">[9]</a></span>.</p>
<p>Reconstruction-based techniques have advantages over the other approaches: Unlike classification-based methods, you do not need to label data as (non) OOD; Unlike density-based methods, you do not need to specify a model of the probability density; And unlike distance-based methods, you do not need to construct complex reference points such as centroids or prototypes. Let’s therefore take a deeper look into reconstruction-based OOD detectors.</p>
<div class="callout callout-style-default callout-note callout-titled">
<div class="callout-header d-flex align-content-center">
<div class="callout-icon-container">
<i class="callout-icon"/>
</div>
<div class="callout-title-container flex-fill">
Autoencoders
</div>
</div>
<div class="callout-body-container callout-body">
<p>Autoencoders describe a neural-network-based method to project high-dimensional inputs into a low-dimensional feature space (often called <em>latent space</em>) with a minimal loss of information. This is achieved through a two-stage architecture:</p>
<ol type="1">
<li><strong>Encoder:</strong> Projects the high-dimensional input into a prespecified low-dimensional latent space.</li>
<li><strong>Decoder:</strong> Maps the projected inputs from the latent space back to the original space.</li>
</ol>
<p>The encoder and decoder mappings are optimized to minimize the reconstruction error of the training data. The reconstruction error of a given input describes the difference (according to some metric) between this input and the output we obtain after sequentially encoding and decoding the input. In our example, this would mean calculating the mean squared error between the initial Impala image and its reconstructed version that runs through the encoder and decoder network.</p>
<div id="ae" class="quarto-figure quarto-figure-center anchored">
<figure class="figure">
<p><img src="../Images/da0e25f5416912eefc3fd9ae45688129.png" class="img-fluid figure-img" data-original-src="https://ml-science-book.com/images/ae.jpg"/></p>
<figcaption>Structure of an autoencoder. Figure created by combining elements from <span class="citation" data-cites="neupert2021introduction"><a href="references.html#ref-neupert2021introduction" role="doc-biblioref">[10]</a></span> and <span class="citation" data-cites="norouzzadeh2018automatically"><a href="references.html#ref-norouzzadeh2018automatically" role="doc-biblioref">[1]</a></span> (used with permission). All rights reserved.</figcaption>
</figure>
</div>
</div>
</div>
<p><strong>Out-of-distribution detection with autoencoders</strong></p>
<p>Say <span class="math inline">\(x\)</span> is the data point you want to classify as within or outside of the training distribution. Then the encoder network can be described as a mapping <span class="math inline">\(E:\mathbb{R}^h\rightarrow \mathbb{R}^l\)</span> from a high-dimensional feature space <span class="math inline">\(\mathbb{R}^h\)</span> to a low dimensional latent space <span class="math inline">\(\mathbb{R}^l\)</span>. Similarly, the decoder network is a mapping <span class="math inline">\(D:\mathbb{R}^l\rightarrow \mathbb{R}^h\)</span> and <span class="math inline">\(L\)</span> is a distance function on the input space <span class="math inline">\(\mathbb{R}^h\)</span> (e.g. mean squared error). Then, the <em>reconstruction error</em> of <span class="math inline">\(x\)</span> is defined as: <span class="math display">\[\text{RE}(x):=L(x,E(D(x))).\]</span> This allows us to define a simple OOD detector: <span class="math display">\[\text{OOD}(x):=\begin{cases}
\text{OOD}\quad\quad \text{if RE}(x)&gt;\tau \\
\text{not OOD}\quad \text{else}
\end{cases}\]</span> Intuitively, any data with a reconstruction error above a certain threshold <span class="math inline">\(\tau\)</span> counts as OOD. This primitive approach faces clear limitations:</p>
<ul>
<li>Also OOD data can have low reconstruction error. By extending the reconstruction error with the Mahalanobis Distance on the latent space, this problem can be tackled <span class="citation" data-cites="denouden2018improving"><a href="references.html#ref-denouden2018improving" role="doc-biblioref">[11]</a></span>.</li>
<li>Training autoencoders is hard, you have to make architectural choices based on domain knowledge (e.g. CNN for images), define an appropriate latent space (i.e. just the right size to capture the training distribution without information loss), and choose an appropriate loss function <span class="citation" data-cites="ruff2021unifying"><a href="references.html#ref-ruff2021unifying" role="doc-biblioref">[8]</a></span>.</li>
<li>Training autoencoders requires representative training data <span class="citation" data-cites="chalapathy2019deep"><a href="references.html#ref-chalapathy2019deep" role="doc-biblioref">[9]</a></span>, but in practice, the data is often unbalanced.</li>
</ul>
</section>
<section id="sec-dataAugmentation" class="level3" data-number="11.5.3">
<h3 data-number="11.5.3" class="anchored" data-anchor-id="sec-dataAugmentation"><span class="header-section-number">11.5.3</span> Gather data representative of the shift</h3>
<p>Why are distribution shifts a problem for machine learning models? In the case of a covariate shift (i.e. shift of <span class="math inline">\(\mathbb{P}(X)\)</span>) or a label shift (i.e. shift of <span class="math inline">\(\mathbb{P}(Y)\)</span>), your model fails because it has never seen this kind of data and is unable to extrapolate. In the case of a concept shift (i.e. shift in <span class="math inline">\(\mathbb{P}(Y\mid X)\)</span>), your model may have faced similar inputs but the learned dependencies became unreliable.</p>
<p>In any case, the most prominent solution in the research literature for how to robustify your model to such shifts is the same – gather more data that reflects the distribution shift! There are two strategies to obtain such data:</p>
<ul>
<li><strong>Gather real labeled data with active learning:</strong> You may want real labeled data. Active learning concerns the systematic search for data worth labeling.</li>
<li><strong>Augment your data:</strong> Gathering real data comes with high costs and you have limited control over which kind of data you get. Data augmentation is concerned with generating synthetic instances using domain knowledge.</li>
</ul>
<p><strong>Active learning</strong></p>
<p>Which data should you label to robustify your model? Labeling all data is often too expensive and time-consuming. The literature differentiates three active learning setups, based on how the labeler receives the data <span class="citation" data-cites="settles.tr09"><a href="references.html#ref-settles.tr09" role="doc-biblioref">[12]</a></span>:</p>
<ol type="1">
<li>In <em>membership query synthesis</em> any input in the input space is a potential candidate for labeling, even completely unrealistic inputs.</li>
<li>In <em>stream-based sampling</em> you receive data sequentially and have to decide whether to label this data.</li>
<li>In <em>pool-based sampling</em> you receive a big data sample and have to choose a subsample that you want to label.</li>
</ol>
<div id="active-learning" class="quarto-figure quarto-figure-center anchored">
<figure class="figure">
<p><img src="../Images/760cffebbce0f279d3e14b0555311595.png" class="img-fluid figure-img" data-original-src="https://ml-science-book.com/images/activeLearning.jpg"/></p>
<figcaption>The three main active learning setups. Based on concepts presented in <span class="citation" data-cites="settles.tr09"><a href="references.html#ref-settles.tr09" role="doc-biblioref">[12]</a></span>. CC-BY(https://creativecommons.org/licenses/by/4.0/)</figcaption>
</figure>
</div>
<p>Active learning is largely concerned with the automation of the selection process for labeling <span class="citation" data-cites="settles.tr09 ren2021survey"><a href="references.html#ref-settles.tr09" role="doc-biblioref">[12]</a>, <a href="references.html#ref-ren2021survey" role="doc-biblioref">[13]</a></span>. The data selection process can be based on high prediction uncertainty, proximity to the decision boundary, randomness, expected model error, expected training effect, or data representativeness. In the example, Norouzzadeh et al. <span class="citation" data-cites="norouzzadeh2018automatically"><a href="references.html#ref-norouzzadeh2018automatically" role="doc-biblioref">[1]</a></span> suggest labeling those wildlife images with the highest prediction uncertainty. Note that all these different active learning strategies are readily available in recent Python packages like modAL <span class="citation" data-cites="danka2018modal"><a href="references.html#ref-danka2018modal" role="doc-biblioref">[14]</a></span> and ALiPy <span class="citation" data-cites="tang2019alipy"><a href="references.html#ref-tang2019alipy" role="doc-biblioref">[15]</a></span>.</p>
<p>You may also have intuitions about what data to track and label. Incorporating such knowledge <span class="citation" data-cites="ciravegna2023knowledge"><a href="references.html#ref-ciravegna2023knowledge" role="doc-biblioref">[16]</a></span> and interacting with the model through interpretability techniques <span class="citation" data-cites="ghai2021explainable"><a href="references.html#ref-ghai2021explainable" role="doc-biblioref">[17]</a></span> can significantly improve active learning strategies.</p>
<p><strong>Data augmentation</strong></p>
<p>Data augmentation is about creating synthetic data. Wait, don’t you also need active learning to label these data? In some cases yes, namely if you want to find the label for an arbitrary input. However, when we talk about data augmentation, we usually create data for which we know the label. Data augmentation has been particularly the focus in computer vision <span class="citation" data-cites="mumuni2022data shorten2019survey"><a href="references.html#ref-mumuni2022data" role="doc-biblioref">[18]</a>, <a href="references.html#ref-shorten2019survey" role="doc-biblioref">[19]</a></span>, but recently there is growing literature on data augmentation in the context of natural language processing <span class="citation" data-cites="feng2021survey"><a href="references.html#ref-feng2021survey" role="doc-biblioref">[20]</a></span>.</p>
<p>There are two general strategies to augment your data <span class="citation" data-cites="mumuni2022data"><a href="references.html#ref-mumuni2022data" role="doc-biblioref">[18]</a></span>:</p>
<ul>
<li><strong>Data transformation:</strong> Transformations applied to labeled data that are known not to change the label. Selecting the right transformations is an excellent way to incorporate domain knowledge. Focus on transformations you expect to occur in practice.</li>
<li><strong>Data synthesis:</strong> Creation of entirely new data with known labels. Data synthesis may be based on generative models or Computer Aided Design (CAD) models. The aim is to generate synthetic data that shares important properties with your training data but varies from it in relevant aspects.</li>
</ul>
<p>In computer vision, there are geometric transformations (changing the angle, position, direction, or size of an image) and photometric transformations (changing attributes like coloring, saturation, contrast, or camera artifacts). Some transformations concern the overall image, while others only concern one region. Transformations may delete, replace, swap, or recombine regions of the image.</p>
<div id="fig-robustness-transformations" class="quarto-float quarto-figure quarto-figure-center anchored">
<figure class="quarto-float quarto-float-fig figure">
<div aria-describedby="fig-robustness-transformations-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
<img src="../Images/38e96c92a85f90cbf15ed10fb97341c6.png" class="img-fluid figure-img" data-original-src="https://ml-science-book.com/images/robustness_transformations.jpg"/>
</div>
<figcaption class="quarto-float-caption-bottom quarto-float-caption quarto-float-fig" id="fig-robustness-transformations-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
Figure 11.4: Impala image (left) with different relevant transformations applied: simple rotation, background from day to night, and artsy filter. Simple rotations can be implemented by hand, whereas complex filters often rely on generative models. Figure modified with permission from <span class="citation" data-cites="norouzzadeh2018automatically"><a href="references.html#ref-norouzzadeh2018automatically" role="doc-biblioref">[1]</a></span>.
</figcaption>
</figure>
</div>
<p>In natural language tasks, it is common to randomly insert, delete, or swap words in a sentence or to substitute words in sentences with their synonyms. If you have a trained language model, also more sophisticated transformations can be performed, such as: back translation, where sentences are translated back and forth between two languages; text paraphrasing, where the same content is rephrased without changing the meaning; and style transformations, where the same content is described in different styles (e.g. more formal vs less formal language).</p>
<p>Data synthesis is more challenging. Computer-aided design (CAD) allows you to model physical objects by hand and perform various geometric and photometric transformations in a physically adequate way. Neural rendering learns 3D scene representations from 2D images and thereby avoids hand-crafted CAD modeling. The most common approach to data synthesis in computer vision is using generative models like generative adversarial networks (GANs) or variational autoencoders (VAEs). The models generate realistic images that can be sampled conditionally on a desired target class. In natural language processing, the best generator models are large language models like ChatGPT or LLaMA, which can be prompted to generate data with a certain content.</p>
<div class="callout callout-style-default callout-note callout-titled">
<div class="callout-header d-flex align-content-center">
<div class="callout-icon-container">
<i class="callout-icon"/>
</div>
<div class="callout-title-container flex-fill">
Generative adversarial network (GAN)
</div>
</div>
<div class="callout-body-container callout-body">
<p>A GAN is a generative model that allows the generation of highly realistic data <span class="citation" data-cites="goodfellow2014generative"><a href="references.html#ref-goodfellow2014generative" role="doc-biblioref">[21]</a></span>. It is trained using two sub-models:</p>
<ul>
<li><strong>Generator:</strong> This neural network model is designed to generate data. It takes random noise from a (Gaussian) distribution as inputs and ideally transforms the noise into realistic data.</li>
<li><strong>Discriminator:</strong> This network is designed to distinguish real from artificial data. It takes inputs and decides whether they are real data or synthetic data.</li>
</ul>
<p>The two sub-models are trained iteratively in a zero-sum game against each other. The generator aims to generate data that the discriminator mistakes for real data. The discriminator aims at perfectly separating real from synthetic data. In the course of the training, both models get better and better at their tasks, which ultimately leads to a well-performing generator model.</p>
<div id="GAN" class="quarto-figure quarto-figure-center anchored">
<figure class="figure">
<p><img src="../Images/a48598fc40a4dfb34451ab6bf5fcb962.png" class="img-fluid figure-img" data-original-src="https://ml-science-book.com/images/robustness_GAN.jpg"/></p>
<figcaption>Structure of a GAN. Figure from <a href="https://developers.google.com/machine-learning/gan/gan_structure?hl=de">Google</a>, CC-BY (https://creativecommons.org/licenses/by/4.0/)</figcaption>
</figure>
</div>
</div>
</div>
<p>The divide between data transformations and synthesis is less straightforward than what we suggested above. Relevant transformations often go beyond simple geometric or photometric transformations. Think of changing the entire background or adding other animals to the Serengeti images. Complex transformations often demand data synthesis methods. For example, data augmentation GANs <span class="citation" data-cites="antoniou2017data"><a href="references.html#ref-antoniou2017data" role="doc-biblioref">[22]</a></span> and conditional GANs <span class="citation" data-cites="isola2017image"><a href="references.html#ref-isola2017image" role="doc-biblioref">[23]</a></span> allow the generation of new instances conditioned on a given data instance.</p>
<p>Common packages to perform data augmentation in Python are the Augmentor package for computer vision <span class="citation" data-cites="bloice2017augmentor"><a href="references.html#ref-bloice2017augmentor" role="doc-biblioref">[24]</a></span>, ImageDataGenerator in Keras, and the natural language toolkit (NLTK) for natural language processing <span class="citation" data-cites="bird2006nltk"><a href="references.html#ref-bird2006nltk" role="doc-biblioref">[25]</a></span>.</p>
<p><strong>What happens after you obtain the data?</strong></p>
<p>Let’s say you have gathered the required data. What should you do? You could <em>retrain</em> the entire model: merge the newly collected data with your training data and run again your machine learning algorithm. Another strategy is to <em>fine-tune</em> your existing machine learning model by training it on the new data you collected. Indeed, fine-tuning sounds like less work than retraining but dependent on the fine-tuning specifics it often introduces a bias either towards the training data or the new data. Instead of retraining and fine-tuning, you may decide to train a new <em>separate model</em> exclusively on the newly collected data.</p>
<p>If you face a covariate or a label shift, retraining and fine-tuning are both reasonable strategies. Old and new data can be merged in one model as the predictive pattern between the two stays intact. Fine-tuning is particularly advisable if you gain a few high-quality data with active learning and you want to emphasize this data in training. In a concept shift, on the other hand, the predictive pattern between old and new data differs – training a separate model is the only option.</p>
<p><strong>Does data augmentation really improve robustness?</strong></p>
<p>This question is difficult to assess in general as it depends on the domain and the data augmentation approach. It is a mantra in machine learning that more data is always better. But what if the data is synthetic? In many settings, data augmentation indeed effectively improves robustness <span class="citation" data-cites="hendrycks2021many mumuni2022data"><a href="references.html#ref-mumuni2022data" role="doc-biblioref">[18]</a>, <a href="references.html#ref-hendrycks2021many" role="doc-biblioref">[26]</a></span>. However, in some cases, (adversarial) robustness conflicts with predictive performance on the original dataset <span class="citation" data-cites="tsipras2018robustness"><a href="references.html#ref-tsipras2018robustness" role="doc-biblioref">[27]</a></span>. This is unsurprising: robustness means insensitivity to certain features, and insensitivity to predictive features leads to a performance drop. Whether you have to trade off (adversarial) robustness and performance depends on the data augmentation approach <span class="citation" data-cites="rebuffi2021data"><a href="references.html#ref-rebuffi2021data" role="doc-biblioref">[28]</a></span>. Interestingly, training your model exclusively on synthetic data may turn your model mad <span class="citation" data-cites="alemohammad2023self"><a href="references.html#ref-alemohammad2023self" role="doc-biblioref">[29]</a></span>.</p>
</section>
<section id="carefully-select-and-construct-features" class="level3" data-number="11.5.4">
<h3 data-number="11.5.4" class="anchored" data-anchor-id="carefully-select-and-construct-features"><span class="header-section-number">11.5.4</span> Carefully select and construct features</h3>
<p>As we discussed in <a href="supervised-ml.html" class="quarto-xref"><span>Chapter 2</span></a>, the input features and the target feature are key modeling choices that every modeler faces. Achieving a robust model with unreliable features can be impossible. Imagine having to predict an animal’s species only on the background against which it was sighted. The slightest distribution shift will diminish model performance. Similarly, if you are forced to predict a specific species but 75% of the data contains no animals <span class="citation" data-cites="norouzzadeh2018automatically"><a href="references.html#ref-norouzzadeh2018automatically" role="doc-biblioref">[1]</a></span>, your model is doomed to fail from the start!</p>
<p>Choosing reasonable input and target features is challenging and requires (causal) domain knowledge (see <a href="domain.html" class="quarto-xref"><span>Chapter 8</span></a> and <a href="causality.html" class="quarto-xref"><span>Chapter 10</span></a>). There exist various approaches to obtain better input features to robustify your models:</p>
<ul>
<li><strong>Feature selection</strong> describes approaches to select an optimal subset of features from a feature set <span class="citation" data-cites="chandrashekar2014survey"><a href="references.html#ref-chandrashekar2014survey" role="doc-biblioref">[30]</a></span>. The subset is chosen based on criteria like the (conditional) mutual information between input and target, or the performance of a trained classifier on the subset of input features (see e.g. conditional feature importance in <a href="interpretability.html" class="quarto-xref"><span>Chapter 9</span></a>). Feature selection reduces the dimensionality of the data and filters unreliable or noisy features, thereby improving robustness. Feature selection algorithms are often tailored to tabular data but are less useful for image, text, or speech data.</li>
<li><strong>Feature engineering</strong> describes approaches that transform the input features. One option is to apply hand-crafted transformations, which:
<ul>
<li>describe statistical properties, e.g. interaction terms,</li>
<li>encode domain knowledge, e.g. graph structure in graph neural networks,</li>
<li>have physical meaning, e.g. edge detectors,</li>
<li>reduce dimensionality, e.g. linear regression with L1 loss,</li>
<li>provide useful encodings, e.g. bucketing or one-hot-encoding, or</li>
<li>emphasize particularly important features, e.g. time.</li>
</ul>
Alternatively one can <em>learn</em> transformations that lead to features with desired properties, for example, smoothness, sparsity, or task generality. These so-called <em>representation learning</em> approaches often lead to increased robustness under distribution shifts <span class="citation" data-cites="bengio2013representation"><a href="references.html#ref-bengio2013representation" role="doc-biblioref">[31]</a></span>.</li>
</ul>
<p>Also, the target encoding can be improved. Norouzzadeh et al. <span class="citation" data-cites="norouzzadeh2018automatically"><a href="references.html#ref-norouzzadeh2018automatically" role="doc-biblioref">[1]</a></span>, for example, dissect their prediction target into two parts: In Task 1, a model discriminates between inputs with and without animals; In Task 2, a second model classifies the images that contain animals into different species. This dissection in two tasks substantially improves the classifier’s robustness. Similarly, target features often come in a hierarchical form <span class="citation" data-cites="vens2008decision"><a href="references.html#ref-vens2008decision" role="doc-biblioref">[32]</a></span>: the Thompson Gazelle and the Grant Gazelle are different subspecies of Gazelles. Such additional structure can be encoded into hierarchical multi-label encodings like decision trees and thereby improve the robustness of the classifier.</p>
</section>
<section id="choose-inductive-biases-wisely" class="level3" data-number="11.5.5">
<h3 data-number="11.5.5" class="anchored" data-anchor-id="choose-inductive-biases-wisely"><span class="header-section-number">11.5.5</span> Choose inductive biases wisely</h3>
<p>The relationship between modeling choices and predictive performance has already been discussed extensively in <a href="generalization.html" class="quarto-xref"><span>Chapter 7</span></a> and <a href="domain.html" class="quarto-xref"><span>Chapter 8</span></a>. The key insight was – the better suited the inductive bias (e.g. model class, architecture, hyperparameters, loss, etc.), the faster you will learn a high-performing model. Data distribution shifts are nothing but learning environments. Modeling choices, therefore, provide another robustifying strategy. For example:</p>
<ul>
<li>CNNs are translational invariant. The position of the animal in the image does not affect model performance.</li>
<li>Dropout improves the robustness to adversarial attacks by switching off certain neurons in training <span class="citation" data-cites="wang2018defensive"><a href="references.html#ref-wang2018defensive" role="doc-biblioref">[33]</a></span>. The reason is that dropout enforces smoother representations in the latent space.</li>
</ul>
<p>Improving robustness to distribution shifts with data augmentation and with inductive modeling biases are two sides of the same coin. The former turns knowledge about (anticipated) distribution shifts into data instances; The latter turns knowledge about (anticipated) distribution shifts into modeling assumptions. CNNs are only one example where this parallelism is evident, many similar architectural solutions encode rotation and scaling invariance <span class="citation" data-cites="mumuni2021cnn"><a href="references.html#ref-mumuni2021cnn" role="doc-biblioref">[34]</a></span>. Similarly, graph neural networks allow encoding all forms of domain knowledge into the graph structure and node/edge properties <span class="citation" data-cites="corso2024graph wu2020comprehensive battaglia2018relational"><a href="references.html#ref-corso2024graph" role="doc-biblioref">[35]</a>, <a href="references.html#ref-wu2020comprehensive" role="doc-biblioref">[36]</a>, <a href="references.html#ref-battaglia2018relational" role="doc-biblioref">[37]</a></span>.</p>
<p>Is it better to apply data transformations or to encode invariances into the inductive modeling assumptions? On the one hand side, some data transformations are difficult to encode as inductive biases into the model. Think about dry versus wet season data, there is no easy way to encode an invariance to seasonal changes. On the other hand, if it is possible to encode invariances as inductive biases, you should. Your model is guaranteed to obey them, whereas data augmentation only makes it more likely that the model learns invariances. Furthermore, there is a computational trade-off: more data requires more compute, whereas better inductive biases usually improve computational efficiency.</p>
</section>
<section id="transfer-learning-to-obtain-robust-representations" class="level3" data-number="11.5.6">
<h3 data-number="11.5.6" class="anchored" data-anchor-id="transfer-learning-to-obtain-robust-representations"><span class="header-section-number">11.5.6</span> Transfer learning to obtain robust representations</h3>
<p>Transfer learning is about transferring knowledge from one task to another. So learning a task does not have to be done from scratch but can build upon existing knowledge. While tasks often differ substantially, they share certain aspects. For example, classifying pets and wildlife animals both require learning higher-order representations that allow us to differentiate animals, even though the animals, their actions, and image backgrounds differ. By inducing more domain-general knowledge, transfer learning makes the model more robust to common distribution shifts. We distinguish different kinds of transfer learning according to the knowledge they transfer:</p>
<ul>
<li><strong>Feature extraction</strong> builds on the representations learned in one task to reuse them in another task. For example, say you have a general image classifier like ResNet or Inception V3 that has been trained on a huge dataset like ImageNET. Then, there are representations stored in the neural network’s weights, activations, and nodes, which can be reused to make the wildlife classifier robust against common image permutations. Commonly used feature extraction methods focus on the penultimate layer before the final prediction. Feature extraction is the most popular transfer learning technique and has also been used by Norouzzadeh et al. <span class="citation" data-cites="norouzzadeh2018automatically"><a href="references.html#ref-norouzzadeh2018automatically" role="doc-biblioref">[1]</a></span> leading to better data efficiency.</li>
<li><strong>Fine-tuning</strong> uses the learned specifics of a model trained for one task as the starting point for another task. One may, for example, take the trained ResNet classifier, substitute the output layer, and train the model on the wildlife images. Unlike in feature extraction, the model can adapt the representations learned by ResNet on ImageNet and tailor them for the wildlife case. This was again performed by <span class="citation" data-cites="norouzzadeh2018automatically"><a href="references.html#ref-norouzzadeh2018automatically" role="doc-biblioref">[1]</a></span>, however, without improving overall performance significantly.</li>
<li><strong>Multi-task learning</strong> concerns training a single core model that is used to perform multiple related tasks simultaneously. The idea is to enforce the core model to learn representations that are useful across different tasks, leading to improved representations and better robustness to common changes. One could, for example, use the same core model to classify trees, and wildlife animals, and predict daytime. By optimizing for such a diverse set of tasks, the core model has to learn representations that work on all of them.</li>
<li><strong>Self-supervised learning</strong> can be seen as one specific approach to learning a core model that is useful across a variety of tasks. It masks certain parts of the data and tries to infer them from the rest of the data. Thereby, self-supervision learns generalizing pattern. One could, for example, mask the animal’s heads to learn interdependencies between animal heads and their bodies.</li>
</ul>
<p>Transfer learning can be key if data is scarce for the specific task at hand but widely available for related tasks. More and more there are core models for all data modalities like ChatGPT for text data or ResNet for image data. Based on vast amounts of data, these core models have learned such powerful representations that they make the models robust to a wide range of standard distribution shifts. We believe that in future scientific applications, transfer learning from core models may play an essential role. The amount of data and knowledge that entered these models should not go unused.</p>
</section>
</section>
<section id="generalization-and-causality-are-linked-to-robustness" class="level2" data-number="11.6">
<h2 data-number="11.6" class="anchored" data-anchor-id="generalization-and-causality-are-linked-to-robustness"><span class="header-section-number">11.6</span> Generalization and causality are linked to robustness</h2>
<p>Remember the three different kinds of generalization that we discussed in <a href="generalization.html" class="quarto-xref"><span>Chapter 7</span></a>? Generalization to predict in theory, generalization to predict in practice, and generalization to the phenomenon. Generalization to predict in theory concerns prediction for a static data distribution, indeed a natural requirement on machine learning models. Robustness usually goes one step further: the machine learning model should perform well in all practically relevant scenarios. That means the performance of the model should be robust under expected data distribution shifts. Generalization to predict in practice and robustness therefore often means the same thing – the model should work under natural conditions.</p>
<p>Causality is about generalization to the phenomenon at hand. You want an accurate representation of the data-generating process. This constitutes a link between robustness to causality. Why? If you have an accurate representation of the phenomenon, then you can simulate all kinds of alternative scenarios and provide predictions under all kinds of distribution shifts:</p>
<ul>
<li><strong>You know what led to the distribution shift?</strong> Then you can simulate the shift using your causal model and still provide optimal predictions with your causal model <span class="citation" data-cites="arjovsky2019invariant kamath2021does"><a href="references.html#ref-arjovsky2019invariant" role="doc-biblioref">[38]</a>, <a href="references.html#ref-kamath2021does" role="doc-biblioref">[39]</a></span>. Even your initial machine learning prediction model may perform robustly under certain shifts <span class="citation" data-cites="konig2023improvement"><a href="references.html#ref-konig2023improvement" role="doc-biblioref">[40]</a></span>.</li>
<li><strong>You do not know what led to the distribution shift?</strong> Say you only receive data indicative of the shift. Then, causal models allow to generate data for various possible shifts and compare them to the observed data <span class="citation" data-cites="cranmer2020frontier"><a href="references.html#ref-cranmer2020frontier" role="doc-biblioref">[41]</a></span>.</li>
</ul>
<p>Even beyond these cases, causal models have an essential property that makes them appealing for machine learning robustness research – causal models are modular. Say you train a machine learning model to learn the joint distribution of two variables <span class="math inline">\(A\)</span> and <span class="math inline">\(B\)</span>, namely <span class="math inline">\(\mathbb{P}(A,B)\)</span>. Then, as soon as your distribution of <span class="math inline">\(A\)</span> or of <span class="math inline">\(B\)</span> changes, you have to learn an entirely new model.</p>
<p>Instead, assume you know that <span class="math inline">\(A\)</span> causes <span class="math inline">\(B\)</span>. Then you can split your learning task into two components, namely <span class="math inline">\(\mathbb{P}(B\mid A)\)</span> and <span class="math inline">\(\mathbb{P}(A)\)</span>. This provides you again with the joint distribution because <span class="math display">\[\mathbb{P}(A,B)=\mathbb{P}(A)\mathbb{P}(B\mid A).\]</span> But now if <span class="math inline">\(\mathbb{P}(A)\)</span> shifts, all you need to update is your model of <span class="math inline">\(\mathbb{P}(A)\)</span>, whereas <span class="math inline">\(\mathbb{P}(B\mid A)\)</span> must remain stable because it is a causal mechanistic relationship (see <a href="causality.html" class="quarto-xref"><span>Chapter 10</span></a>). This modularity makes causal relations worth learning!</p>
</section>
<section id="sec-adversarials" class="level2" data-number="11.7">
<h2 data-number="11.7" class="anchored" data-anchor-id="sec-adversarials"><span class="header-section-number">11.7</span> The riddle of adversarial examples</h2>
<p>Why does a model that is as good as in <span class="citation" data-cites="norouzzadeh2018automatically"><a href="references.html#ref-norouzzadeh2018automatically" role="doc-biblioref">[1]</a></span> make mistakes like in <a href="#fig-robustness-adversarial" class="quarto-xref">Figure <span>11.2</span></a>? Behind this question lies the riddle of adversarial examples. Adversarial examples are inputs that are modified in a way that makes them humanly indistinguishable from the original input but entirely shifts the model’s prediction, leading to misclassification. The reasons for this behavior are still only partially understood.</p>
<p>The first hypothesis was that adversarial examples describe unlikely instances that are not well represented in the original training data <span class="citation" data-cites="szegedy2013intriguing"><a href="references.html#ref-szegedy2013intriguing" role="doc-biblioref">[3]</a></span>. However, if this were true, adding adversarials to the training data should get rid of the problem – but it didn’t <span class="citation" data-cites="zhang2019limitations"><a href="references.html#ref-zhang2019limitations" role="doc-biblioref">[42]</a></span>. Even if you train your model on a wide variety of adversarial examples there will still be new adversarial examples in the direct vicinity. Famously, Goodfellow et al. <span class="citation" data-cites="goodfellow2014explaining"><a href="references.html#ref-goodfellow2014explaining" role="doc-biblioref">[43]</a></span> came up with a new proposal. They suggest that adversarials arise in machine learning models because the models are too linear. Most machine learning models are still based on relatively linear activation functions like Rectified Linear Units (ReLUs). Thus, changing the input up to a certain norm leads (due to linearity) to a significant change in the prediction. This insight led to a new efficient algorithm to compute adversarial examples, the Fast Gradient Sign Method <span class="citation" data-cites="goodfellow2014explaining"><a href="references.html#ref-goodfellow2014explaining" role="doc-biblioref">[43]</a></span>. Having linear activation functions turned out to be neither necessary nor sufficient for adversarials <span class="citation" data-cites="tanay2016boundary"><a href="references.html#ref-tanay2016boundary" role="doc-biblioref">[44]</a></span>. New adversarial examples showed up not only for ReLU-based neural network models but for all kinds of machine learning models <span class="citation" data-cites="han2023interpreting"><a href="references.html#ref-han2023interpreting" role="doc-biblioref">[45]</a></span>. Moreover, these examples transfer between different models trained on the same dataset – you could generate an adversarial example for a ResNet model and apply it successfully to another model with an entirely different architecture <span class="citation" data-cites="papernot2016transferability"><a href="references.html#ref-papernot2016transferability" role="doc-biblioref">[46]</a></span>. Linearity couldn’t explain this strange behavior.</p>
<p><strong>Adversarial examples are not bugs, they are features</strong></p>
<p>Ilyas et al. <span class="citation" data-cites="ilyas2019adversarial"><a href="references.html#ref-ilyas2019adversarial" role="doc-biblioref">[47]</a></span> gave a novel explanation of adversarial examples – adversarial examples arise because human perception and machine learning perception operate differently. Machine learning models learn patterns that are stable across the dataset including patterns on which humans don’t rely. Like classifying an elephant based on the texture of its skin rather than its shape or its trunk. Slight changes in the elephant’s skin will not change a human’s classification but it changes the one by the machine.</p>
<p>Ilyas et al. <span class="citation" data-cites="ilyas2019adversarial"><a href="references.html#ref-ilyas2019adversarial" role="doc-biblioref">[47]</a></span> came to this conclusion based on the following experiment: Say you have a trained model and then generate a set of adversarial examples for this model. Now, train a new model from scratch exclusively on these adversarial data (with the wrong labels). Surprisingly, this model performs strongly on the original data with correct labels. The only explanation for this behavior is that the adversarial examples are strange in a meaningful way, adversarials differ in features that allow to classify ordinary data points. This also explains why adversarial examples can transfer between different models trained on the same data because they differ from real data in ways that are usually indicative of a different class. Unfortunately, this explanation of adversarials (which seems plausible) does not come with easy fixes. It implies that adversarials can only be evaded by relying on the very same features as humans. However, doing so would limit the space of possible solutions and thereby the predictive performance. In science, new predictive patterns undiscovered by humans might be what you are ultimately after.</p>
<p>Another factor leading to adversarial examples is that machine learning models cannot distinguish causes from effects or spurious correlations. Thus, changing a feature associated with a different target class can flip the prediction without changing the underlying target <span class="citation" data-cites="freiesleben2022intriguing"><a href="references.html#ref-freiesleben2022intriguing" role="doc-biblioref">[48]</a></span>. Like changing the elephant’s skin texture similar to a hippo’s without touching causal features like their shape or their trunk. Adding causal assumptions may therefore protect against certain adversarial examples <span class="citation" data-cites="scholkopf2022causality"><a href="references.html#ref-scholkopf2022causality" role="doc-biblioref">[49]</a></span>. But again, this is not an easy fix to use in practice. Adversarial examples remain a phenomenon that you have to live with and it is unclear if getting rid of the phenomenon is always desirable. In science, you might even strive for the weird predictive features invisible to humans.</p>
</section>
<section id="robustness-is-a-constant-challenge" class="level2" data-number="11.8">
<h2 data-number="11.8" class="anchored" data-anchor-id="robustness-is-a-constant-challenge"><span class="header-section-number">11.8</span> Robustness is a constant challenge</h2>
<p>Robustness in machine learning is not something you achieve. Robustness is like the boulder that Sisyphus<a href="#fn2" class="footnote-ref" id="fnref2" role="doc-noteref"><sup>2</sup></a> keeps pushing to the top of the hill just to see it rolling down again. But if you want a reliable machine learning model, the only way is to keep on pushing! Your environment will change making your model performance drop eventually. It’s important to stay on your watch and constantly adapt.</p>
<p>The chapter should have made clear that robustifying models is multifaceted. Each step in your pipeline can contribute and each step should be kept dynamic to be able to react quickly to changes. Each chapter in this book is an ally on your neverending machine learning robustness journey, you need models that generalize (<a href="generalization.html" class="quarto-xref"><span>Chapter 7</span></a>), you have to incorporate domain knowledge (<a href="domain.html" class="quarto-xref"><span>Chapter 8</span></a>), you must audit your model with interpretability techniques (<a href="interpretability.html" class="quarto-xref"><span>Chapter 9</span></a>), you should be aware of prediction uncertainties (<a href="uncertainty.html" class="quarto-xref"><span>Chapter 12</span></a>), and ultimately you should incorporate causality (<a href="causality.html" class="quarto-xref"><span>Chapter 10</span></a>).</p>
<p>Many problems remain challenging in robustness research:</p>
<ul>
<li>Translating a lack of robustness into a robustifying strategy is difficult. Data augmentation can provide a first heuristic solution but there are no guarantees. Also, different shifts require different robustifying strategies.</li>
<li>Adversarial examples remain relatively mysterious. Can they be avoided and if yes, should they be?</li>
<li>Synthetic data is often the least costly approach to robustify your model. But, if the data does not resemble the characteristics of real data, training your model on it will be pointless.</li>
</ul>
<p>Being a machine learning robustness engineer is like being a scientist – it is a constant struggle with nature. Nevertheless, paraphrasing Camus<a href="#fn3" class="footnote-ref" id="fnref3" role="doc-noteref"><sup>3</sup></a>, we must imagine machine learning robustness engineers as happy people.</p>


<div id="refs" class="references csl-bib-body" data-entry-spacing="0" role="list" style="display: none">
<div id="ref-norouzzadeh2018automatically" class="csl-entry" role="listitem">
<div class="csl-left-margin">[1] </div><div class="csl-right-inline">M. S. Norouzzadeh <em>et al.</em>, <span>“Automatically identifying, counting, and describing wild animals in camera-trap images with deep learning,”</span> <em>Proceedings of the National Academy of Sciences</em>, vol. 115, no. 25, pp. E5716–E5725, 2018, doi: <a href="https://doi.org/10.1073/pnas.1719367115">10.1073/pnas.1719367115</a>.</div>
</div>
<div id="ref-swanson2015snapshot" class="csl-entry" role="listitem">
<div class="csl-left-margin">[2] </div><div class="csl-right-inline">A. Swanson, M. Kosmala, C. Lintott, R. Simpson, A. Smith, and C. Packer, <span>“Snapshot serengeti, high-frequency annotated camera trap images of 40 mammalian species in an african savanna,”</span> <em>Scientific data</em>, vol. 2, no. 1, pp. 1–14, 2015, doi: <a href="https://doi.org/10.1038/sdata.2015.26">10.1038/sdata.2015.26</a>.</div>
</div>
<div id="ref-szegedy2013intriguing" class="csl-entry" role="listitem">
<div class="csl-left-margin">[3] </div><div class="csl-right-inline">C. Szegedy <em>et al.</em>, <span>“Intriguing properties of neural networks,”</span> <em>arXiv preprint arXiv:1312.6199</em>, 2013, doi: <a href="https://doi.org/10.48550/arXiv.1312.6199">10.48550/arXiv.1312.6199</a>.</div>
</div>
<div id="ref-freiesleben2023beyond" class="csl-entry" role="listitem">
<div class="csl-left-margin">[4] </div><div class="csl-right-inline">T. Freiesleben and T. Grote, <span>“Beyond generalization: A theory of robustness in machine learning,”</span> <em>Synthese</em>, vol. 202, no. 4, p. 109, 2023, doi: <a href="https://doi.org/10.1007/s11229-023-04334-9">10.1007/s11229-023-04334-9</a>.</div>
</div>
<div id="ref-yang2021generalized" class="csl-entry" role="listitem">
<div class="csl-left-margin">[5] </div><div class="csl-right-inline">J. Yang, K. Zhou, Y. Li, and Z. Liu, <span>“Generalized <span>Out</span>-of-<span>Distribution</span> <span>Detection</span>: <span>A</span> <span>Survey</span>,”</span> <em>International Journal of Computer Vision</em>, Jun. 2024, doi: <a href="https://doi.org/10.1007/s11263-024-02117-4">10.1007/s11263-024-02117-4</a>.</div>
</div>
<div id="ref-ribeiroWhyShouldTrust2016" class="csl-entry" role="listitem">
<div class="csl-left-margin">[6] </div><div class="csl-right-inline">M. T. Ribeiro, S. Singh, and C. Guestrin, <span>“"<span>Why Should I Trust You</span>?": <span>Explaining</span> the <span>Predictions</span> of <span>Any Classifier</span>,”</span> in <em>Proceedings of the 22nd <span>ACM SIGKDD International Conference</span> on <span>Knowledge Discovery</span> and <span>Data Mining</span></em>, in <span>KDD</span> ’16. <span>New York, NY, USA</span>: <span>Association for Computing Machinery</span>, Aug. 2016, pp. 1135–1144. doi: <a href="https://doi.org/10.1145/2939672.2939778">10.1145/2939672.2939778</a>.</div>
</div>
<div id="ref-chattopadhyay2017counting" class="csl-entry" role="listitem">
<div class="csl-left-margin">[7] </div><div class="csl-right-inline">P. Chattopadhyay, R. Vedantam, R. R. Selvaraju, D. Batra, and D. Parikh, <span>“Counting everyday objects in everyday scenes,”</span> in <em>Proceedings of the IEEE conference on computer vision and pattern recognition</em>, 2017, pp. 1135–1144. doi: <a href="https://doi.org/10.1109/cvpr.2017.471">10.1109/cvpr.2017.471</a>.</div>
</div>
<div id="ref-ruff2021unifying" class="csl-entry" role="listitem">
<div class="csl-left-margin">[8] </div><div class="csl-right-inline">L. Ruff <em>et al.</em>, <span>“A unifying review of deep and shallow anomaly detection,”</span> <em>Proceedings of the IEEE</em>, vol. 109, no. 5, pp. 756–795, 2021, doi: <a href="https://doi.org/10.1109/JPROC.2021.3052449">10.1109/JPROC.2021.3052449</a>.</div>
</div>
<div id="ref-chalapathy2019deep" class="csl-entry" role="listitem">
<div class="csl-left-margin">[9] </div><div class="csl-right-inline">R. Chalapathy and S. Chawla, <span>“Deep learning for anomaly detection: A survey,”</span> <em>arXiv preprint arXiv:1901.03407</em>, 2019.</div>
</div>
<div id="ref-neupert2021introduction" class="csl-entry" role="listitem">
<div class="csl-left-margin">[10] </div><div class="csl-right-inline">T. Neupert, M. H. Fischer, E. Greplova, K. Choo, and M. M. Denner, <span>“Introduction to machine learning for the sciences,”</span> <em>arXiv preprint arXiv:2102.04883</em>, 2021, doi: <a href="https://doi.org/10.48550/arXiv.2102.04883">10.48550/arXiv.2102.04883</a>.</div>
</div>
<div id="ref-denouden2018improving" class="csl-entry" role="listitem">
<div class="csl-left-margin">[11] </div><div class="csl-right-inline">T. Denouden, R. Salay, K. Czarnecki, V. Abdelzad, B. Phan, and S. Vernekar, <span>“Improving reconstruction autoencoder out-of-distribution detection with mahalanobis distance,”</span> <em>arXiv preprint arXiv:1812.02765</em>, 2018.</div>
</div>
<div id="ref-settles.tr09" class="csl-entry" role="listitem">
<div class="csl-left-margin">[12] </div><div class="csl-right-inline">B. Settles, <span>“Active learning literature survey,”</span> University of Wisconsin–Madison, Computer Sciences Technical Report 1648, 2009.</div>
</div>
<div id="ref-ren2021survey" class="csl-entry" role="listitem">
<div class="csl-left-margin">[13] </div><div class="csl-right-inline">P. Ren <em>et al.</em>, <span>“A survey of deep active learning,”</span> <em>ACM computing surveys (CSUR)</em>, vol. 54, no. 9, pp. 1–40, 2021, doi: <a href="https://doi.org/10.1145/3472291">10.1145/3472291</a>.</div>
</div>
<div id="ref-danka2018modal" class="csl-entry" role="listitem">
<div class="csl-left-margin">[14] </div><div class="csl-right-inline">T. Danka and P. Horvath, <span>“modAL: A modular active learning framework for python,”</span> <em>arXiv preprint arXiv:1805.00979</em>, 2018.</div>
</div>
<div id="ref-tang2019alipy" class="csl-entry" role="listitem">
<div class="csl-left-margin">[15] </div><div class="csl-right-inline">Y.-P. Tang, G.-X. Li, and S.-J. Huang, <span>“ALiPy: Active learning in python,”</span> <em>arXiv preprint arXiv:1901.03802</em>, 2019, doi: <a href="https://doi.org/10.48550/arXiv.1901.03802">10.48550/arXiv.1901.03802</a>.</div>
</div>
<div id="ref-ciravegna2023knowledge" class="csl-entry" role="listitem">
<div class="csl-left-margin">[16] </div><div class="csl-right-inline">G. Ciravegna, F. Precioso, A. Betti, K. Mottin, and M. Gori, <span>“Knowledge-driven active learning,”</span> in <em>Joint european conference on machine learning and knowledge discovery in databases</em>, Springer, 2023, pp. 38–54. doi: <a href="https://doi.org/10.1007/978-3-031-43412-9_3">10.1007/978-3-031-43412-9_3</a>.</div>
</div>
<div id="ref-ghai2021explainable" class="csl-entry" role="listitem">
<div class="csl-left-margin">[17] </div><div class="csl-right-inline">B. Ghai, Q. V. Liao, Y. Zhang, R. Bellamy, and K. Mueller, <span>“Explainable active learning (xal) toward ai explanations as interfaces for machine teachers,”</span> <em>Proceedings of the ACM on Human-Computer Interaction</em>, vol. 4, no. CSCW3, pp. 1–28, 2021, doi: <a href="https://doi.org/10.1145/3432934">10.1145/3432934</a>.</div>
</div>
<div id="ref-mumuni2022data" class="csl-entry" role="listitem">
<div class="csl-left-margin">[18] </div><div class="csl-right-inline">A. Mumuni and F. Mumuni, <span>“Data augmentation: A comprehensive survey of modern approaches,”</span> <em>Array</em>, vol. 16, p. 100258, 2022, doi: <a href="https://doi.org/10.1016/j.array.2022.100258">10.1016/j.array.2022.100258</a>.</div>
</div>
<div id="ref-shorten2019survey" class="csl-entry" role="listitem">
<div class="csl-left-margin">[19] </div><div class="csl-right-inline">C. Shorten and T. M. Khoshgoftaar, <span>“A survey on image data augmentation for deep learning,”</span> <em>Journal of big data</em>, vol. 6, no. 1, pp. 1–48, 2019, doi: <a href="https://doi.org/10.1186/s40537-019-0197-0">10.1186/s40537-019-0197-0</a>.</div>
</div>
<div id="ref-feng2021survey" class="csl-entry" role="listitem">
<div class="csl-left-margin">[20] </div><div class="csl-right-inline">S. Feng <em>et al.</em>, <span>“A survey of data augmentation approaches for NLP,”</span> in <em>Findings of the association for computational linguistics: ACL-IJCNLP 2021</em>, Association for Computational Linguistics, 2021. doi: <a href="https://doi.org/10.18653/v1/2021.findings-acl.84">10.18653/v1/2021.findings-acl.84</a>.</div>
</div>
<div id="ref-goodfellow2014generative" class="csl-entry" role="listitem">
<div class="csl-left-margin">[21] </div><div class="csl-right-inline">I. Goodfellow <em>et al.</em>, <span>“Generative adversarial nets,”</span> <em>Advances in neural information processing systems</em>, vol. 27, 2014.</div>
</div>
<div id="ref-antoniou2017data" class="csl-entry" role="listitem">
<div class="csl-left-margin">[22] </div><div class="csl-right-inline">A. Antoniou, A. Storkey, and H. Edwards, <span>“Data augmentation generative adversarial networks,”</span> <em>arXiv preprint arXiv:1711.04340</em>, 2017.</div>
</div>
<div id="ref-isola2017image" class="csl-entry" role="listitem">
<div class="csl-left-margin">[23] </div><div class="csl-right-inline">P. Isola, J.-Y. Zhu, T. Zhou, and A. A. Efros, <span>“Image-to-image translation with conditional adversarial networks,”</span> in <em>Proceedings of the IEEE conference on computer vision and pattern recognition</em>, 2017, pp. 1125–1134. doi: <a href="https://doi.org/10.1109/CVPR.2017.632">10.1109/CVPR.2017.632</a>.</div>
</div>
<div id="ref-bloice2017augmentor" class="csl-entry" role="listitem">
<div class="csl-left-margin">[24] </div><div class="csl-right-inline">M. D. Bloice, C. Stocker, and A. Holzinger, <span>“Augmentor: An image augmentation library for machine learning,”</span> <em>Journal of Open Source Software</em>, vol. 2, no. 19, p. 432, 2017, doi: <a href="https://doi.org/10.21105/joss.00432">10.21105/joss.00432</a>.</div>
</div>
<div id="ref-bird2006nltk" class="csl-entry" role="listitem">
<div class="csl-left-margin">[25] </div><div class="csl-right-inline">S. Bird, <span>“NLTK: The natural language toolkit,”</span> in <em>Proceedings of the COLING/ACL 2006 interactive presentation sessions</em>, 2006, pp. 69–72. doi: <a href="https://doi.org/10.3115/1225403.1225421">10.3115/1225403.1225421</a>.</div>
</div>
<div id="ref-hendrycks2021many" class="csl-entry" role="listitem">
<div class="csl-left-margin">[26] </div><div class="csl-right-inline">D. Hendrycks <em>et al.</em>, <span>“The many faces of robustness: A critical analysis of out-of-distribution generalization,”</span> in <em>Proceedings of the IEEE/CVF international conference on computer vision</em>, 2021, pp. 8340–8349. doi: <a href="https://doi.org/10.1109/ICCV48922.2021.00823">10.1109/ICCV48922.2021.00823</a>.</div>
</div>
<div id="ref-tsipras2018robustness" class="csl-entry" role="listitem">
<div class="csl-left-margin">[27] </div><div class="csl-right-inline">D. Tsipras, S. Santurkar, L. Engstrom, A. Turner, and A. Madry, <span>“Robustness may be at odds with accuracy,”</span> <em>arXiv preprint arXiv:1805.12152</em>, 2018, doi: <a href="https://doi.org/10.48550/arXiv.1805.12152">10.48550/arXiv.1805.12152</a>.</div>
</div>
<div id="ref-rebuffi2021data" class="csl-entry" role="listitem">
<div class="csl-left-margin">[28] </div><div class="csl-right-inline">S.-A. Rebuffi, S. Gowal, D. A. Calian, F. Stimberg, O. Wiles, and T. A. Mann, <span>“Data augmentation can improve robustness,”</span> <em>Advances in Neural Information Processing Systems</em>, vol. 34, pp. 29935–29948, 2021, doi: <a href="https://doi.org/10.48550/arXiv.2111.05328">10.48550/arXiv.2111.05328</a>.</div>
</div>
<div id="ref-alemohammad2023self" class="csl-entry" role="listitem">
<div class="csl-left-margin">[29] </div><div class="csl-right-inline">S. Alemohammad <em>et al.</em>, <span>“Self-consuming generative models go mad,”</span> <em>arXiv preprint arXiv:2307.01850</em>, 2023.</div>
</div>
<div id="ref-chandrashekar2014survey" class="csl-entry" role="listitem">
<div class="csl-left-margin">[30] </div><div class="csl-right-inline">G. Chandrashekar and F. Sahin, <span>“A survey on feature selection methods,”</span> <em>Computers &amp; electrical engineering</em>, vol. 40, no. 1, pp. 16–28, 2014, doi: <a href="https://doi.org/10.1016/j.compeleceng.2013.11.024">10.1016/j.compeleceng.2013.11.024</a>.</div>
</div>
<div id="ref-bengio2013representation" class="csl-entry" role="listitem">
<div class="csl-left-margin">[31] </div><div class="csl-right-inline">Y. Bengio, A. Courville, and P. Vincent, <span>“Representation learning: A review and new perspectives,”</span> <em>IEEE Transactions on Pattern Analysis and Machine Intelligence</em>, vol. 35, no. 8, pp. 1798–1828, 2013, doi: <a href="https://doi.org/10.1109/TPAMI.2013.50">10.1109/TPAMI.2013.50</a>.</div>
</div>
<div id="ref-vens2008decision" class="csl-entry" role="listitem">
<div class="csl-left-margin">[32] </div><div class="csl-right-inline">C. Vens, J. Struyf, L. Schietgat, S. Džeroski, and H. Blockeel, <span>“Decision trees for hierarchical multi-label classification,”</span> <em>Machine learning</em>, vol. 73, pp. 185–214, 2008, doi: <a href="https://doi.org/10.1007/s10994-008-5077-3">10.1007/s10994-008-5077-3</a>.</div>
</div>
<div id="ref-wang2018defensive" class="csl-entry" role="listitem">
<div class="csl-left-margin">[33] </div><div class="csl-right-inline">S. Wang <em>et al.</em>, <span>“Defensive dropout for hardening deep neural networks under adversarial attacks,”</span> in <em>2018 IEEE/ACM international conference on computer-aided design (ICCAD)</em>, IEEE, 2018, pp. 1–8. doi: <a href="https://doi.org/10.1145/3240765.3264699">10.1145/3240765.3264699</a>.</div>
</div>
<div id="ref-mumuni2021cnn" class="csl-entry" role="listitem">
<div class="csl-left-margin">[34] </div><div class="csl-right-inline">A. Mumuni and F. Mumuni, <span>“CNN architectures for geometric transformation-invariant feature representation in computer vision: A review,”</span> <em>SN Computer Science</em>, vol. 2, no. 5, p. 340, 2021, doi: <a href="https://doi.org/10.1007/s42979-021-00735-0">10.1007/s42979-021-00735-0</a>.</div>
</div>
<div id="ref-corso2024graph" class="csl-entry" role="listitem">
<div class="csl-left-margin">[35] </div><div class="csl-right-inline">G. Corso, H. Stark, S. Jegelka, T. Jaakkola, and R. Barzilay, <span>“Graph neural networks,”</span> <em>Nature Reviews Methods Primers</em>, vol. 4, no. 1, p. 17, 2024.</div>
</div>
<div id="ref-wu2020comprehensive" class="csl-entry" role="listitem">
<div class="csl-left-margin">[36] </div><div class="csl-right-inline">Z. Wu, S. Pan, F. Chen, G. Long, C. Zhang, and S. Y. Philip, <span>“A comprehensive survey on graph neural networks,”</span> <em>IEEE transactions on neural networks and learning systems</em>, vol. 32, no. 1, pp. 4–24, 2020, doi: <a href="https://doi.org/10.1109/TNNLS.2020.2978386">10.1109/TNNLS.2020.2978386</a>.</div>
</div>
<div id="ref-battaglia2018relational" class="csl-entry" role="listitem">
<div class="csl-left-margin">[37] </div><div class="csl-right-inline">P. W. Battaglia <em>et al.</em>, <span>“Relational inductive biases, deep learning, and graph networks,”</span> <em>arXiv preprint arXiv:1806.01261</em>, 2018.</div>
</div>
<div id="ref-arjovsky2019invariant" class="csl-entry" role="listitem">
<div class="csl-left-margin">[38] </div><div class="csl-right-inline">M. Arjovsky, L. Bottou, I. Gulrajani, and D. Lopez-Paz, <span>“Invariant risk minimization,”</span> <em>arXiv preprint arXiv:1907.02893</em>, 2019.</div>
</div>
<div id="ref-kamath2021does" class="csl-entry" role="listitem">
<div class="csl-left-margin">[39] </div><div class="csl-right-inline">P. Kamath, A. Tangella, D. Sutherland, and N. Srebro, <span>“Does invariant risk minimization capture invariance?”</span> in <em>International conference on artificial intelligence and statistics</em>, PMLR, 2021, pp. 4069–4077.</div>
</div>
<div id="ref-konig2023improvement" class="csl-entry" role="listitem">
<div class="csl-left-margin">[40] </div><div class="csl-right-inline">G. König, T. Freiesleben, and M. Grosse-Wentrup, <span>“Improvement-focused causal recourse (ICR),”</span> in <em>Proceedings of the AAAI conference on artificial intelligence</em>, 2023, pp. 11847–11855. doi: <a href="https://doi.org/10.1609/aaai.v37i10.26398">10.1609/aaai.v37i10.26398</a>.</div>
</div>
<div id="ref-cranmer2020frontier" class="csl-entry" role="listitem">
<div class="csl-left-margin">[41] </div><div class="csl-right-inline">K. Cranmer, J. Brehmer, and G. Louppe, <span>“The frontier of simulation-based inference,”</span> <em>Proceedings of the National Academy of Sciences</em>, vol. 117, no. 48, pp. 30055–30062, 2020, doi: <a href="https://doi.org/10.1073/pnas.1912789117">10.1073/pnas.1912789117</a>.</div>
</div>
<div id="ref-zhang2019limitations" class="csl-entry" role="listitem">
<div class="csl-left-margin">[42] </div><div class="csl-right-inline">H. Zhang, H. Chen, Z. Song, D. Boning, I. S. Dhillon, and C.-J. Hsieh, <span>“The limitations of adversarial training and the blind-spot attack,”</span> <em>arXiv preprint arXiv:1901.04684</em>, 2019, doi: <a href="https://doi.org/10.48550/arXiv.1901.04684">10.48550/arXiv.1901.04684</a>.</div>
</div>
<div id="ref-goodfellow2014explaining" class="csl-entry" role="listitem">
<div class="csl-left-margin">[43] </div><div class="csl-right-inline">I. J. Goodfellow, J. Shlens, and C. Szegedy, <span>“Explaining and harnessing adversarial examples,”</span> <em>arXiv preprint arXiv:1412.6572</em>, 2014, doi: <a href="https://doi.org/10.48550/arXiv.1412.6572">10.48550/arXiv.1412.6572</a>.</div>
</div>
<div id="ref-tanay2016boundary" class="csl-entry" role="listitem">
<div class="csl-left-margin">[44] </div><div class="csl-right-inline">T. Tanay and L. Griffin, <span>“A boundary tilting persepective on the phenomenon of adversarial examples,”</span> <em>arXiv preprint arXiv:1608.07690</em>, 2016, doi: <a href="https://doi.org/10.48550/arXiv.1608.07690">10.48550/arXiv.1608.07690</a>.</div>
</div>
<div id="ref-han2023interpreting" class="csl-entry" role="listitem">
<div class="csl-left-margin">[45] </div><div class="csl-right-inline">S. Han, C. Lin, C. Shen, Q. Wang, and X. Guan, <span>“Interpreting adversarial examples in deep learning: A review,”</span> <em>ACM Computing Surveys</em>, vol. 55, no. 14s, pp. 1–38, 2023, doi: <a href="https://doi.org/10.1145/3594869">10.1145/3594869</a>.</div>
</div>
<div id="ref-papernot2016transferability" class="csl-entry" role="listitem">
<div class="csl-left-margin">[46] </div><div class="csl-right-inline">N. Papernot, P. McDaniel, and I. Goodfellow, <span>“Transferability in machine learning: From phenomena to black-box attacks using adversarial samples,”</span> <em>arXiv preprint arXiv:1605.07277</em>, 2016, doi: <a href="https://doi.org/10.48550/arXiv.1605.07277">10.48550/arXiv.1605.07277</a>.</div>
</div>
<div id="ref-ilyas2019adversarial" class="csl-entry" role="listitem">
<div class="csl-left-margin">[47] </div><div class="csl-right-inline">A. Ilyas, S. Santurkar, D. Tsipras, L. Engstrom, B. Tran, and A. Madry, <span>“Adversarial examples are not bugs, they are features,”</span> <em>Advances in neural information processing systems</em>, vol. 32, 2019.</div>
</div>
<div id="ref-freiesleben2022intriguing" class="csl-entry" role="listitem">
<div class="csl-left-margin">[48] </div><div class="csl-right-inline">T. Freiesleben, <span>“The intriguing relation between counterfactual explanations and adversarial examples,”</span> <em>Minds and Machines</em>, vol. 32, no. 1, pp. 77–109, 2022, doi: <a href="https://doi.org/10.1007/s11023-021-09580-9">10.1007/s11023-021-09580-9</a>.</div>
</div>
<div id="ref-scholkopf2022causality" class="csl-entry" role="listitem">
<div class="csl-left-margin">[49] </div><div class="csl-right-inline">B. Schölkopf, <span>“Causality for machine learning,”</span> in <em>Probabilistic and causal inference: The works of judea pearl</em>, 2022, pp. 765–804.</div>
</div>
</div>
</section>
<section id="footnotes" class="footnotes footnotes-end-of-document" role="doc-endnotes">
<hr/>
<ol>
<li id="fn1"><p>To evaluate your model performance on the new data it must be labeled. We discuss in <a href="#sec-dataAugmentation" class="quarto-xref"><span>Section 11.5.3</span></a> how to label data systematically using active learning.<a href="#fnref1" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn2"><p>Sisyphus was a figure in Greek mythology, known for his cunning and deceitful nature. He was the King of Corinth and was infamous for his trickery, which often got him into trouble with the gods. One of the most famous stories involving Sisyphus is his punishment in the afterlife. According to Greek mythology, after his death, Sisyphus was condemned by the gods to roll a boulder uphill for eternity, only for it to roll back down every time he neared the top. This endless and futile task became known as <em>Sisyphean</em> and is often used as a metaphor for a task that is never-ending and ultimately feels pointless.<a href="#fnref2" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn3"><p>Albert Camus was a French philosopher, author, and journalist who is best known for his existentialist works. In his philosophical essay <em>The Myth of Sisyphus</em> (1942), Camus explores the philosophical concept of the absurd – the inherent conflict between the human desire to find meaning in life and the universe’s indifference to human concerns. Camus argues that despite the apparent pointlessness of Sisyphus’s task, he can still find happiness and meaning in his existence by embracing the absurdity of life and finding fulfillment in the act of rebellion against it. He therefore famously stated that “we must imagine Sisyphus happy”. Indeed, connecting these deep thoughts to machine learning robustness is a bit far-fetched…<a href="#fnref3" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
</ol>
</section>

    
</body>
</html>