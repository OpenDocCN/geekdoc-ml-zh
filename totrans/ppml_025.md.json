["```py\n    fn main() {\n       // `x` is not yet in scope here\n       let y = \"Hello\".to_string();\n       let x = \"World\".to_string(); // <-- x's scope starts here...\n       let h = \"!\".to_string(); //   |\n    } //  <-------------- ...and ends here\n    ```", "```py\n    fn compute(t: String) {\n       // Do something [...]\n    }\n\n    fn main() {\n        let s = \"Hello\".to_string(); // <-- s's scope starts here...\n                    //                    | \n        compute(s); // <------------------- ..and ends here\n                    //   because `s` is moved into `compute`\n    }\n    ```", "```py\nfn main() {\n   let y = \"Hello\".to_string();\n   let x = \"World\".to_string();\n   let h = \"!\".to_string();\n}\n```", "```py\nfn main() {\n   let y = \"Hello\".to_string();\n   let x = \"World\".to_string();\n   let h = \"!\".to_string();\n   // Variables are dropped in reverse order of declaration\n   drop(h);\n   drop(x);\n   drop(y);\n}\n```", "```py\nfn compute(s: String) {\n   // Do something [...]\n}\n\nfn main() {\n   let s = \"Hello\".to_string();\n   compute(s);\n}\n```", "```py\nfn compute(t: String) {\n    // Do something [...]\n    drop(t); // <-- Assuming `t` wasn't dropped or moved \n             //     before this point, the compiler will call \n             //     `drop` here, when it goes out of scope\n}\n\nfn main() {\n    let s = \"Hello\".to_string();\n    compute(s);\n}\n```", "```py\nlet x = \"Hello\".to_string();\ndrop(x);\nprintln!(\"{}\", x);\n```", "```py\nerror[E0382]: use of moved value: `x`\n --> src/main.rs:4:20\n  |\n3 |     drop(x);\n  |          - value moved here\n4 |     println!(\"{}\", x);\n  |                    ^ value used here after move\n```", "```py\nlet x = 42i32;\nlet y = &x;\ndrop(y);\n```", "```py\nwarning: calls to `std::mem::drop` with a reference \n         instead of an owned value does nothing\n --> src/main.rs:4:5\n  |\n4 |     drop(y);\n  |     ^^^^^-^\n  |          |\n  |          argument has type `&i32`\n  | \n```"]