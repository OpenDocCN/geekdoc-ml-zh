<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.1//EN"
  "http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd">

<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<title>Modules</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1>Modules</h1>
<blockquote>原文：<a href="https://rust-exercises.com/100-exercises/03_ticket_v1/03_modules.html">https://rust-exercises.com/100-exercises/03_ticket_v1/03_modules.html</a></blockquote>
                        
<p>The <code>new</code> method you've just defined is trying to enforce some <strong>constraints</strong> on the field values for <code>Ticket</code>.
But are those invariants really enforced? What prevents a developer from creating a <code>Ticket</code>
without going through <code>Ticket::new</code>?</p>
<p>To get proper <strong>encapsulation</strong> you need to become familiar with two new concepts: <strong>visibility</strong> and <strong>modules</strong>.
Let's start with modules.</p>
<h2 id="what-is-a-module"><a class="header" href="#what-is-a-module">What is a module?</a></h2>
<p>In Rust a <strong>module</strong> is a way to group related code together, under a common namespace (i.e. the module's name).<br/>
You've already seen modules in action: the unit tests that verify the correctness of your code are defined in a
different module, named <code>tests</code>.</p>
<pre><code class="language-rust">#[cfg(test)]
mod tests {
    // [...]
}</code></pre>
<h2 id="inline-modules"><a class="header" href="#inline-modules">Inline modules</a></h2>
<p>The <code>tests</code> module above is an example of an <strong>inline module</strong>: the module declaration (<code>mod tests</code>) and the module
contents (the stuff inside <code>{ ... }</code>) are next to each other.</p>
<h2 id="module-tree"><a class="header" href="#module-tree">Module tree</a></h2>
<p>Modules can be nested, forming a <strong>tree</strong> structure.<br/>
The root of the tree is the <strong>crate</strong> itself, which is the top-level module that contains all the other modules.
For a library crate, the root module is usually <code>src/lib.rs</code> (unless its location has been customized).
The root module is also known as the <strong>crate root</strong>.</p>
<p>The crate root can have submodules, which in turn can have their own submodules, and so on.</p>
<h2 id="external-modules-and-the-filesystem"><a class="header" href="#external-modules-and-the-filesystem">External modules and the filesystem</a></h2>
<p>Inline modules are useful for small pieces of code, but as your project grows you'll want to split your code into
multiple files. In the parent module, you declare the existence of a submodule using the <code>mod</code> keyword.</p>
<pre><code class="language-rust">mod dog;</code></pre>
<p><code>cargo</code>, Rust's build tool, is then in charge of finding the file that contains
the module implementation.<br/>
If your module is declared in the root of your crate (e.g. <code>src/lib.rs</code> or <code>src/main.rs</code>),
<code>cargo</code> expects the file to be named either:</p>
<ul>
<li><code>src/&lt;module_name&gt;.rs</code></li>
<li><code>src/&lt;module_name&gt;/mod.rs</code></li>
</ul>
<p>If your module is a submodule of another module, the file should be named:</p>
<ul>
<li><code>[..]/&lt;parent_module&gt;/&lt;module_name&gt;.rs</code></li>
<li><code>[..]/&lt;parent_module&gt;/&lt;module_name&gt;/mod.rs</code></li>
</ul>
<p>E.g. <code>src/animals/dog.rs</code> or <code>src/animals/dog/mod.rs</code> if <code>dog</code> is a submodule of <code>animals</code>.</p>
<p>Your IDE might help you create these files automatically when you declare a new module using the <code>mod</code> keyword.</p>
<h2 id="item-paths-and-use-statements"><a class="header" href="#item-paths-and-use-statements">Item paths and <code>use</code> statements</a></h2>
<p>You can access items defined in the same module without any special syntax. You just use their name.</p>
<pre><code class="language-rust">struct Ticket {
    // [...]
}

// No need to qualify `Ticket` in any way here
// because we're in the same module
fn mark_ticket_as_done(ticket: Ticket) {
    // [...]
}</code></pre>
<p>That's not the case if you want to access an entity from a different module.<br/>
You have to use a <strong>path</strong> pointing to the entity you want to access.</p>
<p>You can compose the path in various ways:</p>
<ul>
<li>starting from the root of the current crate, e.g. <code>crate::module_1::MyStruct</code></li>
<li>starting from the parent module, e.g. <code>super::my_function</code></li>
<li>starting from the current module, e.g. <code>sub_module_1::MyStruct</code></li>
</ul>
<p>Both <code>crate</code> and <code>super</code> are <strong>keywords</strong>.<br/>
<code>crate</code> refers to the root of the current crate, while <code>super</code> refers to the parent of the current module.</p>
<p>Having to write the full path every time you want to refer to a type can be cumbersome.
To make your life easier, you can introduce a <code>use</code> statement to bring the entity into scope.</p>
<pre><code class="language-rust">// Bring `MyStruct` into scope
use crate::module_1::module_2::MyStruct;

// Now you can refer to `MyStruct` directly
fn a_function(s: MyStruct) {
     // [...]
}</code></pre>
<h3 id="star-imports"><a class="header" href="#star-imports">Star imports</a></h3>
<p>You can also import all the items from a module with a single <code>use</code> statement.</p>
<pre><code class="language-rust">use crate::module_1::module_2::*;</code></pre>
<p>This is known as a <strong>star import</strong>.<br/>
It is generally discouraged because it can pollute the current namespace, making it hard to understand
where each name comes from and potentially introducing name conflicts.<br/>
Nonetheless, it can be useful in some cases, like when writing unit tests. You might have noticed
that most of our test modules start with a <code>use super::*;</code> statement to bring all the items from the parent module
(the one being tested) into scope.</p>
<h2 id="visualizing-the-module-tree"><a class="header" href="#visualizing-the-module-tree">Visualizing the module tree</a></h2>
<p>If you're struggling to picture the module tree of your project, you can try using
<a href="https://crates.io/crates/cargo-modules"><code>cargo-modules</code></a> to visualize it!</p>
<p>Refer to their documentation for installation instructions and usage examples.</p>
<h2 id="exercise"><a class="header" href="#exercise">Exercise</a></h2>
<p>The exercise for this section is located in <a href="https://github.com/mainmatter/100-exercises-to-learn-rust/tree/main/exercises/03_ticket_v1/03_modules"><code>03_ticket_v1/03_modules</code></a></p>

                        
</body>
</html>