- en: Sized
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 原文：[https://rust-exercises.com/100-exercises/04_traits/08_sized.html](https://rust-exercises.com/100-exercises/04_traits/08_sized.html)
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: There's more to `&str` than meets the eye, even after having investigated deref
    coercion.
  prefs: []
  type: TYPE_NORMAL
- en: 'From our previous [discussion on memory layouts](/100-exercises/03_ticket_v1/10_references_in_memory),
    it would have been reasonable to expect `&str` to be represented as a single `usize`
    on the stack, a pointer. That''s not the case though. `&str` stores some **metadata**
    next to the pointer: the length of the slice it points to. Going back to the example
    from [a previous section](/100-exercises/04_traits/06_str_slice):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'In memory, we get:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: What's going on?
  prefs: []
  type: TYPE_NORMAL
- en: '[Dynamically sized types](#dynamically-sized-types)'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '`str` is a **dynamically sized type** (DST).'
  prefs: []
  type: TYPE_NORMAL
- en: A DST is a type whose size is not known at compile time. Whenever you have a
    reference to a DST, like `&str`, it has to include additional information about
    the data it points to. It is a **fat pointer**.
  prefs: []
  type: TYPE_NORMAL
- en: In the case of `&str`, it stores the length of the slice it points to. We'll
    see more examples of DSTs in the rest of the course.
  prefs: []
  type: TYPE_NORMAL
- en: '[The `Sized` trait](#the-sized-trait)'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Rust's `std` library defines a trait called `Sized`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: A type is `Sized` if its size is known at compile time. In other words, it's
    not a DST.
  prefs: []
  type: TYPE_NORMAL
- en: '[Marker traits](#marker-traits)'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '`Sized` is your first example of a **marker trait**.'
  prefs: []
  type: TYPE_NORMAL
- en: A marker trait is a trait that doesn't require any methods to be implemented.
    It doesn't define any behavior. It only serves to **mark** a type as having certain
    properties. The mark is then leveraged by the compiler to enable certain behaviors
    or optimizations.
  prefs: []
  type: TYPE_NORMAL
- en: '[Auto traits](#auto-traits)'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In particular, `Sized` is also an **auto trait**.
  prefs: []
  type: TYPE_NORMAL
- en: You don't need to implement it explicitly; the compiler implements it automatically
    for you based on the type's definition.
  prefs: []
  type: TYPE_NORMAL
- en: '[Examples](#examples)'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'All the types we''ve seen so far are `Sized`: `u32`, `String`, `bool`, etc.'
  prefs: []
  type: TYPE_NORMAL
- en: '`str`, as we just saw, is not `Sized`.'
  prefs: []
  type: TYPE_NORMAL
- en: '`&str` is `Sized` though! We know its size at compile time: two `usize`s, one
    for the pointer and one for the length.'
  prefs: []
  type: TYPE_NORMAL
- en: '[Exercise](#exercise)'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The exercise for this section is located in [`04_traits/08_sized`](https://github.com/mainmatter/100-exercises-to-learn-rust/tree/main/exercises/04_traits/08_sized)
  prefs: []
  type: TYPE_NORMAL
