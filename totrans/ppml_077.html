<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.1//EN"
  "http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd">

<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<title>'static</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1>'static</h1>
<blockquote>原文：<a href="https://rust-exercises.com/100-exercises/07_threads/02_static.html">https://rust-exercises.com/100-exercises/07_threads/02_static.html</a></blockquote>
                        
<p>If you tried to borrow a slice from the vector in the previous exercise,
you probably got a compiler error that looks something like this:</p>
<pre><code class="language-text">error[E0597]: `v` does not live long enough
   |
11 | pub fn sum(v: Vec&lt;i32&gt;) -&gt; i32 {
   |            - binding `v` declared here
...
15 |     let right = &amp;v[split_point..];
   |                  ^ borrowed value does not live long enough
16 |     let left_handle = spawn(move || left.iter().sum::&lt;i32&gt;());
   |                             -------------------------------- 
                     argument requires that `v` is borrowed for `'static`
19 | }
   |  - `v` dropped here while still borrowed
</code></pre>
<p><code>argument requires that v is borrowed for 'static</code>, what does that mean?</p>
<p>The <code>'static</code> lifetime is a special lifetime in Rust.<br/>
It means that the value will be valid for the entire duration of the program.</p>
<h2 id="detached-threads"><a class="header" href="#detached-threads">Detached threads</a></h2>
<p>A thread launched via <code>thread::spawn</code> can <strong>outlive</strong> the thread that spawned it.<br/>
For example:</p>
<pre><code class="language-rust">use std::thread;

fn f() {
    thread::spawn(|| {
        thread::spawn(|| {
            loop {
                thread::sleep(std::time::Duration::from_secs(1));
                println!("Hello from the detached thread!");
            }
        });
    });
}</code></pre>
<p>In this example, the first spawned thread will in turn spawn
a child thread that prints a message every second.<br/>
The first thread will then finish and exit. When that happens,
its child thread will <strong>continue running</strong> for as long as the
overall process is running.<br/>
In Rust's lingo, we say that the child thread has <strong>outlived</strong>
its parent.</p>
<h2 id="static-lifetime"><a class="header" href="#static-lifetime"><code>'static</code> lifetime</a></h2>
<p>Since a spawned thread can:</p>
<ul>
<li>outlive the thread that spawned it (its parent thread)</li>
<li>run until the program exits</li>
</ul>
<p>it must not borrow any values that might be dropped before the program exits;
violating this constraint would expose us to a use-after-free bug.<br/>
That's why <code>std::thread::spawn</code>'s signature requires that the closure passed to it
has the <code>'static</code> lifetime:</p>
<pre><code class="language-rust">pub fn spawn&lt;F, T&gt;(f: F) -&gt; JoinHandle&lt;T&gt; 
where
    F: FnOnce() -&gt; T + Send + 'static,
    T: Send + 'static
{
    // [..]
}</code></pre>
<h2 id="static-is-not-just-about-references"><a class="header" href="#static-is-not-just-about-references"><code>'static</code> is not (just) about references</a></h2>
<p>All values in Rust have a lifetime, not just references.</p>
<p>In particular, a type that owns its data (like a <code>Vec</code> or a <code>String</code>)
satisfies the <code>'static</code> constraint: if you own it, you can keep working with it
for as long as you want, even after the function that originally created it
has returned.</p>
<p>You can thus interpret <code>'static</code> as a way to say:</p>
<ul>
<li>Give me an owned value</li>
<li>Give me a reference that's valid for the entire duration of the program</li>
</ul>
<p>The first approach is how you solved the issue in the previous exercise:
by allocating new vectors to hold the left and right parts of the original vector,
which were then moved into the spawned threads.</p>
<h2 id="static-references"><a class="header" href="#static-references"><code>'static</code> references</a></h2>
<p>Let's talk about the second case, references that are valid for the entire
duration of the program.</p>
<h3 id="static-data"><a class="header" href="#static-data">Static data</a></h3>
<p>The most common case is a reference to <strong>static data</strong>, such as string literals:</p>
<pre><code class="language-rust">let s: &amp;'static str = "Hello world!";</code></pre>
<p>Since string literals are known at compile-time, Rust stores them <em>inside</em> your executable,
in a region known as <strong>read-only data segment</strong>.
All references pointing to that region will therefore be valid for as long as
the program runs; they satisfy the <code>'static</code> contract.</p>
<h2 id="further-reading"><a class="header" href="#further-reading">Further reading</a></h2>
<ul>
<li><a href="https://en.wikipedia.org/wiki/Data_segment">The data segment</a></li>
</ul>
<h2 id="exercise"><a class="header" href="#exercise">Exercise</a></h2>
<p>The exercise for this section is located in <a href="https://github.com/mainmatter/100-exercises-to-learn-rust/tree/main/exercises/07_threads/02_static"><code>07_threads/02_static</code></a></p>

                        
</body>
</html>