<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.1//EN"
  "http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd">

<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<title>match</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1>match</h1>
<blockquote>原文：<a href="https://rust-exercises.com/100-exercises/05_ticket_v2/02_match.html">https://rust-exercises.com/100-exercises/05_ticket_v2/02_match.html</a></blockquote>
                        
<p>You may be wondering—what can you actually <strong>do</strong> with an enum?<br/>
The most common operation is to <strong>match</strong> on it.</p>
<pre><code class="language-rust">enum Status {
    ToDo,
    InProgress,
    Done
}

impl Status {
    fn is_done(&amp;self) -&gt; bool {
        match self {
            Status::Done =&gt; true,
            // The `|` operator lets you match multiple patterns.
            // It reads as "either `Status::ToDo` or `Status::InProgress`".
            Status::InProgress | Status::ToDo =&gt; false
        }
    }
}</code></pre>
<p>A <code>match</code> statement that lets you compare a Rust value against a series of <strong>patterns</strong>.<br/>
You can think of it as a type-level <code>if</code>. If <code>status</code> is a <code>Done</code> variant, execute the first block;
if it's a <code>InProgress</code> or <code>ToDo</code> variant, execute the second block.</p>
<h2 id="exhaustiveness"><a class="header" href="#exhaustiveness">Exhaustiveness</a></h2>
<p>There's one key detail here: <code>match</code> is <strong>exhaustive</strong>. You must handle all enum variants.<br/>
If you forget to handle a variant, Rust will stop you <strong>at compile-time</strong> with an error.</p>
<p>E.g. if we forget to handle the <code>ToDo</code> variant:</p>
<pre><code class="language-rust">match self {
    Status::Done =&gt; true,
    Status::InProgress =&gt; false,
}</code></pre>
<p>the compiler will complain:</p>
<pre><code class="language-text">error[E0004]: non-exhaustive patterns: `ToDo` not covered
 --&gt; src/main.rs:5:9
  |
5 |     match status {
  |     ^^^^^^^^^^^^ pattern `ToDo` not covered
</code></pre>
<p>This is a big deal!<br/>
Codebases evolve over time—you might add a new status down the line, e.g. <code>Blocked</code>. The Rust compiler
will emit an error for every single <code>match</code> statement that's missing logic for the new variant.
That's why Rust developers often sing the praises of "compiler-driven refactoring"—the compiler tells you
what to do next, you just have to fix what it reports.</p>
<h2 id="catch-all"><a class="header" href="#catch-all">Catch-all</a></h2>
<p>If you don't care about one or more variants, you can use the <code>_</code> pattern as a catch-all:</p>
<pre><code class="language-rust">match status {
    Status::Done =&gt; true,
    _ =&gt; false
}</code></pre>
<p>The <code>_</code> pattern matches anything that wasn't matched by the previous patterns.</p>
<div class="warning">
By using this catch-all pattern, you _won't_ get the benefits of compiler-driven refactoring.
If you add a new enum variant, the compiler _won't_ tell you that you're not handling it.
<p>If you're keen on correctness, avoid using catch-alls. Leverage the compiler to re-examine all matching sites and determine how new enum variants should be handled.</p>
</div>
<h2 id="exercise"><a class="header" href="#exercise">Exercise</a></h2>
<p>The exercise for this section is located in <a href="https://github.com/mainmatter/100-exercises-to-learn-rust/tree/main/exercises/05_ticket_v2/02_match"><code>05_ticket_v2/02_match</code></a></p>

                        
</body>
</html>