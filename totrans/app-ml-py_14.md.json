["```py\nignore_warnings = True                                        # ignore warnings?\nimport numpy as np                                            # ndarrays for gridded data\nimport pandas as pd                                           # DataFrames for tabular data\nimport copy                                                   # for deep copies\nimport os                                                     # set working directory, run executables\nimport matplotlib.pyplot as plt                               # for plotting\nfrom matplotlib.colors import ListedColormap                  # custom color maps\nfrom matplotlib.ticker import (MultipleLocator,AutoMinorLocator,NullLocator,FuncFormatter) # control of axes ticks\nfrom matplotlib.lines import Line2D                           # custom legend entry\nimport matplotlib.ticker as mtick                             # control tick label formatting\nfrom sklearn.preprocessing import MinMaxScaler                # min/max normalization\nfrom sklearn.cluster import KMeans                            # k-means clustering\nfrom sklearn.cluster import SpectralClustering                # spectral clustering\nplt.rc('axes', axisbelow=True)                                # plot all grids below the plot elements\nif ignore_warnings == True:                                   \n    import warnings\n    warnings.filterwarnings('ignore')\ncmap = plt.cm.inferno                                         # color map\nseed = 42                                                     # random number seed \n```", "```py\ncontinuous_cmap = plt.get_cmap('seismic')\nnum_levels = 7  \ndiscretized_cmap = continuous_cmap(np.linspace(0, 1, num_levels))\ndiscrete_cmap = ListedColormap(discretized_cmap) \n```", "```py\ndef comma_format(x, pos):\n    return f'{int(x):,}'\n\ndef add_grid():                                            \n    plt.gca().grid(True, which='major',linewidth = 1.0); plt.gca().grid(True, which='minor',linewidth = 0.2) # add y grids\n    plt.gca().tick_params(which='major',length=7); plt.gca().tick_params(which='minor', length=4)\n    plt.gca().xaxis.set_minor_locator(AutoMinorLocator()); plt.gca().yaxis.set_minor_locator(AutoMinorLocator()) # turn on minor ticks \n```", "```py\n#os.chdir(\"d:/PGE383\")                                        # set the working directory with the input data file \n```", "```py\nimport pandas as pd \n```", "```py\npd.read_csv() \n```", "```py\ndf = pd.read_csv(\"nonlinear_facies_v1.csv\") \n```", "```py\ndf = df.sample(frac=.30, random_state = 73073); \ndf = df.reset_index() \n```", "```py\ndataset = 1                                                   # select a dataset, 1 - 4\nreduce_the_data = True; retain_fraction = 0.02                # reduce the number of samples to improve visualization and run time \nyname = 'Facies'                                              # available group label for checking\n\nif dataset == 1:\n    Xname = ['Por','Perm']; Xunit = ['%','mD']; Xlabel = ['Porosity','Permeability'] \n    Xlabelunit = [Xlabel[0] + ' (' + Xunit[0] + ')',Xlabel[1] + ' (' + Xunit[1] + ')']\n    Xmin = [0.0,0.0]; Xmax = [30.0,1400.0]                    # set minimums and maximums for visualization \n    df = pd.read_csv(r'https://raw.githubusercontent.com/GeostatsGuy/GeoDataSets/master/nonlinear_facies_v1.csv') # load our data table \nelif dataset == 2:\n    Xname = ['AI','Por']; Xunit = [r'$kg/m2*10^3$','%']; Xlabel = ['Acoustic Impedance','Porosity'] \n    Xlabelunit = [Xlabel[0] + ' (' + Xunit[0] + ')',Xlabel[1] + ' (' + Xunit[1] + ')']\n    Xmin = [0.0,0.0]; Xmax = [1200.0,30.0]                    # set minimums and maximums for visualization \n    df = pd.read_csv(r'https://raw.githubusercontent.com/GeostatsGuy/GeoDataSets/master/nonlinear_facies_v2.csv') # load our data table\nelif dataset == 3:\n    Xname = ['AI','Por']; Xunit = [r'$kg/m2*10^3$','%']; Xlabel = ['Acoustic Impedance','Porosity'] \n    Xlabelunit = [Xlabel[0] + ' (' + Xunit[0] + ')',Xlabel[1] + ' (' + Xunit[1] + ')']\n    Xmin = [0.0,0.0]; Xmax = [1200.0,30.0]                    # set minimums and maximums for visualization \n    df = pd.read_csv(r'https://raw.githubusercontent.com/GeostatsGuy/GeoDataSets/master/nonlinear_facies_v3.csv') # load our data table\nelif dataset == 4:\n    Xname = ['AI','Por']; Xunit = [r'$kg/m2*10^3$','%']; Xlabel = ['Acoustic Impedance','Porosity'] \n    Xlabelunit = [Xlabel[0] + ' (' + Xunit[0] + ')',Xlabel[1] + ' (' + Xunit[1] + ')']\n    Xmin = [0.0,0.0]; Xmax = [7000.0,30.0]                    # set minimums and maximums for visualization \n    df = pd.read_csv(r'https://raw.githubusercontent.com/GeostatsGuy/GeoDataSets/master/sample_data_Gaussian_mixture_v1.csv') # load our data table\n\nnXname = ['n' + feature for feature in Xname]                 # labels, units and ranges for normalized features\nnXunit = ['norm[' + unit + ']' for unit in Xunit]\nnXlabel = ['Normalized ' + feature for feature in Xlabel]\nnXlabelunit = [nXlabel[0] + ' (' + nXunit[0] + ')',nXlabel[1] + ' (' + nXunit[1] + ')']\nnXmin = [0.0,0.0]; nXmax = [1.0,1.0]    \n\nif reduce_the_data == True:\n    df = df.sample(frac=retain_fraction, random_state = 73073); df = df.reset_index() # extract a fraction of the data\n\ndf = df[Xname + [yname]]                                      # make a new DataFrame with only the features of interest\ndf.head() \n```", "```py\ndf.describe().transpose()                                     # summary statistics \n```", "```py\nplt.subplot(221)                                              # histogram feature 1\nplt.hist(df[Xname[0]],alpha=0.8,color=\"darkorange\",edgecolor=\"black\",bins=np.linspace(Xmin[0],Xmax[0],20),density = False)\nplt.title(Xlabel[0])\nplt.xlabel(Xlabelunit[0]); plt.ylabel(\"Frequency\")\nadd_grid()\n\nplt.subplot(222)                                              # histogram feature 2\nplt.hist(df[Xname[1]],alpha=0.8,color=\"darkorange\",edgecolor=\"black\",bins=np.linspace(Xmin[1],Xmax[1],20),density = False)\nplt.title(Xlabel[1]); plt.xlabel(Xlabelunit[1]); plt.ylabel(\"Frequency\")\nplt.gca().xaxis.set_major_formatter(FuncFormatter(comma_format)); add_grid()\n\nplt.subplot(223)                                              # histogram truth label\nn, bins, patches = plt.hist(df[yname],alpha=0.8,color=\"darkorange\",edgecolor=\"black\",bins=[0.5,1.5,2.5,3.5],label = ['Shale','SandShale','Sand'],range=[0.5,2.5],density = True)\nplt.title('Facies Proportions')\nplt.xlabel('Facies'); plt.ylabel(\"Proportion\")\nax = plt.gca()\nax.set_xticks(np.arange(1.0, 3.1, 1)); ax.set_yticks(np.arange(0, 0.6, 0.2)); ax.set_yticks(np.arange(0, 0.6, 0.05), minor=True)\nax.grid(which='minor', alpha=0.1); ax.grid(which='major', alpha=0.2)\ncolors = plt.cm.YlOrBr_r(np.linspace(0, 1, len(patches)))\nfor patch, color in zip(patches, colors):\n    patch.set_facecolor(color)\n\nplt.subplots_adjust(left=0.0, bottom=0.0, right=2.0, top=2.1, wspace=0.2, hspace=0.2); plt.show() \n```", "```py\ntransform = MinMaxScaler();                                   # instantiate the normalization object\ndf['n' + Xname[0]], df['n' + Xname[1]] = transform.fit_transform(df.loc[:,Xname].values).T # normalize features\ndf.head(n = 3) \n```", "```py\ndf.describe().transpose()                                     # check normalization via summary statistics \n```", "```py\nplt.subplot(221)                                              # original histograms\nplt.hist(df[Xname[0]],alpha=0.8,color=\"darkorange\",edgecolor=\"black\",bins=np.linspace(Xmin[0],Xmax[0],20),density = False)\nplt.title(Xlabel[0]); plt.xlabel(Xlabelunit[0]); plt.ylabel(\"Frequency\"); plt.xlim([Xmin[0],Xmax[0]]); add_grid()\n\nplt.subplot(222)\nplt.hist(df[Xname[1]],alpha=0.8,color=\"darkorange\",edgecolor=\"black\",bins=np.linspace(Xmin[1],Xmax[1],20),density = False)\nplt.title(Xlabel[1]); plt.xlabel(Xlabelunit[1]); plt.ylabel(\"Frequency\"); plt.xlim([Xmin[1],Xmax[1]])\nplt.gca().xaxis.set_major_formatter(FuncFormatter(comma_format)); add_grid()\n\nplt.subplot(223)                                              # normalized histograms\nplt.hist(df[nXname[0]],alpha=0.8,color=\"darkorange\",edgecolor=\"black\",bins=np.linspace(nXmin[0],nXmax[0],20),density = False)\nplt.title(nXlabel[0]); plt.xlabel(nXlabelunit[0]); plt.ylabel(\"Frequency\"); add_grid(); plt.xlim([nXmin[0],nXmax[0]]);\n\nplt.subplot(224)\nplt.hist(df[nXname[1]],alpha=0.8,color=\"darkorange\",edgecolor=\"black\",bins=np.linspace(nXmin[1],nXmax[1],20),density = False)\nplt.title(nXlabel[1]); plt.xlabel(nXlabelunit[1]); plt.ylabel(\"Frequency\"); add_grid(); plt.xlim([nXmin[1],nXmax[1]]);\n\nplt.subplots_adjust(left=0.0, bottom=0.0, right=2.0, top=2.1, wspace=0.2, hspace=0.2); plt.show() \n```", "```py\nfacies_list = np.unique(df[yname])                            # get the facies list from loaded data\nmin_facies = min(facies_list); max_facies = max(facies_list)\nfor ifacies in facies_list:                                   # plot the labeled data\n    plt.scatter(df[df[yname] == ifacies][Xname[0]],df[df[yname] == ifacies][Xname[1]],\n        color = plt.cm.YlOrBr_r((ifacies-min_facies)/(max_facies-min_facies)),edgecolor='black',alpha = 0.8,\n        vmin = min_facies, vmax = max_facies,label = 'Facies: ' + str(ifacies))\n\nplt.xlabel(Xlabelunit[0]); plt.ylabel(Xlabelunit[1]); plt.title(Xlabel[1] + ' vs. ' + Xlabel[0] + ' with Truth ' + yname); add_grid()\nplt.xlim([Xmin[0],Xmax[0]]); plt.ylim([Xmin[1],Xmax[1]])\nplt.gca().yaxis.set_major_formatter(FuncFormatter(comma_format)); plt.legend(loc = 'lower right')\n\nplt.subplots_adjust(left=0.0, bottom=0.0, right=1.0, top=1.1, wspace=0.2, hspace=0.2) \n```", "```py\nplt.subplot(121)                                              # scatter plot our training data \nplt.scatter(df[Xname[0]],df[Xname[1]], c=\"black\", alpha = 0.8, linewidths=1.0, edgecolors=\"black\")\nplt.title(Xlabel[1] + ' vs. ' + Xlabel[0]); plt.xlabel(Xlabelunit[0]); plt.ylabel(Xlabelunit[1])\nplt.gca().yaxis.set_major_formatter(FuncFormatter(comma_format)); \nplt.xlim(Xmin[0],Xmax[0]); plt.ylim(Xmin[1],Xmax[1]); add_grid()\n\nplt.subplot(122)\nplt.scatter(df[nXname[0]],df[nXname[1]], c=\"black\", alpha = 0.8, linewidths=1.0, edgecolors=\"black\")\nplt.title(nXlabel[1] + ' vs. ' + nXlabel[0]); plt.xlabel(nXlabelunit[0]); plt.ylabel(nXlabelunit[1])\nplt.xlim(nXmin[0],nXmax[0]); plt.ylim(nXmin[1],nXmax[1]); add_grid()\n\nplt.subplots_adjust(left=0.0, bottom=0.0, right=2.0, top=1.0, wspace=0.2, hspace=0.2) \n```", "```py\nplt.subplot(131)                                              # plot the data unlabeled\nnp.random.seed(15)                                            # I found a seed with pretty good random \"jittered\" labels\nplt.scatter(df[Xname[0]], df[Xname[1]],c='black',alpha=0.5,edgecolor='k',cmap = cmap)\nplt.xlabel(Xlabelunit[0]); plt.ylabel(Xlabelunit[1]); plt.title(Xlabel[1] + ' vs. ' + Xlabel[0]); add_grid()\nplt.gca().yaxis.set_major_formatter(FuncFormatter(comma_format))\nplt.xlim([Xmin[0],Xmax[0]]); plt.ylim([Xmin[1],Xmax[1]])\nfor i in range(0,len(df)):\n    dx = dy = np.random.choice([-1,0,1])*2; dy = np.random.choice([-1,0,1])*30\n    x0 = df[Xname[0]][i]; x1 = df[Xname[1]][i]\n    xa0 = df[Xname[0]][i]+dx; xa1 = df[Xname[1]][i]+dy\n    plt.annotate(i,[xa0,xa1],size=7,zorder=20,color='red')\n    plt.plot([x0,xa0],[x1,xa1],color='black',lw=0.5)\n\nplt.subplots_adjust(left=0.0, bottom=0.0, right=2.4, top=0.8, wspace=0.2, hspace=0.2); plt.show() \n```", "```py\nconnect = [(33,1),(1,4),(4,29),(29,20),(32,24),(24,15),(14,15),(14,8),(14,26),(26,28),(28,27),(27,16)]\nconnect = connect + [(30,5),(5,12),(12,2),(2,10),(10,18),(18,31),(31,10),(10,3),(3,7),(7,13),(13,21),(21,11)]\nconnect = connect + [(11,0),(0,9),(9,6),(6,23),(23,19),(19,17),(22,2),(31,2)]\n\nA = np.zeros((len(df),len(df))); D = np.zeros((len(df),len(df))) # declare the adjacency and degree matrices\n\nfor icon in range(0,len(connect)):                            # make adjacency matrix\n    A[connect[icon][0],connect[icon][1]] = 1.0\n    A[connect[icon][1],connect[icon][0]] = 1.0\n\ndegrees = np.sum(A,axis=0)                                    # make degree matrix\nfor i in range(0,len(df)):\n    D[i,i] = degrees[i]\n\nL = D - A                                                     # calculate graph Laplacian matrix\n\nplt.subplot(221)                                              # plot the data with graph vertices\nplt.scatter(df[Xname[0]], df[Xname[1]],c='black',alpha=0.5,edgecolor='k',cmap = cmap,zorder=5,label='vertex')\nplt.xlabel(Xlabelunit[0]); plt.ylabel(Xlabelunit[1]); plt.title('Graph with Data Samples'); add_grid()\nplt.gca().yaxis.set_major_formatter(FuncFormatter(comma_format))\nplt.xlim([Xmin[0],Xmax[0]]); plt.ylim([Xmin[1],Xmax[1]])\nfor i in range(0,len(df)):\n    x0 = df[Xname[0]][i]; x1 = df[Xname[1]][i]+60\n    plt.annotate(i,[x0,x1],color='blue',zorder=20)\n\nfor icon in range(0,len(connect)):\n    i,j = connect[icon]\n    plt.plot([df[Xname[0]][i],df[Xname[0]][j]],[df[Xname[1]][i],df[Xname[1]][j]],color='red',zorder=1)\nline = Line2D([0], [0], label='edge', color='red')\n\ncolors = ['#FFFFFF','#000000']  # Black and white\nbinary_cmap = ListedColormap(colors)\nhandles, labels = plt.gca().get_legend_handles_labels()\nhandles.extend([line])\nplt.legend(handles=handles,loc='lower right')\n\nplt.subplot(222)                                              # plot adjacency matrix\nplt.imshow(A,extent=[-0.5,len(df)-1+0.5,-0.5,len(df)-1+0.5],cmap = discrete_cmap,vmin=-3.5,vmax=3.5)\nfor icon in range(0,len(df)+1):\n    plt.plot([icon+0.5,icon+0.5],[-0.5,len(df)-1+0.5],color='grey')\n    plt.plot([-0.5,len(df)-1+0.5],[icon+0.5,icon+0.5],color='grey')\nplt.xlim([-0.5,len(df)-1+0.5]); plt.ylim([-0.5,len(df)-1+0.5]);\nplt.title('Adjacency Matrix (A)'); plt.xlabel('$i$ (Data Sample Index)'); plt.ylabel('$j$ (Data Sample Index)');\ncbar = plt.colorbar()\n\nplt.subplot(223)                                              # plot the degree matrix\nplt.imshow(D,extent=[-0.5,len(df)-1+0.5,-0.5,len(df)-1+0.5],cmap = discrete_cmap,vmin=-3.5,vmax=3.5)\nfor icon in range(0,len(df)+1):\n    plt.plot([icon+0.5,icon+0.5],[-0.5,len(df)-1+0.5],color='grey')\n    plt.plot([-0.5,len(df)-1+0.5],[icon+0.5,icon+0.5],color='grey')\nplt.xlim([-0.5,len(df)-1+0.5]); plt.ylim([-0.5,len(df)-1+0.5]);\nplt.title('Degree Matrix (D)'); plt.xlabel('$i$ (Data Sample Index)'); plt.ylabel('$j$ (Data Sample Index)');\ncbar = plt.colorbar()\n\nplt.subplot(224)                                              # plot the graph Laplacian matrix\nplt.imshow(L,extent=[-0.5,len(df)-1+0.5,-0.5,len(df)-1+0.5],cmap = discrete_cmap,vmin=-3.5,vmax=3.5)\nfor icon in range(0,len(df)+1):\n    plt.plot([icon+0.5,icon+0.5],[-0.5,len(df)-1+0.5],color='grey')\n    plt.plot([-0.5,len(df)-1+0.5],[icon+0.5,icon+0.5],color='grey')\nplt.xlim([-0.5,len(df)-1+0.5]); plt.ylim([-0.5,len(df)-1+0.5]);\nplt.title('Graph Laplacian Matrix (L = D - A)'); plt.xlabel('$i$ (Data Sample Index)'); plt.ylabel('$j$ (Data Sample Index)');\ncbar = plt.colorbar()\n\nplt.subplots_adjust(left=0.0, bottom=0.0, right=1.6, top=1.6, wspace=0.2, hspace=0.25); plt.show() \n```", "```py\nK = 3\nspectral = SpectralClustering(n_clusters=K,assign_labels=\"kmeans\",affinity='precomputed', random_state=seed).fit(A)\n\ndf['Spectral'] = spectral.labels_ + 1\ncluster_list = np.unique(df['Spectral']); min_cluster = min(cluster_list); max_cluster = max(cluster_list)\n\ncmap = plt.cm.inferno\n\nplt.subplot(221)                                              # plot the clusters and graph\nfor k in range(1,K+1):    \n    plt.scatter(df[df['Spectral']==k][Xname[0]], df[df['Spectral']==k][Xname[1]],color=cmap((k-1)/(K-1)),alpha = 1.0,\n        linewidths=1.0, edgecolors=\"black\", cmap = cmap,label = 'Cluster ' + str(k),vmin=0,vmax=K,zorder=10)\nplt.title(Xname[1] + ' vs. ' + Xname[1] + ' with Spectral Clustering by Custom Adjacency Matrix'); plt.xlabel(Xlabelunit[0])\nplt.ylabel(Xlabelunit[1]); plt.xlim([Xmin[0],Xmax[0]]); plt.ylim([Xmin[1],Xmax[1]]); add_grid()\nplt.gca().yaxis.set_major_formatter(FuncFormatter(comma_format))\nfor icon in range(0,len(connect)):\n    i,j = connect[icon]\n    plt.plot([df[Xname[0]][i],df[Xname[0]][j]],[df[Xname[1]][i],df[Xname[1]][j]],color='grey',lw=0.5,zorder=1)\nplt.legend(loc='lower right')\n\nplt.subplot(222)                                              # plot the clusters and graph\nfor k in range(1,K+1):    \n    plt.scatter(df[df['Spectral']==k][nXname[0]], df[df['Spectral']==k][nXname[1]],color=cmap((k-1)/(K-1)),alpha = 1.0,\n        linewidths=1.0, edgecolors=\"black\", cmap = cmap,label = 'Cluster ' + str(k),vmin=0,vmax=K,zorder=10)\nplt.title(nXname[1] + ' vs. ' + nXname[1] + ' Spectral Clustering by Custom Adjacency Matrix'); plt.xlabel(nXlabelunit[0])\nplt.ylabel(nXlabelunit[1]); plt.xlim([nXmin[0],nXmax[0]]); plt.ylim([nXmin[1],nXmax[1]]); add_grid()\nfor icon in range(0,len(connect)):\n    i,j = connect[icon]\n    plt.plot([df[nXname[0]][i],df[nXname[0]][j]],[df[nXname[1]][i],df[nXname[1]][j]],color='grey',lw=0.5,zorder=1)\nplt.legend(loc='lower right')\n\nplt.subplot(223)                                              # plot the cluster groups histograms \nN, bins, patches  = plt.hist(df['Spectral'],alpha=0.8,edgecolor=\"black\",range=[min_cluster-0.5,max_cluster-0.5],\n    bins=np.insert(np.linspace(min_cluster,max_cluster,len(cluster_list))+0.5,0,min_cluster-0.5),density = True)\nfor i in range(0,len(cluster_list)):\n    patches[i].set_facecolor(cmap((cluster_list[i]-min_cluster)/(max_cluster-min_cluster)));\nax = plt.gca(); ax.set_xticks(cluster_list); plt.xlabel('Spectral Clusters'); plt.ylabel('Proportion'); plt.title('Spectral Clustering Groups')\nplt.xlim([0.5,K+0.5]); plt.ylim([0,1]); add_grid()   \n\nplt.subplots_adjust(left=0.0, bottom=0.0, right=2.0, top=2.1, wspace=0.2, hspace=0.2) \n```", "```py\nnew_vertices = [(20,32),(16,30)]                              # add new vertices\nconnect2 = connect + new_vertices\n\nA2 = np.zeros((len(df),len(df)))                              # declare the adjacency and degree matrices\n\nfor icon in range(0,len(connect2)):\n    A2[connect2[icon][0],connect2[icon][1]] = 1.0\n    A2[connect2[icon][1],connect2[icon][0]] = 1.0\n\nK = 3                                                         # spectral clustering with the new graph\nspectral2 = SpectralClustering(n_clusters=K,assign_labels=\"kmeans\",affinity='precomputed', random_state=seed).fit(A2)\n\ndf['Spectral2'] = spectral2.labels_ + 1\ncluster_list = np.unique(df['Spectral2']); min_cluster = min(cluster_list); max_cluster = max(cluster_list)\n\ncmap = plt.cm.inferno\n\nplt.subplot(121)                                              # plot the clusters and graph\nfor k in range(1,K+1):    \n    plt.scatter(df[df['Spectral2']==k][Xname[0]], df[df['Spectral2']==k][Xname[1]],color=cmap((k-1)/(K-1)),alpha = 1.0,\n        linewidths=1.0, edgecolors=\"black\", cmap = cmap,label = 'Cluster ' + str(k),vmin=0,vmax=K,zorder=10)\nplt.title(Xname[1] + ' vs. ' + Xname[1] + ' with Spectral Clustering & New Connections'); plt.xlabel(Xlabelunit[0]); plt.ylabel(Xlabelunit[1])\nplt.xlim([Xmin[0],Xmax[0]]); plt.ylim([Xmin[1],Xmax[1]]); add_grid()\nplt.gca().yaxis.set_major_formatter(FuncFormatter(comma_format))\nfor icon in range(0,len(connect)):\n    i,j = connect[icon]\n    plt.plot([df[Xname[0]][i],df[Xname[0]][j]],[df[Xname[1]][i],df[Xname[1]][j]],color='grey',lw=0.5,zorder=1)\nfor icon in range(0,len(new_vertices)):\n    i,j = new_vertices[icon]\n    if icon == 1:\n        plt.plot([df[Xname[0]][i],df[Xname[0]][j]],[df[Xname[1]][i],df[Xname[1]][j]],color='red',lw=1.0,zorder=1,label='New Connection')\n    else:\n        plt.plot([df[Xname[0]][i],df[Xname[0]][j]],[df[Xname[1]][i],df[Xname[1]][j]],color='red',lw=1.0,zorder=1)\nplt.legend(loc='lower right')\n\nplt.subplot(122)                                              # plot the clustering and graph\nfor k in range(1,K+1):    \n    plt.scatter(df[df['Spectral']==k][Xname[0]], df[df['Spectral']==k][Xname[1]],color=cmap((k-1)/(K-1)),alpha = 1.0,\n        linewidths=1.0, edgecolors=\"black\", cmap = cmap,label = 'Cluster ' + str(k),vmin=0,vmax=K,zorder=10)\nplt.title(Xname[1] + ' vs. ' + Xname[1] + ' with Spectral Clustering'); plt.xlabel(Xlabelunit[0]); plt.ylabel(Xlabelunit[1])\nplt.xlim([Xmin[0],Xmax[0]]); plt.ylim([Xmin[1],Xmax[1]]); add_grid()\nplt.gca().yaxis.set_major_formatter(FuncFormatter(comma_format))\nfor icon in range(0,len(connect)):\n    i,j = connect[icon]\n    plt.plot([df[Xname[0]][i],df[Xname[0]][j]],[df[Xname[1]][i],df[Xname[1]][j]],color='grey',lw=0.5,zorder=1)\nplt.legend(loc='lower right')\n\nplt.subplots_adjust(left=0.0, bottom=0.0, right=2.0, top=1.1, wspace=0.2, hspace=0.2) \n```", "```py\nK = 3; gamma = 1.0\nspectral = SpectralClustering(n_clusters=K,assign_labels=\"kmeans\",affinity = 'rbf',\n                               gamma = gamma,random_state=seed).fit(df[[nXname[0],nXname[1]]].values)\ndf['Spectral3'] = spectral.labels_ + 1\ncluster_list = np.unique(df['Spectral3']); min_cluster = min(cluster_list); max_cluster = max(cluster_list)\n\ncmap = plt.cm.inferno\n\nplt.subplot(121)                                              # plot the clusters and graph\nfor k in range(1,K+1):    \n    plt.scatter(df[df['Spectral3']==k][Xname[0]], df[df['Spectral3']==k][Xname[1]],color=cmap((k-1)/(K-1)),alpha = 1.0,\n        linewidths=1.0, edgecolors=\"black\", cmap = cmap,label = 'Cluster ' + str(k),vmin=0,vmax=K,zorder=10)\nplt.title(Xname[1] + ' vs. ' + Xname[1] + ' with Spectral Clustering'); plt.xlabel(Xlabelunit[0]); plt.ylabel(Xlabelunit[1])\nplt.xlim([Xmin[0],Xmax[0]]); plt.ylim([Xmin[1],Xmax[1]]); add_grid()\nplt.gca().yaxis.set_major_formatter(FuncFormatter(comma_format)); plt.legend(loc='lower right')\n\nplt.subplot(122)                                              # plot the cluster and graph \nN, bins, patches  = plt.hist(df['Spectral3'],alpha=0.8,edgecolor=\"black\",range=[min_cluster-0.5,max_cluster-0.5],\n    bins=np.insert(np.linspace(min_cluster,max_cluster,len(cluster_list))+0.5,0,min_cluster-0.5),density = True)\nfor i in range(0,len(cluster_list)):\n    patches[i].set_facecolor(cmap((cluster_list[i]-min_cluster)/(max_cluster-min_cluster)));\nax = plt.gca(); ax.set_xticks(cluster_list); plt.xlabel('Spectral Clusters'); plt.ylabel('Proportion')\nplt.title('Spectral Clustering Groups'); plt.xlim([0.5,K+0.5]); plt.ylim([0,1]); add_grid()   \n\nplt.subplots_adjust(left=0.0, bottom=0.0, right=2.0, top=1.1, wspace=0.2, hspace=0.2) \n```", "```py\nplt.subplot(111)                                              # plot the affinity matrix \nplt.imshow(spectral.affinity_matrix_,cmap = plt.cm.gist_heat_r,vmin = 0.0, vmax = 1.0)\nplt.xlabel(r'Sample Data $\\alpha = 1, \\ldots ,n$'); plt.ylabel(r'Sample Data $\\alpha = 1, \\ldots ,n$')\nplt.subplots_adjust(left=0.0, bottom=0.0, right=1.0, top=1.1, wspace=0.2, hspace=0.2) \n```", "```py\nncluster_mat = [2,3,4] \ngamma_mat = [0.01,1.0,10] \n```", "```py\nncluster_mat = [2,3,4]                                        # spectral clustering with RBF kernel affinity cases\ngamma_mat = [0.01,1.0,10]\nindex = 1\nfor ncluster in ncluster_mat:\n    for gamma in gamma_mat:\n        spectral = SpectralClustering(n_clusters=ncluster,assign_labels=\"kmeans\",affinity = 'rbf',\n                              gamma = gamma,n_neighbors = 200,random_state=230).fit(df[[nXname[0],nXname[1]]].values)\n        df['Spectral_test'] = spectral.labels_ + 1\n\n        plt.subplot(3,3,index)                                 \n        for k in range(1,ncluster+1):    \n            if len(df[df['Spectral_test']==k]) > 0:\n                plt.scatter(df[df['Spectral_test']==k][Xname[0]], df[df['Spectral_test']==k][Xname[1]],color=cmap((k-1)/(ncluster-1)),alpha = 1.0,\n                    linewidths=1.0, edgecolors=\"black\", cmap = cmap,label = 'Cluster ' + str(k),vmin=0,vmax=ncluster,zorder=10)\n        plt.title(Xlabel[1] + ' vs. ' + Xlabel[0] + ' with Spectral, ncluster = ' + str(ncluster) + ', RBF: gamma = ' + str(gamma)); \n        plt.xlabel(Xlabelunit[0]); plt.ylabel(Xlabelunit[1])\n        plt.xlim([Xmin[0],Xmax[0]]); plt.ylim([Xmin[1],Xmax[1]]); add_grid()\n        plt.gca().yaxis.set_major_formatter(FuncFormatter(comma_format))\n        plt.legend(loc='lower right')\n        index = index + 1\nplt.subplots_adjust(left=0.0, bottom=0.0, right=3.0, top=3.50, wspace=0.2, hspace=0.2) \n```", "```py\nignore_warnings = True                                        # ignore warnings?\nimport numpy as np                                            # ndarrays for gridded data\nimport pandas as pd                                           # DataFrames for tabular data\nimport copy                                                   # for deep copies\nimport os                                                     # set working directory, run executables\nimport matplotlib.pyplot as plt                               # for plotting\nfrom matplotlib.colors import ListedColormap                  # custom color maps\nfrom matplotlib.ticker import (MultipleLocator,AutoMinorLocator,NullLocator,FuncFormatter) # control of axes ticks\nfrom matplotlib.lines import Line2D                           # custom legend entry\nimport matplotlib.ticker as mtick                             # control tick label formatting\nfrom sklearn.preprocessing import MinMaxScaler                # min/max normalization\nfrom sklearn.cluster import KMeans                            # k-means clustering\nfrom sklearn.cluster import SpectralClustering                # spectral clustering\nplt.rc('axes', axisbelow=True)                                # plot all grids below the plot elements\nif ignore_warnings == True:                                   \n    import warnings\n    warnings.filterwarnings('ignore')\ncmap = plt.cm.inferno                                         # color map\nseed = 42                                                     # random number seed \n```", "```py\ncontinuous_cmap = plt.get_cmap('seismic')\nnum_levels = 7  \ndiscretized_cmap = continuous_cmap(np.linspace(0, 1, num_levels))\ndiscrete_cmap = ListedColormap(discretized_cmap) \n```", "```py\ndef comma_format(x, pos):\n    return f'{int(x):,}'\n\ndef add_grid():                                            \n    plt.gca().grid(True, which='major',linewidth = 1.0); plt.gca().grid(True, which='minor',linewidth = 0.2) # add y grids\n    plt.gca().tick_params(which='major',length=7); plt.gca().tick_params(which='minor', length=4)\n    plt.gca().xaxis.set_minor_locator(AutoMinorLocator()); plt.gca().yaxis.set_minor_locator(AutoMinorLocator()) # turn on minor ticks \n```", "```py\n#os.chdir(\"d:/PGE383\")                                        # set the working directory with the input data file \n```", "```py\nimport pandas as pd \n```", "```py\npd.read_csv() \n```", "```py\ndf = pd.read_csv(\"nonlinear_facies_v1.csv\") \n```", "```py\ndf = df.sample(frac=.30, random_state = 73073); \ndf = df.reset_index() \n```", "```py\ndataset = 1                                                   # select a dataset, 1 - 4\nreduce_the_data = True; retain_fraction = 0.02                # reduce the number of samples to improve visualization and run time \nyname = 'Facies'                                              # available group label for checking\n\nif dataset == 1:\n    Xname = ['Por','Perm']; Xunit = ['%','mD']; Xlabel = ['Porosity','Permeability'] \n    Xlabelunit = [Xlabel[0] + ' (' + Xunit[0] + ')',Xlabel[1] + ' (' + Xunit[1] + ')']\n    Xmin = [0.0,0.0]; Xmax = [30.0,1400.0]                    # set minimums and maximums for visualization \n    df = pd.read_csv(r'https://raw.githubusercontent.com/GeostatsGuy/GeoDataSets/master/nonlinear_facies_v1.csv') # load our data table \nelif dataset == 2:\n    Xname = ['AI','Por']; Xunit = [r'$kg/m2*10^3$','%']; Xlabel = ['Acoustic Impedance','Porosity'] \n    Xlabelunit = [Xlabel[0] + ' (' + Xunit[0] + ')',Xlabel[1] + ' (' + Xunit[1] + ')']\n    Xmin = [0.0,0.0]; Xmax = [1200.0,30.0]                    # set minimums and maximums for visualization \n    df = pd.read_csv(r'https://raw.githubusercontent.com/GeostatsGuy/GeoDataSets/master/nonlinear_facies_v2.csv') # load our data table\nelif dataset == 3:\n    Xname = ['AI','Por']; Xunit = [r'$kg/m2*10^3$','%']; Xlabel = ['Acoustic Impedance','Porosity'] \n    Xlabelunit = [Xlabel[0] + ' (' + Xunit[0] + ')',Xlabel[1] + ' (' + Xunit[1] + ')']\n    Xmin = [0.0,0.0]; Xmax = [1200.0,30.0]                    # set minimums and maximums for visualization \n    df = pd.read_csv(r'https://raw.githubusercontent.com/GeostatsGuy/GeoDataSets/master/nonlinear_facies_v3.csv') # load our data table\nelif dataset == 4:\n    Xname = ['AI','Por']; Xunit = [r'$kg/m2*10^3$','%']; Xlabel = ['Acoustic Impedance','Porosity'] \n    Xlabelunit = [Xlabel[0] + ' (' + Xunit[0] + ')',Xlabel[1] + ' (' + Xunit[1] + ')']\n    Xmin = [0.0,0.0]; Xmax = [7000.0,30.0]                    # set minimums and maximums for visualization \n    df = pd.read_csv(r'https://raw.githubusercontent.com/GeostatsGuy/GeoDataSets/master/sample_data_Gaussian_mixture_v1.csv') # load our data table\n\nnXname = ['n' + feature for feature in Xname]                 # labels, units and ranges for normalized features\nnXunit = ['norm[' + unit + ']' for unit in Xunit]\nnXlabel = ['Normalized ' + feature for feature in Xlabel]\nnXlabelunit = [nXlabel[0] + ' (' + nXunit[0] + ')',nXlabel[1] + ' (' + nXunit[1] + ')']\nnXmin = [0.0,0.0]; nXmax = [1.0,1.0]    \n\nif reduce_the_data == True:\n    df = df.sample(frac=retain_fraction, random_state = 73073); df = df.reset_index() # extract a fraction of the data\n\ndf = df[Xname + [yname]]                                      # make a new DataFrame with only the features of interest\ndf.head() \n```", "```py\ndf.describe().transpose()                                     # summary statistics \n```", "```py\nplt.subplot(221)                                              # histogram feature 1\nplt.hist(df[Xname[0]],alpha=0.8,color=\"darkorange\",edgecolor=\"black\",bins=np.linspace(Xmin[0],Xmax[0],20),density = False)\nplt.title(Xlabel[0])\nplt.xlabel(Xlabelunit[0]); plt.ylabel(\"Frequency\")\nadd_grid()\n\nplt.subplot(222)                                              # histogram feature 2\nplt.hist(df[Xname[1]],alpha=0.8,color=\"darkorange\",edgecolor=\"black\",bins=np.linspace(Xmin[1],Xmax[1],20),density = False)\nplt.title(Xlabel[1]); plt.xlabel(Xlabelunit[1]); plt.ylabel(\"Frequency\")\nplt.gca().xaxis.set_major_formatter(FuncFormatter(comma_format)); add_grid()\n\nplt.subplot(223)                                              # histogram truth label\nn, bins, patches = plt.hist(df[yname],alpha=0.8,color=\"darkorange\",edgecolor=\"black\",bins=[0.5,1.5,2.5,3.5],label = ['Shale','SandShale','Sand'],range=[0.5,2.5],density = True)\nplt.title('Facies Proportions')\nplt.xlabel('Facies'); plt.ylabel(\"Proportion\")\nax = plt.gca()\nax.set_xticks(np.arange(1.0, 3.1, 1)); ax.set_yticks(np.arange(0, 0.6, 0.2)); ax.set_yticks(np.arange(0, 0.6, 0.05), minor=True)\nax.grid(which='minor', alpha=0.1); ax.grid(which='major', alpha=0.2)\ncolors = plt.cm.YlOrBr_r(np.linspace(0, 1, len(patches)))\nfor patch, color in zip(patches, colors):\n    patch.set_facecolor(color)\n\nplt.subplots_adjust(left=0.0, bottom=0.0, right=2.0, top=2.1, wspace=0.2, hspace=0.2); plt.show() \n```", "```py\ntransform = MinMaxScaler();                                   # instantiate the normalization object\ndf['n' + Xname[0]], df['n' + Xname[1]] = transform.fit_transform(df.loc[:,Xname].values).T # normalize features\ndf.head(n = 3) \n```", "```py\ndf.describe().transpose()                                     # check normalization via summary statistics \n```", "```py\nplt.subplot(221)                                              # original histograms\nplt.hist(df[Xname[0]],alpha=0.8,color=\"darkorange\",edgecolor=\"black\",bins=np.linspace(Xmin[0],Xmax[0],20),density = False)\nplt.title(Xlabel[0]); plt.xlabel(Xlabelunit[0]); plt.ylabel(\"Frequency\"); plt.xlim([Xmin[0],Xmax[0]]); add_grid()\n\nplt.subplot(222)\nplt.hist(df[Xname[1]],alpha=0.8,color=\"darkorange\",edgecolor=\"black\",bins=np.linspace(Xmin[1],Xmax[1],20),density = False)\nplt.title(Xlabel[1]); plt.xlabel(Xlabelunit[1]); plt.ylabel(\"Frequency\"); plt.xlim([Xmin[1],Xmax[1]])\nplt.gca().xaxis.set_major_formatter(FuncFormatter(comma_format)); add_grid()\n\nplt.subplot(223)                                              # normalized histograms\nplt.hist(df[nXname[0]],alpha=0.8,color=\"darkorange\",edgecolor=\"black\",bins=np.linspace(nXmin[0],nXmax[0],20),density = False)\nplt.title(nXlabel[0]); plt.xlabel(nXlabelunit[0]); plt.ylabel(\"Frequency\"); add_grid(); plt.xlim([nXmin[0],nXmax[0]]);\n\nplt.subplot(224)\nplt.hist(df[nXname[1]],alpha=0.8,color=\"darkorange\",edgecolor=\"black\",bins=np.linspace(nXmin[1],nXmax[1],20),density = False)\nplt.title(nXlabel[1]); plt.xlabel(nXlabelunit[1]); plt.ylabel(\"Frequency\"); add_grid(); plt.xlim([nXmin[1],nXmax[1]]);\n\nplt.subplots_adjust(left=0.0, bottom=0.0, right=2.0, top=2.1, wspace=0.2, hspace=0.2); plt.show() \n```", "```py\nfacies_list = np.unique(df[yname])                            # get the facies list from loaded data\nmin_facies = min(facies_list); max_facies = max(facies_list)\nfor ifacies in facies_list:                                   # plot the labeled data\n    plt.scatter(df[df[yname] == ifacies][Xname[0]],df[df[yname] == ifacies][Xname[1]],\n        color = plt.cm.YlOrBr_r((ifacies-min_facies)/(max_facies-min_facies)),edgecolor='black',alpha = 0.8,\n        vmin = min_facies, vmax = max_facies,label = 'Facies: ' + str(ifacies))\n\nplt.xlabel(Xlabelunit[0]); plt.ylabel(Xlabelunit[1]); plt.title(Xlabel[1] + ' vs. ' + Xlabel[0] + ' with Truth ' + yname); add_grid()\nplt.xlim([Xmin[0],Xmax[0]]); plt.ylim([Xmin[1],Xmax[1]])\nplt.gca().yaxis.set_major_formatter(FuncFormatter(comma_format)); plt.legend(loc = 'lower right')\n\nplt.subplots_adjust(left=0.0, bottom=0.0, right=1.0, top=1.1, wspace=0.2, hspace=0.2) \n```", "```py\nplt.subplot(121)                                              # scatter plot our training data \nplt.scatter(df[Xname[0]],df[Xname[1]], c=\"black\", alpha = 0.8, linewidths=1.0, edgecolors=\"black\")\nplt.title(Xlabel[1] + ' vs. ' + Xlabel[0]); plt.xlabel(Xlabelunit[0]); plt.ylabel(Xlabelunit[1])\nplt.gca().yaxis.set_major_formatter(FuncFormatter(comma_format)); \nplt.xlim(Xmin[0],Xmax[0]); plt.ylim(Xmin[1],Xmax[1]); add_grid()\n\nplt.subplot(122)\nplt.scatter(df[nXname[0]],df[nXname[1]], c=\"black\", alpha = 0.8, linewidths=1.0, edgecolors=\"black\")\nplt.title(nXlabel[1] + ' vs. ' + nXlabel[0]); plt.xlabel(nXlabelunit[0]); plt.ylabel(nXlabelunit[1])\nplt.xlim(nXmin[0],nXmax[0]); plt.ylim(nXmin[1],nXmax[1]); add_grid()\n\nplt.subplots_adjust(left=0.0, bottom=0.0, right=2.0, top=1.0, wspace=0.2, hspace=0.2) \n```", "```py\nplt.subplot(131)                                              # plot the data unlabeled\nnp.random.seed(15)                                            # I found a seed with pretty good random \"jittered\" labels\nplt.scatter(df[Xname[0]], df[Xname[1]],c='black',alpha=0.5,edgecolor='k',cmap = cmap)\nplt.xlabel(Xlabelunit[0]); plt.ylabel(Xlabelunit[1]); plt.title(Xlabel[1] + ' vs. ' + Xlabel[0]); add_grid()\nplt.gca().yaxis.set_major_formatter(FuncFormatter(comma_format))\nplt.xlim([Xmin[0],Xmax[0]]); plt.ylim([Xmin[1],Xmax[1]])\nfor i in range(0,len(df)):\n    dx = dy = np.random.choice([-1,0,1])*2; dy = np.random.choice([-1,0,1])*30\n    x0 = df[Xname[0]][i]; x1 = df[Xname[1]][i]\n    xa0 = df[Xname[0]][i]+dx; xa1 = df[Xname[1]][i]+dy\n    plt.annotate(i,[xa0,xa1],size=7,zorder=20,color='red')\n    plt.plot([x0,xa0],[x1,xa1],color='black',lw=0.5)\n\nplt.subplots_adjust(left=0.0, bottom=0.0, right=2.4, top=0.8, wspace=0.2, hspace=0.2); plt.show() \n```", "```py\nconnect = [(33,1),(1,4),(4,29),(29,20),(32,24),(24,15),(14,15),(14,8),(14,26),(26,28),(28,27),(27,16)]\nconnect = connect + [(30,5),(5,12),(12,2),(2,10),(10,18),(18,31),(31,10),(10,3),(3,7),(7,13),(13,21),(21,11)]\nconnect = connect + [(11,0),(0,9),(9,6),(6,23),(23,19),(19,17),(22,2),(31,2)]\n\nA = np.zeros((len(df),len(df))); D = np.zeros((len(df),len(df))) # declare the adjacency and degree matrices\n\nfor icon in range(0,len(connect)):                            # make adjacency matrix\n    A[connect[icon][0],connect[icon][1]] = 1.0\n    A[connect[icon][1],connect[icon][0]] = 1.0\n\ndegrees = np.sum(A,axis=0)                                    # make degree matrix\nfor i in range(0,len(df)):\n    D[i,i] = degrees[i]\n\nL = D - A                                                     # calculate graph Laplacian matrix\n\nplt.subplot(221)                                              # plot the data with graph vertices\nplt.scatter(df[Xname[0]], df[Xname[1]],c='black',alpha=0.5,edgecolor='k',cmap = cmap,zorder=5,label='vertex')\nplt.xlabel(Xlabelunit[0]); plt.ylabel(Xlabelunit[1]); plt.title('Graph with Data Samples'); add_grid()\nplt.gca().yaxis.set_major_formatter(FuncFormatter(comma_format))\nplt.xlim([Xmin[0],Xmax[0]]); plt.ylim([Xmin[1],Xmax[1]])\nfor i in range(0,len(df)):\n    x0 = df[Xname[0]][i]; x1 = df[Xname[1]][i]+60\n    plt.annotate(i,[x0,x1],color='blue',zorder=20)\n\nfor icon in range(0,len(connect)):\n    i,j = connect[icon]\n    plt.plot([df[Xname[0]][i],df[Xname[0]][j]],[df[Xname[1]][i],df[Xname[1]][j]],color='red',zorder=1)\nline = Line2D([0], [0], label='edge', color='red')\n\ncolors = ['#FFFFFF','#000000']  # Black and white\nbinary_cmap = ListedColormap(colors)\nhandles, labels = plt.gca().get_legend_handles_labels()\nhandles.extend([line])\nplt.legend(handles=handles,loc='lower right')\n\nplt.subplot(222)                                              # plot adjacency matrix\nplt.imshow(A,extent=[-0.5,len(df)-1+0.5,-0.5,len(df)-1+0.5],cmap = discrete_cmap,vmin=-3.5,vmax=3.5)\nfor icon in range(0,len(df)+1):\n    plt.plot([icon+0.5,icon+0.5],[-0.5,len(df)-1+0.5],color='grey')\n    plt.plot([-0.5,len(df)-1+0.5],[icon+0.5,icon+0.5],color='grey')\nplt.xlim([-0.5,len(df)-1+0.5]); plt.ylim([-0.5,len(df)-1+0.5]);\nplt.title('Adjacency Matrix (A)'); plt.xlabel('$i$ (Data Sample Index)'); plt.ylabel('$j$ (Data Sample Index)');\ncbar = plt.colorbar()\n\nplt.subplot(223)                                              # plot the degree matrix\nplt.imshow(D,extent=[-0.5,len(df)-1+0.5,-0.5,len(df)-1+0.5],cmap = discrete_cmap,vmin=-3.5,vmax=3.5)\nfor icon in range(0,len(df)+1):\n    plt.plot([icon+0.5,icon+0.5],[-0.5,len(df)-1+0.5],color='grey')\n    plt.plot([-0.5,len(df)-1+0.5],[icon+0.5,icon+0.5],color='grey')\nplt.xlim([-0.5,len(df)-1+0.5]); plt.ylim([-0.5,len(df)-1+0.5]);\nplt.title('Degree Matrix (D)'); plt.xlabel('$i$ (Data Sample Index)'); plt.ylabel('$j$ (Data Sample Index)');\ncbar = plt.colorbar()\n\nplt.subplot(224)                                              # plot the graph Laplacian matrix\nplt.imshow(L,extent=[-0.5,len(df)-1+0.5,-0.5,len(df)-1+0.5],cmap = discrete_cmap,vmin=-3.5,vmax=3.5)\nfor icon in range(0,len(df)+1):\n    plt.plot([icon+0.5,icon+0.5],[-0.5,len(df)-1+0.5],color='grey')\n    plt.plot([-0.5,len(df)-1+0.5],[icon+0.5,icon+0.5],color='grey')\nplt.xlim([-0.5,len(df)-1+0.5]); plt.ylim([-0.5,len(df)-1+0.5]);\nplt.title('Graph Laplacian Matrix (L = D - A)'); plt.xlabel('$i$ (Data Sample Index)'); plt.ylabel('$j$ (Data Sample Index)');\ncbar = plt.colorbar()\n\nplt.subplots_adjust(left=0.0, bottom=0.0, right=1.6, top=1.6, wspace=0.2, hspace=0.25); plt.show() \n```", "```py\nK = 3\nspectral = SpectralClustering(n_clusters=K,assign_labels=\"kmeans\",affinity='precomputed', random_state=seed).fit(A)\n\ndf['Spectral'] = spectral.labels_ + 1\ncluster_list = np.unique(df['Spectral']); min_cluster = min(cluster_list); max_cluster = max(cluster_list)\n\ncmap = plt.cm.inferno\n\nplt.subplot(221)                                              # plot the clusters and graph\nfor k in range(1,K+1):    \n    plt.scatter(df[df['Spectral']==k][Xname[0]], df[df['Spectral']==k][Xname[1]],color=cmap((k-1)/(K-1)),alpha = 1.0,\n        linewidths=1.0, edgecolors=\"black\", cmap = cmap,label = 'Cluster ' + str(k),vmin=0,vmax=K,zorder=10)\nplt.title(Xname[1] + ' vs. ' + Xname[1] + ' with Spectral Clustering by Custom Adjacency Matrix'); plt.xlabel(Xlabelunit[0])\nplt.ylabel(Xlabelunit[1]); plt.xlim([Xmin[0],Xmax[0]]); plt.ylim([Xmin[1],Xmax[1]]); add_grid()\nplt.gca().yaxis.set_major_formatter(FuncFormatter(comma_format))\nfor icon in range(0,len(connect)):\n    i,j = connect[icon]\n    plt.plot([df[Xname[0]][i],df[Xname[0]][j]],[df[Xname[1]][i],df[Xname[1]][j]],color='grey',lw=0.5,zorder=1)\nplt.legend(loc='lower right')\n\nplt.subplot(222)                                              # plot the clusters and graph\nfor k in range(1,K+1):    \n    plt.scatter(df[df['Spectral']==k][nXname[0]], df[df['Spectral']==k][nXname[1]],color=cmap((k-1)/(K-1)),alpha = 1.0,\n        linewidths=1.0, edgecolors=\"black\", cmap = cmap,label = 'Cluster ' + str(k),vmin=0,vmax=K,zorder=10)\nplt.title(nXname[1] + ' vs. ' + nXname[1] + ' Spectral Clustering by Custom Adjacency Matrix'); plt.xlabel(nXlabelunit[0])\nplt.ylabel(nXlabelunit[1]); plt.xlim([nXmin[0],nXmax[0]]); plt.ylim([nXmin[1],nXmax[1]]); add_grid()\nfor icon in range(0,len(connect)):\n    i,j = connect[icon]\n    plt.plot([df[nXname[0]][i],df[nXname[0]][j]],[df[nXname[1]][i],df[nXname[1]][j]],color='grey',lw=0.5,zorder=1)\nplt.legend(loc='lower right')\n\nplt.subplot(223)                                              # plot the cluster groups histograms \nN, bins, patches  = plt.hist(df['Spectral'],alpha=0.8,edgecolor=\"black\",range=[min_cluster-0.5,max_cluster-0.5],\n    bins=np.insert(np.linspace(min_cluster,max_cluster,len(cluster_list))+0.5,0,min_cluster-0.5),density = True)\nfor i in range(0,len(cluster_list)):\n    patches[i].set_facecolor(cmap((cluster_list[i]-min_cluster)/(max_cluster-min_cluster)));\nax = plt.gca(); ax.set_xticks(cluster_list); plt.xlabel('Spectral Clusters'); plt.ylabel('Proportion'); plt.title('Spectral Clustering Groups')\nplt.xlim([0.5,K+0.5]); plt.ylim([0,1]); add_grid()   \n\nplt.subplots_adjust(left=0.0, bottom=0.0, right=2.0, top=2.1, wspace=0.2, hspace=0.2) \n```", "```py\nnew_vertices = [(20,32),(16,30)]                              # add new vertices\nconnect2 = connect + new_vertices\n\nA2 = np.zeros((len(df),len(df)))                              # declare the adjacency and degree matrices\n\nfor icon in range(0,len(connect2)):\n    A2[connect2[icon][0],connect2[icon][1]] = 1.0\n    A2[connect2[icon][1],connect2[icon][0]] = 1.0\n\nK = 3                                                         # spectral clustering with the new graph\nspectral2 = SpectralClustering(n_clusters=K,assign_labels=\"kmeans\",affinity='precomputed', random_state=seed).fit(A2)\n\ndf['Spectral2'] = spectral2.labels_ + 1\ncluster_list = np.unique(df['Spectral2']); min_cluster = min(cluster_list); max_cluster = max(cluster_list)\n\ncmap = plt.cm.inferno\n\nplt.subplot(121)                                              # plot the clusters and graph\nfor k in range(1,K+1):    \n    plt.scatter(df[df['Spectral2']==k][Xname[0]], df[df['Spectral2']==k][Xname[1]],color=cmap((k-1)/(K-1)),alpha = 1.0,\n        linewidths=1.0, edgecolors=\"black\", cmap = cmap,label = 'Cluster ' + str(k),vmin=0,vmax=K,zorder=10)\nplt.title(Xname[1] + ' vs. ' + Xname[1] + ' with Spectral Clustering & New Connections'); plt.xlabel(Xlabelunit[0]); plt.ylabel(Xlabelunit[1])\nplt.xlim([Xmin[0],Xmax[0]]); plt.ylim([Xmin[1],Xmax[1]]); add_grid()\nplt.gca().yaxis.set_major_formatter(FuncFormatter(comma_format))\nfor icon in range(0,len(connect)):\n    i,j = connect[icon]\n    plt.plot([df[Xname[0]][i],df[Xname[0]][j]],[df[Xname[1]][i],df[Xname[1]][j]],color='grey',lw=0.5,zorder=1)\nfor icon in range(0,len(new_vertices)):\n    i,j = new_vertices[icon]\n    if icon == 1:\n        plt.plot([df[Xname[0]][i],df[Xname[0]][j]],[df[Xname[1]][i],df[Xname[1]][j]],color='red',lw=1.0,zorder=1,label='New Connection')\n    else:\n        plt.plot([df[Xname[0]][i],df[Xname[0]][j]],[df[Xname[1]][i],df[Xname[1]][j]],color='red',lw=1.0,zorder=1)\nplt.legend(loc='lower right')\n\nplt.subplot(122)                                              # plot the clustering and graph\nfor k in range(1,K+1):    \n    plt.scatter(df[df['Spectral']==k][Xname[0]], df[df['Spectral']==k][Xname[1]],color=cmap((k-1)/(K-1)),alpha = 1.0,\n        linewidths=1.0, edgecolors=\"black\", cmap = cmap,label = 'Cluster ' + str(k),vmin=0,vmax=K,zorder=10)\nplt.title(Xname[1] + ' vs. ' + Xname[1] + ' with Spectral Clustering'); plt.xlabel(Xlabelunit[0]); plt.ylabel(Xlabelunit[1])\nplt.xlim([Xmin[0],Xmax[0]]); plt.ylim([Xmin[1],Xmax[1]]); add_grid()\nplt.gca().yaxis.set_major_formatter(FuncFormatter(comma_format))\nfor icon in range(0,len(connect)):\n    i,j = connect[icon]\n    plt.plot([df[Xname[0]][i],df[Xname[0]][j]],[df[Xname[1]][i],df[Xname[1]][j]],color='grey',lw=0.5,zorder=1)\nplt.legend(loc='lower right')\n\nplt.subplots_adjust(left=0.0, bottom=0.0, right=2.0, top=1.1, wspace=0.2, hspace=0.2) \n```", "```py\nK = 3; gamma = 1.0\nspectral = SpectralClustering(n_clusters=K,assign_labels=\"kmeans\",affinity = 'rbf',\n                               gamma = gamma,random_state=seed).fit(df[[nXname[0],nXname[1]]].values)\ndf['Spectral3'] = spectral.labels_ + 1\ncluster_list = np.unique(df['Spectral3']); min_cluster = min(cluster_list); max_cluster = max(cluster_list)\n\ncmap = plt.cm.inferno\n\nplt.subplot(121)                                              # plot the clusters and graph\nfor k in range(1,K+1):    \n    plt.scatter(df[df['Spectral3']==k][Xname[0]], df[df['Spectral3']==k][Xname[1]],color=cmap((k-1)/(K-1)),alpha = 1.0,\n        linewidths=1.0, edgecolors=\"black\", cmap = cmap,label = 'Cluster ' + str(k),vmin=0,vmax=K,zorder=10)\nplt.title(Xname[1] + ' vs. ' + Xname[1] + ' with Spectral Clustering'); plt.xlabel(Xlabelunit[0]); plt.ylabel(Xlabelunit[1])\nplt.xlim([Xmin[0],Xmax[0]]); plt.ylim([Xmin[1],Xmax[1]]); add_grid()\nplt.gca().yaxis.set_major_formatter(FuncFormatter(comma_format)); plt.legend(loc='lower right')\n\nplt.subplot(122)                                              # plot the cluster and graph \nN, bins, patches  = plt.hist(df['Spectral3'],alpha=0.8,edgecolor=\"black\",range=[min_cluster-0.5,max_cluster-0.5],\n    bins=np.insert(np.linspace(min_cluster,max_cluster,len(cluster_list))+0.5,0,min_cluster-0.5),density = True)\nfor i in range(0,len(cluster_list)):\n    patches[i].set_facecolor(cmap((cluster_list[i]-min_cluster)/(max_cluster-min_cluster)));\nax = plt.gca(); ax.set_xticks(cluster_list); plt.xlabel('Spectral Clusters'); plt.ylabel('Proportion')\nplt.title('Spectral Clustering Groups'); plt.xlim([0.5,K+0.5]); plt.ylim([0,1]); add_grid()   \n\nplt.subplots_adjust(left=0.0, bottom=0.0, right=2.0, top=1.1, wspace=0.2, hspace=0.2) \n```", "```py\nplt.subplot(111)                                              # plot the affinity matrix \nplt.imshow(spectral.affinity_matrix_,cmap = plt.cm.gist_heat_r,vmin = 0.0, vmax = 1.0)\nplt.xlabel(r'Sample Data $\\alpha = 1, \\ldots ,n$'); plt.ylabel(r'Sample Data $\\alpha = 1, \\ldots ,n$')\nplt.subplots_adjust(left=0.0, bottom=0.0, right=1.0, top=1.1, wspace=0.2, hspace=0.2) \n```", "```py\nncluster_mat = [2,3,4] \ngamma_mat = [0.01,1.0,10] \n```", "```py\nncluster_mat = [2,3,4]                                        # spectral clustering with RBF kernel affinity cases\ngamma_mat = [0.01,1.0,10]\nindex = 1\nfor ncluster in ncluster_mat:\n    for gamma in gamma_mat:\n        spectral = SpectralClustering(n_clusters=ncluster,assign_labels=\"kmeans\",affinity = 'rbf',\n                              gamma = gamma,n_neighbors = 200,random_state=230).fit(df[[nXname[0],nXname[1]]].values)\n        df['Spectral_test'] = spectral.labels_ + 1\n\n        plt.subplot(3,3,index)                                 \n        for k in range(1,ncluster+1):    \n            if len(df[df['Spectral_test']==k]) > 0:\n                plt.scatter(df[df['Spectral_test']==k][Xname[0]], df[df['Spectral_test']==k][Xname[1]],color=cmap((k-1)/(ncluster-1)),alpha = 1.0,\n                    linewidths=1.0, edgecolors=\"black\", cmap = cmap,label = 'Cluster ' + str(k),vmin=0,vmax=ncluster,zorder=10)\n        plt.title(Xlabel[1] + ' vs. ' + Xlabel[0] + ' with Spectral, ncluster = ' + str(ncluster) + ', RBF: gamma = ' + str(gamma)); \n        plt.xlabel(Xlabelunit[0]); plt.ylabel(Xlabelunit[1])\n        plt.xlim([Xmin[0],Xmax[0]]); plt.ylim([Xmin[1],Xmax[1]]); add_grid()\n        plt.gca().yaxis.set_major_formatter(FuncFormatter(comma_format))\n        plt.legend(loc='lower right')\n        index = index + 1\nplt.subplots_adjust(left=0.0, bottom=0.0, right=3.0, top=3.50, wspace=0.2, hspace=0.2) \n```"]