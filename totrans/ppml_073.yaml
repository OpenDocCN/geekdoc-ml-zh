- en: HashMap
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 原文：[https://rust-exercises.com/100-exercises/06_ticket_management/15_hashmap.html](https://rust-exercises.com/100-exercises/06_ticket_management/15_hashmap.html)
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'Our implementation of `Index`/`IndexMut` is not ideal: we need to iterate over
    the entire `Vec` to retrieve a ticket by id; the algorithmic complexity is `O(n)`,
    where `n` is the number of tickets in the store.'
  prefs: []
  type: TYPE_NORMAL
- en: 'We can do better by using a different data structure for storing tickets: a
    `HashMap<K, V>`.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: '`HashMap` works with key-value pairs. It''s generic over both: `K` is the generic
    parameter for the key type, while `V` is the one for the value type.'
  prefs: []
  type: TYPE_NORMAL
- en: The expected cost of insertions, retrievals and removals is **constant**, `O(1)`.
    That sounds perfect for our usecase, doesn't it?
  prefs: []
  type: TYPE_NORMAL
- en: '[Key requirements](#key-requirements)'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'There are no trait bounds on `HashMap`''s struct definition, but you''ll find
    some on its methods. Let''s look at `insert`, for example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: The key type must implement the `Eq` and `Hash` traits.
  prefs: []
  type: TYPE_NORMAL
- en: Let's dig into those two.
  prefs: []
  type: TYPE_NORMAL
- en: '[`Hash`](#hash)'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A hashing function (or hasher) maps a potentially infinite set of a values (e.g.
    all possible strings) to a bounded range (e.g. a `u64` value).
  prefs: []
  type: TYPE_NORMAL
- en: There are many different hashing functions around, each with different properties
    (speed, collision risk, reversibility, etc.).
  prefs: []
  type: TYPE_NORMAL
- en: A `HashMap`, as the name suggests, uses a hashing function behind the scene.
    It hashes your key and then uses that hash to store/retrieve the associated value.
    This strategy requires the key type must be hashable, hence the `Hash` trait bound
    on `K`.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can find the `Hash` trait in the `std::hash` module:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'You will rarely implement `Hash` manually. Most of the times you''ll derive
    it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: '[`Eq`](#eq)'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '`HashMap` must be able to compare keys for equality. This is particularly important
    when dealing with hash collisions—i.e. when two different keys hash to the same
    value.'
  prefs: []
  type: TYPE_NORMAL
- en: 'You may wonder: isn''t that what the `PartialEq` trait is for? Almost!'
  prefs: []
  type: TYPE_NORMAL
- en: '`PartialEq` is not enough for `HashMap` because it doesn''t guarantee reflexivity,
    i.e. `a == a` is always `true`.'
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, floating point numbers (`f32` and `f64`) implement `PartialEq`,
    but they don''t satisfy the reflexivity property: `f32::NAN == f32::NAN` is `false`.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Reflexivity is crucial for `HashMap` to work correctly: without it, you wouldn''t
    be able to retrieve a value from the map using the same key you used to insert
    it.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The `Eq` trait extends `PartialEq` with the reflexivity property:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'It''s a marker trait: it doesn''t add any new methods, it''s just a way for
    you to say to the compiler that the equality logic implemented in `PartialEq`
    is reflexive.'
  prefs: []
  type: TYPE_NORMAL
- en: 'You can derive `Eq` automatically when you derive `PartialEq`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: '[`Eq` and `Hash` are linked](#eq-and-hash-are-linked)'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'There is an implicit contract between `Eq` and `Hash`: if two keys are equal,
    their hashes must be equal too. This is crucial for `HashMap` to work correctly.
    If you break this contract, you''ll get nonsensical results when using `HashMap`.'
  prefs: []
  type: TYPE_NORMAL
- en: '[Exercise](#exercise)'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The exercise for this section is located in [`06_ticket_management/15_hashmap`](https://github.com/mainmatter/100-exercises-to-learn-rust/tree/main/exercises/06_ticket_management/15_hashmap)
  prefs: []
  type: TYPE_NORMAL
