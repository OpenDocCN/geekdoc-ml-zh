<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.1//EN"
  "http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd">

<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<title>Copying values, pt. 1</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1>Copying values, pt. 1</h1>
<blockquote>原文：<a href="https://rust-exercises.com/100-exercises/04_traits/11_clone.html">https://rust-exercises.com/100-exercises/04_traits/11_clone.html</a></blockquote>
                        
<p>In the previous chapter we introduced ownership and borrowing.<br/>
We stated, in particular, that:</p>
<ul>
<li>Every value in Rust has a single owner at any given time.</li>
<li>When a function takes ownership of a value ("it consumes it"), the caller can't use that value anymore.</li>
</ul>
<p>These restrictions can be somewhat limiting.<br/>
Sometimes we might have to call a function that takes ownership of a value, but we still need to use
that value afterward.</p>
<pre><code class="language-rust">fn consumer(s: String) { /* */ }

fn example() {
     let mut s = String::from("hello");
     consumer(s);
     s.push_str(", world!"); // error: value borrowed here after move
}</code></pre>
<p>That's where <code>Clone</code> comes in.</p>
<h2 id="clone"><a class="header" href="#clone"><code>Clone</code></a></h2>
<p><code>Clone</code> is a trait defined in Rust's standard library:</p>
<pre><code class="language-rust">pub trait Clone {
    fn clone(&amp;self) -&gt; Self;
}</code></pre>
<p>Its method, <code>clone</code>, takes a reference to <code>self</code> and returns a new <strong>owned</strong> instance of the same type.</p>
<h2 id="in-action"><a class="header" href="#in-action">In action</a></h2>
<p>Going back to the example above, we can use <code>clone</code> to create a new <code>String</code> instance before calling <code>consumer</code>:</p>
<pre><code class="language-rust">fn consumer(s: String) { /* */ }

fn example() {
     let mut s = String::from("hello");
     let t = s.clone();
     consumer(t);
     s.push_str(", world!"); // no error
}</code></pre>
<p>Instead of giving ownership of <code>s</code> to <code>consumer</code>, we create a new <code>String</code> (by cloning <code>s</code>) and give
that to <code>consumer</code> instead.<br/>
<code>s</code> remains valid and usable after the call to <code>consumer</code>.</p>
<h2 id="in-memory"><a class="header" href="#in-memory">In memory</a></h2>
<p>Let's look at what happened in memory in the example above.
When <code>let mut s = String::from("hello");</code> is executed, the memory looks like this:</p>
<pre><code class="language-text">                    s
      +---------+--------+----------+
Stack | pointer | length | capacity | 
      |  |      |   5    |    5     |
      +--|------+--------+----------+
         |
         |
         v
       +---+---+---+---+---+
Heap:  | H | e | l | l | o |
       +---+---+---+---+---+
</code></pre>
<p>When <code>let t = s.clone()</code> is executed, a whole new region is allocated on the heap to store a copy of the data:</p>
<pre><code class="language-text">                    s                                    t
      +---------+--------+----------+      +---------+--------+----------+
Stack | pointer | length | capacity |      | pointer | length | capacity |
      |  |      |   5    |    5     |      |  |      |   5    |    5     |
      +--|------+--------+----------+      +--|------+--------+----------+
         |                                    |
         |                                    |
         v                                    v
       +---+---+---+---+---+                +---+---+---+---+---+
Heap:  | H | e | l | l | o |                | H | e | l | l | o |
       +---+---+---+---+---+                +---+---+---+---+---+
</code></pre>
<p>If you're coming from a language like Java, you can think of <code>clone</code> as a way to create a deep copy of an object.</p>
<h2 id="implementing-clone"><a class="header" href="#implementing-clone">Implementing <code>Clone</code></a></h2>
<p>To make a type <code>Clone</code>-able, we have to implement the <code>Clone</code> trait for it.<br/>
You almost always implement <code>Clone</code> by deriving it:</p>
<pre><code class="language-rust">#[derive(Clone)]
struct MyType {
    // fields
}</code></pre>
<p>The compiler implements <code>Clone</code> for <code>MyType</code> as you would expect: it clones each field of <code>MyType</code> individually and
then constructs a new <code>MyType</code> instance using the cloned fields.<br/>
Remember that you can use <code>cargo expand</code> (or your IDE) to explore the code generated by <code>derive</code> macros.</p>
<h2 id="exercise"><a class="header" href="#exercise">Exercise</a></h2>
<p>The exercise for this section is located in <a href="https://github.com/mainmatter/100-exercises-to-learn-rust/tree/main/exercises/04_traits/11_clone"><code>04_traits/11_clone</code></a></p>

                        
</body>
</html>