["```py\nlibrary(microbenchmark)\nlibrary(doBy)\n\n# define the estimators.\nbetaEX =  function(y, X) solve(crossprod(X)) %*%  t(X) %*%  y\nbetaQR =  function(y, X) qr.solve(X, y)\n# define the grid of input sizes to examine.\nnn =  c(1, 2, 5, 10, 20, 50, 100) *  1000\npp =  c(10, 20, 50, 100, 200, 500)\n# a data frame to store the running times.\ntime =  data.frame(\n expand.grid(n = nn, p = pp, betahat = c(\"EX\", \"QR\")),\n lq = NA, mean = NA, uq = NA\n)\n# quantiles defining a 90% confidence band.\nlq =  function(x) quantile(x, 0.05)\nuq =  function(x) quantile(x, 0.95)\n# for all combinations of input sizes...\nfor (n in nn) {\n for (p in pp) {\n # ... measure the running time averaging over 100 runs...\n bench =  microbenchmark(betaEX(y, X), betaQR(y, X),\n times = 100,\n control = list(warmup = 10),\n setup = {\n X =  matrix(rnorm(n *  p), nrow = n, ncol = p)\n y =  X %*%  rnorm(ncol(X))\n })\n # ... and save the results for later analyses.\n time[time$n ==  n &  time$p ==  p, c(\"lq\", \"mean\", \"uq\")] =\n summaryBy(time ~  expr, data = bench,\n FUN = c(lq, mean, uq))[, -1]\n }#FOR\n}#FOR\n```", "```py\n# rescale to make the coefficients easier to interpret.\ntime$mean =  time$mean *  10^(-9)\ntime$n =  time$n /  1000\nbigO.EX =  lm(mean ~  I(p^3) +  I((n +  1) *  p^2) +  I(n *  p),\n data = subset(time, betahat == \"EX\"))\ncoefficients(bigO.EX)\n```", "```py\n##      (Intercept)           I(p^3) I((n + 1) * p^2)\n##    -0.0120329302    -0.0000000025     0.0000017156\n##         I(n * p)\n##     0.0000244271\n```", "```py\nbigO.QR =  lm(mean ~  I((n +  1) *  p^2) +  I(n *  p),\n data = subset(time, betahat == \"QR\"))\ncoefficients(bigO.QR)\n```", "```py\n##      (Intercept) I((n + 1) * p^2)         I(n * p)\n##       -0.1103315        0.0000013        0.0000502\n```", "```py\nlibrary(Matrix)\nm =  Matrix(c(0, 0, 2:0), 3, 5)\nm\n```", "```py\n## 3 x 5 sparse Matrix of class \"dgCMatrix\"\n##\n## [1,] . 1 . . 2\n## [2,] . . 2 . 1\n## [3,] 2 . 1 . .\n```", "```py\nstr(m)\n```", "```py\n## Formal class 'dgCMatrix' [package \"Matrix\"] with 6 slots\n##   ..@ i       : int [1:6] 2 0 1 2 0 1\n##   ..@ p       : int [1:6] 0 1 2 4 4 6\n##   ..@ Dim     : int [1:2] 3 5\n##   ..@ Dimnames:List of 2\n##   .. ..$ : NULL\n##   .. ..$ : NULL\n##   ..@ x       : num [1:6] 2 1 2 1 2 1\n##   ..@ factors : list()\n```", "```py\nread10 =  function(m) m[sample(length(m), 10)]\nwrite10 =  function(m) m[sample(length(m), 10)] =  1\n[...]\nfor (z in zz) {\n bench =  microbenchmark(\n read10(sparse), read10(dense),\n write10(sparse), write10(dense),\n times = 200,\n control = list(warmup = 10),\n setup = {\n sparse =  Matrix(0, n, n)\n sparse[sample(length(sparse), round(z))] =  1\n dense =  matrix(0, n, n)\n })\n [...]\n}#FOR\n```", "```py\nlibrary(bnlearn)\n\nmelancon =  function(nodes, n) {\n # step (1)\n dag =  empty.graph(nodes)\n adjmat =  matrix(0, nrow = length(nodes), ncol = length(nodes),\n dimnames = list(nodes, nodes))\n # step (2)\n ret =  vector(n, mode = \"list\")\n for (i in seq(n)) {\n # step (3a)\n candidate.arc =  sample(nodes, 2, replace = FALSE)\n # step (3b)\n if (adjmat[candidate.arc[1], candidate.arc[2]] ==  1) {\n adjmat[candidate.arc[1], candidate.arc[2]] =  0\n amat(dag) =  adjmat\n }#THEN\n else {\n # step (3c)\n if (!path.exists(dag, from = candidate.arc[2],\n to = candidate.arc[1])) {\n adjmat[candidate.arc[1], candidate.arc[2]] =  1\n amat(dag) =  adjmat\n }#THEN\n }#ELSE\n # step (3d)\n ret[[i]] =  dag\n }#FOR\n return(ret)\n}#MELANCON\n```"]