["```py\n#include <LSM6DS3.h>\n#include <Wire.h>\n\n// Create IMU object using I2C interface\nLSM6DS3 myIMU(I2C_MODE, 0x6A);\n\nfloat accelX, accelY, accelZ;\nfloat gyroX, gyroY, gyroZ;\n\nvoid setup() {\n  Serial.begin(115200);\n  while (!Serial) delay(10);\n\n  Serial.println(\"XIAOML Kit IMU Test\");\n  Serial.println(\"LSM6DS3TR-C 6-Axis IMU\");\n  Serial.println(\"====================\");\n\n  // Initialize the IMU\n  if (myIMU.begin() != 0) {\n      Serial.println(\"ERROR: IMU initialization failed!\");\n      while(1) delay(1000);\n  } else {\n      Serial.println(\"âœ“ IMU initialized successfully\");\n      Serial.println(\"Data Format: AccelX,AccelY,AccelZ,\"\n                    \"GyroX,GyroY,GyroZ\");\n      Serial.println(\"Units: g-force, degrees/second\");\n      Serial.println();\n  }\n}\n\nvoid loop() {\n  // Read accelerometer data (in g-force)\n  accelX = myIMU.readFloatAccelX();\n  accelY = myIMU.readFloatAccelY();\n  accelZ = myIMU.readFloatAccelZ();\n\n  // Read gyroscope data (in degrees per second)\n  gyroX = myIMU.readFloatGyroX();\n  gyroY = myIMU.readFloatGyroY();\n  gyroZ = myIMU.readFloatGyroZ();\n\n  // Print readable format\n  Serial.print(\"Accel (g): X=\"); Serial.print(accelX, 3);\n  Serial.print(\" Y=\"); Serial.print(accelY, 3);\n  Serial.print(\" Z=\"); Serial.print(accelZ, 3);\n  Serial.print(\" | Gyro (Â°/s): X=\"); Serial.print(gyroX, 2);\n  Serial.print(\" Y=\"); Serial.print(gyroY, 2);\n  Serial.print(\" Z=\"); Serial.println(gyroZ, 2);\n\n  delay(100); // 10 Hz update rate\n}\n```", "```py\n#include <LSM6DS3.h>\n#include <Wire.h>\n\n#define FREQUENCY_HZ 50\n#define INTERVAL_MS (1000  /  (FREQUENCY_HZ  +  1))\n\nLSM6DS3 myIMU(I2C_MODE, 0x6A);\nstatic unsigned long last_interval_ms = 0;\n\nvoid setup() {\n  Serial.begin(115200);\n  while (!Serial) delay(10);\n\n  Serial.println(\"XIAOML Kit - Motion Data Collection\");\n  Serial.println(\"LSM6DS3TR-C IMU Sensor\");\n\n  // Initialize IMU\n  if (myIMU.begin() != 0) {\n      Serial.println(\"ERROR: IMU initialization failed!\");\n      while(1) delay(1000);\n  }\n\n  delay(2000);\n  Serial.println(\"Starting data collection in 3 seconds...\");\n  delay(3000);\n}\n\nvoid loop() {\n  if (millis() > last_interval_ms + INTERVAL_MS) {\n      last_interval_ms = millis();\n\n      // Read accelerometer data\n      float ax = myIMU.readFloatAccelX();\n      float ay = myIMU.readFloatAccelY();\n      float az = myIMU.readFloatAccelZ();\n\n      // Convert to m/sÂ² (multiply by 9.81)\n      float ax_ms2 = ax * 9.81;\n      float ay_ms2 = ay * 9.81;\n      float az_ms2 = az * 9.81;\n\n      // Output in Edge Impulse format\n      Serial.print(ax_ms2);\n      Serial.print(\"\\t\");\n      Serial.print(ay_ms2);\n      Serial.print(\"\\t\");\n      Serial.println(az_ms2);\n  }\n}\n```", "```py\n/* Includes -------------------------------------------- */\n#include <XIAOML_Kit_Motion_Class_-_AD_inferencing.h>\n#include <Arduino_LSM9DS1.h>\n```", "```py\n#include <XIAOML_Kit_Motion_Class_-_AD_inferencing.h>\n#include <LSM6DS3.h>\n#include <Wire.h>\n```", "```py\n// IMU setup\nLSM6DS3 myIMU(I2C_MODE, 0x6A);\n\n// Inference settings\n#define CONVERT_G_TO_MS2 9.81f\n#define MAX_ACCEPTED_RANGE 2.0f  *  CONVERT_G_TO_MS2\n```", "```py\n   // Initialize IMU\n    if (myIMU.begin() != 0) {\n        Serial.println(\"ERROR: IMU initialization failed!\");\n        return;\n    }\n```", "```py\nIMU.readAcceleration(buffer[ix], buffer[ix + 1], buffer[ix + 2]);\n```", "```py\n// Read IMU data\nfloat x = myIMU.readFloatAccelX();\nfloat y = myIMU.readFloatAccelY();\nfloat z = myIMU.readFloatAccelZ();\n```", "```py\n  // Convert to m/sÂ²\n  buffer[i + 0] = x * CONVERT_G_TO_MS2;\n  buffer[i + 1] = y * CONVERT_G_TO_MS2;\n  buffer[i + 2] = z * CONVERT_G_TO_MS2;\n\n  // Apply range limiting\n  for (int j = 0; j < 3; j++) {\n      if (fabs(buffer[i + j]) > MAX_ACCEPTED_RANGE) {\n          buffer[i + j] = copysign(MAX_ACCEPTED_RANGE, buffer[i + j]);\n      }\n  }\n```", "```py\n// Motion Classification with LSM6DS3TR-C IMU\n#include <XIAOML_Kit_Motion_Class_-_AD_inferencing.h>\n#include <LSM6DS3.h>\n#include <Wire.h>\n\n// IMU setup\nLSM6DS3 myIMU(I2C_MODE, 0x6A);\n\n// Inference settings\n#define CONVERT_G_TO_MS2 9.81f\n#define MAX_ACCEPTED_RANGE 2.0f  *  CONVERT_G_TO_MS2\n\nstatic bool debug_nn = false;\nstatic float buffer[EI_CLASSIFIER_DSP_INPUT_FRAME_SIZE] = { 0 };\nstatic float inference_buffer[EI_CLASSIFIER_DSP_INPUT_FRAME_SIZE];\n\nvoid setup() {\n    Serial.begin(115200);\n    while (!Serial) delay(10);\n\n    Serial.println(\"XIAOML Kit - Motion Classification\");\n    Serial.println(\"LSM6DS3TR-C IMU Inference\");\n\n    // Initialize IMU\n    if (myIMU.begin() != 0) {\n        Serial.println(\"ERROR: IMU initialization failed!\");\n        return;\n    }\n\n    Serial.println(\"âœ“ IMU initialized\");\n\n    if (EI_CLASSIFIER_RAW_SAMPLES_PER_FRAME != 3) {\n        Serial.println(\"ERROR: EI_CLASSIFIER_RAW_SAMPLES_PER_FRAME\"\n                       \"should be 3\");\n        return;\n    }\n\n    Serial.println(\"âœ“ Model loaded\");\n    Serial.println(\"Starting motion classification...\");\n}\n\nvoid loop() {\n    ei_printf(\"\\nStarting inferencing in 2 seconds...\\n\");\n    delay(2000);\n\n    ei_printf(\"Sampling...\\n\");\n\n    // Clear buffer\n    for (size_t i = 0; i < EI_CLASSIFIER_DSP_INPUT_FRAME_SIZE; i++) {\n        buffer[i] = 0.0f;\n    }\n\n    // Collect accelerometer data\n    for (int i = 0; i < EI_CLASSIFIER_DSP_INPUT_FRAME_SIZE; i += 3) {\n        uint64_t next_tick = micros() +\n          (EI_CLASSIFIER_INTERVAL_MS * 1000);\n\n        // Read IMU data\n        float x = myIMU.readFloatAccelX();\n        float y = myIMU.readFloatAccelY();\n        float z = myIMU.readFloatAccelZ();\n\n        // Convert to m/sÂ²\n        buffer[i + 0] = x * CONVERT_G_TO_MS2;\n        buffer[i + 1] = y * CONVERT_G_TO_MS2;\n        buffer[i + 2] = z * CONVERT_G_TO_MS2;\n\n        // Apply range limiting\n        for (int j = 0; j < 3; j++) {\n            if (fabs(buffer[i + j]) > MAX_ACCEPTED_RANGE) {\n                buffer[i + j] = copysign(MAX_ACCEPTED_RANGE,\n                                         buffer[i + j]);\n            }\n        }\n\n        delayMicroseconds(next_tick - micros());\n    }\n\n    // Copy to inference buffer\n    for (int i = 0; i < EI_CLASSIFIER_DSP_INPUT_FRAME_SIZE; i++) {\n        inference_buffer[i] = buffer[i];\n    }\n\n    // Create signal from buffer\n    signal_t signal;\n    int err = numpy::signal_from_buffer(inference_buffer,\n              EI_CLASSIFIER_DSP_INPUT_FRAME_SIZE, &signal);\n    if (err != 0) {\n        ei_printf(\"ERROR: Failed to create signal from buffer (%d)\\n\",\n                  err);\n        return;\n    }\n\n    // Run the classifier\n    ei_impulse_result_t result = { 0 };\n    err = run_classifier(&signal, &result, debug_nn);\n    if (err != EI_IMPULSE_OK) {\n        ei_printf(\"ERROR: Failed to run classifier (%d)\\n\", err);\n        return;\n    }\n\n    // Print predictions\n    ei_printf(\"Predictions (DSP: %d ms, Classification: %d ms, \"\n              \"Anomaly: %d ms):\\n\",\n        result.timing.dsp, result.timing.classification, result.timing.anomaly);\n\n    for (size_t ix = 0; ix < EI_CLASSIFIER_LABEL_COUNT; ix++) {\n        ei_printf(\" %s: %.5f\\n\", result.classification[ix].label,\n                  result.classification[ix].value);\n    }\n\n    // Print anomaly score\n#if EI_CLASSIFIER_HAS_ANOMALY == 1\n    ei_printf(\"Anomaly score: %.3f\\n\", result.anomaly);\n#endif\n\n    // Determine prediction\n    float max_confidence = 0.0;\n    String predicted_class = \"unknown\";\n\n    for (size_t ix = 0; ix < EI_CLASSIFIER_LABEL_COUNT; ix++) {\n        if (result.classification[ix].value > max_confidence) {\n            max_confidence = result.classification[ix].value;\n            predicted_class = String(result.classification[ix].label);\n        }\n    }\n\n    // Display result with confidence threshold\n    if (max_confidence > 0.6) {\n        ei_printf(\"\\nðŸŽ¯ PREDICTION: %s (%.1f%% confidence)\\n\",\n                 predicted_class.c_str(), max_confidence * 100);\n    } else {\n        ei_printf(\"\\nâ“ UNCERTAIN: Highest confidence is %s (%.1f%%)\\n\",\n                 predicted_class.c_str(), max_confidence * 100);\n    }\n\n    // Check for anomaly\n#if EI_CLASSIFIER_HAS_ANOMALY == 1\n    if (result.anomaly > 0.5) {\n        ei_printf(\"âš ï¸ ANOMALY DETECTED! Score: %.3f\\n\", result.anomaly);\n    }\n#endif\n\n    delay(1000);\n}\n\nvoid ei_printf(const char *format, ...) {\n    static char print_buf[1024] = { 0 };\n    va_list args;\n    va_start(args, format);\n    int r = vsnprintf(print_buf, sizeof(print_buf), format, args);\n    va_end(args);\n    if (r > 0) {\n        Serial.write(print_buf);\n    }\n}\n```"]