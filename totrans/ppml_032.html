<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.1//EN"
  "http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd">

<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<title>Trait bounds</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1>Trait bounds</h1>
<blockquote>原文：<a href="https://rust-exercises.com/100-exercises/04_traits/05_trait_bounds.html">https://rust-exercises.com/100-exercises/04_traits/05_trait_bounds.html</a></blockquote>
                        
<p>We've seen two use cases for traits so far:</p>
<ul>
<li>Unlocking "built-in" behaviour (e.g. operator overloading)</li>
<li>Adding new behaviour to existing types (i.e. extension traits)</li>
</ul>
<p>There's a third use case: <strong>generic programming</strong>.</p>
<h2 id="the-problem"><a class="header" href="#the-problem">The problem</a></h2>
<p>All our functions and methods, so far, have been working with <strong>concrete types</strong>.<br/>
Code that operates on concrete types is usually straightforward to write and understand. But it's also
limited in its reusability.<br/>
Let's imagine, for example, that we want to write a function that returns <code>true</code> if an integer is even.
Working with concrete types, we'd have to write a separate function for each integer type we want to
support:</p>
<pre><code class="language-rust">fn is_even_i32(n: i32) -&gt; bool {
    n % 2 == 0
}

fn is_even_i64(n: i64) -&gt; bool {
    n % 2 == 0
}

// Etc.</code></pre>
<p>Alternatively, we could write a single extension trait and then different implementations for each integer type:</p>
<pre><code class="language-rust">trait IsEven {
    fn is_even(&amp;self) -&gt; bool;
}

impl IsEven for i32 {
    fn is_even(&amp;self) -&gt; bool {
        self % 2 == 0
    }
}

impl IsEven for i64 {
    fn is_even(&amp;self) -&gt; bool {
        self % 2 == 0
    }
}

// Etc.</code></pre>
<p>The duplication remains.</p>
<h2 id="generic-programming"><a class="header" href="#generic-programming">Generic programming</a></h2>
<p>We can do better using <strong>generics</strong>.<br/>
Generics allow us to write code that works with a <strong>type parameter</strong> instead of a concrete type:</p>
<pre><code class="language-rust">fn print_if_even&lt;T&gt;(n: T)
where
    T: IsEven + Debug
{
    if n.is_even() {
        println!("{n:?} is even");
    }
}</code></pre>
<p><code>print_if_even</code> is a <strong>generic function</strong>.<br/>
It isn't tied to a specific input type. Instead, it works with any type <code>T</code> that:</p>
<ul>
<li>Implements the <code>IsEven</code> trait.</li>
<li>Implements the <code>Debug</code> trait.</li>
</ul>
<p>This contract is expressed with a <strong>trait bound</strong>: <code>T: IsEven + Debug</code>.<br/>
The <code>+</code> symbol is used to require that <code>T</code> implements multiple traits. <code>T: IsEven + Debug</code> is equivalent to
"where <code>T</code> implements <code>IsEven</code> <strong>and</strong> <code>Debug</code>".</p>
<h2 id="trait-bounds-1"><a class="header" href="#trait-bounds-1">Trait bounds</a></h2>
<p>What purpose do trait bounds serve in <code>print_if_even</code>?<br/>
To find out, let's try to remove them:</p>
<pre><code class="language-rust">fn print_if_even&lt;T&gt;(n: T) {
    if n.is_even() {
        println!("{n:?} is even");
    }
}</code></pre>
<p>This code won't compile:</p>
<pre><code class="language-text">error[E0599]: no method named `is_even` found for type parameter `T` 
              in the current scope
 --&gt; src/lib.rs:2:10
  |
1 | fn print_if_even&lt;T&gt;(n: T) {
  |                  - method `is_even` not found 
  |                    for this type parameter
2 |     if n.is_even() {
  |          ^^^^^^^ method not found in `T`

error[E0277]: `T` doesn't implement `Debug`
 --&gt; src/lib.rs:3:19
  |
3 |         println!("{n:?} is even");
  |                   ^^^^^ 
  |   `T` cannot be formatted using `{:?}` because 
  |         it doesn't implement `Debug`
  |
help: consider restricting type parameter `T`
  |
1 | fn print_if_even&lt;T: std::fmt::Debug&gt;(n: T) {
  |                   +++++++++++++++++
</code></pre>
<p>Without trait bounds, the compiler doesn't know what <code>T</code> <strong>can do</strong>.<br/>
It doesn't know that <code>T</code> has an <code>is_even</code> method, and it doesn't know how to format <code>T</code> for printing.
From the compiler point of view, a bare <code>T</code> has no behaviour at all.<br/>
Trait bounds restrict the set of types that can be used by ensuring that the behaviour required by the function
body is present.</p>
<h2 id="syntax-inlining-trait-bounds"><a class="header" href="#syntax-inlining-trait-bounds">Syntax: inlining trait bounds</a></h2>
<p>All the examples above used a <strong><code>where</code> clause</strong> to specify trait bounds:</p>
<pre><code class="language-rust">fn print_if_even&lt;T&gt;(n: T)
where
    T: IsEven + Debug
//  ^^^^^^^^^^^^^^^^^
//  This is a `where` clause
{
    // [...]
}</code></pre>
<p>If the trait bounds are simple, you can <strong>inline</strong> them directly next to the type parameter:</p>
<pre><code class="language-rust">fn print_if_even&lt;T: IsEven + Debug&gt;(n: T) {
    //           ^^^^^^^^^^^^^^^^^
    //           This is an inline trait bound
    // [...]
}</code></pre>
<h2 id="syntax-meaningful-names"><a class="header" href="#syntax-meaningful-names">Syntax: meaningful names</a></h2>
<p>In the examples above, we used <code>T</code> as the type parameter name. This is a common convention when a function has
only one type parameter.<br/>
Nothing stops you from using a more meaningful name, though:</p>
<pre><code class="language-rust">fn print_if_even&lt;Number: IsEven + Debug&gt;(n: Number) {
    // [...]
}</code></pre>
<p>It is actually <strong>desirable</strong> to use meaningful names when there are multiple type parameters at play or when the name
<code>T</code> doesn't convey enough information about the type's role in the function.
Maximize clarity and readability when naming type parameters, just as you would with variables or function parameters.
Follow Rust's conventions, though: use <a href="https://rust-lang.github.io/api-guidelines/naming.html#casing-conforms-to-rfc-430-c-case">upper camel case for type parameter names</a>.</p>
<h2 id="the-function-signature-is-king"><a class="header" href="#the-function-signature-is-king">The function signature is king</a></h2>
<p>You may wonder why we need trait bounds at all. Can't the compiler infer the required traits from the function's body?<br/>
It could, but it won't.<br/>
The rationale is the same as for <a href="/100-exercises/02_basic_calculator/02_variables#function-arguments-are-variables">explicit type annotations on function parameters</a>:
each function signature is a contract between the caller and the callee, and the terms must be explicitly stated.
This allows for better error messages, better documentation, less unintentional breakages across versions,
and faster compilation times.</p>
<h2 id="exercise"><a class="header" href="#exercise">Exercise</a></h2>
<p>The exercise for this section is located in <a href="https://github.com/mainmatter/100-exercises-to-learn-rust/tree/main/exercises/04_traits/05_trait_bounds"><code>04_traits/05_trait_bounds</code></a></p>

                        
</body>
</html>