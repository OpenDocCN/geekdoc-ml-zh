<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.1//EN"
  "http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd">

<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<title>Heap</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1>Heap</h1>
<blockquote>原文：<a href="https://rust-exercises.com/100-exercises/03_ticket_v1/09_heap.html">https://rust-exercises.com/100-exercises/03_ticket_v1/09_heap.html</a></blockquote>
                        
<p>The stack is great, but it can't solve all our problems. What about data whose size is not known at compile time?
Collections, strings, and other dynamically-sized data cannot be (entirely) stack-allocated.
That's where the <strong>heap</strong> comes in.</p>
<h2 id="heap-allocations"><a class="header" href="#heap-allocations">Heap allocations</a></h2>
<p>You can visualize the heap as a big chunk of memory—a huge array, if you will.<br/>
Whenever you need to store data on the heap, you ask a special program, the <strong>allocator</strong>, to reserve for you
a subset of the heap. We call this interaction (and the memory you reserved) a <strong>heap allocation</strong>.
If the allocation succeeds, the allocator will give you a <strong>pointer</strong> to the start of the reserved block.</p>
<h2 id="no-automatic-de-allocation"><a class="header" href="#no-automatic-de-allocation">No automatic de-allocation</a></h2>
<p>The heap is structured quite differently from the stack.<br/>
Heap allocations are not contiguous, they can be located anywhere inside the heap.</p>
<pre><code>+---+---+---+---+---+---+-...-+-...-+---+---+---+---+---+---+---+
|  Allocation 1 | Free  | ... | ... |  Allocation N |    Free   |
+---+---+---+---+---+---+ ... + ... +---+---+---+---+---+---+---+
</code></pre>
<p>It's the allocator's job to keep track of which parts of the heap are in use and which are free.
The allocator won't automatically free the memory you allocated, though: you need to be deliberate about it,
calling the allocator again to <strong>free</strong> the memory you no longer need.</p>
<h2 id="performance"><a class="header" href="#performance">Performance</a></h2>
<p>The heap's flexibility comes at a cost: heap allocations are <strong>slower</strong> than stack allocations.
There's a lot more bookkeeping involved!<br/>
If you read articles about performance optimization you'll often be advised to minimize heap allocations
and prefer stack-allocated data whenever possible.</p>
<h2 id="strings-memory-layout"><a class="header" href="#strings-memory-layout"><code>String</code>'s memory layout</a></h2>
<p>When you create a local variable of type <code>String</code>,
Rust is forced to allocate on the heap<sup class="footnote-reference" id="fr-empty-1"><a href="#footnote-empty">1</a></sup>: it doesn't know in advance how much text you're going to put in it,
so it can't reserve the right amount of space on the stack.<br/>
But a <code>String</code> is not <em>entirely</em> heap-allocated, it also keeps some data on the stack. In particular:</p>
<ul>
<li>The <strong>pointer</strong> to the heap region you reserved.</li>
<li>The <strong>length</strong> of the string, i.e. how many bytes are in the string.</li>
<li>The <strong>capacity</strong> of the string, i.e. how many bytes have been reserved on the heap.</li>
</ul>
<p>Let's look at an example to understand this better:</p>
<pre><code class="language-rust">let mut s = String::with_capacity(5);</code></pre>
<p>If you run this code, memory will be laid out like this:</p>
<pre><code>      +---------+--------+----------+
Stack | pointer | length | capacity | 
      |  |      |   0    |    5     |
      +--|------+--------+----------+
         |
         |
         v
       +---+---+---+---+---+
Heap:  | ? | ? | ? | ? | ? |
       +---+---+---+---+---+
</code></pre>
<p>We asked for a <code>String</code> that can hold up to 5 bytes of text.<br/>
<code>String::with_capacity</code> goes to the allocator and asks for 5 bytes of heap memory. The allocator returns
a pointer to the start of that memory block.<br/>
The <code>String</code> is empty, though. On the stack, we keep track of this information by distinguishing between
the length and the capacity: this <code>String</code> can hold up to 5 bytes, but it currently holds 0 bytes of
actual text.</p>
<p>If you push some text into the <code>String</code>, the situation will change:</p>
<pre><code class="language-rust">s.push_str("Hey");</code></pre>
<pre><code>      +---------+--------+----------+
Stack | pointer | length | capacity |
      |  |      |   3    |    5     |
      +--|  ----+--------+----------+
         |
         |
         v
       +---+---+---+---+---+
Heap:  | H | e | y | ? | ? |
       +---+---+---+---+---+
</code></pre>
<p><code>s</code> now holds 3 bytes of text. Its length is updated to 3, but capacity remains 5.
Three of the five bytes on the heap are used to store the characters <code>H</code>, <code>e</code>, and <code>y</code>.</p>
<h3 id="usize"><a class="header" href="#usize"><code>usize</code></a></h3>
<p>How much space do we need to store pointer, length and capacity on the stack?<br/>
It depends on the <strong>architecture</strong> of the machine you're running on.</p>
<p>Every memory location on your machine has an <a href="https://en.wikipedia.org/wiki/Memory_address"><strong>address</strong></a>, commonly
represented as an unsigned integer.
Depending on the maximum size of the address space (i.e. how much memory your machine can address),
this integer can have a different size. Most modern machines use either a 32-bit or a 64-bit address space.</p>
<p>Rust abstracts away these architecture-specific details by providing the <code>usize</code> type:
an unsigned integer that's as big as the number of bytes needed to address memory on your machine.
On a 32-bit machine, <code>usize</code> is equivalent to <code>u32</code>. On a 64-bit machine, it matches <code>u64</code>.</p>
<p>Capacity, length and pointers are all represented as <code>usize</code>s in Rust<sup class="footnote-reference" id="fr-equivalence-1"><a href="#footnote-equivalence">2</a></sup>.</p>
<h3 id="no-stdmemsize_of-for-the-heap"><a class="header" href="#no-stdmemsize_of-for-the-heap">No <code>std::mem::size_of</code> for the heap</a></h3>
<p><code>std::mem::size_of</code> returns the amount of space a type would take on the stack,
which is also known as the <strong>size of the type</strong>.</p>
<blockquote>
<p>What about the memory buffer that <code>String</code> is managing on the heap? Isn't that
part of the size of <code>String</code>?</p>
</blockquote>
<p>No!<br/>
That heap allocation is a <strong>resource</strong> that <code>String</code> is managing.
It's not considered to be part of the <code>String</code> type by the compiler.</p>
<p><code>std::mem::size_of</code> doesn't know (or care) about additional heap-allocated data
that a type might manage or refer to via pointers, as is the case with <code>String</code>,
therefore it doesn't track its size.</p>
<p>Unfortunately there is no equivalent of <code>std::mem::size_of</code> to measure the amount of
heap memory that a certain value is allocating at runtime. Some types might
provide methods to inspect their heap usage (e.g. <code>String</code>'s <code>capacity</code> method),
but there is no general-purpose "API" to retrieve runtime heap usage in Rust.<br/>
You can, however, use a memory profiler tool (e.g. <a href="https://valgrind.org/docs/manual/dh-manual.html">DHAT</a>
or <a href="https://docs.rs/dhat/latest/dhat/">a custom allocator</a>) to inspect the heap usage of your program.</p>
<h2 id="exercise"><a class="header" href="#exercise">Exercise</a></h2>
<p>The exercise for this section is located in <a href="https://github.com/mainmatter/100-exercises-to-learn-rust/tree/main/exercises/03_ticket_v1/09_heap"><code>03_ticket_v1/09_heap</code></a></p>
<hr/>
<ol class="footnote-definition"><li id="footnote-empty">
<p><code>std</code> doesn't allocate if you create an <strong>empty</strong> <code>String</code> (i.e. <code>String::new()</code>).
Heap memory will be reserved when you push data into it for the first time. <a href="#fr-empty-1">↩</a></p>
</li>
<li id="footnote-equivalence">
<p>The size of a pointer depends on the operating system too.
In certain environments, a pointer is <strong>larger</strong> than a memory address (e.g. <a href="https://web.archive.org/web/20240517051950/https://blog.acolyer.org/2019/05/28/cheri-abi/">CHERI</a>).
Rust makes the simplifying assumption that pointers are the same size as memory addresses,
which is true for most modern systems you're likely to encounter. <a href="#fr-equivalence-1">↩</a></p>
</li>
</ol>
                        
</body>
</html>