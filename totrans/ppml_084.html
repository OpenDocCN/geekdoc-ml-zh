<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.1//EN"
  "http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd">

<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<title>Bounded vs unbounded channels</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1>Bounded vs unbounded channels</h1>
<blockquote>原文：<a href="https://rust-exercises.com/100-exercises/07_threads/09_bounded.html">https://rust-exercises.com/100-exercises/07_threads/09_bounded.html</a></blockquote>
                        
<p>So far we've been using unbounded channels.<br/>
You can send as many messages as you want, and the channel will grow to accommodate them.<br/>
In a multi-producer single-consumer scenario, this can be problematic: if the producers
enqueue messages at a faster rate than the consumer can process them, the channel will
keep growing, potentially consuming all available memory.</p>
<p>Our recommendation is to <strong>never</strong> use an unbounded channel in a production system.<br/>
You should always enforce an upper limit on the number of messages that can be enqueued using a
<strong>bounded channel</strong>.</p>
<h2 id="bounded-channels"><a class="header" href="#bounded-channels">Bounded channels</a></h2>
<p>A bounded channel has a fixed capacity.<br/>
You can create one by calling <code>sync_channel</code> with a capacity greater than zero:</p>
<pre><code class="language-rust">use std::sync::mpsc::sync_channel;

let (sender, receiver) = sync_channel(10);</code></pre>
<p><code>receiver</code> has the same type as before, <code>Receiver&lt;T&gt;</code>.<br/>
<code>sender</code>, instead, is an instance of <code>SyncSender&lt;T&gt;</code>.</p>
<h3 id="sending-messages"><a class="header" href="#sending-messages">Sending messages</a></h3>
<p>You have two different methods to send messages through a <code>SyncSender</code>:</p>
<ul>
<li><code>send</code>: if there is space in the channel, it will enqueue the message and return <code>Ok(())</code>.<br/>
If the channel is full, it will block and wait until there is space available.</li>
<li><code>try_send</code>: if there is space in the channel, it will enqueue the message and return <code>Ok(())</code>.<br/>
If the channel is full, it will return <code>Err(TrySendError::Full(value))</code>, where <code>value</code> is the message that couldn't be sent.</li>
</ul>
<p>Depending on your use case, you might want to use one or the other.</p>
<h3 id="backpressure"><a class="header" href="#backpressure">Backpressure</a></h3>
<p>The main advantage of using bounded channels is that they provide a form of <strong>backpressure</strong>.<br/>
They force the producers to slow down if the consumer can't keep up.
The backpressure can then propagate through the system, potentially affecting the whole architecture and
preventing end users from overwhelming the system with requests.</p>
<h2 id="exercise"><a class="header" href="#exercise">Exercise</a></h2>
<p>The exercise for this section is located in <a href="https://github.com/mainmatter/100-exercises-to-learn-rust/tree/main/exercises/07_threads/09_bounded"><code>07_threads/09_bounded</code></a></p>

                        
</body>
</html>