<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.1//EN"
  "http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd">

<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<title>String slices</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1>String slices</h1>
<blockquote>原文：<a href="https://rust-exercises.com/100-exercises/04_traits/06_str_slice.html">https://rust-exercises.com/100-exercises/04_traits/06_str_slice.html</a></blockquote>
                        
<p>Throughout the previous chapters you've seen quite a few <strong>string literals</strong> being used in the code,
like <code>"To-Do"</code> or <code>"A ticket description"</code>.
They were always followed by a call to <code>.to_string()</code> or <code>.into()</code>. It's time to understand why!</p>
<h2 id="string-literals"><a class="header" href="#string-literals">String literals</a></h2>
<p>You define a string literal by enclosing the raw text in double quotes:</p>
<pre><code class="language-rust">let s = "Hello, world!";</code></pre>
<p>The type of <code>s</code> is <code>&amp;str</code>, a <strong>reference to a string slice</strong>.</p>
<h2 id="memory-layout"><a class="header" href="#memory-layout">Memory layout</a></h2>
<p><code>&amp;str</code> and <code>String</code> are different types—they're not interchangeable.<br/>
Let's recall the memory layout of a <code>String</code> from our
<a href="/100-exercises/03_ticket_v1/09_heap">previous exploration</a>.
If we run:</p>
<pre><code class="language-rust">let mut s = String::with_capacity(5);
s.push_str("Hello");</code></pre>
<p>we'll get this scenario in memory:</p>
<pre><code class="language-text">      +---------+--------+----------+
Stack | pointer | length | capacity | 
      |  |      |   5    |    5     |
      +--|------+--------+----------+
         |
         |
         v
       +---+---+---+---+---+
Heap:  | H | e | l | l | o |
       +---+---+---+---+---+
</code></pre>
<p>If you remember, we've <a href="/100-exercises/03_ticket_v1/10_references_in_memory">also examined</a>
how a <code>&amp;String</code> is laid out in memory:</p>
<pre><code class="language-text">     --------------------------------------
     |                                    |         
+----v----+--------+----------+      +----|----+
| pointer | length | capacity |      | pointer |
|    |    |   5    |    5     |      |         |
+----|----+--------+----------+      +---------+
     |        s                          &amp;s 
     |       
     v       
   +---+---+---+---+---+
   | H | e | l | l | o |
   +---+---+---+---+---+
</code></pre>
<p><code>&amp;String</code> points to the memory location where the <code>String</code>'s metadata is stored.<br/>
If we follow the pointer, we get to the heap-allocated data. In particular, we get to the first byte of the string, <code>H</code>.</p>
<p>What if we wanted a type that represents a <strong>substring</strong> of <code>s</code>? E.g. <code>ello</code> in <code>Hello</code>?</p>
<h2 id="string-slices-1"><a class="header" href="#string-slices-1">String slices</a></h2>
<p>A <code>&amp;str</code> is a <strong>view</strong> into a string, a <strong>reference</strong> to a sequence of UTF-8 bytes stored elsewhere.
You can, for example, create a <code>&amp;str</code> from a <code>String</code> like this:</p>
<pre><code class="language-rust">let mut s = String::with_capacity(5);
s.push_str("Hello");
// Create a string slice reference from the `String`, 
// skipping the first byte.
let slice: &amp;str = &amp;s[1..];</code></pre>
<p>In memory, it'd look like this:</p>
<pre><code class="language-text">                    s                              slice
      +---------+--------+----------+      +---------+--------+
Stack | pointer | length | capacity |      | pointer | length |
      |    |    |   5    |    5     |      |    |    |   4    |
      +----|----+--------+----------+      +----|----+--------+
           |        s                           |  
           |                                    |
           v                                    | 
         +---+---+---+---+---+                  |
Heap:    | H | e | l | l | o |                  |
         +---+---+---+---+---+                  |
               ^                                |
               |                                |
               +--------------------------------+
</code></pre>
<p><code>slice</code> stores two pieces of information on the stack:</p>
<ul>
<li>A pointer to the first byte of the slice.</li>
<li>The length of the slice.</li>
</ul>
<p><code>slice</code> doesn't own the data, it just points to it: it's a <strong>reference</strong> to the <code>String</code>'s heap-allocated data.<br/>
When <code>slice</code> is dropped, the heap-allocated data won't be deallocated, because it's still owned by <code>s</code>.
That's why <code>slice</code> doesn't have a <code>capacity</code> field: it doesn't own the data, so it doesn't need to know how much
space it was allocated for it; it only cares about the data it references.</p>
<h2 id="str-vs-string"><a class="header" href="#str-vs-string"><code>&amp;str</code> vs <code>&amp;String</code></a></h2>
<p>As a rule of thumb, use <code>&amp;str</code> rather than <code>&amp;String</code> whenever you need a reference to textual data.<br/>
<code>&amp;str</code> is more flexible and generally considered more idiomatic in Rust code.</p>
<p>If a method returns a <code>&amp;String</code>, you're promising that there is heap-allocated UTF-8 text somewhere that
<strong>matches exactly</strong> the one you're returning a reference to.<br/>
If a method returns a <code>&amp;str</code>, instead, you have a lot more freedom: you're just saying that <em>somewhere</em> there's a
bunch of text data and that a subset of it matches what you need, therefore you're returning a reference to it.</p>
<h2 id="exercise"><a class="header" href="#exercise">Exercise</a></h2>
<p>The exercise for this section is located in <a href="https://github.com/mainmatter/100-exercises-to-learn-rust/tree/main/exercises/04_traits/06_str_slice"><code>04_traits/06_str_slice</code></a></p>

                        
</body>
</html>