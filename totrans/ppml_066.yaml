- en: impl Trait
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 原文：[https://rust-exercises.com/100-exercises/06_ticket_management/08_impl_trait.html](https://rust-exercises.com/100-exercises/06_ticket_management/08_impl_trait.html)
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '`TicketStore::to_dos` returns a `Vec<&Ticket>`.'
  prefs: []
  type: TYPE_NORMAL
- en: That signature introduces a new heap allocation every time `to_dos` is called,
    which may be unnecessary depending on what the caller needs to do with the result.
    It'd be better if `to_dos` returned an iterator instead of a `Vec`, thus empowering
    the caller to decide whether to collect the results into a `Vec` or just iterate
    over them.
  prefs: []
  type: TYPE_NORMAL
- en: That's tricky though! What's the return type of `to_dos`, as implemented below?
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: '[Unnameable types](#unnameable-types)'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The `filter` method returns an instance of `std::iter::Filter`, which has the
    following definition:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: where `I` is the type of the iterator being filtered on and `P` is the predicate
    used to filter the elements.
  prefs: []
  type: TYPE_NORMAL
- en: We know that `I` is `std::slice::Iter<'_, Ticket>` in this case, but what about
    `P`?
  prefs: []
  type: TYPE_NORMAL
- en: '`P` is a closure, an **anonymous function**. As the name suggests, closures
    don''t have a name, so we can''t write them down in our code.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Rust has a solution for this: **impl Trait**.'
  prefs: []
  type: TYPE_NORMAL
- en: '[`impl Trait`](#impl-trait-1)'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '`impl Trait` is a feature that allows you to return a type without specifying
    its name. You just declare what trait(s) the type implements, and Rust figures
    out the rest.'
  prefs: []
  type: TYPE_NORMAL
- en: 'In this case, we want to return an iterator of references to `Ticket`s:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: That's it!
  prefs: []
  type: TYPE_NORMAL
- en: '[Generic?](#generic)'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '`impl Trait` in return position is **not** a generic parameter.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Generics are placeholders for types that are filled in by the caller of the
    function. A function with a generic parameter is **polymorphic**: it can be called
    with different types, and the compiler will generate a different implementation
    for each type.'
  prefs: []
  type: TYPE_NORMAL
- en: 'That''s not the case with `impl Trait`. The return type of a function with
    `impl Trait` is **fixed** at compile time, and the compiler will generate a single
    implementation for it. This is why `impl Trait` is also called **opaque return
    type**: the caller doesn''t know the exact type of the return value, only that
    it implements the specified trait(s). But the compiler knows the exact type, there
    is no polymorphism involved.'
  prefs: []
  type: TYPE_NORMAL
- en: '[RPIT](#rpit)'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: If you read RFCs or deep-dives about Rust, you might come across the acronym
    **RPIT**.
  prefs: []
  type: TYPE_NORMAL
- en: It stands for **"Return Position Impl Trait"** and refers to the use of `impl
    Trait` in return position.
  prefs: []
  type: TYPE_NORMAL
- en: '[Exercise](#exercise)'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The exercise for this section is located in [`06_ticket_management/08_impl_trait`](https://github.com/mainmatter/100-exercises-to-learn-rust/tree/main/exercises/06_ticket_management/08_impl_trait)
  prefs: []
  type: TYPE_NORMAL
