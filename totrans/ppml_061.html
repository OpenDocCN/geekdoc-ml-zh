<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.1//EN"
  "http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd">

<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<title>Resizing</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1>Resizing</h1>
<blockquote>原文：<a href="https://rust-exercises.com/100-exercises/06_ticket_management/03_resizing.html">https://rust-exercises.com/100-exercises/06_ticket_management/03_resizing.html</a></blockquote>
                        
<p>We said that <code>Vec</code> is a "growable" vector type, but what does that mean?
What happens if you try to insert an element into a <code>Vec</code> that's already at maximum capacity?</p>
<pre><code class="language-rust">let mut numbers = Vec::with_capacity(3);
numbers.push(1);
numbers.push(2);
numbers.push(3); // Max capacity reached
numbers.push(4); // What happens here?</code></pre>
<p>The <code>Vec</code> will <strong>resize</strong> itself.<br/>
It will ask the allocator for a new (larger) chunk of heap memory, copy the elements over, and deallocate the old memory.</p>
<p>This operation can be expensive, as it involves a new memory allocation and copying all existing elements.</p>
<h2 id="vecwith_capacity"><a class="header" href="#vecwith_capacity"><code>Vec::with_capacity</code></a></h2>
<p>If you have a rough idea of how many elements you'll store in a <code>Vec</code>, you can use the <code>Vec::with_capacity</code>
method to pre-allocate enough memory upfront.<br/>
This can avoid a new allocation when the <code>Vec</code> grows, but it may waste memory if you overestimate actual usage.</p>
<p>Evaluate on a case-by-case basis.</p>
<h2 id="exercise"><a class="header" href="#exercise">Exercise</a></h2>
<p>The exercise for this section is located in <a href="https://github.com/mainmatter/100-exercises-to-learn-rust/tree/main/exercises/06_ticket_management/03_resizing"><code>06_ticket_management/03_resizing</code></a></p>

                        
</body>
</html>