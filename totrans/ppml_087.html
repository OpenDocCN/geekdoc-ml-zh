<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.1//EN"
  "http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd">

<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<title>Readers and writers</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1>Readers and writers</h1>
<blockquote>原文：<a href="https://rust-exercises.com/100-exercises/07_threads/12_rw_lock.html">https://rust-exercises.com/100-exercises/07_threads/12_rw_lock.html</a></blockquote>
                        
<p>Our new <code>TicketStore</code> works, but its read performance is not great: there can only be one client at a time
reading a specific ticket, because <code>Mutex&lt;T&gt;</code> doesn't distinguish between readers and writers.</p>
<p>We can solve the issue by using a different locking primitive: <code>RwLock&lt;T&gt;</code>.<br/>
<code>RwLock&lt;T&gt;</code> stands for <strong>read-write lock</strong>. It allows <strong>multiple readers</strong> to access the data simultaneously,
but only one writer at a time.</p>
<p><code>RwLock&lt;T&gt;</code> has two methods to acquire a lock: <code>read</code> and <code>write</code>.<br/>
<code>read</code> returns a guard that allows you to read the data, while <code>write</code> returns a guard that allows you to modify it.</p>
<pre><code class="language-rust">use std::sync::RwLock;

// An integer protected by a read-write lock
let lock = RwLock::new(0);

// Acquire a read lock on the RwLock
let guard1 = lock.read().unwrap();

// Acquire a **second** read lock
// while the first one is still active
let guard2 = lock.read().unwrap();</code></pre>
<h2 id="trade-offs"><a class="header" href="#trade-offs">Trade-offs</a></h2>
<p>On the surface, <code>RwLock&lt;T&gt;</code> seems like a no-brainer: it provides a superset of the functionality of <code>Mutex&lt;T&gt;</code>.
Why would you ever use <code>Mutex&lt;T&gt;</code> if you can use <code>RwLock&lt;T&gt;</code> instead?</p>
<p>There are two key reasons:</p>
<ul>
<li>Locking a <code>RwLock&lt;T&gt;</code> is more expensive than locking a <code>Mutex&lt;T&gt;</code>.<br/>
This is because <code>RwLock&lt;T&gt;</code> has to keep track of the number of active readers and writers, while <code>Mutex&lt;T&gt;</code>
only has to keep track of whether the lock is held or not.
This performance overhead is not an issue if there are more readers than writers, but if the workload
is write-heavy <code>Mutex&lt;T&gt;</code> might be a better choice.</li>
<li><code>RwLock&lt;T&gt;</code> can cause <strong>writer starvation</strong>.<br/>
If there are always readers waiting to acquire the lock, writers might never get a chance to run.<br/>
<code>RwLock&lt;T&gt;</code> doesn't provide any guarantees about the order in which readers and writers are granted access to the lock.
It depends on the policy implemented by the underlying OS, which might not be fair to writers.</li>
</ul>
<p>In our case, we can expect the workload to be read-heavy (since most clients will be reading tickets, not modifying them),
so <code>RwLock&lt;T&gt;</code> is a good choice.</p>
<h2 id="exercise"><a class="header" href="#exercise">Exercise</a></h2>
<p>The exercise for this section is located in <a href="https://github.com/mainmatter/100-exercises-to-learn-rust/tree/main/exercises/07_threads/12_rw_lock"><code>07_threads/12_rw_lock</code></a></p>

                        
</body>
</html>