<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.1//EN"
  "http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd">

<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<title>Iteration</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1>Iteration</h1>
<blockquote>原文：<a href="https://rust-exercises.com/100-exercises/06_ticket_management/04_iterators.html">https://rust-exercises.com/100-exercises/06_ticket_management/04_iterators.html</a></blockquote>
                        
<p>During the very first exercises, you learned that Rust lets you iterate over collections using <code>for</code> loops.
We were looking at ranges at that point (e.g. <code>0..5</code>), but the same holds true for collections like arrays and vectors.</p>
<pre><code class="language-rust">// It works for `Vec`s
let v = vec![1, 2, 3];
for n in v {
    println!("{}", n);
}

// It also works for arrays
let a: [u32; 3] = [1, 2, 3];
for n in a {
    println!("{}", n);
}</code></pre>
<p>It's time to understand how this works under the hood.</p>
<h2 id="for-desugaring"><a class="header" href="#for-desugaring"><code>for</code> desugaring</a></h2>
<p>Every time you write a <code>for</code> loop in Rust, the compiler <em>desugars</em> it into the following code:</p>
<pre><code class="language-rust">let mut iter = IntoIterator::into_iter(v);
loop {
    match iter.next() {
        Some(n) =&gt; {
            println!("{}", n);
        }
        None =&gt; break,
    }
}</code></pre>
<p><code>loop</code> is another looping construct, on top of <code>for</code> and <code>while</code>.<br/>
A <code>loop</code> block will run forever, unless you explicitly <code>break</code> out of it.</p>
<h2 id="iterator-trait"><a class="header" href="#iterator-trait"><code>Iterator</code> trait</a></h2>
<p>The <code>next</code> method in the previous code snippet comes from the <code>Iterator</code> trait.
The <code>Iterator</code> trait is defined in Rust's standard library and provides a shared interface for
types that can produce a sequence of values:</p>
<pre><code class="language-rust">trait Iterator {
    type Item;
    fn next(&amp;mut self) -&gt; Option&lt;Self::Item&gt;;
}</code></pre>
<p>The <code>Item</code> associated type specifies the type of the values produced by the iterator.</p>
<p><code>next</code> returns the next value in the sequence.<br/>
It returns <code>Some(value)</code> if there's a value to return, and <code>None</code> when there isn't.</p>
<p>Be careful: there is no guarantee that an iterator is exhausted when it returns <code>None</code>. That's only
guaranteed if the iterator implements the (more restrictive)
<a href="https://doc.rust-lang.org/std/iter/trait.FusedIterator.html"><code>FusedIterator</code></a> trait.</p>
<h2 id="intoiterator-trait"><a class="header" href="#intoiterator-trait"><code>IntoIterator</code> trait</a></h2>
<p>Not all types implement <code>Iterator</code>, but many can be converted into a type that does.<br/>
That's where the <code>IntoIterator</code> trait comes in:</p>
<pre><code class="language-rust">trait IntoIterator {
    type Item;
    type IntoIter: Iterator&lt;Item = Self::Item&gt;;
    fn into_iter(self) -&gt; Self::IntoIter;
}</code></pre>
<p>The <code>into_iter</code> method consumes the original value and returns an iterator over its elements.<br/>
A type can only have one implementation of <code>IntoIterator</code>: there can be no ambiguity as to what <code>for</code> should desugar to.</p>
<p>One detail: every type that implements <code>Iterator</code> automatically implements <code>IntoIterator</code> as well.
They just return themselves from <code>into_iter</code>!</p>
<h2 id="bounds-checks"><a class="header" href="#bounds-checks">Bounds checks</a></h2>
<p>Iterating over iterators has a nice side effect: you can't go out of bounds, by design.<br/>
This allows Rust to remove bounds checks from the generated machine code, making iteration faster.</p>
<p>In other words,</p>
<pre><code class="language-rust">let v = vec![1, 2, 3];
for n in v {
    println!("{}", n);
}</code></pre>
<p>is usually faster than</p>
<pre><code class="language-rust">let v = vec![1, 2, 3];
for i in 0..v.len() {
    println!("{}", v[i]);
}</code></pre>
<p>There are exceptions to this rule: the compiler can sometimes prove that you're not going out of bounds even
with manual indexing, thus removing the bounds checks anyway. But in general, prefer iteration to indexing
where possible.</p>
<h2 id="exercise"><a class="header" href="#exercise">Exercise</a></h2>
<p>The exercise for this section is located in <a href="https://github.com/mainmatter/100-exercises-to-learn-rust/tree/main/exercises/06_ticket_management/04_iterators"><code>06_ticket_management/04_iterators</code></a></p>

                        
</body>
</html>