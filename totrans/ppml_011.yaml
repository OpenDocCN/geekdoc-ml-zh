- en: Overflow
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 原文：[https://rust-exercises.com/100-exercises/02_basic_calculator/08_overflow.html](https://rust-exercises.com/100-exercises/02_basic_calculator/08_overflow.html)
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: The factorial of a number grows quite fast.
  prefs: []
  type: TYPE_NORMAL
- en: For example, the factorial of 20 is 2,432,902,008,176,640,000\. That's already
    bigger than the maximum value for a 32-bit integer, 2,147,483,647.
  prefs: []
  type: TYPE_NORMAL
- en: When the result of an arithmetic operation is bigger than the maximum value
    for a given integer type, we are talking about **an integer overflow**.
  prefs: []
  type: TYPE_NORMAL
- en: Integer overflows are an issue because they violate the contract for arithmetic
    operations.
  prefs: []
  type: TYPE_NORMAL
- en: The result of an arithmetic operation between two integers of a given type should
    be another integer of the same type. But the *mathematically correct result* doesn't
    fit into that integer type!
  prefs: []
  type: TYPE_NORMAL
- en: If the result is smaller than the minimum value for a given integer type, we
    refer to the event as **an integer underflow**.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: For brevity, we'll only talk about integer overflows for the rest of this section,
    but keep in mind that everything we say applies to integer underflows as well.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: The `speed` function you wrote in the ["Variables" section](/100-exercises/02_basic_calculator/02_variables)
    underflowed for some input combinations. E.g. if `end` is smaller than `start`,
    `end - start` will underflow the `u32` type since the result is supposed to be
    negative but `u32` can't represent negative numbers.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '[No automatic promotion](#no-automatic-promotion)'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: One possible approach would be automatically promote the result to a bigger
    integer type. E.g. if you're summing two `u8` integers and the result is 256 (`u8::MAX
    + 1`), Rust could choose to interpret the result as `u16`, the next integer type
    that's big enough to hold 256.
  prefs: []
  type: TYPE_NORMAL
- en: But, as we've discussed before, Rust is quite picky about type conversions.
    Automatic integer promotion is not Rust's solution to the integer overflow problem.
  prefs: []
  type: TYPE_NORMAL
- en: '[Alternatives](#alternatives)'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Since we ruled out automatic promotion, what can we do when an integer overflow
    occurs?
  prefs: []
  type: TYPE_NORMAL
- en: 'It boils down to two different approaches:'
  prefs: []
  type: TYPE_NORMAL
- en: Reject the operation
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Come up with a "sensible" result that fits into the expected integer type
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Reject the operation](#reject-the-operation)'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'This is the most conservative approach: we stop the program when an integer
    overflow occurs.'
  prefs: []
  type: TYPE_NORMAL
- en: That's done via a panic, the mechanism we've already seen in the ["Panics" section](/100-exercises/02_basic_calculator/04_panics).
  prefs: []
  type: TYPE_NORMAL
- en: '[Come up with a "sensible" result](#come-up-with-a-sensible-result)'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: When the result of an arithmetic operation is bigger than the maximum value
    for a given integer type, you can choose to **wrap around**.
  prefs: []
  type: TYPE_NORMAL
- en: If you think of all the possible values for a given integer type as a circle,
    wrapping around means that when you reach the maximum value, you start again from
    the minimum value.
  prefs: []
  type: TYPE_NORMAL
- en: For example, if you do a **wrapping addition** between 1 and 255 (=`u8::MAX`),
    the result is 0 (=`u8::MIN`). If you're working with signed integers, the same
    principle applies. E.g. adding 1 to 127 (=`i8::MAX`) with wrapping will give you
    -128 (=`i8::MIN`).
  prefs: []
  type: TYPE_NORMAL
- en: '[`overflow-checks`](#overflow-checks)'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Rust lets you, the developer, choose which approach to use when an integer overflow
    occurs. The behaviour is controlled by the `overflow-checks` profile setting.
  prefs: []
  type: TYPE_NORMAL
- en: If `overflow-checks` is set to `true`, Rust will **panic at runtime** when an
    integer operation overflows. If `overflow-checks` is set to `false`, Rust will
    **wrap around** when an integer operation overflows.
  prefs: []
  type: TYPE_NORMAL
- en: You may be wondering—what is a profile setting? Let's get into that!
  prefs: []
  type: TYPE_NORMAL
- en: '[Profiles](#profiles)'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A [**profile**](https://doc.rust-lang.org/cargo/reference/profiles.html) is
    a set of configuration options that can be used to customize the way Rust code
    is compiled.
  prefs: []
  type: TYPE_NORMAL
- en: 'Cargo provides 4 built-in profiles: `dev`, `release`, `test`, and `bench`.'
  prefs: []
  type: TYPE_NORMAL
- en: The `dev` profile is used every time you run `cargo build`, `cargo run` or `cargo
    test`. It's aimed at local development, therefore it sacrifices runtime performance
    in favor of faster compilation times and a better debugging experience.
  prefs: []
  type: TYPE_NORMAL
- en: The `release` profile, instead, is optimized for runtime performance but incurs
    longer compilation times. You need to explicitly request via the `--release` flag—e.g.
    `cargo build --release` or `cargo run --release`. The `test` profile is the default
    profile used by `cargo test`. The `test` profile inherits the settings from the
    `dev` profile. The `bench` profile is the default profile used by `cargo bench`.
    The `bench` profile inherits from the `release` profile. Use `dev` for iterative
    development and debugging, `release` for optimized production builds,
  prefs: []
  type: TYPE_NORMAL
- en: '`test` for correctness testing, and `bench` for performance benchmarking.'
  prefs: []
  type: TYPE_NORMAL
- en: '"Have you built your project in release mode?" is almost a meme in the Rust
    community.'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: It refers to developers who are not familiar with Rust and complain about its
    performance on social media (e.g. Reddit, Twitter) before realizing they haven't
    built their project in release mode.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: You can also define custom profiles or customize the built-in ones.
  prefs: []
  type: TYPE_NORMAL
- en: '[`overflow-check`](#overflow-check)'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'By default, `overflow-checks` is set to:'
  prefs: []
  type: TYPE_NORMAL
- en: '`true` for the `dev` profile'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`false` for the `release` profile'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: This is in line with the goals of the two profiles.
  prefs: []
  type: TYPE_NORMAL
- en: '`dev` is aimed at local development, so it panics in order to highlight potential
    issues as early as possible.'
  prefs: []
  type: TYPE_NORMAL
- en: '`release`, instead, is tuned for runtime performance: checking for overflows
    would slow down the program, so it prefers to wrap around.'
  prefs: []
  type: TYPE_NORMAL
- en: At the same time, having different behaviours for the two profiles can lead
    to subtle bugs.
  prefs: []
  type: TYPE_NORMAL
- en: 'Our recommendation is to enable `overflow-checks` for both profiles: it''s
    better to crash than to silently produce incorrect results. The runtime performance
    hit is negligible in most cases; if you''re working on a performance-critical
    application, you can run benchmarks to decide if it''s something you can afford.'
  prefs: []
  type: TYPE_NORMAL
- en: '[Further reading](#further-reading)'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Check out ["Myths and legends about integer overflow in Rust"](https://huonw.github.io/blog/2016/04/myths-and-legends-about-integer-overflow-in-rust/)
    for an in-depth discussion about integer overflow in Rust.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Exercise](#exercise)'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The exercise for this section is located in [`02_basic_calculator/08_overflow`](https://github.com/mainmatter/100-exercises-to-learn-rust/tree/main/exercises/02_basic_calculator/08_overflow)
  prefs: []
  type: TYPE_NORMAL
