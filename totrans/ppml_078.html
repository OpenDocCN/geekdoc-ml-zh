<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.1//EN"
  "http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd">

<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<title>Leaking data</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1>Leaking data</h1>
<blockquote>原文：<a href="https://rust-exercises.com/100-exercises/07_threads/03_leak.html">https://rust-exercises.com/100-exercises/07_threads/03_leak.html</a></blockquote>
                        
<p>The main concern around passing references to spawned threads is use-after-free bugs:
accessing data using a pointer to a memory region that's already been freed/de-allocated.<br/>
If you're working with heap-allocated data, you can avoid the issue by
telling Rust that you'll never reclaim that memory: you choose to <strong>leak memory</strong>,
intentionally.</p>
<p>This can be done, for example, using the <code>Box::leak</code> method from Rust's standard library:</p>
<pre><code class="language-rust">// Allocate a `u32` on the heap, by wrapping it in a `Box`.
let x = Box::new(41u32);
// Tell Rust that you'll never free that heap allocation
// using `Box::leak`. You can thus get back a 'static reference.
let static_ref: &amp;'static mut u32 = Box::leak(x);</code></pre>
<h2 id="data-leakage-is-process-scoped"><a class="header" href="#data-leakage-is-process-scoped">Data leakage is process-scoped</a></h2>
<p>Leaking data is dangerous: if you keep leaking memory, you'll eventually
run out and crash with an out-of-memory error.</p>
<pre><code class="language-rust">// If you leave this running for a while, 
// it'll eventually use all the available memory.
fn oom_trigger() {
    loop {
        let v: Vec&lt;usize&gt; = Vec::with_capacity(1024);
        v.leak();
    }
}</code></pre>
<p>At the same time, memory leaked via <code>leak</code> method is not truly forgotten.<br/>
The operating system can map each memory region to the process responsible for it.
When the process exits, the operating system will reclaim that memory.</p>
<p>Keeping this in mind, it can be OK to leak memory when:</p>
<ul>
<li>The amount of memory you need to leak is bounded/known upfront, or</li>
<li>Your process is short-lived and you're confident you won't exhaust
all the available memory before it exits</li>
</ul>
<p>"Let the OS deal with it" is a perfectly valid memory management strategy
if your usecase allows for it.</p>
<h2 id="exercise"><a class="header" href="#exercise">Exercise</a></h2>
<p>The exercise for this section is located in <a href="https://github.com/mainmatter/100-exercises-to-learn-rust/tree/main/exercises/07_threads/03_leak"><code>07_threads/03_leak</code></a></p>

                        
</body>
</html>