["```py\npub async fn echo(listener: TcpListener) -> Result<(), anyhow::Error> {\n    loop {\n        let (mut socket, _) = listener.accept().await?;\n        let (mut reader, mut writer) = socket.split();\n        tokio::io::copy(&mut reader, &mut writer).await?;\n    }\n}\n```", "```py\nuse tokio::net::TcpListener;\n\npub async fn echo(listener: TcpListener) -> Result<(), anyhow::Error> {\n    loop {\n        let (mut socket, _) = listener.accept().await?;\n        // Spawn a background task to handle the connection\n        // thus allowing the main task to immediately start \n        // accepting new connections\n        tokio::spawn(async move {\n            let (mut reader, mut writer) = socket.split();\n            tokio::io::copy(&mut reader, &mut writer).await?;\n        });\n    }\n}\n```", "```py\npub async fn run() {\n    // Spawn a background task to ship telemetry data\n    // to a remote server\n    let handle = tokio::spawn(emit_telemetry());\n    // In the meantime, do some other useful work\n    do_work().await;\n    // But don't return to the caller until \n    // the telemetry data has been successfully delivered\n    handle.await;\n}\n\npub async fn emit_telemetry() {\n    // [...]\n}\n\npub async fn do_work() {\n    // [...]\n}\n```", "```py\nuse tokio::task::JoinError;\n\npub async fn run() {\n    let handle = tokio::spawn(work());\n    if let Err(e) = handle.await {\n        if let Ok(reason) = e.try_into_panic() {\n            // The task has panicked\n            // We resume unwinding the panic,\n            // thus propagating it to the current task\n            panic::resume_unwind(reason);\n        }\n    }\n}\n\npub async fn work() {\n    // [...]\n}\n```"]