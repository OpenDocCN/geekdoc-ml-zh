<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" xmlns:epub="http://www.idpf.org/2007/ops" lang="en-US" xml:lang="en-US">
<head>
  <meta charset="utf-8" />
  <meta name="generator" content="pandoc" />
  <title>ch035.xhtml</title>
  <style>
    /* CSS for syntax highlighting */
    html { -webkit-text-size-adjust: 100%; }
    pre > code.sourceCode { white-space: pre; position: relative; }
    pre > code.sourceCode > span { display: inline-block; line-height: 1.25; }
    pre > code.sourceCode > span:empty { height: 1.2em; }
    .sourceCode { overflow: visible; }
    code.sourceCode > span { color: inherit; text-decoration: inherit; }
    div.sourceCode { margin: 1em 0; }
    pre.sourceCode { margin: 0; }
    @media screen {
    div.sourceCode { overflow: auto; }
    }
    @media print {
    pre > code.sourceCode { white-space: pre-wrap; }
    pre > code.sourceCode > span { text-indent: -5em; padding-left: 5em; }
    }
    pre.numberSource code
      { counter-reset: source-line 0; }
    pre.numberSource code > span
      { position: relative; left: -4em; counter-increment: source-line; }
    pre.numberSource code > span > a:first-child::before
      { content: counter(source-line);
        position: relative; left: -1em; text-align: right; vertical-align: baseline;
        border: none; display: inline-block;
        -webkit-touch-callout: none; -webkit-user-select: none;
        -khtml-user-select: none; -moz-user-select: none;
        -ms-user-select: none; user-select: none;
        padding: 0 4px; width: 4em;
        color: #aaaaaa;
      }
    pre.numberSource { margin-left: 3em; border-left: 1px solid #aaaaaa;  padding-left: 4px; }
    div.sourceCode
      { color: #003b4f; background-color: #f1f3f5; }
    @media screen {
    pre > code.sourceCode > span > a:first-child::before { text-decoration: underline; }
    }
    code span { color: #003b4f; } /* Normal */
    code span.al { color: #ad0000; } /* Alert */
    code span.an { color: #5e5e5e; } /* Annotation */
    code span.at { color: #657422; } /* Attribute */
    code span.bn { color: #ad0000; } /* BaseN */
    code span.bu { } /* BuiltIn */
    code span.cf { color: #003b4f; font-weight: bold; } /* ControlFlow */
    code span.ch { color: #20794d; } /* Char */
    code span.cn { color: #8f5902; } /* Constant */
    code span.co { color: #5e5e5e; } /* Comment */
    code span.cv { color: #5e5e5e; font-style: italic; } /* CommentVar */
    code span.do { color: #5e5e5e; font-style: italic; } /* Documentation */
    code span.dt { color: #ad0000; } /* DataType */
    code span.dv { color: #ad0000; } /* DecVal */
    code span.er { color: #ad0000; } /* Error */
    code span.ex { } /* Extension */
    code span.fl { color: #ad0000; } /* Float */
    code span.fu { color: #4758ab; } /* Function */
    code span.im { color: #00769e; } /* Import */
    code span.in { color: #5e5e5e; } /* Information */
    code span.kw { color: #003b4f; font-weight: bold; } /* Keyword */
    code span.op { color: #5e5e5e; } /* Operator */
    code span.ot { color: #003b4f; } /* Other */
    code span.pp { color: #ad0000; } /* Preprocessor */
    code span.sc { color: #5e5e5e; } /* SpecialChar */
    code span.ss { color: #20794d; } /* SpecialString */
    code span.st { color: #20794d; } /* String */
    code span.va { color: #111111; } /* Variable */
    code span.vs { color: #20794d; } /* VerbatimString */
    code span.wa { color: #5e5e5e; font-style: italic; } /* Warning */
  </style>
  <link rel="stylesheet" type="text/css" href="../styles/stylesheet1.css" />
  <style type="text/css">

  .callout {
    margin-top: 1em;
    margin-bottom: 1em;  
    border-radius: .25rem;
  }

  .callout.callout-style-simple { 
    padding: 0em 0.5em;
    border-left: solid #acacac .3rem;
    border-right: solid 1px silver;
    border-top: solid 1px silver;
    border-bottom: solid 1px silver;
    display: flex;
  }

  .callout.callout-style-default {
    border-left: solid #acacac .3rem;
    border-right: solid 1px silver;
    border-top: solid 1px silver;
    border-bottom: solid 1px silver;
  }

  .callout .callout-body-container {
    flex-grow: 1;
  }

  .callout.callout-style-simple .callout-body {
    font-size: 1rem;
    font-weight: 400;
  }

  .callout.callout-style-default .callout-body {
    font-size: 0.9rem;
    font-weight: 400;
  }

  .callout.callout-titled.callout-style-simple .callout-body {
    margin-top: 0.2em;
  }

  .callout:not(.callout-titled) .callout-body {
      display: flex;
  }

  .callout:not(.no-icon).callout-titled.callout-style-simple .callout-content {
    padding-left: 1.6em;
  }

  .callout.callout-titled .callout-header {
    padding-top: 0.2em;
    margin-bottom: -0.2em;
  }

  .callout.callout-titled .callout-title  p {
    margin-top: 0.5em;
    margin-bottom: 0.5em;
  }
    
  .callout.callout-titled.callout-style-simple .callout-content  p {
    margin-top: 0;
  }

  .callout.callout-titled.callout-style-default .callout-content  p {
    margin-top: 0.7em;
  }

  .callout.callout-style-simple div.callout-title {
    border-bottom: none;
    font-size: .9rem;
    font-weight: 600;
    opacity: 75%;
  }

  .callout.callout-style-default  div.callout-title {
    border-bottom: none;
    font-weight: 600;
    opacity: 85%;
    font-size: 0.9rem;
    padding-left: 0.5em;
    padding-right: 0.5em;
  }

  .callout.callout-style-default div.callout-content {
    padding-left: 0.5em;
    padding-right: 0.5em;
  }

  .callout.callout-style-simple .callout-icon::before {
    height: 1rem;
    width: 1rem;
    display: inline-block;
    content: "";
    background-repeat: no-repeat;
    background-size: 1rem 1rem;
  }

  .callout.callout-style-default .callout-icon::before {
    height: 0.9rem;
    width: 0.9rem;
    display: inline-block;
    content: "";
    background-repeat: no-repeat;
    background-size: 0.9rem 0.9rem;
  }

  .callout-title {
    display: flex
  }
    
  .callout-icon::before {
    margin-top: 1rem;
    padding-right: .5rem;
  }

  .callout.no-icon::before {
    display: none !important;
  }

  .callout.callout-titled .callout-body > .callout-content > :last-child {
    padding-bottom: 0.5rem;
    margin-bottom: 0;
  }

  .callout.callout-titled .callout-icon::before {
    margin-top: .5rem;
    padding-right: .5rem;
  }

  .callout:not(.callout-titled) .callout-icon::before {
    margin-top: 1rem;
    padding-right: .5rem;
  }

  /* Callout Types */

  div.callout-note {
    border-left-color: #4582ec !important;
  }

  div.callout-note .callout-icon::before {
    background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAYAAABzenr0AAAAAXNSR0IArs4c6QAAAERlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAA6ABAAMAAAABAAEAAKACAAQAAAABAAAAIKADAAQAAAABAAAAIAAAAACshmLzAAAEU0lEQVRYCcVXTWhcVRQ+586kSUMMxkyaElstCto2SIhitS5Ek8xUKV2poatCcVHtUlFQk8mbaaziwpWgglJwVaquitBOfhQXFlqlzSJpFSpIYyXNjBNiTCck7x2/8/LeNDOZxDuEkgOXe++553zfefee+/OYLOXFk3+1LLrRdiO81yNqZ6K9cG0P3MeFaMIQjXssE8Z1JzLO9ls20MBZX7oG8w9GxB0goaPrW5aNMp1yOZIa7Wv6o2ykpLtmAPs/vrG14Z+6d4jpbSKuhdcSyq9wGMPXjonwmESXrriLzFGOdDBLB8Y6MNYBu0dRokSygMA/mrun8MGFN3behm6VVAwg4WR3i6FvYK1T7MHo9BK7ydH+1uurECoouk5MPRyVSBrBHMYwVobG2aOXM07sWrn5qgB60rc6mcwIDJtQrnrEr44kmy+UO9r0u9O5/YbkS9juQckLed3DyW2XV/qWBBB3ptvI8EUY3I9p/67OW+g967TNr3Sotn3IuVlfMLVnsBwH4fsnebJvyGm5GeIUA3jljERmrv49SizPYuq+z7c2H/jlGC+Ghhupn/hcapqmcudB9jwJ/3jvnvu6vu5lVzF1fXyZuZZ7U8nRmVzytvT+H3kilYvH09mLWrQdwFSsFEsxFVs5fK7A0g8gMZjbif4ACpKbjv7gNGaD8bUrlk8x+KRflttr22JEMRUbTUwwDQScyzPgedQHZT0xnx7ujw2jfVfExwYHwOsDTjLdJ2ebmeQIlJ7neo41s/DrsL3kl+W2lWvAga0tR3zueGr6GL78M3ifH0rGXrBC2aAR8uYcIA5gwV8zIE8onoh8u0Fca/ciF7j1uOzEnqcIm59sEXoGc0+z6+H45V1CvAvHcD7THztu669cnp+L0okAeIc6zjbM/24LgGM1gZk7jnRu1aQWoU9sfUOuhrmtaPIO3YY1KLLWZaEO5TKUbMY5zx8W9UJ6elpLwKXbsaZ4EFl7B4bMtDv0iRipKoDQT2sNQI9b1utXFdYisi+wzZ/ri/1m7QfDgEuvgUUEIJPq3DhX/5DWNqIXDOweC2wvIR90Oq3lDpdMIgD2r0dXvGdsEW5H6x6HLRJYU7C69VefO1x8Gde1ZFSJLfWS1jbCnhtOPxmpfv2LXOA2Xk2tvnwKKPFuZ/oRmwBwqRQDcKNeVQkYcOjtWVBuM/JuYw5b6isojIkYxyYAFn5K7ZBF10fea52y8QltAg6jnMqNHFBmGkQ1j+U43HMi2xMar1Nv0zGsf1s8nUsmUtPOOrbFIR8bHFDMB5zL13Gmr/kGlCkUzedTzzmzsaJXhYawnA3UmARpiYj5ooJZiUoxFRtK3X6pgNPv+IZVPcnwbOl6f+aBaO1CNvPW9n9LmCp01nuSaTRF2YxHqZ8DYQT6WsXT+RD6eUztwYLZ8rM+rcPxamv1VQzFUkzFXvkiVrySGQgJNvXHJAxiU3/NwiC03rSf05VBaPtu/Z7/B8Yn/w7eguloAAAAAElFTkSuQmCC');
  }

  div.callout-note.callout-style-default .callout-title {
    background-color: #dae6fb
  }

  div.callout-important {
    border-left-color: #d9534f !important;
  }

  div.callout-important .callout-icon::before {
    background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAYAAABzenr0AAAAAXNSR0IArs4c6QAAAERlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAA6ABAAMAAAABAAEAAKACAAQAAAABAAAAIKADAAQAAAABAAAAIAAAAACshmLzAAAEKklEQVRYCcVXTWhcVRS+575MJym48A+hSRFr00ySRQhURRfd2HYjk2SSTokuBCkU2o0LoSKKraKIBTcuFCoidGFD08nkBzdREbpQ1EDNIv8qSGMFUboImMSZd4/f9zJv8ibJMC8xJQfO3HPPPef7zrvvvnvviIkpC9nsw0UttFunbUhpFzFtarSd6WJkStVMw5xyVqYTvkwfzuf/5FgtkVoB0729j1rjXwThS7Vio+Mo6DNnvLfahoZ+i/o32lULuJ3NNiz7q6+pyAUkJaFF6JwaM2lUJlV0MlnQn5aTRbEu0SEqHUa0A4AdiGuB1kFXRfVyg5d87+Dg4DL6m2TLAub60ilj7A1Ec4odSAc8X95sHh7+ZRPCFo6Fnp7HfU/fBng/hi10CjCnWnJjsxvDNxWw0NfV6Rv5GgP3I3jGWXumdTD/3cbEOP2ZbOZp69yniG3FQ9z1jD7bnBu9Fc2tKGC2q+uAJOQHBDRiZX1x36o7fWBs7J9ownbtO+n0/qWkvW7UPIfc37WgT6ZGR++EOJyeQDSb9UB+DZ1G6DdLDzyS+b/kBCYGsYgJbSQHuThGKRcw5xdeQf8YdNHsc6ePXrlSYMBuSIAFTGAtQo+VuALo4BX83N190NWZWbynBjhOHsmNfFWLeL6v+ynsA58zDvvAC8j5PkbOcXCMg2PZFk3q8MjI7WAG/Dp9AwP7jdGBOOQkAvlFUB+irtm16I1Zw9YBcpGTGXYmk3kQIC/Cds55l+iMI3jqhjAuaoe+am2Jw5GT3Nbz3CkE12NavmzN5+erJW7046n/CH1RO/RVa8lBLozXk9uqykkGAyRXLWlLv5jyp4RFsG5vGVzpDLnIjTWgnRy2Rr+tDKvRc7Y8AyZq10jj8DqXdnIRNtFZb+t/ZRtXcDiVnzpqx8mPcDWxgARUqx0W1QB9MeUZiNrV4qP+Ehc+BpNgATsTX8ozYKL2NtFYAHc84fG7ndxUPr+AR/iQSns7uSUufAymwDOb2+NjK27lEFocm/EE2WpyIy/Hi66MWuMKJn8RvxIcj87IM5Vh9663ziW36kR0HNenXuxmfaD8JC7tfKbrhFr7LiZCrMjrzTeGx+PmkosrkNzW94ObzwocJ7A1HokLolY+AvkTiD/q1H0cN48c5EL8Crkttsa/AXQVDmutfyku0E7jShx49XqV3MFK8IryDhYVbj7Sj2P2eBxwcXoe8T8idsKKPRcnZw1b+slFTubwUwhktrfnAt7J++jwQtLZcm3sr9LQrjRzz6cfMv9aLvgmnAGvpoaGLxM4mAEaLV7iAzQ3oU0IvD5x9ix3yF2RAAuYAOO2f7PEFWCXZ4C9Pb2UsgDeVnFSpbFK7/IWu7TPTvBqzbGdCHOJQSxiEjt6IyZmxQyEJHv6xyQsYk//moVFsN2zP6fRImjfq7/n/wFDguUQFNEwugAAAABJRU5ErkJggg==');
  }

  div.callout-important.callout-style-default .callout-title {
    background-color: #f7dddc
  }

  div.callout-warning {
    border-left-color: #f0ad4e !important;
  }

  div.callout-warning .callout-icon::before {
    background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAYAAABzenr0AAAAAXNSR0IArs4c6QAAAERlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAA6ABAAMAAAABAAEAAKACAAQAAAABAAAAIKADAAQAAAABAAAAIAAAAACshmLzAAAETklEQVRYCeVWW2gcVRg+58yaTUnizqbipZeX4uWhBEniBaoUX1Ioze52t7sRq6APio9V9MEaoWlVsFasRq0gltaAPuxms8lu0gcviE/FFOstVbSIxgcv6SU7EZqmdc7v9+9mJtNks51NTUH84ed889/PP+cmxP+d5FIbMJmNbpREu4WUkiTtCicKny0l1pIKmBzovF2S+hIJHX8iEu3hZJ5lNZGqyRrGSIQpq15AzF28jgpeY6yk6GVdrfFqdrD6Iw+QlB8g0YS2g7dyQmXM/IDhBhT0UCiRf59lfqmmDvzRt6kByV/m4JjtzuaujMUM2c5Z2d6JdKrRb3K2q6mA+oYVz8JnDdKPmmNthzkAk/lN63sYPgevrguc72aZX/L9C6x09GYyxBgCX4NlvyGUHOKELlm5rXeR1kchuChJt4SSwyddZRXgvwMGvYo4QSlk3/zkHD8UHxwVJA6zjZZqP8v8kK8OWLnIZtLyCAJagYC4rTGW/9Pqj92N/c+LUaAj27movwbi19tk/whRCIE7Q9vyI6yvRpftAKVTdUjOW40X3h5OXsKCdmFcx0xlLJoSuQngnrJe7Kcjm4OMq9FlC7CMmScQANuNvjfP3PjGXDBaUQmbp296S5L4DrpbrHN1T87ZVEZVCzg1FF0Ft+dKrlLukI+/c9ENo+TvlTDbYFvuKPtQ9+l052rXrgKoWkDAFnvh0wTOmYn8R5f4k/jN/fZiCM1tQx9jQQ4ANhqG4hiL0qIFTGViG9DKB7GYzgubnpofgYRwO+DFjh0Zin2m4b/97EDkXkc+f6xYAPX0KK2I/7fUQuwzuwo/L3AkcjugPNixC8cHf0FyPjWlItmLxWw4Ou9YsQCr5fijMGoD/zpdRy95HRysyXA74MWOnscpO4j2y3HAVisw85hX5+AFBRSHt4ShfLFkIMXTqyKFc46xdzQM6XbAi702a7sy04J0+feReMFKp5q9esYLCqAZYw/k14E/xcLLsFElaornTuJB0svMuJINy8xkIYuL+xPAlWRceH6+HX7THJ0djLUom46zREu7tTkxwmf/FdOZ/sh6Q8qvEAiHpm4PJ4a/doJe0gH1t+aHRgCzOvBvJedEK5OFE5jpm4AGP2a8Dxe3gGJ/pAutug9Gp6he92CsSsWBaEcxGx0FHytmIpuqGkOpldqNYQK8cSoXvd+xLxXADw0kf6UkJNFtdo5MOgaLjiQOQHcn+A6h5NuL2s0qsC2LOM75PcF3yr5STuBSAcGG+meA14K/CI21HcS4LBT6tv0QAh8Dr5l93AhZzG5ZJ4VxAqdZUEl9z7WJ4aN+svMvwHHL21UKTd1mqvChH7/Za5xzXBBKrUcB0TQ+Ulgkfbi/H/YT5EptrGzsEK7tR1B7ln9BBwckYfMiuSqklSznIuoIIOM42MQO+QnduCoFCI0bpkzjCjddHPN/F+2Yu+sd9bKNpVwHhbS3LluK/0zgfwD0xYI5dXuzlQAAAABJRU5ErkJggg==');
  }

  div.callout-warning.callout-style-default .callout-title {
    background-color: #fcefdc
  }

  div.callout-tip {
    border-left-color: #02b875 !important;
  }

  div.callout-tip .callout-icon::before {
    background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAYAAABzenr0AAAAAXNSR0IArs4c6QAAAERlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAA6ABAAMAAAABAAEAAKACAAQAAAABAAAAIKADAAQAAAABAAAAIAAAAACshmLzAAADr0lEQVRYCe1XTWgTQRj9ZjZV8a9SPIkKgj8I1bMHsUWrqYLVg4Ue6v9BwZOxSYsIerFao7UiUryIqJcqgtpimhbBXoSCVxUFe9CTiogUrUp2Pt+3aUI2u5vdNh4dmMzOzHvvezuz8xNFM0mjnbXaNu1MvFWRXkXEyE6aYOYJpdW4IXuA4r0fo8qqSMDBU0v1HJUgVieAXxzCsdE/YJTdFcVIZQNMyhruOMJKXYFoLfIfIvVIMWdsrd+Rpd86ZmyzzjJmLStqRn0v8lzkb4rVIXvnpScOJuAn2ACC65FkPzEdEy4TPWRLJ2h7z4cArXzzaOdKlbOvKKX25Wl00jSnrwVxAg3o4dRxhO13RBSdNvH0xSARv3adTXbBdTf64IWO2vH0LT+cv4GR1DJt+DUItaQogeBX/chhbTBxEiZ6gftlDNXTrvT7co4ub5A6gp9HIcHvzTa46OS5fBeP87Qm0fQkr4FsYgVQ7Qg+ZayaDg9jhg1GkWj8RG6lkeSacrrHgDaxdoBiZPg+NXV/KifMuB6//JmYH4CntVEHy/keA6x4h4CU5oFy8GzrBS18cLJMXcljAKB6INjWsRcuZBWVaS3GDrqB7rdapVIeA+isQ57Eev9eCqzqOa81CY05VLd6SamW2wA2H3SiTbnbSxmzfp7WtKZkqy4mdyAlGx7ennghYf8voqp9cLSgKdqNfa6RdRsAAkPwRuJZNbpByn+RrJi1RXTwdi8RQF6ymDwGMAtZ6TVE+4uoKh+MYkcLsT0Hk8eAienbiGdjJHZTpmNjlbFJNKDVAp2fJlYju6IreQxQ08UJDNYdoLSl6AadO+fFuCQqVMB1NJwPm69T04Wv5WhfcWyfXQB+wXRs1pt+nCknRa0LVzSA/2B+a9+zQJadb7IyyV24YAxKp2Jqs3emZTuNnKxsah+uabKbMk7CbTgJx/zIgQYErIeTKRQ9yD9wxVof5YolPHqaWo7TD6tJlh7jQnK5z2n3+fGdggIOx2kaa2YI9QWarc5Ce1ipNWMKeSG4DysFF52KBmTNMmn5HqCFkwy34rDg05gDwgH3bBi+sgFhN/e8QvRn8kbamCOhgrZ9GJhFDgfcMHzFb6BAtjKpFhzTjwv1KCVuxHvCbsSiEz4CANnj84cwHdFXAbAOJ4LTSAawGWFn5tDhLMYz6nWeU2wJfIhmIJBefcd/A5FWQWGgrWzyORZ3Q6HuV+Jf0Bj+BTX69fm1zWgK7By1YTXchFDORywnfQ7GpzOo6S+qECrsx2ifVQAAAABJRU5ErkJggg==');
  }

  div.callout-tip.callout-style-default .callout-title {
    background-color: #ccf1e3
  }

  div.callout-caution {
    border-left-color: #fd7e14 !important;
  }

  div.callout-caution .callout-icon::before {
    background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAYAAABzenr0AAAAAXNSR0IArs4c6QAAAERlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAA6ABAAMAAAABAAEAAKACAAQAAAABAAAAIKADAAQAAAABAAAAIAAAAACshmLzAAACV0lEQVRYCdVWzWoUQRCuqp2ICBLJXgITZL1EfQDBW/bkzUMUD7klD+ATSHBEfAIfQO+iXsWDxJsHL96EHAwhgzlkg8nBg25XWb0zIb0zs9muYYWkoKeru+vn664fBqElyZNuyh167NXJ8Ut8McjbmEraKHkd7uAnAFku+VWdb3reSmRV8PKSLfZ0Gjn3a6Xlcq9YGb6tADjn+lUfTXtVmaZ1KwBIvFI11rRXlWlatwIAAv2asaa9mlB9wwygiDX26qaw1yYPzFXg2N1GgG0FMF8Oj+VIx7E/03lHx8UhvYyNZLN7BwSPgekXXLribw7w5/c8EF+DBK5idvDVYtEEwMeYefjjLAdEyQ3M9nfOkgnPTEkYU+sxMq0BxNR6jExrAI31H1rzvLEfRIdgcv1XEdj6QTQAS2wtstEALLG1yEZ3QhH6oDX7ExBSFEkFINXH98NTrme5IOaaA7kIfiu2L8A3qhH9zRbukdCqdsA98TdElyeMe5BI8Rs2xHRIsoTSSVFfCFCWGPn9XHb4cdobRIWABNf0add9jakDjQJpJ1bTXOJXnnRXHRf+dNL1ZV1MBRCXhMbaHqGI1JkKIL7+i8uffuP6wVQAzO7+qVEbF6NbS0LJureYcWXUUhH66nLR5rYmva+2tjRFtojkM2aD76HEGAD3tPtKM309FJg5j/K682ywcWJ3PASCcycH/22u+Bh7Aa0ehM2Fu4z0SAE81HF9RkB21c5bEn4Dzw+/qNOyXr3DCTQDMBOdhi4nAgiFDGCinIa2owCEChUwD8qzd03PG+qdW/4fDzjUMcE1ZpIAAAAASUVORK5CYII=');
  }

  div.callout-caution.callout-style-default .callout-title {
    background-color: #ffe5d0
  }

  </style>
  <style type="text/css">
    /* Figure formatting */
    .quarto-layout-panel>figure>figcaption,
    .quarto-layout-panel>.panel-caption {
      margin-top: 10pt;
    }

    .quarto-layout-row {
      display: flex;
      align-items: flex-start;
    }

    .quarto-layout-valign-top {
      align-items: flex-start;
    }

    .quarto-layout-valign-bottom {
      align-items: flex-end;
    }

    .quarto-layout-valign-center {
      align-items: center;
    }

    .quarto-layout-cell {
      position: relative;
      margin-right: 20px;
    }

    .quarto-layout-cell:last-child {
      margin-right: 0;
    }

    .quarto-layout-cell figure,
    .quarto-layout-cell>p {
      margin: 0.2em;
    }

    .quarto-layout-cell .html-widget {
      width: 100% !important;
    }

    .quarto-layout-cell div figure p {
      margin: 0;
    }

    .quarto-layout-cell figure {
      display: inline-block;
      margin-inline-start: 0;
      margin-inline-end: 0;
    }

    .quarto-layout-cell table {
      display: inline-table;
    }

    .quarto-layout-cell-subref figcaption {
      font-style: italic;
      text-align: center;
    }

    .quarto-figure>figure {
      width: 100%;
    }

    .quarto-figure-left>figure>p {
      text-align: left;
    }

    .quarto-figure-center>figure>p {
      text-align: center;
    }

    .quarto-figure-right>figure>p {
      text-align: right;
    }

    figure>p:empty {
      display: none;
    }

    figure>p:first-child {
      margin-top: 0;
      margin-bottom: 0;
    }

    figure>figcaption {
      margin-top: 0.5em;
    }

    figcaption {
      font-size: 0.8em;
    }

    details {
      margin-bottom: 1em;
    }

    details[show] {
      margin-bottom: 0;
    }

    .quarto-unresolved-ref {
      font-weight: 600;
    }

    .quarto-cover-image {
      float: right;
      margin-left: 30px;
    }

    .cell-output-display {
      overflow-x: scroll;
    }

    .hidden {
      display: none;
    }
  </style>
</head>
<body epub:type="bodymatter">
<section id="keyword-spotting-kws" class="level1 unnumbered">
<h1 class="unnumbered">Keyword Spotting (KWS)</h1>
<div class="quarto-figure quarto-figure-center">
<figure>
<p><img src="../media/file444.jpg" alt="" /></p>
<figcaption><em>DALL·E 3 Prompt: 1950s style cartoon scene set in a vintage audio research room. Two Afro-American female scientists are at the center. One holds a magnifying glass, closely examining ancient circuitry, while the other takes notes. On their wooden table, there are multiple boards with sensors, notably featuring a microphone. Behind these boards, a computer with a large, rounded back displays the Arduino IDE. The IDE showcases code for LED pin assignments and machine learning inference for voice command detection. A distinct window in the IDE, the Serial Monitor, reveals outputs indicating the spoken commands ‘yes’ and ‘no’. The room ambiance is nostalgic with vintage lamps, classic audio analysis tools, and charts depicting FFT graphs and time-domain curves.</em></figcaption>
</figure>
</div>
<section id="sec-keyword-spotting-kws-overview-0ae6" class="level2 unnumbered">
<h2 class="unnumbered">Overview</h2>
<p>Having already explored the Nicla Vision board in the <em>Image Classification</em> and <em>Object Detection</em> applications, we are now shifting our focus to voice-activated applications with a project on Keyword Spotting (KWS).</p>
<p>As introduced in the <em>Feature Engineering for Audio Classification</em> Hands-On tutorial, Keyword Spotting (KWS) is integrated into many voice recognition systems, enabling devices to respond to specific words or phrases. While this technology underpins popular devices like Google Assistant or Amazon Alexa, it’s equally applicable and feasible on smaller, low-power devices. This tutorial will guide you through implementing a KWS system using TinyML on the Nicla Vision development board equipped with a digital microphone.</p>
<p>Our model will be designed to recognize keywords that can trigger device wake-up or specific actions, bringing them to life with voice-activated commands.</p>
</section>
<section id="sec-keyword-spotting-kws-voice-assistant-work-7c16" class="level2 unnumbered">
<h2 class="unnumbered">How does a voice assistant work?</h2>
<p>As said, <em>voice assistants</em> on the market, like Google Home or Amazon Echo-Dot, only react to humans when they are “waked up” by particular keywords such as ” Hey Google” on the first one and “Alexa” on the second.</p>
<p> <img src="../media/file445.png" class="quarto-figure quarto-figure-center" style="width:70.0%" alt="" /></p>
<p>In other words, recognizing voice commands is based on a multi-stage model or Cascade Detection.</p>
<p> <img src="../media/file446.jpg" class="quarto-figure quarto-figure-center" style="width:90.0%" alt="" /></p>
<p><strong>Stage 1</strong>: A small microprocessor inside the Echo Dot or Google Home continuously listens, waiting for the keyword to be spotted, using a TinyML model at the edge (KWS application).</p>
<p><strong>Stage 2</strong>: Only when triggered by the KWS application on Stage 1 is the data sent to the cloud and processed on a larger model.</p>
<p>The video below shows an example of a Google Assistant being programmed on a Raspberry Pi (Stage 2), with an Arduino Nano 33 BLE as the TinyML device (Stage 1).</p>
<p><a href="https://youtu.be/e_OPgcnsyvM">https://youtu.be/e_OPgcnsyvM</a></p>
<blockquote>
<p>To explore the above Google Assistant project, please see the tutorial: <a href="https://www.hackster.io/mjrobot/building-an-intelligent-voice-assistant-from-scratch-2199c3">Building an Intelligent Voice Assistant From Scratch</a>.</p>
</blockquote>
<p>In this KWS project, we will focus on Stage 1 (KWS or Keyword Spotting), where we will use the Nicla Vision, which has a digital microphone that will be used to spot the keyword.</p>
</section>
<section id="sec-keyword-spotting-kws-kws-handson-project-d8cd" class="level2 unnumbered">
<h2 class="unnumbered">The KWS Hands-On Project</h2>
<p>The diagram below gives an idea of how the final KWS application should work (during inference):</p>
<p> <img src="../media/file447.jpg" alt="" /></p>
<p>Our KWS application will recognize four classes of sound:</p>
<ul>
<li><strong>YES</strong> (Keyword 1)</li>
<li><strong>NO</strong> (Keyword 2)</li>
<li><strong>NOISE</strong> (no words spoken; only background noise is present)</li>
<li><strong>UNKNOWN</strong> (a mix of different words than YES and NO)</li>
</ul>
<blockquote>
<p>For real-world projects, it is always advisable to include other sounds besides the keywords, such as “Noise” (or Background) and “Unknown.”</p>
</blockquote>
<section id="sec-keyword-spotting-kws-machine-learning-workflow-bc51" class="level3 unnumbered">
<h3 class="unnumbered">The Machine Learning workflow</h3>
<p>The main component of the KWS application is its model. So, we must train such a model with our specific keywords, noise, and other words (the “unknown”):</p>
<p> <img src="../media/file448.jpg" alt="" /></p>
</section>
</section>
<section id="sec-keyword-spotting-kws-dataset-bd0d" class="level2 unnumbered">
<h2 class="unnumbered">Dataset</h2>
<p>The critical component of any Machine Learning Workflow is the <strong>dataset</strong>. Once we have decided on specific keywords, in our case (<em>YES</em> and NO), we can take advantage of the dataset developed by Pete Warden, <a href="https://arxiv.org/pdf/1804.03209.pdf">“Speech Commands: A Dataset for Limited-Vocabulary Speech Recognition</a>.” This dataset has 35 keywords (with +1,000 samples each), such as yes, no, stop, and go. In words such as <em>yes</em> and <em>no,</em> we can get 1,500 samples.</p>
<p>You can download a small portion of the dataset from Edge Studio (<a href="https://docs.edgeimpulse.com/docs/pre-built-datasets/keyword-spotting">Keyword spotting pre-built dataset</a>), which includes samples from the four classes we will use in this project: yes, no, noise, and background. For this, follow the steps below:</p>
<ul>
<li>Download the <a href="https://cdn.edgeimpulse.com/datasets/keywords2.zip">keywords dataset.</a></li>
<li>Unzip the file to a location of your choice.</li>
</ul>
<section id="sec-keyword-spotting-kws-uploading-dataset-edge-impulse-studio-fb56" class="level3 unnumbered">
<h3 class="unnumbered">Uploading the dataset to the Edge Impulse Studio</h3>
<p>Initiate a new project at Edge Impulse Studio (EIS) and select the <code>Upload Existing Data</code> tool in the <code>Data Acquisition</code> section. Choose the files to be uploaded:</p>
<p> <img src="../media/file449.jpg" alt="" /></p>
<p>Define the Label, select <code>Automatically split between train and test,</code> and <code>Upload data</code> to the EIS. Repeat for all classes.</p>
<p> <img src="../media/file450.jpg" class="quarto-figure quarto-figure-center" style="width:80.0%" alt="" /></p>
<p>The dataset will now appear in the <code>Data acquisition</code> section. Note that the approximately 6,000 samples (1,500 for each class) are split into Train (4,800) and Test (1,200) sets.</p>
<p> <img src="../media/file451.jpg" class="quarto-figure quarto-figure-center" style="width:80.0%" alt="" /></p>
</section>
<section id="sec-keyword-spotting-kws-capturing-additional-audio-data-6177" class="level3 unnumbered">
<h3 class="unnumbered">Capturing additional Audio Data</h3>
<p>Although we have a lot of data from Pete’s dataset, collecting some words spoken by us is advised. When working with accelerometers, creating a dataset with data captured by the same type of sensor is essential. In the case of <em>sound</em>, this is optional because what we will classify is, in reality, <em>audio</em> data.</p>
<blockquote>
<p>The key difference between sound and audio is the type of energy. Sound is mechanical perturbation (longitudinal sound waves) that propagate through a medium, causing variations of pressure in it. Audio is an electrical (analog or digital) signal representing sound.</p>
</blockquote>
<p>When we pronounce a keyword, the sound waves should be converted to audio data. The conversion should be done by sampling the signal generated by the microphone at a 16 KHz frequency with 16-bit per sample amplitude.</p>
<p>So, any device that can generate audio data with this basic specification (16 KHz/16 bits) will work fine. As a <em>device</em>, we can use the NiclaV, a computer, or even your mobile phone.</p>
<p> <img src="../media/file452.jpg" alt="" /></p>
<section id="sec-keyword-spotting-kws-using-niclav-edge-impulse-studio-23b8" class="level4 unnumbered">
<h4 class="unnumbered">Using the NiclaV and the Edge Impulse Studio</h4>
<p>As we learned in the chapter <em>Setup Nicla Vision</em>, EIS officially supports the Nicla Vision, which simplifies the capture of the data from its sensors, including the microphone. So, please create a new project on EIS and connect the Nicla to it, following these steps:</p>
<ul>
<li><p>Download the last updated <a href="https://cdn.edgeimpulse.com/firmware/arduino-nicla-vision.zip">EIS Firmware</a> and unzip it.</p></li>
<li><p>Open the zip file on your computer and select the uploader corresponding to your OS:</p></li>
</ul>
<p> <img src="../media/file453.png" class="quarto-figure quarto-figure-center" style="width:85.0%" alt="" /></p>
<ul>
<li><p>Put the NiclaV in Boot Mode by pressing the reset button twice.</p></li>
<li><p>Upload the binary <em>arduino-nicla-vision.bin</em> to your board by running the batch code corresponding to your OS.</p></li>
</ul>
<p>Go to your project on EIS, and on the <code>Data Acquisition tab</code>, select <code>WebUSB</code>. A window will pop up; choose the option that shows that the <code>Nicla is paired</code> and press <code>[Connect]</code>.</p>
<p>You can choose which sensor data to pick in the <code>Collect Data</code> section on the <code>Data Acquisition</code> tab. Select: <code>Built-in microphone</code>, define your <code>label</code> (for example, <em>yes</em>), the sampling <code>Frequency</code>[16000Hz], and the <code>Sample length (in milliseconds)</code>, for example [10s]. <code>Start sampling</code>.</p>
<p> <img src="../media/file454.jpg" class="quarto-figure quarto-figure-center" style="width:75.0%" alt="" /></p>
<p>Data on Pete’s dataset have a length of 1s, but the recorded samples are 10s long and must be split into 1s samples. Click on <code>three dots</code> after the sample name and select <code>Split sample</code>.</p>
<p>A window will pop up with the Split tool.</p>
<p> <img src="../media/file455.jpg" class="quarto-figure quarto-figure-center" style="width:80.0%" alt="" /></p>
<p>Once inside the tool, split the data into 1-second (1000 ms) records. If necessary, add or remove segments. This procedure should be repeated for all new samples.</p>
</section>
<section id="sec-keyword-spotting-kws-using-smartphone-ei-studio-c13b" class="level4 unnumbered">
<h4 class="unnumbered">Using a smartphone and the EI Studio</h4>
<p>You can also use your PC or smartphone to capture audio data, using a sampling frequency of 16 KHz and a bit depth of 16.</p>
<p>Go to <code>Devices</code>, scan the <code>QR Code</code> using your phone, and click on the link. A data Collection app will appear in your browser. Select <code>Collecting Audio</code>, and define your <code>Label</code>, data capture <code>Length,</code> and <code>Category</code>.</p>
<p> <img src="../media/file456.jpg" class="quarto-figure quarto-figure-center" style="width:90.0%" alt="" /></p>
<p>Repeat the same procedure used with the NiclaV.</p>
<blockquote>
<p>Note that any app, such as <a href="https://www.audacityteam.org/">Audacity</a>, can be used for audio recording, provided you use 16 KHz/16-bit depth samples.</p>
</blockquote>
</section>
</section>
</section>
<section id="sec-keyword-spotting-kws-creating-impulse-preprocess-model-definition-5c3e" class="level2 unnumbered">
<h2 class="unnumbered">Creating Impulse (Pre-Process / Model definition)</h2>
<p><em>An</em> <strong>impulse</strong> <em>takes raw data, uses signal processing to extract features, and then uses a learning block to classify new data.</em></p>
<section id="sec-keyword-spotting-kws-impulse-design-0a62" class="level3 unnumbered">
<h3 class="unnumbered">Impulse Design</h3>
<p> <img src="../media/file457.jpg" class="quarto-figure quarto-figure-center" style="width:90.0%" alt="" /></p>
<p>First, we will take the data points with a 1-second window, augmenting the data and sliding that window in 500 ms intervals. Note that the option zero-pad data is set. It is essential to fill with ‘zeros’ samples smaller than 1 second (in some cases, some samples can result smaller than the 1000 ms window on the split tool to avoid noise and spikes).</p>
<p>Each 1-second audio sample should be pre-processed and converted to an image (for example, <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>13</mn><mo>×</mo><mn>49</mn><mo>×</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">13\times 49\times 1</annotation></semantics></math>). As discussed in the <em>Feature Engineering for Audio Classification</em> Hands-On tutorial, we will use <code>Audio (MFCC)</code>, which extracts features from audio signals using <a href="https://en.wikipedia.org/wiki/Mel-frequency_cepstrum">Mel Frequency Cepstral Coefficients</a>, which are well suited for the human voice, our case here.</p>
<p>Next, we select the <code>Classification</code> block to build our model from scratch using a Convolution Neural Network (CNN).</p>
<blockquote>
<p>Alternatively, you can use the <code>Transfer Learning (Keyword Spotting)</code> block, which fine-tunes a pre-trained keyword spotting model on your data. This approach has good performance with relatively small keyword datasets.</p>
</blockquote>
</section>
<section id="sec-keyword-spotting-kws-preprocessing-mfcc-0c8d" class="level3 unnumbered">
<h3 class="unnumbered">Pre-Processing (MFCC)</h3>
<p>The following step is to create the features to be trained in the next phase:</p>
<p>We could keep the default parameter values, but we will use the DSP <code>Autotune parameters</code> option.</p>
<p> <img src="../media/file458.jpg" alt="" /></p>
<p>We will take the <code>Raw features</code> (our 1-second, 16 KHz sampled audio data) and use the MFCC processing block to calculate the <code>Processed features</code>. For every 16,000 raw features (16,000 <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>×</mi><annotation encoding="application/x-tex">\times</annotation></semantics></math> 1 second), we will get 637 processed features <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="true" form="prefix">(</mo><mn>13</mn><mo>×</mo><mn>49</mn><mo stretchy="true" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">(13\times 49)</annotation></semantics></math>.</p>
<p> <img src="../media/file459.jpg" class="quarto-figure quarto-figure-center" style="width:90.0%" alt="" /></p>
<p>The result shows that we only used a small amount of memory to pre-process data (16 KB) and a latency of 34 ms, which is excellent. For example, on an Arduino Nano (Cortex-M4f @ 64 MHz), the same pre-process will take around 480 ms. The parameters chosen, such as the <code>FFT length</code> [512], will significantly impact the latency.</p>
<p>Now, let’s <code>Save parameters</code> and move to the <code>Generated features</code> tab, where the actual features will be generated. Using <a href="https://umap-learn.readthedocs.io/en/latest/">UMAP</a>, a dimension reduction technique, the <code>Feature explorer</code> shows how the features are distributed on a two-dimensional plot.</p>
<p> <img src="../media/file460.jpg" class="quarto-figure quarto-figure-center" style="width:80.0%" alt="" /></p>
<p>The result seems OK, with a visually clear separation between <em>yes</em> features (in red) and <em>no</em> features (in blue). The <em>unknown</em> features seem nearer to the <em>no space</em> than the <em>yes</em>. This suggests that the keyword <em>no</em> has more propensity to false positives.</p>
</section>
<section id="sec-keyword-spotting-kws-going-hood-36e4" class="level3 unnumbered">
<h3 class="unnumbered">Going under the hood</h3>
<p>To understand better how the raw sound is preprocessed, look at the <em>Feature Engineering for Audio Classification</em> chapter. You can play with the MFCC features generation by downloading this <a href="https://github.com/Mjrovai/Arduino_Nicla_Vision/blob/main/KWS/KWS_MFCC_Analysis.ipynb">notebook</a> from GitHub or <a href="https://colab.research.google.com/github/Mjrovai/Arduino_Nicla_Vision/blob/main/KWS/KWS_MFCC_Analysis.ipynb">[Opening it In Colab]</a></p>
</section>
</section>
<section id="sec-keyword-spotting-kws-model-design-training-1c97" class="level2 unnumbered">
<h2 class="unnumbered">Model Design and Training</h2>
<p>We will use a simple Convolution Neural Network (CNN) model, tested with 1D and 2D convolutions. The basic architecture has two blocks of Convolution + MaxPooling ([8] and [16] filters, respectively) and a Dropout of [0.25] for the 1D and [0.5] for the 2D. For the last layer, after Flattening, we have [4] neurons, one for each class:</p>
<p> <img src="../media/file461.jpg" alt="" /></p>
<p>As hyper-parameters, we will have a <code>Learning Rate</code> of [0.005] and a model trained by [100] epochs. We will also include a data augmentation method based on <a href="https://arxiv.org/abs/1904.08779">SpecAugment</a>. We trained the 1D and the 2D models with the same hyperparameters. The 1D architecture had a better overall result (90.5% accuracy when compared with 88% of the 2D, so we will use the 1D.</p>
<p> <img src="../media/file462.jpg" class="quarto-figure quarto-figure-center" style="width:80.0%" alt="" /></p>
<blockquote>
<p>Using 1D convolutions is more efficient because it requires fewer parameters than 2D convolutions, making them more suitable for resource-constrained environments.</p>
</blockquote>
<p>It is also interesting to pay attention to the 1D Confusion Matrix. The F1 Score for <code>yes</code> is 95%, and for <code>no</code>, 91%. That was expected by what we saw with the Feature Explorer (<code>no</code> and <code>unknown</code> at close distance). In trying to improve the result, you can inspect closely the results of the samples with an error.</p>
<p> <img src="../media/file463.jpg" class="quarto-figure quarto-figure-center" style="width:90.0%" alt="" /></p>
<p>Listen to the samples that went wrong. For example, for <code>yes</code>, most of the mistakes were related to a yes pronounced as “yeh”. You can acquire additional samples and then retrain your model.</p>
<section id="sec-keyword-spotting-kws-going-hood-f766" class="level3 unnumbered">
<h3 class="unnumbered">Going under the hood</h3>
<p>If you want to understand what is happening “under the hood,” you can download the pre-processed dataset (<code>MFCC training data</code>) from the <code>Dashboard</code> tab and run this <a href="https://github.com/Mjrovai/Arduino_Nicla_Vision/blob/main/KWS/KWS_CNN_training.ipynb">Jupyter Notebook</a>, playing with the code or <a href="https://colab.research.google.com/github/Mjrovai/Arduino_Nicla_Vision/blob/main/KWS/KWS_CNN_training.ipynb">[Opening it In Colab]</a>. For example, you can analyze the accuracy by each epoch:</p>
<p> <img src="../media/file464.jpg" alt="" /></p>
</section>
</section>
<section id="sec-keyword-spotting-kws-testing-bd97" class="level2 unnumbered">
<h2 class="unnumbered">Testing</h2>
<p>Testing the model with the data reserved for training (Test Data), we got an accuracy of approximately 76%.</p>
<p> <img src="../media/file465.jpg" class="quarto-figure quarto-figure-center" style="width:70.0%" alt="" /></p>
<p>Inspecting the F1 score, we can see that for YES, we got 0.90, an excellent result since we expect to use this keyword as the primary “trigger” for our KWS project. The worst result (0.70) is for UNKNOWN, which is OK.</p>
<p>For NO, we got 0.72, which was expected, but to improve this result, we can move the samples that were not correctly classified to the training dataset and then repeat the training process.</p>
<section id="sec-keyword-spotting-kws-live-classification-ef76" class="level3 unnumbered">
<h3 class="unnumbered">Live Classification</h3>
<p>We can proceed to the project’s next step but also consider that it is possible to perform <code>Live Classification</code> using the NiclaV or a smartphone to capture live samples, testing the trained model before deployment on our device.</p>
</section>
</section>
<section id="sec-keyword-spotting-kws-deploy-inference-152d" class="level2 unnumbered">
<h2 class="unnumbered">Deploy and Inference</h2>
<p>The EIS will package all the needed libraries, preprocessing functions, and trained models, downloading them to your computer. Go to the <code>Deployment</code> section, select <code>Arduino Library</code>, and at the bottom, choose <code>Quantized (Int8)</code> and press <code>Build</code>.</p>
<p> <img src="../media/file466.jpg" class="quarto-figure quarto-figure-center" style="width:90.0%" alt="" /></p>
<p>When the <code>Build</code> button is selected, a zip file will be created and downloaded to your computer. On your Arduino IDE, go to the <code>Sketch</code> tab, select the option <code>Add .ZIP Library</code>, and Choose the .zip file downloaded by EIS:</p>
<p> <img src="../media/file467.jpg" alt="" /></p>
<p>Now, it is time for a real test. We will make inferences while completely disconnected from the EIS. Let’s use the NiclaV code example created when we deployed the Arduino Library.</p>
<p>In your Arduino IDE, go to the <code>File/Examples</code> tab, look for your project, and select <code>nicla-vision/nicla-vision_microphone</code> (or <code>nicla-vision_microphone_continuous</code>)</p>
<p> <img src="../media/file468.jpg" alt="" /></p>
<p>Press the reset button twice to put the NiclaV in boot mode, upload the sketch to your board, and test some real inferences:</p>
<p> <img src="../media/file469.jpg" alt="" /></p>
</section>
<section id="sec-keyword-spotting-kws-postprocessing-ce62" class="level2 unnumbered">
<h2 class="unnumbered">Post-processing</h2>
<p>Now that we know the model is working since it detects our keywords, let’s modify the code to see the result with the NiclaV completely offline (disconnected from the PC and powered by a battery, a power bank, or an independent 5V power supply).</p>
<p>The idea is that whenever the keyword YES is detected, the Green LED will light; if a NO is heard, the Red LED will light, if it is a UNKNOWN, the Blue LED will light; and in the presence of noise (No Keyword), the LEDs will be OFF.</p>
<p>We should modify one of the code examples. Let’s do it now with the <code>nicla-vision_microphone_continuous</code>.</p>
<p>Start with initializing the LEDs:</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode numberSource cpp number-lines"><code class="sourceCode cpp"><span id="cb1-1"><a href="#cb1-1"></a><span class="op">...</span></span>
<span id="cb1-2"><a href="#cb1-2"></a><span class="dt">void</span> setup<span class="op">()</span></span>
<span id="cb1-3"><a href="#cb1-3"></a><span class="op">{</span></span>
<span id="cb1-4"><a href="#cb1-4"></a>        <span class="co">// Once you finish debugging your code, you can</span></span>
<span id="cb1-5"><a href="#cb1-5"></a>        <span class="co">// comment or delete the Serial part of the code</span></span>
<span id="cb1-6"><a href="#cb1-6"></a>    Serial<span class="op">.</span>begin<span class="op">(</span><span class="dv">115200</span><span class="op">);</span></span>
<span id="cb1-7"><a href="#cb1-7"></a>    <span class="cf">while</span> <span class="op">(!</span>Serial<span class="op">);</span></span>
<span id="cb1-8"><a href="#cb1-8"></a>    Serial<span class="op">.</span>println<span class="op">(</span><span class="st">&quot;Inferencing - Nicla Vision KWS with LEDs&quot;</span><span class="op">);</span></span>
<span id="cb1-9"><a href="#cb1-9"></a></span>
<span id="cb1-10"><a href="#cb1-10"></a>    <span class="co">// Pins for the built-in RGB LEDs on the Arduino NiclaV</span></span>
<span id="cb1-11"><a href="#cb1-11"></a>    pinMode<span class="op">(</span>LEDR<span class="op">,</span> OUTPUT<span class="op">);</span></span>
<span id="cb1-12"><a href="#cb1-12"></a>    pinMode<span class="op">(</span>LEDG<span class="op">,</span> OUTPUT<span class="op">);</span></span>
<span id="cb1-13"><a href="#cb1-13"></a>    pinMode<span class="op">(</span>LEDB<span class="op">,</span> OUTPUT<span class="op">);</span></span>
<span id="cb1-14"><a href="#cb1-14"></a></span>
<span id="cb1-15"><a href="#cb1-15"></a>    <span class="co">// Ensure the LEDs are OFF by default.</span></span>
<span id="cb1-16"><a href="#cb1-16"></a>    <span class="co">// Note: The RGB LEDs on the Arduino Nicla Vision</span></span>
<span id="cb1-17"><a href="#cb1-17"></a>    <span class="co">// are ON when the pin is LOW, OFF when HIGH.</span></span>
<span id="cb1-18"><a href="#cb1-18"></a>    digitalWrite<span class="op">(</span>LEDR<span class="op">,</span> HIGH<span class="op">);</span></span>
<span id="cb1-19"><a href="#cb1-19"></a>    digitalWrite<span class="op">(</span>LEDG<span class="op">,</span> HIGH<span class="op">);</span></span>
<span id="cb1-20"><a href="#cb1-20"></a>    digitalWrite<span class="op">(</span>LEDB<span class="op">,</span> HIGH<span class="op">);</span></span>
<span id="cb1-21"><a href="#cb1-21"></a><span class="op">...</span></span>
<span id="cb1-22"><a href="#cb1-22"></a><span class="op">}</span></span></code></pre></div>
<p>Create two functions, <code>turn_off_leds()</code> function , to turn off all RGB LEDs</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode numberSource cpp number-lines"><code class="sourceCode cpp"><span id="cb2-1"><a href="#cb2-1"></a><span class="co">/*</span></span>
<span id="cb2-2"><a href="#cb2-2"></a><span class="co"> * @brief      turn_off_leds function - turn-off all RGB LEDs</span></span>
<span id="cb2-3"><a href="#cb2-3"></a><span class="co"> */</span></span>
<span id="cb2-4"><a href="#cb2-4"></a><span class="dt">void</span> turn_off_leds<span class="op">(){</span></span>
<span id="cb2-5"><a href="#cb2-5"></a>    digitalWrite<span class="op">(</span>LEDR<span class="op">,</span> HIGH<span class="op">);</span></span>
<span id="cb2-6"><a href="#cb2-6"></a>    digitalWrite<span class="op">(</span>LEDG<span class="op">,</span> HIGH<span class="op">);</span></span>
<span id="cb2-7"><a href="#cb2-7"></a>    digitalWrite<span class="op">(</span>LEDB<span class="op">,</span> HIGH<span class="op">);</span></span>
<span id="cb2-8"><a href="#cb2-8"></a><span class="op">}</span></span></code></pre></div>
<p>Another <code>turn_on_led()</code> function is used to turn on the RGB LEDs according to the most probable result of the classifier.</p>
<div class="sourceCode" id="cb3"><pre class="sourceCode numberSource cpp number-lines"><code class="sourceCode cpp"><span id="cb3-1"><a href="#cb3-1"></a><span class="co">/*</span></span>
<span id="cb3-2"><a href="#cb3-2"></a><span class="co"> * @brief     turn_on_leds function used to turn on the RGB LEDs</span></span>
<span id="cb3-3"><a href="#cb3-3"></a><span class="co"> * @param[in] pred_index</span></span>
<span id="cb3-4"><a href="#cb3-4"></a><span class="co"> *            no:       [0] ==&gt; Red ON</span></span>
<span id="cb3-5"><a href="#cb3-5"></a><span class="co"> *            noise:    [1] ==&gt; ALL OFF</span></span>
<span id="cb3-6"><a href="#cb3-6"></a><span class="co"> *            unknown:  [2] ==&gt; Blue ON</span></span>
<span id="cb3-7"><a href="#cb3-7"></a><span class="co"> *            Yes:      [3] ==&gt; Green ON</span></span>
<span id="cb3-8"><a href="#cb3-8"></a><span class="co"> */</span></span>
<span id="cb3-9"><a href="#cb3-9"></a><span class="dt">void</span> turn_on_leds<span class="op">(</span><span class="dt">int</span> pred_index<span class="op">)</span> <span class="op">{</span></span>
<span id="cb3-10"><a href="#cb3-10"></a>  <span class="cf">switch</span> <span class="op">(</span>pred_index<span class="op">)</span></span>
<span id="cb3-11"><a href="#cb3-11"></a>  <span class="op">{</span></span>
<span id="cb3-12"><a href="#cb3-12"></a>    <span class="cf">case</span> <span class="dv">0</span><span class="op">:</span></span>
<span id="cb3-13"><a href="#cb3-13"></a>      turn_off_leds<span class="op">();</span></span>
<span id="cb3-14"><a href="#cb3-14"></a>      digitalWrite<span class="op">(</span>LEDR<span class="op">,</span> LOW<span class="op">);</span></span>
<span id="cb3-15"><a href="#cb3-15"></a>      <span class="cf">break</span><span class="op">;</span></span>
<span id="cb3-16"><a href="#cb3-16"></a></span>
<span id="cb3-17"><a href="#cb3-17"></a>    <span class="cf">case</span> <span class="dv">1</span><span class="op">:</span></span>
<span id="cb3-18"><a href="#cb3-18"></a>      turn_off_leds<span class="op">();</span></span>
<span id="cb3-19"><a href="#cb3-19"></a>      <span class="cf">break</span><span class="op">;</span></span>
<span id="cb3-20"><a href="#cb3-20"></a></span>
<span id="cb3-21"><a href="#cb3-21"></a>    <span class="cf">case</span> <span class="dv">2</span><span class="op">:</span></span>
<span id="cb3-22"><a href="#cb3-22"></a>      turn_off_leds<span class="op">();</span></span>
<span id="cb3-23"><a href="#cb3-23"></a>      digitalWrite<span class="op">(</span>LEDB<span class="op">,</span> LOW<span class="op">);</span></span>
<span id="cb3-24"><a href="#cb3-24"></a>      <span class="cf">break</span><span class="op">;</span></span>
<span id="cb3-25"><a href="#cb3-25"></a></span>
<span id="cb3-26"><a href="#cb3-26"></a>    <span class="cf">case</span> <span class="dv">3</span><span class="op">:</span></span>
<span id="cb3-27"><a href="#cb3-27"></a>      turn_off_leds<span class="op">();</span></span>
<span id="cb3-28"><a href="#cb3-28"></a>      digitalWrite<span class="op">(</span>LEDG<span class="op">,</span> LOW<span class="op">);</span></span>
<span id="cb3-29"><a href="#cb3-29"></a>      <span class="cf">break</span><span class="op">;</span></span>
<span id="cb3-30"><a href="#cb3-30"></a>  <span class="op">}</span></span>
<span id="cb3-31"><a href="#cb3-31"></a><span class="op">}</span></span></code></pre></div>
<p>And change the <code>// print the predictions</code> portion of the code on <code>loop()</code>:</p>
<div class="sourceCode" id="cb4"><pre class="sourceCode numberSource cpp number-lines"><code class="sourceCode cpp"><span id="cb4-1"><a href="#cb4-1"></a><span class="op">...</span></span>
<span id="cb4-2"><a href="#cb4-2"></a></span>
<span id="cb4-3"><a href="#cb4-3"></a> <span class="cf">if</span> <span class="op">(++</span>print_results <span class="op">&gt;=</span> <span class="op">(</span>EI_CLASSIFIER_SLICES_PER_MODEL_WINDOW<span class="op">))</span> <span class="op">{</span></span>
<span id="cb4-4"><a href="#cb4-4"></a>     <span class="co">// print the predictions</span></span>
<span id="cb4-5"><a href="#cb4-5"></a>     ei_printf<span class="op">(</span><span class="st">&quot;Predictions &quot;</span><span class="op">);</span></span>
<span id="cb4-6"><a href="#cb4-6"></a>     ei_printf<span class="op">(</span><span class="st">&quot;(DSP: </span><span class="sc">%d</span><span class="st"> ms., Classification: </span><span class="sc">%d</span><span class="st"> ms.,</span></span>
<span id="cb4-7"><a href="#cb4-7"></a>                 Anomaly<span class="op">:</span> <span class="op">%</span>d ms<span class="op">.)</span><span class="st">&quot;,</span></span>
<span id="cb4-8"><a href="#cb4-8"></a>         result<span class="op">.</span>timing<span class="op">.</span>dsp<span class="op">,</span> result<span class="op">.</span>timing<span class="op">.</span>classification<span class="op">,</span></span>
<span id="cb4-9"><a href="#cb4-9"></a>         result<span class="op">.</span>timing<span class="op">.</span>anomaly<span class="op">);</span></span>
<span id="cb4-10"><a href="#cb4-10"></a>     ei_printf<span class="op">(</span><span class="st">&quot;: </span><span class="sc">\n</span><span class="st">&quot;</span><span class="op">);</span></span>
<span id="cb4-11"><a href="#cb4-11"></a>     <span class="dt">int</span> pred_index <span class="op">=</span> <span class="dv">0</span><span class="op">;</span>     <span class="co">// Initialize pred_index</span></span>
<span id="cb4-12"><a href="#cb4-12"></a>     <span class="dt">float</span> pred_value <span class="op">=</span> <span class="dv">0</span><span class="op">;</span>   <span class="co">// Initialize pred_value</span></span>
<span id="cb4-13"><a href="#cb4-13"></a>     <span class="cf">for</span> <span class="op">(</span><span class="dt">size_t</span> ix <span class="op">=</span> <span class="dv">0</span><span class="op">;</span> ix <span class="op">&lt;</span> EI_CLASSIFIER_LABEL_COUNT<span class="op">;</span> ix<span class="op">++)</span> <span class="op">{</span></span>
<span id="cb4-14"><a href="#cb4-14"></a>         <span class="cf">if</span> <span class="op">(</span>result<span class="op">.</span>classification<span class="op">[</span>ix<span class="op">].</span>value <span class="op">&gt;</span> pred_value<span class="op">){</span></span>
<span id="cb4-15"><a href="#cb4-15"></a>             pred_index <span class="op">=</span> ix<span class="op">;</span></span>
<span id="cb4-16"><a href="#cb4-16"></a>             pred_value <span class="op">=</span> result<span class="op">.</span>classification<span class="op">[</span>ix<span class="op">].</span>value<span class="op">;</span></span>
<span id="cb4-17"><a href="#cb4-17"></a>         <span class="op">}</span></span>
<span id="cb4-18"><a href="#cb4-18"></a>         <span class="co">// ei_printf(&quot;    %s: &quot;,</span></span>
<span id="cb4-19"><a href="#cb4-19"></a>         <span class="co">// result.classification[ix].label);</span></span>
<span id="cb4-20"><a href="#cb4-20"></a>         <span class="co">// ei_printf_float(result.classification[ix].value);</span></span>
<span id="cb4-21"><a href="#cb4-21"></a>         <span class="co">// ei_printf(&quot;\n&quot;);</span></span>
<span id="cb4-22"><a href="#cb4-22"></a>     <span class="op">}</span></span>
<span id="cb4-23"><a href="#cb4-23"></a>     ei_printf<span class="op">(</span><span class="st">&quot;  PREDICTION: ==&gt; </span><span class="sc">%s</span><span class="st"> with probability </span><span class="sc">%.2f\n</span><span class="st">&quot;</span><span class="op">,</span></span>
<span id="cb4-24"><a href="#cb4-24"></a>               result<span class="op">.</span>classification<span class="op">[</span>pred_index<span class="op">].</span>label<span class="op">,</span></span>
<span id="cb4-25"><a href="#cb4-25"></a>               pred_value<span class="op">);</span></span>
<span id="cb4-26"><a href="#cb4-26"></a>     turn_on_leds <span class="op">(</span>pred_index<span class="op">);</span></span>
<span id="cb4-27"><a href="#cb4-27"></a></span>
<span id="cb4-28"><a href="#cb4-28"></a><span class="pp">#if EI_CLASSIFIER_HAS_ANOMALY == 1</span></span>
<span id="cb4-29"><a href="#cb4-29"></a>        ei_printf<span class="op">(</span><span class="st">&quot;    anomaly score: &quot;</span><span class="op">);</span></span>
<span id="cb4-30"><a href="#cb4-30"></a>        ei_printf_float<span class="op">(</span>result<span class="op">.</span>anomaly<span class="op">);</span></span>
<span id="cb4-31"><a href="#cb4-31"></a>        ei_printf<span class="op">(</span><span class="st">&quot;</span><span class="sc">\n</span><span class="st">&quot;</span><span class="op">);</span></span>
<span id="cb4-32"><a href="#cb4-32"></a><span class="pp">#endif</span></span>
<span id="cb4-33"><a href="#cb4-33"></a></span>
<span id="cb4-34"><a href="#cb4-34"></a>        print_results <span class="op">=</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="cb4-35"><a href="#cb4-35"></a>    <span class="op">}</span></span>
<span id="cb4-36"><a href="#cb4-36"></a><span class="op">}</span></span>
<span id="cb4-37"><a href="#cb4-37"></a></span>
<span id="cb4-38"><a href="#cb4-38"></a><span class="op">...</span></span></code></pre></div>
<p>You can find the complete code on the <a href="https://github.com/Mjrovai/Arduino_Nicla_Vision/tree/main/KWS/nicla_vision_microphone_continuous_LED">project’s GitHub</a>.</p>
<p>Upload the sketch to your board and test some real inferences. The idea is that the Green LED will be ON whenever the keyword YES is detected, the Red will lit for a NO, and any other word will turn on the Blue LED. All the LEDs should be off if silence or background noise is present. Remember that the same procedure can “trigger” an external device to perform a desired action instead of turning on an LED, as we saw in the introduction.</p>
<p><a href="https://youtu.be/25Rd76OTXLY">https://youtu.be/25Rd76OTXLY</a></p>
</section>
<section id="sec-keyword-spotting-kws-summary-06f5" class="level2 unnumbered">
<h2 class="unnumbered">Summary</h2>
<blockquote>
<p>You will find the notebooks and code used in this hands-on tutorial on the <a href="https://github.com/Mjrovai/Arduino_Nicla_Vision/tree/main/KWS">GitHub</a> repository.</p>
</blockquote>
<p>Before we finish, consider that Sound Classification is more than just voice. For example, you can develop TinyML projects around sound in several areas, such as:</p>
<ul>
<li><strong>Security</strong> (Broken Glass detection, Gunshot)</li>
<li><strong>Industry</strong> (Anomaly Detection)</li>
<li><strong>Medical</strong> (Snore, Cough, Pulmonary diseases)</li>
<li><strong>Nature</strong> (Beehive control, insect sound, pouching mitigation)</li>
</ul>
</section>
<section id="sec-keyword-spotting-kws-resources-a202" class="level2 unnumbered">
<h2 class="unnumbered">Resources</h2>
<ul>
<li><p><a href="https://cdn.edgeimpulse.com/datasets/keywords2.zip">Subset of Google Speech Commands Dataset</a></p></li>
<li><p><a href="https://colab.research.google.com/github/Mjrovai/Arduino_Nicla_Vision/blob/main/KWS/KWS_MFCC_Analysis.ipynb">KWS MFCC Analysis Colab Notebook</a></p></li>
<li><p><a href="https://colab.research.google.com/github/Mjrovai/Arduino_Nicla_Vision/blob/main/KWS/KWS_CNN_training.ipynb">KWS_CNN_training Colab Notebook</a></p></li>
<li><p><a href="https://github.com/Mjrovai/Arduino_Nicla_Vision/tree/main/KWS/nicla_vision_microphone_continuous_LED">Arduino Post-processing Code</a></p></li>
<li><p><a href="https://studio.edgeimpulse.com/public/292418/latest">Edge Impulse Project</a></p></li>
</ul>
</section>
</section>
</body>
</html>
