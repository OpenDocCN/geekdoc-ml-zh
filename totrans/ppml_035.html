<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.1//EN"
  "http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd">

<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<title>Sized</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1>Sized</h1>
<blockquote>原文：<a href="https://rust-exercises.com/100-exercises/04_traits/08_sized.html">https://rust-exercises.com/100-exercises/04_traits/08_sized.html</a></blockquote>
                        
<p>There's more to <code>&amp;str</code> than meets the eye, even after having
investigated deref coercion.<br/>
From our previous <a href="/100-exercises/03_ticket_v1/10_references_in_memory">discussion on memory layouts</a>,
it would have been reasonable to expect <code>&amp;str</code> to be represented as a single <code>usize</code> on
the stack, a pointer. That's not the case though. <code>&amp;str</code> stores some <strong>metadata</strong> next
to the pointer: the length of the slice it points to. Going back to the example from
<a href="/100-exercises/04_traits/06_str_slice">a previous section</a>:</p>
<pre><code class="language-rust">let mut s = String::with_capacity(5);
s.push_str("Hello");
// Create a string slice reference from the `String`, 
// skipping the first byte.
let slice: &amp;str = &amp;s[1..];</code></pre>
<p>In memory, we get:</p>
<pre><code class="language-text">                    s                              slice
      +---------+--------+----------+      +---------+--------+
Stack | pointer | length | capacity |      | pointer | length |
      |    |    |   5    |    5     |      |    |    |   4    |
      +----|----+--------+----------+      +----|----+--------+
           |        s                           |  
           |                                    |
           v                                    | 
         +---+---+---+---+---+                  |
Heap:    | H | e | l | l | o |                  |
         +---+---+---+---+---+                  |
               ^                                |
               |                                |
               +--------------------------------+
</code></pre>
<p>What's going on?</p>
<h2 id="dynamically-sized-types"><a class="header" href="#dynamically-sized-types">Dynamically sized types</a></h2>
<p><code>str</code> is a <strong>dynamically sized type</strong> (DST).<br/>
A DST is a type whose size is not known at compile time. Whenever you have a
reference to a DST, like <code>&amp;str</code>, it has to include additional
information about the data it points to. It is a <strong>fat pointer</strong>.<br/>
In the case of <code>&amp;str</code>, it stores the length of the slice it points to.
We'll see more examples of DSTs in the rest of the course.</p>
<h2 id="the-sized-trait"><a class="header" href="#the-sized-trait">The <code>Sized</code> trait</a></h2>
<p>Rust's <code>std</code> library defines a trait called <code>Sized</code>.</p>
<pre><code class="language-rust">pub trait Sized {
    // This is an empty trait, no methods to implement.
}</code></pre>
<p>A type is <code>Sized</code> if its size is known at compile time. In other words, it's not a DST.</p>
<h3 id="marker-traits"><a class="header" href="#marker-traits">Marker traits</a></h3>
<p><code>Sized</code> is your first example of a <strong>marker trait</strong>.<br/>
A marker trait is a trait that doesn't require any methods to be implemented. It doesn't define any behavior.
It only serves to <strong>mark</strong> a type as having certain properties.
The mark is then leveraged by the compiler to enable certain behaviors or optimizations.</p>
<h3 id="auto-traits"><a class="header" href="#auto-traits">Auto traits</a></h3>
<p>In particular, <code>Sized</code> is also an <strong>auto trait</strong>.<br/>
You don't need to implement it explicitly; the compiler implements it automatically for you
based on the type's definition.</p>
<h3 id="examples"><a class="header" href="#examples">Examples</a></h3>
<p>All the types we've seen so far are <code>Sized</code>: <code>u32</code>, <code>String</code>, <code>bool</code>, etc.</p>
<p><code>str</code>, as we just saw, is not <code>Sized</code>.<br/>
<code>&amp;str</code> is <code>Sized</code> though! We know its size at compile time: two <code>usize</code>s, one for the pointer
and one for the length.</p>
<h2 id="exercise"><a class="header" href="#exercise">Exercise</a></h2>
<p>The exercise for this section is located in <a href="https://github.com/mainmatter/100-exercises-to-learn-rust/tree/main/exercises/04_traits/08_sized"><code>04_traits/08_sized</code></a></p>

                        
</body>
</html>