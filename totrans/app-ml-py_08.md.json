["```py\nimport geostatspy.GSLIB as GSLIB                              # GSLIB utilities, visualization and wrapper\nimport geostatspy.geostats as geostats                        # GSLIB methods convert to Python \nimport geostatspy\nprint('GeostatsPy version: ' + str(geostatspy.__version__)) \n```", "```py\nGeostatsPy version: 0.0.71 \n```", "```py\nignore_warnings = True                                        # ignore warnings?\nimport numpy as np                                            # ndarrays for gridded data\nimport pandas as pd                                           # DataFrames for tabular data\nfrom scipy import stats                                       # summary statistics\nfrom scipy.stats import pearsonr                              # Pearson product moment correlation\nfrom scipy.stats import spearmanr                             # spearman rank correlation\nfrom scipy.stats import rankdata                              # rank data for visualization\nimport copy                                                   # for deep copies\nimport os                                                     # set working directory, run executables\nimport matplotlib.pyplot as plt                               # for plotting\nfrom matplotlib.ticker import (MultipleLocator, AutoMinorLocator) # control of axes ticks\nfrom matplotlib.colors import ListedColormap                  # custom color maps\nimport seaborn as sns                                         # advanced plotting\nimport matplotlib.ticker as mtick                             # control tick label formatting\nplt.rc('axes', axisbelow=True)                                # plot all grids below the plot elements\nif ignore_warnings == True:                                   \n    import warnings\n    warnings.filterwarnings('ignore')\ncmap = plt.cm.inferno                                         # color map\nseed = 42                                                     # random number seed \n```", "```py\ndef plot_corr(corr_matrix,title,limits,mask):                 # plots a graphical correlation matrix \n    my_colormap = plt.cm.get_cmap('RdBu_r', 256)          \n    newcolors = my_colormap(np.linspace(0, 1, 256))\n    white = np.array([256/256, 256/256, 256/256, 1])\n    white_low = int(128 - mask*128); white_high = int(128+mask*128)\n    newcolors[white_low:white_high, :] = white                # mask all correlations less than abs(0.8)\n    newcmp = ListedColormap(newcolors)\n    m = corr_matrix.shape[0]\n    im = plt.matshow(corr_matrix,fignum=0,vmin = -1.0*limits, vmax = limits,cmap = newcmp)\n    plt.xticks(range(len(corr_matrix.columns)), corr_matrix.columns)\n    plt.yticks(range(len(corr_matrix.columns)), corr_matrix.columns)\n    plt.colorbar(im, orientation = 'vertical')\n    plt.title(title)\n    for i in range(0,m):\n        plt.plot([i-0.5,i-0.5],[-0.5,m-0.5],color='black')\n        plt.plot([-0.5,m-0.5],[i-0.5,i-0.5],color='black')\n    plt.ylim([-0.5,m-0.5]); plt.xlim([-0.5,m-0.5])\n\ndef add_grid():\n    plt.gca().grid(True, which='major',linewidth = 1.0); plt.gca().grid(True, which='minor',linewidth = 0.2) # add y grids\n    plt.gca().tick_params(which='major',length=7); plt.gca().tick_params(which='minor', length=4)\n    plt.gca().xaxis.set_minor_locator(AutoMinorLocator()); plt.gca().yaxis.set_minor_locator(AutoMinorLocator()) # turn on minor ticks \n\ndef add_grid2(sub_plot):\n    sub_plot.grid(True, which='major',linewidth = 1.0); sub_plot.grid(True, which='minor',linewidth = 0.2) # add y grids\n    sub_plot.tick_params(which='major',length=7); sub_plot.tick_params(which='minor', length=4)\n    sub_plot.xaxis.set_minor_locator(AutoMinorLocator()); sub_plot.yaxis.set_minor_locator(AutoMinorLocator()) # turn on minor ticks \n```", "```py\nmy_colormap = plt.cm.get_cmap('RdBu_r', 256)                  # make a custom colormap\nnewcolors = my_colormap(np.linspace(0, 1, 256))               # define colormap space\nwhite = np.array([250/256, 250/256, 250/256, 1])              # define white color (4 channel)\n#newcolors[26:230, :] = white                                 # mask all correlations less than abs(0.8)\n#newcolors[56:200, :] = white                                 # mask all correlations less than abs(0.6)\nnewcolors[76:180, :] = white                                  # mask all correlations less than abs(0.4)\nsignif = ListedColormap(newcolors)                            # assign as listed colormap\n\nmy_colormap = plt.cm.get_cmap('inferno', 256)                 # make a custom colormap\nnewcolors = my_colormap(np.linspace(0, 1, 256))               # define colormap space\nwhite = np.array([250/256, 250/256, 250/256, 1])              # define white color (4 channel)\n#newcolors[26:230, :] = white                                 # mask all correlations less than abs(0.8)\nnewcolors[0:12, :] = white                                    # mask all correlations less than abs(0.6)\n#newcolors[86:170, :] = white                                 # mask all correlations less than abs(0.4)\nsign1 = ListedColormap(newcolors)                             # assign as listed colormap \n```", "```py\ncorr_mat = [-0.96,0.0,0.4,0.7]; ndata = 1000                   # set the correlation coefficient, number of samples\n\nfor i, corr in enumerate(corr_mat):\n    plt.subplot(2,2,i+1)\n    mean = np.array([0,0])                                     # make the bivariate Gaussian data\n    correl = np.array([[1.0,corr],[corr,1.0]],dtype=float)\n    np.random.seed(seed = seed)\n    sample = np.random.multivariate_normal(mean,correl,size = ndata)\n    plt.scatter(sample[:,0],sample[:,1],color = 'red',alpha = 0.2,edgecolors='black',label = 'Samples',zorder=100)\n    plt.xlim([-3.0,3.0]); plt.ylim([-3.0,3.0])\n    plt.xlabel(r'$x_1$'); plt.ylabel(r'$X_2$'); plt.legend(loc='upper left'); add_grid()\n    plt.title(r'Bivariate Standard Gaussian Distributed Data with $\\rho_{x_1,x_2} =$' + str(np.round(corr,2)))\n\nplt.subplots_adjust(left=0.0, bottom=0.0, right=2.0, top=2.2, wspace=0.3, hspace=0.3); plt.show() \n```", "```py\ncorr = 0.0; outlier_mat = [0,1,1.5,1.9]; ndata = 100           # set the correlation coefficient, number of samples\n\nfor i, outlier in enumerate(outlier_mat):\n    plt.subplot(2,2,i+1)\n    mean = np.array([0,0])                                     # make the bivariate Gaussian data\n    correl = np.array([[1.0,corr],[corr,1.0]],dtype=float)\n    np.random.seed(seed = seed)\n    sample = np.random.multivariate_normal(mean,correl,size = ndata)\n    sample = np.vstack([sample, [pow(10.0,outlier),pow(10.0,outlier)]]) # add outlier\n    plt.scatter(sample[:,0],sample[:,1],color = 'red',alpha = 0.2,edgecolors='black',s=10,label = 'samples',zorder=100) # plot result\n    plt.scatter(sample[-1,0],sample[-1,1],color = 'black',alpha = 0.8,marker = 'x',label = 'outlier', zorder=200)\n    plt.xlim([-3.0,100.0]); plt.ylim([-3.0,100.0])\n    plt.xlabel(r'$x_1$'); plt.ylabel(r'$X_2$'); plt.legend(loc='upper left'); add_grid()\n    plt.title(r'Bivariate Standard Gaussian Distributed Data with $\\rho_{x_1,x_2} =$' + str(np.round(corr,2)))\n    pearson_corr = pearsonr(sample[:,0],sample[:,1])[0]\n    rank_corr = spearmanr(sample[:,0],sample[:,1])[0]\n    plt.annotate(r'$\\rho_{x_1,x_2}$ = ' + str(np.round(pearson_corr,3)),[75.0,30.0])\n    plt.annotate(r'$\\rho_{R_{x_1},R_{x_2}}$ = ' + str(np.round(rank_corr,3)),[75.0,25.0])\nplt.subplots_adjust(left=0.0, bottom=0.0, right=2.0, top=2.2, wspace=0.3, hspace=0.3); plt.show() \n```", "```py\n#os.chdir(\"c:/PGE383\")                                        # set the working directory \n```", "```py\n#df = pd.read_csv('sample_data_MV_biased.csv')                # load our data table\ndf = pd.read_csv('https://raw.githubusercontent.com/GeostatsGuy/GeoDataSets/master/sample_data_MV_biased.csv')\ndf = df.iloc[:,1:] \n```", "```py\ndf.head(n=13)                                                 # we could also use this command for a table preview \n```", "```py\ndf.describe().transpose()                                     # DataFrame summary statistics \n```", "```py\nxmin = 0.0; xmax = 1000.0                                     # range of x values\nymin = 0.0; ymax = 1000.0                                     # range of y values\npormin = 0.05; pormax = 0.25;                                 # range of porosity values\npermmin = 0.01; permmax = 2000.0                              # range of permeability values\nAImin = 2000.0; AImax = 8000.0                                # range of AI values\nnx = 100; ny = 100; csize = 10.0 \n```", "```py\nplt.subplot(221)\nGSLIB.locmap_st(df,'X','Y','Facies',xmin,xmax,ymin,ymax,0,1,'Well Data - Porosity','X(m)','Y(m)','Facies (0-shale, 1-sand)',cmap)\n\nplt.subplot(222)\nGSLIB.locmap_st(df,'X','Y','Porosity',xmin,xmax,ymin,ymax,pormin,pormax,'Well Data - Porosity','X(m)','Y(m)','Porosity (fraction)',cmap)\n\nplt.subplot(223)\nGSLIB.locmap_st(df,'X','Y','Perm',xmin,xmax,ymin,ymax,permmin,permmax,'Well Data - Permeability','X(m)','Y(m)','Permeability (md)',cmap)\n\nplt.subplot(224)\nGSLIB.locmap_st(df,'X','Y','AI',xmin,xmax,ymin,ymax,AImin,AImax,'Well Data - Acoustic Impedance','X(m)','Y(m)','Acoustic Impedance (m/s x g/cm^3)',cmap)\n\nplt.subplots_adjust(left=0.0, bottom=0.0, right=1.5, top=1.7, wspace=0.3, hspace=0.3); plt.show() \n```", "```py\nplt.subplot(121)\nplt.plot(df['Porosity'].values,df['Perm'].values, 'o', label='', markerfacecolor='darkorange', markeredgecolor='black', alpha=0.8)\nplt.title('Well Data Permeability vs. Porosity')\nplt.xlabel('Porosity (fraction)'); plt.ylabel('Permeability (mD)')\nplt.xlim([pormin,pormax]); plt.ylim([permmin,permmax]); add_grid()\n\nplt.subplot(122)\nplt.plot(df['AI'].values,df['Porosity'].values, 'o', label='', markerfacecolor='darkorange', markeredgecolor='black', alpha=0.8)\nplt.title('Well Data Porosity vs. Acoustic Impedance')\nplt.ylabel('Porosity (fraction)'); plt.xlabel('Acoustic Impedance (m/s x g/cm^3)')\nplt.xlim([AImin,AImax]); plt.ylim([pormin,pormax]); add_grid()\n\nplt.subplots_adjust(left=0.0, bottom=0.0, right=1.5, top=0.8, wspace=0.3, hspace=0.2)\n#plt.savefig('Test.pdf', dpi=600, bbox_inches = 'tight',format='pdf') \nplt.show() \n```", "```py\nprint(df.iloc[:,3:7].cov())                                   # the covariance matrix for columns 3,4,5 and 6 and all rows\nprint('The variance of porosity is ' + str(round(np.var(df['Porosity'].values),6))) \n```", "```py\n Porosity          Perm             AI\nPorosity   0.000939      4.055029     -17.132244\nPerm       4.055029  52149.501968  -46471.695092\nAI       -17.132244 -46471.695092  949768.302409\nThe variance of porosity is 0.000936 \n```", "```py\ndf.iloc[:,3:7].corr()                                         # correlation matrix \n```", "```py\ncorr_matrix = df.iloc[:,2:].corr()\nplt.subplot(111)\nplot_corr(corr_matrix,'Correlation Matrix',1.0,0.5)           # using our correlation matrix visualization function\nplt.subplots_adjust(left=0.0, bottom=0.0, right=1.0, top=0.8, wspace=0.2, hspace=0.3); plt.show() \n```", "```py\ncorr, corr_p_value = pearsonr(df['Porosity'],df['Perm'])\n\nplt.subplot(111)\nplt.plot(df['Porosity'].values,df['Perm'].values, 'o', label='', markerfacecolor='darkorange', markeredgecolor='black', alpha=0.8)\nplt.title('Well Data Permeability vs. Porosity')\nplt.xlabel('Porosity (fraction)'); plt.ylabel('Permeability (mD)')\nplt.xlim([pormin,pormax]); plt.ylim([permmin,permmax]); add_grid()\n\nplt.annotate(r'$\\rho_{\\phi,k}$ = ' + str(np.round(corr,3)),[0.075,1600.0])\nplt.annotate(r'$\\rho_{\\phi,k}$, p-value = ' + str(np.round(corr_p_value,20)),[0.075,1500.0])\nplt.subplots_adjust(left=0.0, bottom=0.0, right=1.0, top=1.2, wspace=0.3, hspace=0.2); plt.show() \n```", "```py\nrank_correlation, rank_correlation_pval = stats.spearmanr(df.iloc[:,2:]) # calculate the range correlation coefficient\nrank_matrix = pd.DataFrame(rank_correlation,columns=corr_matrix.columns)\nprint('Rank Correlation:')\nprint(rank_correlation)\nprint('\\nRank Correlation p-value:')\nprint(rank_correlation_pval) \n```", "```py\nRank Correlation:\n[[ 1\\.          0.79973189  0.71923703 -0.50503617]\n [ 0.79973189  1\\.          0.88314655 -0.56863773]\n [ 0.71923703  0.88314655  1\\.         -0.34876935]\n [-0.50503617 -0.56863773 -0.34876935  1\\.        ]]\n\nRank Correlation p-value:\n[[0.00000000e+000 4.11417796e-083 7.49150387e-060 3.24513314e-025]\n [4.11417796e-083 0.00000000e+000 2.26847950e-122 6.59769641e-033]\n [7.49150387e-060 2.26847950e-122 0.00000000e+000 5.77157354e-012]\n [3.24513314e-025 6.59769641e-033 5.77157354e-012 0.00000000e+000]] \n```", "```py\ncorr = 0.0; xout = 9; yout = 9; n = 100                       # correlation, outlier datum, and total number of data\nmean = [0, 0]                                                 # bivariate Gaussian mean vector\ncov = [[1, corr], [corr, 1]]                                  # bivariate Gaussian covariance matrix\n\nnp.random.seed(seed = seed)                                   # set seed for repeatability\nsamples = np.random.multivariate_normal(mean, cov, n)         # random samples from bivariate Gaussian\nsamples[-1,0] = xout; samples[-1,1] = yout                    # replace last sample with user specified outlier\nx2 = samples[:, 0]; y2 = samples[:, 1]                        # copy x and y for compact code\n\ncorr = stats.pearsonr(x2[:-1],y2[:-1])[0]                     # calculate Pearson and Spearman correlation without outlier\nrank_corr = stats.spearmanr(x2[:-1],y2[:-1])[0] \ncorr_out = stats.pearsonr(x2,y2)[0]                           # calculate Pearson and Spearman correlation with outlier\nrank_corr_out = stats.spearmanr(x2,y2)[0]\n\nplt.subplot(121)\nplt.scatter(x2,y2,color='red',edgecolor='black',zorder=1)     # plot and annotate results\nplt.scatter(x2[-1],y2[-1],color='white',edgecolor='black',zorder=10)\nplt.scatter([5.7,5.7],[0.17,-1.8],color='white',edgecolor='black',zorder=1) \nplt.scatter([5.4],[-1.8],color='red',edgecolor='black',zorder=1) \nplt.annotate('With outlier:',[6.0,0.1])\nplt.annotate(r'$\\rho^{out}_{x,y} = $',[6.5,-0.5])\nplt.annotate(r'$\\rho^{out}_{R_x,R_y} = $',[6.5,-1.2])\nplt.annotate('Without outlier:',[6.0,-1.9])\nplt.annotate(r'$\\rho_{x,y} = $',[6.5,-2.5])\nplt.annotate(r'$\\rho_{R_x,R_y} = $',[6.5,-3.2])\nplt.xlim([-4,10]); plt.ylim([-4,10]); plt.xlabel('X'); plt.ylabel('Y'); add_grid(); plt.title('Impact of an Outlier on Correlation')\n\nplt.subplot(122)\nplt.scatter(x2,y2,color='red',edgecolor='black',zorder=1)       # plot and annotate results\nplt.scatter(x2[-1],y2[-1],color='white',edgecolor='black',zorder=10)\nplt.scatter([5.7,5.7],[0.17,-1.8],color='white',edgecolor='black',zorder=1) \nplt.scatter([5.4],[-1.8],color='red',edgecolor='black',zorder=1) \nplt.annotate('With outlier:',[6.0,0.1])\nplt.annotate(r'$\\rho^{out}_{x,y} = $' + str(round(corr_out,2)),[6.5,-0.5])\nplt.annotate(r'$\\rho^{out}_{R_x,R_y} = $' + str(round(rank_corr_out,2)),[6.5,-1.2])\nplt.annotate('Without outlier:',[6.0,-1.9])\nplt.annotate(r'$\\rho_{x,y} = $' + str(round(corr,2)),[6.5,-2.5])\nplt.annotate(r'$\\rho_{R_x,R_y} = $' + str(round(rank_corr,2)),[6.5,-3.2])\nplt.xlim([-4,10]); plt.ylim([-4,10]); plt.xlabel('X'); plt.ylabel('Y'); add_grid(); plt.title('Impact of an Outlier on Correlation')\n\nplt.subplots_adjust(left=0.0, bottom=0.0, right=2.0, top=1.2, wspace=0.2, hspace=0.3); plt.show() \n```", "```py\nx2_rank = rankdata(x2)                                          # rank transform data, x and y separately\ny2_rank = rankdata(y2)\n\nplt.subplot(121)\nplt.scatter(x2,y2,color='red',edgecolor='black',zorder=1)       # plot and annotate results\nplt.scatter(x2[-1],y2[-1],color='white',edgecolor='black',zorder=10)\nplt.scatter([5.7,5.7],[0.17,-1.8],color='white',edgecolor='black',zorder=1) \nplt.scatter([5.4],[-1.8],color='red',edgecolor='black',zorder=1) \nplt.annotate('With outlier:',[6.0,0.1])\nplt.annotate(r'$\\rho^{out}_{x,y} = $' + str(round(corr_out,2)),[6.5,-0.5])\nplt.annotate(r'$\\rho^{out}_{R_x,R_y} = $' + str(round(rank_corr_out,2)),[6.5,-1.2])\nplt.annotate('Without outlier:',[6.0,-1.9])\nplt.annotate(r'$\\rho_{x,y} = $' + str(round(corr,2)),[6.5,-2.5])\nplt.annotate(r'$\\rho_{R_x,R_y} = $' + str(round(rank_corr,2)),[6.5,-3.2])\nplt.xlim([-4,10]); plt.ylim([-4,10]); plt.xlabel('X'); plt.ylabel('Y'); add_grid(); plt.title('Impact of an Outlier on Correlation')\n\nplt.subplot(122)\nplt.scatter(x2_rank,y2_rank,color='red',edgecolor='black',zorder=1) # plot and annotate results\nplt.scatter(x2_rank[-1],y2_rank[-1],color='white',edgecolor='black',zorder=10)\nplt.xlim([0,n+1]); plt.ylim([0,n+1]); plt.xlabel(r'$X_{rank}$'); plt.ylabel(r'$Y_{rank}$'); add_grid(); plt.title('Data Rank Transformed')\n\nplt.subplots_adjust(left=0.0, bottom=0.0, right=2.0, top=1.2, wspace=0.2, hspace=0.3); plt.show() \n```", "```py\nx3 = np.linspace(-3.0,3.0,n)\ny3 = x3**2\n\ncorr = stats.pearsonr(x3,y3)[0]                               # calculate Pearson and Spearman correlation with outlier\nrank_corr = stats.spearmanr(x3,y3)[0]\n\ncorr_half = stats.pearsonr(x3[:-50],y3[:-50])[0]              # calculate Pearson and Spearman correlation with outlier\nrank_corr_half = stats.spearmanr(x3[:-50],y3[:-50])[0]\n\nplt.subplot(121)\nplt.scatter(x3,y3,color='red',edgecolor='black',zorder=1)     # plot and annotate results\nplt.scatter(x3[:-50],y3[:-50],color='white',edgecolor='black',zorder=10) # first half\nplt.scatter([5.7,5.7],[4.15,2.15],color='white',edgecolor='black',zorder=1) \nplt.scatter([5.4],[2.15],color='red',edgecolor='black',zorder=1) \nplt.annotate('First half of data only:',[6.0,4.1])\nplt.annotate(r'$\\rho^{half}_{x,y} = $',[6.5,3.5])\nplt.annotate(r'$\\rho^{half}_{R_x,R_y} = $',[6.5,2.8])\nplt.annotate('All data:',[6.0,2.1])\nplt.annotate(r'$\\rho_{x,y} = $',[6.5,1.5])\nplt.annotate(r'$\\rho_{R_x,R_y} = $',[6.5,0.8])\nplt.xlim([-4,10]); plt.ylim([-0.1,10]); plt.xlabel('X'); plt.ylabel('Y'); add_grid(); plt.title('Impact of an Outlier on Correlation')\n\nplt.subplot(122)\nplt.scatter(x3,y3,color='red',edgecolor='black',zorder=1)     # plot and annotate results\nplt.scatter(x3[:-50],y3[:-50],color='white',edgecolor='black',zorder=10) # first half\nplt.scatter([5.7,5.7],[4.15,2.15],color='white',edgecolor='black',zorder=1) \nplt.scatter([5.4],[2.15],color='red',edgecolor='black',zorder=1) \nplt.annotate('First half of data only:',[6.0,4.1])\nplt.annotate(r'$\\rho^{half}_{x,y} = $' + str(round(corr_half,2)),[6.5,3.5])\nplt.annotate(r'$\\rho^{half}_{R_x,R_y} = $' + str(round(rank_corr_half,2)),[6.5,2.8])\nplt.annotate('All data:',[6.0,2.1])\nplt.annotate(r'$\\rho_{x,y} = $' + str(round(corr,2)),[6.5,1.5])\nplt.annotate(r'$\\rho_{R_x,R_y} = $' + str(round(rank_corr,2)),[6.5,0.8])\nplt.xlim([-4,10]); plt.ylim([-0.1,10]); plt.xlabel('X'); plt.ylabel('Y'); add_grid(); plt.title('Impact of an Outlier on Correlation')\n\nplt.subplots_adjust(left=0.0, bottom=0.0, right=2.0, top=1.2, wspace=0.2, hspace=0.3); plt.show() \n```", "```py\nx3_rank = rankdata(x3)                                        # rank transform data, x and y separately\ny3_rank = rankdata(y3)\n\nplt.subplot(121)\nplt.scatter(x3,y3,color='red',edgecolor='black',zorder=1)     # plot and annotate results\nplt.scatter(x3[:-50],y3[:-50],color='white',edgecolor='black',zorder=10) # first half\nplt.scatter([5.7,5.7],[4.15,2.15],color='white',edgecolor='black',zorder=1) \nplt.scatter([5.4],[2.15],color='red',edgecolor='black',zorder=1) \nplt.annotate('First half of data only:',[6.0,4.1])\nplt.annotate(r'$\\rho^{half}_{x,y} = $' + str(round(corr_half,2)),[6.5,3.5])\nplt.annotate(r'$\\rho^{half}_{R_x,R_y} = $' + str(round(rank_corr_half,2)),[6.5,2.8])\nplt.annotate('All data:',[6.0,2.1])\nplt.annotate(r'$\\rho_{x,y} = $' + str(round(corr,2)),[6.5,1.5])\nplt.annotate(r'$\\rho_{R_x,R_y} = $' + str(round(rank_corr,2)),[6.5,0.8])\nplt.xlim([-4,10]); plt.ylim([-0.1,10]); plt.xlabel('X'); plt.ylabel('Y'); add_grid(); plt.title('Impact of an Nonlinearity on Correlation')\n\nplt.subplot(122)\nplt.scatter(x3_rank,y3_rank,color='red',edgecolor='black',zorder=1) # plot and annotate results\nplt.scatter(x3_rank[:-50],y3_rank[:-50],color='white',edgecolor='black',zorder=10)\nplt.xlim([0,n+1]); plt.ylim([0,n+1]); plt.xlabel(r'$X_{rank}$'); plt.ylabel(r'$Y_{rank}$'); add_grid(); plt.title('Data Rank Transformed')\n\nplt.subplots_adjust(left=0.0, bottom=0.0, right=2.0, top=1.2, wspace=0.2, hspace=0.3); plt.show() \n```", "```py\nn = 100                                                        # total number in each population\nnp.random.seed(seed = seed)                                   # set seed for repeatability\nmean4 = [-1.0, 2.0]                                                 # bivariate Gaussian mean vector\ncov4 = [[0.5, 0.0], [0.0, 0.5]]                               # bivariate Gaussian covariance matrix\nsamples4 = np.random.multivariate_normal(mean4, cov4, n)        # random samples from bivariate Gaussian\n\nmean5 = [4.0, 6.0]                                                 # bivariate Gaussian mean vector\ncov5 = [[0.3, 0.0], [0.0, 0.3]]                               # bivariate Gaussian covariance matrix\nsamples5 = np.random.multivariate_normal(mean5, cov5, n)        # random samples from bivariate Gaussian\n\nsamples45 = np.vstack((samples4,samples5))\n\ncorr = stats.pearsonr(samples45[:,0],samples45[:,1])[0]                               # calculate Pearson and Spearman correlation with outlier\nrank_corr = stats.spearmanr(samples45[:,0],samples45[:,1])[0]\n\ncorr_one = stats.pearsonr(samples4[:,0],samples4[:,1])[0]              # calculate Pearson and Spearman correlation with outlier\nrank_corr_one = stats.spearmanr(samples4[:,0],samples4[:,1])[0]\n\nplt.subplot(121)\nplt.scatter(samples4[:,0],samples4[:,1],color='white',edgecolor='black',zorder=1)     # plot and annotate results\nplt.scatter(samples5[:,0],samples5[:,1],color='red',edgecolor='black',zorder=1)     # plot and annotate results\n\nplt.scatter([5.7,5.7],[4.15,2.15],color='white',edgecolor='black',zorder=1) \nplt.scatter([5.4],[2.15],color='red',edgecolor='black',zorder=1) \nplt.annotate('First population only:',[6.0,4.1])\nplt.annotate(r'$\\rho^{half}_{x,y} = $' + str(round(corr_one,2)),[6.5,3.5])\nplt.annotate(r'$\\rho^{half}_{R_x,R_y} = $' + str(round(rank_corr_one,2)),[6.5,2.8])\nplt.annotate('Both populations:',[6.0,2.1])\nplt.annotate(r'$\\rho_{x,y} = $' + str(round(corr,2)),[6.5,1.5])\nplt.annotate(r'$\\rho_{R_x,R_y} = $' + str(round(rank_corr,2)),[6.5,0.8])\nplt.xlim([-4,10]); plt.ylim([-0.1,10]); plt.xlabel('X'); plt.ylabel('Y'); add_grid(); plt.title('Impact of Multiple Populations on Correlation')\n\nmean6 = [3.0, 4.0]                                                 # bivariate Gaussian mean vector\ncov6 = [[0.5, 0.45], [0.45, 0.5]]                               # bivariate Gaussian covariance matrix\nsamples6 = np.random.multivariate_normal(mean6, cov6, n)        # random samples from bivariate Gaussian\n\nmean7 = [2.0, 6.0]                                                 # bivariate Gaussian mean vector\ncov7 = [[0.3, 0.25], [0.25, 0.3]]                               # bivariate Gaussian covariance matrix\nsamples7 = np.random.multivariate_normal(mean7, cov7, n)        # random samples from bivariate Gaussian\n\nsamples67 = np.vstack((samples6,samples7))\n\ncorr = stats.pearsonr(samples67[:,0],samples67[:,1])[0]                               # calculate Pearson and Spearman correlation with outlier\nrank_corr = stats.spearmanr(samples67[:,0],samples67[:,1])[0]\n\ncorr_one = stats.pearsonr(samples6[:,0],samples6[:,1])[0]              # calculate Pearson and Spearman correlation with outlier\nrank_corr_one = stats.spearmanr(samples6[:,0],samples6[:,1])[0]\n\nplt.subplot(122)\nplt.scatter(samples6[:,0],samples6[:,1],color='white',edgecolor='black',zorder=1)     # plot and annotate results\nplt.scatter(samples7[:,0],samples7[:,1],color='red',edgecolor='black',zorder=1)     # plot and annotate results\n\nplt.scatter([5.7,5.7],[4.15,2.15],color='white',edgecolor='black',zorder=1) \nplt.scatter([5.4],[2.15],color='red',edgecolor='black',zorder=1) \nplt.annotate('First population only:',[6.0,4.1])\nplt.annotate(r'$\\rho^{half}_{x,y} = $' + str(round(corr_one,2)),[6.5,3.5])\nplt.annotate(r'$\\rho^{half}_{R_x,R_y} = $' + str(round(rank_corr_one,2)),[6.5,2.8])\nplt.annotate('Both populations:',[6.0,2.1])\nplt.annotate(r'$\\rho_{x,y} = $' + str(round(corr,2)),[6.5,1.5])\nplt.annotate(r'$\\rho_{R_x,R_y} = $' + str(round(rank_corr,2)),[6.5,0.8])\nplt.xlim([-4,10]); plt.ylim([-0.1,10]); plt.xlabel('X'); plt.ylabel('Y'); add_grid(); plt.title('Impact of Multiple Populations on Correlation')\n\nplt.subplots_adjust(left=0.0, bottom=0.0, right=2.0, top=1.2, wspace=0.2, hspace=0.3); plt.show() \n```", "```py\nplt.subplot(131)                                              # plot correlation matrix with significance colormap\nplot_corr(corr_matrix,'Correlation Matrix',1.0,0.5)           # using our correlation matrix visualization function\n\nplt.subplot(132)                                              # plot correlation matrix with significance colormap\nplot_corr(rank_matrix,'Rank Correlation Matrix',1.0,0.5)      # using our correlation matrix visualization function\n\nplt.subplot(133)                                              # plot correlation matrix with significance colormap\ndiff = corr_matrix.values - rank_matrix.values\ndiff_matrix = pd.DataFrame(diff,columns=corr_matrix.columns)\nplot_corr(diff_matrix,'Correlation - Rank Correlation',0.3,0.0) # using our correlation matrix visualization function\n\nplt.subplots_adjust(left=0.0, bottom=0.0, right=2.5, top=0.6, wspace=0.2, hspace=0.3); plt.show() \n```", "```py\nsns.pairplot(df, hue='Facies',vars=['Porosity','Perm','AI'],markers='o')\nplt.subplots_adjust(left=0.0, bottom=0.0, right=0.9, top=0.9, wspace=0.2, hspace=0.3); plt.show() \n```", "```py\npairgrid = sns.PairGrid(df,vars=['Porosity','Perm','AI'])\npairgrid = pairgrid.map_upper(plt.scatter, color = 'darkorange', edgecolor = 'black', alpha = 0.8, s = 10)\npairgrid = pairgrid.map_diag(plt.hist, bins = 20, color = 'darkorange',alpha = 0.8, edgecolor = 'k')# Map a density plot to the lower triangle\npairgrid = pairgrid.map_lower(sns.kdeplot, cmap = plt.cm.inferno, \n                              shade = False, shade_lowest = False, alpha = 1.0, n_levels = 10)\npairgrid.add_legend()\nplt.subplots_adjust(left=0.0, bottom=0.0, right=0.9, top=0.9, wspace=0.2, hspace=0.2); plt.show() \n```", "```py\nax = sns.kdeplot(x=df['AI'].values,y=df['Porosity'].values, shade=True, n_levels = 10,cmap=cmap,cbar= True, shade_lowest = False)\n#ax = sns.kdeplot(df.loc[:,['AI','Porosity']], shade=True, n_levels = 10,cmap=cmap,cbar= True, shade_lowest = False)\nax.set_xlabel('Acoustic Impedance (m/s x g/cm^3)'); ax.set_ylabel('Porosity (fraction)'); ax.set_title('Porosity vs. Acoustic Impedance')\nadd_grid()\nplt.subplots_adjust(left=0.0, bottom=0.0, right=0.9, top=0.9, wspace=0.2, hspace=0.2); plt.show() \n```", "```py\nax = sns.jointplot(x=df['AI'],y=df['Porosity'],kind='kde',shade = False,n_levels = 10,cmap=cmap,shade_lowest = True); \n```", "```py\nAI_bins = np.linspace(2000,8000,10)                           # set the bin boundaries and then the centroids for plotting\nAI_centroids = np.linspace((AI_bins[0]+AI_bins[1])*0.5,(AI_bins[8]+AI_bins[9])*0.5,9)\nprint(AI_bins)                                                # check the boundaries\nprint(AI_centroids)                                           # check the centroids\ndf['AI_bins'] = pd.cut(df['AI'], AI_bins,labels = AI_centroids) # cut on bondaries and label with centroids \ndf.head()                                                     # check the new column in the DataFrame \n```", "```py\n[2000\\.         2666.66666667 3333.33333333 4000\\.         4666.66666667\n 5333.33333333 6000\\.         6666.66666667 7333.33333333 8000\\.        ]\n[2333.33333333 3000\\.         3666.66666667 4333.33333333 5000.\n 5666.66666667 6333.33333333 7000\\.         7666.66666667] \n```", "```py\ncond_exp = df.groupby('AI_bins')['Porosity'].mean()\ncond_P90 = df.groupby('AI_bins')['Porosity'].quantile(.9)\ncond_P10 = df.groupby('AI_bins')['Porosity'].quantile(.1)\n\nplt.subplot(111)\nplt.plot(AI_centroids,cond_exp,color='black')\nplt.plot(AI_centroids,cond_P90,'r--',color='black',linewidth = 1.0)\nplt.plot(AI_centroids,cond_P10,'r--',color='black',linewidth = 1.0)\n\nplt.xlabel('Acoustic Impedance (m/s x g/cm^3)')\nplt.ylabel('Porosity (fraction) | Acoustic Impedance')\nt = plt.title('Porosity Conditional to Acoustic Impedance')\nplt.ylim(pormin,pormax)\nplt.xlim(AImin,AImax)\nplt.text(3200, .10, 'P10')\nplt.text(3200, .15, 'Expectation')\nplt.text(3200, .19, 'P90')\n\nadd_grid()\n\nplt.subplots_adjust(left=0.0, bottom=0.0, right=1.2, top=1.2, wspace=0.2, hspace=0.2); plt.show() \n```", "```py\nimport geostatspy.GSLIB as GSLIB                              # GSLIB utilities, visualization and wrapper\nimport geostatspy.geostats as geostats                        # GSLIB methods convert to Python \nimport geostatspy\nprint('GeostatsPy version: ' + str(geostatspy.__version__)) \n```", "```py\nGeostatsPy version: 0.0.71 \n```", "```py\nignore_warnings = True                                        # ignore warnings?\nimport numpy as np                                            # ndarrays for gridded data\nimport pandas as pd                                           # DataFrames for tabular data\nfrom scipy import stats                                       # summary statistics\nfrom scipy.stats import pearsonr                              # Pearson product moment correlation\nfrom scipy.stats import spearmanr                             # spearman rank correlation\nfrom scipy.stats import rankdata                              # rank data for visualization\nimport copy                                                   # for deep copies\nimport os                                                     # set working directory, run executables\nimport matplotlib.pyplot as plt                               # for plotting\nfrom matplotlib.ticker import (MultipleLocator, AutoMinorLocator) # control of axes ticks\nfrom matplotlib.colors import ListedColormap                  # custom color maps\nimport seaborn as sns                                         # advanced plotting\nimport matplotlib.ticker as mtick                             # control tick label formatting\nplt.rc('axes', axisbelow=True)                                # plot all grids below the plot elements\nif ignore_warnings == True:                                   \n    import warnings\n    warnings.filterwarnings('ignore')\ncmap = plt.cm.inferno                                         # color map\nseed = 42                                                     # random number seed \n```", "```py\ndef plot_corr(corr_matrix,title,limits,mask):                 # plots a graphical correlation matrix \n    my_colormap = plt.cm.get_cmap('RdBu_r', 256)          \n    newcolors = my_colormap(np.linspace(0, 1, 256))\n    white = np.array([256/256, 256/256, 256/256, 1])\n    white_low = int(128 - mask*128); white_high = int(128+mask*128)\n    newcolors[white_low:white_high, :] = white                # mask all correlations less than abs(0.8)\n    newcmp = ListedColormap(newcolors)\n    m = corr_matrix.shape[0]\n    im = plt.matshow(corr_matrix,fignum=0,vmin = -1.0*limits, vmax = limits,cmap = newcmp)\n    plt.xticks(range(len(corr_matrix.columns)), corr_matrix.columns)\n    plt.yticks(range(len(corr_matrix.columns)), corr_matrix.columns)\n    plt.colorbar(im, orientation = 'vertical')\n    plt.title(title)\n    for i in range(0,m):\n        plt.plot([i-0.5,i-0.5],[-0.5,m-0.5],color='black')\n        plt.plot([-0.5,m-0.5],[i-0.5,i-0.5],color='black')\n    plt.ylim([-0.5,m-0.5]); plt.xlim([-0.5,m-0.5])\n\ndef add_grid():\n    plt.gca().grid(True, which='major',linewidth = 1.0); plt.gca().grid(True, which='minor',linewidth = 0.2) # add y grids\n    plt.gca().tick_params(which='major',length=7); plt.gca().tick_params(which='minor', length=4)\n    plt.gca().xaxis.set_minor_locator(AutoMinorLocator()); plt.gca().yaxis.set_minor_locator(AutoMinorLocator()) # turn on minor ticks \n\ndef add_grid2(sub_plot):\n    sub_plot.grid(True, which='major',linewidth = 1.0); sub_plot.grid(True, which='minor',linewidth = 0.2) # add y grids\n    sub_plot.tick_params(which='major',length=7); sub_plot.tick_params(which='minor', length=4)\n    sub_plot.xaxis.set_minor_locator(AutoMinorLocator()); sub_plot.yaxis.set_minor_locator(AutoMinorLocator()) # turn on minor ticks \n```", "```py\nmy_colormap = plt.cm.get_cmap('RdBu_r', 256)                  # make a custom colormap\nnewcolors = my_colormap(np.linspace(0, 1, 256))               # define colormap space\nwhite = np.array([250/256, 250/256, 250/256, 1])              # define white color (4 channel)\n#newcolors[26:230, :] = white                                 # mask all correlations less than abs(0.8)\n#newcolors[56:200, :] = white                                 # mask all correlations less than abs(0.6)\nnewcolors[76:180, :] = white                                  # mask all correlations less than abs(0.4)\nsignif = ListedColormap(newcolors)                            # assign as listed colormap\n\nmy_colormap = plt.cm.get_cmap('inferno', 256)                 # make a custom colormap\nnewcolors = my_colormap(np.linspace(0, 1, 256))               # define colormap space\nwhite = np.array([250/256, 250/256, 250/256, 1])              # define white color (4 channel)\n#newcolors[26:230, :] = white                                 # mask all correlations less than abs(0.8)\nnewcolors[0:12, :] = white                                    # mask all correlations less than abs(0.6)\n#newcolors[86:170, :] = white                                 # mask all correlations less than abs(0.4)\nsign1 = ListedColormap(newcolors)                             # assign as listed colormap \n```", "```py\ncorr_mat = [-0.96,0.0,0.4,0.7]; ndata = 1000                   # set the correlation coefficient, number of samples\n\nfor i, corr in enumerate(corr_mat):\n    plt.subplot(2,2,i+1)\n    mean = np.array([0,0])                                     # make the bivariate Gaussian data\n    correl = np.array([[1.0,corr],[corr,1.0]],dtype=float)\n    np.random.seed(seed = seed)\n    sample = np.random.multivariate_normal(mean,correl,size = ndata)\n    plt.scatter(sample[:,0],sample[:,1],color = 'red',alpha = 0.2,edgecolors='black',label = 'Samples',zorder=100)\n    plt.xlim([-3.0,3.0]); plt.ylim([-3.0,3.0])\n    plt.xlabel(r'$x_1$'); plt.ylabel(r'$X_2$'); plt.legend(loc='upper left'); add_grid()\n    plt.title(r'Bivariate Standard Gaussian Distributed Data with $\\rho_{x_1,x_2} =$' + str(np.round(corr,2)))\n\nplt.subplots_adjust(left=0.0, bottom=0.0, right=2.0, top=2.2, wspace=0.3, hspace=0.3); plt.show() \n```", "```py\ncorr = 0.0; outlier_mat = [0,1,1.5,1.9]; ndata = 100           # set the correlation coefficient, number of samples\n\nfor i, outlier in enumerate(outlier_mat):\n    plt.subplot(2,2,i+1)\n    mean = np.array([0,0])                                     # make the bivariate Gaussian data\n    correl = np.array([[1.0,corr],[corr,1.0]],dtype=float)\n    np.random.seed(seed = seed)\n    sample = np.random.multivariate_normal(mean,correl,size = ndata)\n    sample = np.vstack([sample, [pow(10.0,outlier),pow(10.0,outlier)]]) # add outlier\n    plt.scatter(sample[:,0],sample[:,1],color = 'red',alpha = 0.2,edgecolors='black',s=10,label = 'samples',zorder=100) # plot result\n    plt.scatter(sample[-1,0],sample[-1,1],color = 'black',alpha = 0.8,marker = 'x',label = 'outlier', zorder=200)\n    plt.xlim([-3.0,100.0]); plt.ylim([-3.0,100.0])\n    plt.xlabel(r'$x_1$'); plt.ylabel(r'$X_2$'); plt.legend(loc='upper left'); add_grid()\n    plt.title(r'Bivariate Standard Gaussian Distributed Data with $\\rho_{x_1,x_2} =$' + str(np.round(corr,2)))\n    pearson_corr = pearsonr(sample[:,0],sample[:,1])[0]\n    rank_corr = spearmanr(sample[:,0],sample[:,1])[0]\n    plt.annotate(r'$\\rho_{x_1,x_2}$ = ' + str(np.round(pearson_corr,3)),[75.0,30.0])\n    plt.annotate(r'$\\rho_{R_{x_1},R_{x_2}}$ = ' + str(np.round(rank_corr,3)),[75.0,25.0])\nplt.subplots_adjust(left=0.0, bottom=0.0, right=2.0, top=2.2, wspace=0.3, hspace=0.3); plt.show() \n```", "```py\n#os.chdir(\"c:/PGE383\")                                        # set the working directory \n```", "```py\n#df = pd.read_csv('sample_data_MV_biased.csv')                # load our data table\ndf = pd.read_csv('https://raw.githubusercontent.com/GeostatsGuy/GeoDataSets/master/sample_data_MV_biased.csv')\ndf = df.iloc[:,1:] \n```", "```py\ndf.head(n=13)                                                 # we could also use this command for a table preview \n```", "```py\ndf.describe().transpose()                                     # DataFrame summary statistics \n```", "```py\nxmin = 0.0; xmax = 1000.0                                     # range of x values\nymin = 0.0; ymax = 1000.0                                     # range of y values\npormin = 0.05; pormax = 0.25;                                 # range of porosity values\npermmin = 0.01; permmax = 2000.0                              # range of permeability values\nAImin = 2000.0; AImax = 8000.0                                # range of AI values\nnx = 100; ny = 100; csize = 10.0 \n```", "```py\nplt.subplot(221)\nGSLIB.locmap_st(df,'X','Y','Facies',xmin,xmax,ymin,ymax,0,1,'Well Data - Porosity','X(m)','Y(m)','Facies (0-shale, 1-sand)',cmap)\n\nplt.subplot(222)\nGSLIB.locmap_st(df,'X','Y','Porosity',xmin,xmax,ymin,ymax,pormin,pormax,'Well Data - Porosity','X(m)','Y(m)','Porosity (fraction)',cmap)\n\nplt.subplot(223)\nGSLIB.locmap_st(df,'X','Y','Perm',xmin,xmax,ymin,ymax,permmin,permmax,'Well Data - Permeability','X(m)','Y(m)','Permeability (md)',cmap)\n\nplt.subplot(224)\nGSLIB.locmap_st(df,'X','Y','AI',xmin,xmax,ymin,ymax,AImin,AImax,'Well Data - Acoustic Impedance','X(m)','Y(m)','Acoustic Impedance (m/s x g/cm^3)',cmap)\n\nplt.subplots_adjust(left=0.0, bottom=0.0, right=1.5, top=1.7, wspace=0.3, hspace=0.3); plt.show() \n```", "```py\nplt.subplot(121)\nplt.plot(df['Porosity'].values,df['Perm'].values, 'o', label='', markerfacecolor='darkorange', markeredgecolor='black', alpha=0.8)\nplt.title('Well Data Permeability vs. Porosity')\nplt.xlabel('Porosity (fraction)'); plt.ylabel('Permeability (mD)')\nplt.xlim([pormin,pormax]); plt.ylim([permmin,permmax]); add_grid()\n\nplt.subplot(122)\nplt.plot(df['AI'].values,df['Porosity'].values, 'o', label='', markerfacecolor='darkorange', markeredgecolor='black', alpha=0.8)\nplt.title('Well Data Porosity vs. Acoustic Impedance')\nplt.ylabel('Porosity (fraction)'); plt.xlabel('Acoustic Impedance (m/s x g/cm^3)')\nplt.xlim([AImin,AImax]); plt.ylim([pormin,pormax]); add_grid()\n\nplt.subplots_adjust(left=0.0, bottom=0.0, right=1.5, top=0.8, wspace=0.3, hspace=0.2)\n#plt.savefig('Test.pdf', dpi=600, bbox_inches = 'tight',format='pdf') \nplt.show() \n```", "```py\nprint(df.iloc[:,3:7].cov())                                   # the covariance matrix for columns 3,4,5 and 6 and all rows\nprint('The variance of porosity is ' + str(round(np.var(df['Porosity'].values),6))) \n```", "```py\n Porosity          Perm             AI\nPorosity   0.000939      4.055029     -17.132244\nPerm       4.055029  52149.501968  -46471.695092\nAI       -17.132244 -46471.695092  949768.302409\nThe variance of porosity is 0.000936 \n```", "```py\ndf.iloc[:,3:7].corr()                                         # correlation matrix \n```", "```py\ncorr_matrix = df.iloc[:,2:].corr()\nplt.subplot(111)\nplot_corr(corr_matrix,'Correlation Matrix',1.0,0.5)           # using our correlation matrix visualization function\nplt.subplots_adjust(left=0.0, bottom=0.0, right=1.0, top=0.8, wspace=0.2, hspace=0.3); plt.show() \n```", "```py\ncorr, corr_p_value = pearsonr(df['Porosity'],df['Perm'])\n\nplt.subplot(111)\nplt.plot(df['Porosity'].values,df['Perm'].values, 'o', label='', markerfacecolor='darkorange', markeredgecolor='black', alpha=0.8)\nplt.title('Well Data Permeability vs. Porosity')\nplt.xlabel('Porosity (fraction)'); plt.ylabel('Permeability (mD)')\nplt.xlim([pormin,pormax]); plt.ylim([permmin,permmax]); add_grid()\n\nplt.annotate(r'$\\rho_{\\phi,k}$ = ' + str(np.round(corr,3)),[0.075,1600.0])\nplt.annotate(r'$\\rho_{\\phi,k}$, p-value = ' + str(np.round(corr_p_value,20)),[0.075,1500.0])\nplt.subplots_adjust(left=0.0, bottom=0.0, right=1.0, top=1.2, wspace=0.3, hspace=0.2); plt.show() \n```", "```py\nrank_correlation, rank_correlation_pval = stats.spearmanr(df.iloc[:,2:]) # calculate the range correlation coefficient\nrank_matrix = pd.DataFrame(rank_correlation,columns=corr_matrix.columns)\nprint('Rank Correlation:')\nprint(rank_correlation)\nprint('\\nRank Correlation p-value:')\nprint(rank_correlation_pval) \n```", "```py\nRank Correlation:\n[[ 1\\.          0.79973189  0.71923703 -0.50503617]\n [ 0.79973189  1\\.          0.88314655 -0.56863773]\n [ 0.71923703  0.88314655  1\\.         -0.34876935]\n [-0.50503617 -0.56863773 -0.34876935  1\\.        ]]\n\nRank Correlation p-value:\n[[0.00000000e+000 4.11417796e-083 7.49150387e-060 3.24513314e-025]\n [4.11417796e-083 0.00000000e+000 2.26847950e-122 6.59769641e-033]\n [7.49150387e-060 2.26847950e-122 0.00000000e+000 5.77157354e-012]\n [3.24513314e-025 6.59769641e-033 5.77157354e-012 0.00000000e+000]] \n```", "```py\ncorr = 0.0; xout = 9; yout = 9; n = 100                       # correlation, outlier datum, and total number of data\nmean = [0, 0]                                                 # bivariate Gaussian mean vector\ncov = [[1, corr], [corr, 1]]                                  # bivariate Gaussian covariance matrix\n\nnp.random.seed(seed = seed)                                   # set seed for repeatability\nsamples = np.random.multivariate_normal(mean, cov, n)         # random samples from bivariate Gaussian\nsamples[-1,0] = xout; samples[-1,1] = yout                    # replace last sample with user specified outlier\nx2 = samples[:, 0]; y2 = samples[:, 1]                        # copy x and y for compact code\n\ncorr = stats.pearsonr(x2[:-1],y2[:-1])[0]                     # calculate Pearson and Spearman correlation without outlier\nrank_corr = stats.spearmanr(x2[:-1],y2[:-1])[0] \ncorr_out = stats.pearsonr(x2,y2)[0]                           # calculate Pearson and Spearman correlation with outlier\nrank_corr_out = stats.spearmanr(x2,y2)[0]\n\nplt.subplot(121)\nplt.scatter(x2,y2,color='red',edgecolor='black',zorder=1)     # plot and annotate results\nplt.scatter(x2[-1],y2[-1],color='white',edgecolor='black',zorder=10)\nplt.scatter([5.7,5.7],[0.17,-1.8],color='white',edgecolor='black',zorder=1) \nplt.scatter([5.4],[-1.8],color='red',edgecolor='black',zorder=1) \nplt.annotate('With outlier:',[6.0,0.1])\nplt.annotate(r'$\\rho^{out}_{x,y} = $',[6.5,-0.5])\nplt.annotate(r'$\\rho^{out}_{R_x,R_y} = $',[6.5,-1.2])\nplt.annotate('Without outlier:',[6.0,-1.9])\nplt.annotate(r'$\\rho_{x,y} = $',[6.5,-2.5])\nplt.annotate(r'$\\rho_{R_x,R_y} = $',[6.5,-3.2])\nplt.xlim([-4,10]); plt.ylim([-4,10]); plt.xlabel('X'); plt.ylabel('Y'); add_grid(); plt.title('Impact of an Outlier on Correlation')\n\nplt.subplot(122)\nplt.scatter(x2,y2,color='red',edgecolor='black',zorder=1)       # plot and annotate results\nplt.scatter(x2[-1],y2[-1],color='white',edgecolor='black',zorder=10)\nplt.scatter([5.7,5.7],[0.17,-1.8],color='white',edgecolor='black',zorder=1) \nplt.scatter([5.4],[-1.8],color='red',edgecolor='black',zorder=1) \nplt.annotate('With outlier:',[6.0,0.1])\nplt.annotate(r'$\\rho^{out}_{x,y} = $' + str(round(corr_out,2)),[6.5,-0.5])\nplt.annotate(r'$\\rho^{out}_{R_x,R_y} = $' + str(round(rank_corr_out,2)),[6.5,-1.2])\nplt.annotate('Without outlier:',[6.0,-1.9])\nplt.annotate(r'$\\rho_{x,y} = $' + str(round(corr,2)),[6.5,-2.5])\nplt.annotate(r'$\\rho_{R_x,R_y} = $' + str(round(rank_corr,2)),[6.5,-3.2])\nplt.xlim([-4,10]); plt.ylim([-4,10]); plt.xlabel('X'); plt.ylabel('Y'); add_grid(); plt.title('Impact of an Outlier on Correlation')\n\nplt.subplots_adjust(left=0.0, bottom=0.0, right=2.0, top=1.2, wspace=0.2, hspace=0.3); plt.show() \n```", "```py\nx2_rank = rankdata(x2)                                          # rank transform data, x and y separately\ny2_rank = rankdata(y2)\n\nplt.subplot(121)\nplt.scatter(x2,y2,color='red',edgecolor='black',zorder=1)       # plot and annotate results\nplt.scatter(x2[-1],y2[-1],color='white',edgecolor='black',zorder=10)\nplt.scatter([5.7,5.7],[0.17,-1.8],color='white',edgecolor='black',zorder=1) \nplt.scatter([5.4],[-1.8],color='red',edgecolor='black',zorder=1) \nplt.annotate('With outlier:',[6.0,0.1])\nplt.annotate(r'$\\rho^{out}_{x,y} = $' + str(round(corr_out,2)),[6.5,-0.5])\nplt.annotate(r'$\\rho^{out}_{R_x,R_y} = $' + str(round(rank_corr_out,2)),[6.5,-1.2])\nplt.annotate('Without outlier:',[6.0,-1.9])\nplt.annotate(r'$\\rho_{x,y} = $' + str(round(corr,2)),[6.5,-2.5])\nplt.annotate(r'$\\rho_{R_x,R_y} = $' + str(round(rank_corr,2)),[6.5,-3.2])\nplt.xlim([-4,10]); plt.ylim([-4,10]); plt.xlabel('X'); plt.ylabel('Y'); add_grid(); plt.title('Impact of an Outlier on Correlation')\n\nplt.subplot(122)\nplt.scatter(x2_rank,y2_rank,color='red',edgecolor='black',zorder=1) # plot and annotate results\nplt.scatter(x2_rank[-1],y2_rank[-1],color='white',edgecolor='black',zorder=10)\nplt.xlim([0,n+1]); plt.ylim([0,n+1]); plt.xlabel(r'$X_{rank}$'); plt.ylabel(r'$Y_{rank}$'); add_grid(); plt.title('Data Rank Transformed')\n\nplt.subplots_adjust(left=0.0, bottom=0.0, right=2.0, top=1.2, wspace=0.2, hspace=0.3); plt.show() \n```", "```py\nx3 = np.linspace(-3.0,3.0,n)\ny3 = x3**2\n\ncorr = stats.pearsonr(x3,y3)[0]                               # calculate Pearson and Spearman correlation with outlier\nrank_corr = stats.spearmanr(x3,y3)[0]\n\ncorr_half = stats.pearsonr(x3[:-50],y3[:-50])[0]              # calculate Pearson and Spearman correlation with outlier\nrank_corr_half = stats.spearmanr(x3[:-50],y3[:-50])[0]\n\nplt.subplot(121)\nplt.scatter(x3,y3,color='red',edgecolor='black',zorder=1)     # plot and annotate results\nplt.scatter(x3[:-50],y3[:-50],color='white',edgecolor='black',zorder=10) # first half\nplt.scatter([5.7,5.7],[4.15,2.15],color='white',edgecolor='black',zorder=1) \nplt.scatter([5.4],[2.15],color='red',edgecolor='black',zorder=1) \nplt.annotate('First half of data only:',[6.0,4.1])\nplt.annotate(r'$\\rho^{half}_{x,y} = $',[6.5,3.5])\nplt.annotate(r'$\\rho^{half}_{R_x,R_y} = $',[6.5,2.8])\nplt.annotate('All data:',[6.0,2.1])\nplt.annotate(r'$\\rho_{x,y} = $',[6.5,1.5])\nplt.annotate(r'$\\rho_{R_x,R_y} = $',[6.5,0.8])\nplt.xlim([-4,10]); plt.ylim([-0.1,10]); plt.xlabel('X'); plt.ylabel('Y'); add_grid(); plt.title('Impact of an Outlier on Correlation')\n\nplt.subplot(122)\nplt.scatter(x3,y3,color='red',edgecolor='black',zorder=1)     # plot and annotate results\nplt.scatter(x3[:-50],y3[:-50],color='white',edgecolor='black',zorder=10) # first half\nplt.scatter([5.7,5.7],[4.15,2.15],color='white',edgecolor='black',zorder=1) \nplt.scatter([5.4],[2.15],color='red',edgecolor='black',zorder=1) \nplt.annotate('First half of data only:',[6.0,4.1])\nplt.annotate(r'$\\rho^{half}_{x,y} = $' + str(round(corr_half,2)),[6.5,3.5])\nplt.annotate(r'$\\rho^{half}_{R_x,R_y} = $' + str(round(rank_corr_half,2)),[6.5,2.8])\nplt.annotate('All data:',[6.0,2.1])\nplt.annotate(r'$\\rho_{x,y} = $' + str(round(corr,2)),[6.5,1.5])\nplt.annotate(r'$\\rho_{R_x,R_y} = $' + str(round(rank_corr,2)),[6.5,0.8])\nplt.xlim([-4,10]); plt.ylim([-0.1,10]); plt.xlabel('X'); plt.ylabel('Y'); add_grid(); plt.title('Impact of an Outlier on Correlation')\n\nplt.subplots_adjust(left=0.0, bottom=0.0, right=2.0, top=1.2, wspace=0.2, hspace=0.3); plt.show() \n```", "```py\nx3_rank = rankdata(x3)                                        # rank transform data, x and y separately\ny3_rank = rankdata(y3)\n\nplt.subplot(121)\nplt.scatter(x3,y3,color='red',edgecolor='black',zorder=1)     # plot and annotate results\nplt.scatter(x3[:-50],y3[:-50],color='white',edgecolor='black',zorder=10) # first half\nplt.scatter([5.7,5.7],[4.15,2.15],color='white',edgecolor='black',zorder=1) \nplt.scatter([5.4],[2.15],color='red',edgecolor='black',zorder=1) \nplt.annotate('First half of data only:',[6.0,4.1])\nplt.annotate(r'$\\rho^{half}_{x,y} = $' + str(round(corr_half,2)),[6.5,3.5])\nplt.annotate(r'$\\rho^{half}_{R_x,R_y} = $' + str(round(rank_corr_half,2)),[6.5,2.8])\nplt.annotate('All data:',[6.0,2.1])\nplt.annotate(r'$\\rho_{x,y} = $' + str(round(corr,2)),[6.5,1.5])\nplt.annotate(r'$\\rho_{R_x,R_y} = $' + str(round(rank_corr,2)),[6.5,0.8])\nplt.xlim([-4,10]); plt.ylim([-0.1,10]); plt.xlabel('X'); plt.ylabel('Y'); add_grid(); plt.title('Impact of an Nonlinearity on Correlation')\n\nplt.subplot(122)\nplt.scatter(x3_rank,y3_rank,color='red',edgecolor='black',zorder=1) # plot and annotate results\nplt.scatter(x3_rank[:-50],y3_rank[:-50],color='white',edgecolor='black',zorder=10)\nplt.xlim([0,n+1]); plt.ylim([0,n+1]); plt.xlabel(r'$X_{rank}$'); plt.ylabel(r'$Y_{rank}$'); add_grid(); plt.title('Data Rank Transformed')\n\nplt.subplots_adjust(left=0.0, bottom=0.0, right=2.0, top=1.2, wspace=0.2, hspace=0.3); plt.show() \n```", "```py\nn = 100                                                        # total number in each population\nnp.random.seed(seed = seed)                                   # set seed for repeatability\nmean4 = [-1.0, 2.0]                                                 # bivariate Gaussian mean vector\ncov4 = [[0.5, 0.0], [0.0, 0.5]]                               # bivariate Gaussian covariance matrix\nsamples4 = np.random.multivariate_normal(mean4, cov4, n)        # random samples from bivariate Gaussian\n\nmean5 = [4.0, 6.0]                                                 # bivariate Gaussian mean vector\ncov5 = [[0.3, 0.0], [0.0, 0.3]]                               # bivariate Gaussian covariance matrix\nsamples5 = np.random.multivariate_normal(mean5, cov5, n)        # random samples from bivariate Gaussian\n\nsamples45 = np.vstack((samples4,samples5))\n\ncorr = stats.pearsonr(samples45[:,0],samples45[:,1])[0]                               # calculate Pearson and Spearman correlation with outlier\nrank_corr = stats.spearmanr(samples45[:,0],samples45[:,1])[0]\n\ncorr_one = stats.pearsonr(samples4[:,0],samples4[:,1])[0]              # calculate Pearson and Spearman correlation with outlier\nrank_corr_one = stats.spearmanr(samples4[:,0],samples4[:,1])[0]\n\nplt.subplot(121)\nplt.scatter(samples4[:,0],samples4[:,1],color='white',edgecolor='black',zorder=1)     # plot and annotate results\nplt.scatter(samples5[:,0],samples5[:,1],color='red',edgecolor='black',zorder=1)     # plot and annotate results\n\nplt.scatter([5.7,5.7],[4.15,2.15],color='white',edgecolor='black',zorder=1) \nplt.scatter([5.4],[2.15],color='red',edgecolor='black',zorder=1) \nplt.annotate('First population only:',[6.0,4.1])\nplt.annotate(r'$\\rho^{half}_{x,y} = $' + str(round(corr_one,2)),[6.5,3.5])\nplt.annotate(r'$\\rho^{half}_{R_x,R_y} = $' + str(round(rank_corr_one,2)),[6.5,2.8])\nplt.annotate('Both populations:',[6.0,2.1])\nplt.annotate(r'$\\rho_{x,y} = $' + str(round(corr,2)),[6.5,1.5])\nplt.annotate(r'$\\rho_{R_x,R_y} = $' + str(round(rank_corr,2)),[6.5,0.8])\nplt.xlim([-4,10]); plt.ylim([-0.1,10]); plt.xlabel('X'); plt.ylabel('Y'); add_grid(); plt.title('Impact of Multiple Populations on Correlation')\n\nmean6 = [3.0, 4.0]                                                 # bivariate Gaussian mean vector\ncov6 = [[0.5, 0.45], [0.45, 0.5]]                               # bivariate Gaussian covariance matrix\nsamples6 = np.random.multivariate_normal(mean6, cov6, n)        # random samples from bivariate Gaussian\n\nmean7 = [2.0, 6.0]                                                 # bivariate Gaussian mean vector\ncov7 = [[0.3, 0.25], [0.25, 0.3]]                               # bivariate Gaussian covariance matrix\nsamples7 = np.random.multivariate_normal(mean7, cov7, n)        # random samples from bivariate Gaussian\n\nsamples67 = np.vstack((samples6,samples7))\n\ncorr = stats.pearsonr(samples67[:,0],samples67[:,1])[0]                               # calculate Pearson and Spearman correlation with outlier\nrank_corr = stats.spearmanr(samples67[:,0],samples67[:,1])[0]\n\ncorr_one = stats.pearsonr(samples6[:,0],samples6[:,1])[0]              # calculate Pearson and Spearman correlation with outlier\nrank_corr_one = stats.spearmanr(samples6[:,0],samples6[:,1])[0]\n\nplt.subplot(122)\nplt.scatter(samples6[:,0],samples6[:,1],color='white',edgecolor='black',zorder=1)     # plot and annotate results\nplt.scatter(samples7[:,0],samples7[:,1],color='red',edgecolor='black',zorder=1)     # plot and annotate results\n\nplt.scatter([5.7,5.7],[4.15,2.15],color='white',edgecolor='black',zorder=1) \nplt.scatter([5.4],[2.15],color='red',edgecolor='black',zorder=1) \nplt.annotate('First population only:',[6.0,4.1])\nplt.annotate(r'$\\rho^{half}_{x,y} = $' + str(round(corr_one,2)),[6.5,3.5])\nplt.annotate(r'$\\rho^{half}_{R_x,R_y} = $' + str(round(rank_corr_one,2)),[6.5,2.8])\nplt.annotate('Both populations:',[6.0,2.1])\nplt.annotate(r'$\\rho_{x,y} = $' + str(round(corr,2)),[6.5,1.5])\nplt.annotate(r'$\\rho_{R_x,R_y} = $' + str(round(rank_corr,2)),[6.5,0.8])\nplt.xlim([-4,10]); plt.ylim([-0.1,10]); plt.xlabel('X'); plt.ylabel('Y'); add_grid(); plt.title('Impact of Multiple Populations on Correlation')\n\nplt.subplots_adjust(left=0.0, bottom=0.0, right=2.0, top=1.2, wspace=0.2, hspace=0.3); plt.show() \n```", "```py\nplt.subplot(131)                                              # plot correlation matrix with significance colormap\nplot_corr(corr_matrix,'Correlation Matrix',1.0,0.5)           # using our correlation matrix visualization function\n\nplt.subplot(132)                                              # plot correlation matrix with significance colormap\nplot_corr(rank_matrix,'Rank Correlation Matrix',1.0,0.5)      # using our correlation matrix visualization function\n\nplt.subplot(133)                                              # plot correlation matrix with significance colormap\ndiff = corr_matrix.values - rank_matrix.values\ndiff_matrix = pd.DataFrame(diff,columns=corr_matrix.columns)\nplot_corr(diff_matrix,'Correlation - Rank Correlation',0.3,0.0) # using our correlation matrix visualization function\n\nplt.subplots_adjust(left=0.0, bottom=0.0, right=2.5, top=0.6, wspace=0.2, hspace=0.3); plt.show() \n```", "```py\nsns.pairplot(df, hue='Facies',vars=['Porosity','Perm','AI'],markers='o')\nplt.subplots_adjust(left=0.0, bottom=0.0, right=0.9, top=0.9, wspace=0.2, hspace=0.3); plt.show() \n```", "```py\npairgrid = sns.PairGrid(df,vars=['Porosity','Perm','AI'])\npairgrid = pairgrid.map_upper(plt.scatter, color = 'darkorange', edgecolor = 'black', alpha = 0.8, s = 10)\npairgrid = pairgrid.map_diag(plt.hist, bins = 20, color = 'darkorange',alpha = 0.8, edgecolor = 'k')# Map a density plot to the lower triangle\npairgrid = pairgrid.map_lower(sns.kdeplot, cmap = plt.cm.inferno, \n                              shade = False, shade_lowest = False, alpha = 1.0, n_levels = 10)\npairgrid.add_legend()\nplt.subplots_adjust(left=0.0, bottom=0.0, right=0.9, top=0.9, wspace=0.2, hspace=0.2); plt.show() \n```", "```py\nax = sns.kdeplot(x=df['AI'].values,y=df['Porosity'].values, shade=True, n_levels = 10,cmap=cmap,cbar= True, shade_lowest = False)\n#ax = sns.kdeplot(df.loc[:,['AI','Porosity']], shade=True, n_levels = 10,cmap=cmap,cbar= True, shade_lowest = False)\nax.set_xlabel('Acoustic Impedance (m/s x g/cm^3)'); ax.set_ylabel('Porosity (fraction)'); ax.set_title('Porosity vs. Acoustic Impedance')\nadd_grid()\nplt.subplots_adjust(left=0.0, bottom=0.0, right=0.9, top=0.9, wspace=0.2, hspace=0.2); plt.show() \n```", "```py\nax = sns.jointplot(x=df['AI'],y=df['Porosity'],kind='kde',shade = False,n_levels = 10,cmap=cmap,shade_lowest = True); \n```", "```py\nAI_bins = np.linspace(2000,8000,10)                           # set the bin boundaries and then the centroids for plotting\nAI_centroids = np.linspace((AI_bins[0]+AI_bins[1])*0.5,(AI_bins[8]+AI_bins[9])*0.5,9)\nprint(AI_bins)                                                # check the boundaries\nprint(AI_centroids)                                           # check the centroids\ndf['AI_bins'] = pd.cut(df['AI'], AI_bins,labels = AI_centroids) # cut on bondaries and label with centroids \ndf.head()                                                     # check the new column in the DataFrame \n```", "```py\n[2000\\.         2666.66666667 3333.33333333 4000\\.         4666.66666667\n 5333.33333333 6000\\.         6666.66666667 7333.33333333 8000\\.        ]\n[2333.33333333 3000\\.         3666.66666667 4333.33333333 5000.\n 5666.66666667 6333.33333333 7000\\.         7666.66666667] \n```", "```py\ncond_exp = df.groupby('AI_bins')['Porosity'].mean()\ncond_P90 = df.groupby('AI_bins')['Porosity'].quantile(.9)\ncond_P10 = df.groupby('AI_bins')['Porosity'].quantile(.1)\n\nplt.subplot(111)\nplt.plot(AI_centroids,cond_exp,color='black')\nplt.plot(AI_centroids,cond_P90,'r--',color='black',linewidth = 1.0)\nplt.plot(AI_centroids,cond_P10,'r--',color='black',linewidth = 1.0)\n\nplt.xlabel('Acoustic Impedance (m/s x g/cm^3)')\nplt.ylabel('Porosity (fraction) | Acoustic Impedance')\nt = plt.title('Porosity Conditional to Acoustic Impedance')\nplt.ylim(pormin,pormax)\nplt.xlim(AImin,AImax)\nplt.text(3200, .10, 'P10')\nplt.text(3200, .15, 'Expectation')\nplt.text(3200, .19, 'P90')\n\nadd_grid()\n\nplt.subplots_adjust(left=0.0, bottom=0.0, right=1.2, top=1.2, wspace=0.2, hspace=0.2); plt.show() \n```"]