- en: Operator overloading
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 原文：[https://rust-exercises.com/100-exercises/04_traits/03_operator_overloading.html](https://rust-exercises.com/100-exercises/04_traits/03_operator_overloading.html)
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Now that we have a basic understanding of what traits are, let's circle back
    to **operator overloading**. Operator overloading is the ability to define custom
    behavior for operators like `+`, `-`, `*`, `/`, `==`, `!=`, etc.
  prefs: []
  type: TYPE_NORMAL
- en: '[Operators are traits](#operators-are-traits)'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In Rust, operators are traits.
  prefs: []
  type: TYPE_NORMAL
- en: For each operator, there is a corresponding trait that defines the behavior
    of that operator. By implementing that trait for your type, you **unlock** the
    usage of the corresponding operators.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, the [`PartialEq` trait](https://doc.rust-lang.org/std/cmp/trait.PartialEq.html)
    defines the behavior of the `==` and `!=` operators:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: When you write `x == y` the compiler will look for an implementation of the
    `PartialEq` trait for the types of `x` and `y` and replace `x == y` with `x.eq(y)`.
    It's syntactic sugar!
  prefs: []
  type: TYPE_NORMAL
- en: 'This is the correspondence for the main operators:'
  prefs: []
  type: TYPE_NORMAL
- en: '| Operator | Trait |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `+` | [`Add`](https://doc.rust-lang.org/std/ops/trait.Add.html) |'
  prefs: []
  type: TYPE_TB
- en: '| `-` | [`Sub`](https://doc.rust-lang.org/std/ops/trait.Sub.html) |'
  prefs: []
  type: TYPE_TB
- en: '| `*` | [`Mul`](https://doc.rust-lang.org/std/ops/trait.Mul.html) |'
  prefs: []
  type: TYPE_TB
- en: '| `/` | [`Div`](https://doc.rust-lang.org/std/ops/trait.Div.html) |'
  prefs: []
  type: TYPE_TB
- en: '| `%` | [`Rem`](https://doc.rust-lang.org/std/ops/trait.Rem.html) |'
  prefs: []
  type: TYPE_TB
- en: '| `==` and `!=` | [`PartialEq`](https://doc.rust-lang.org/std/cmp/trait.PartialEq.html)
    |'
  prefs: []
  type: TYPE_TB
- en: '| `<`, `>`, `<=`, and `>=` | [`PartialOrd`](https://doc.rust-lang.org/std/cmp/trait.PartialOrd.html)
    |'
  prefs: []
  type: TYPE_TB
- en: Arithmetic operators live in the [`std::ops`](https://doc.rust-lang.org/std/ops/index.html)
    module, while comparison ones live in the [`std::cmp`](https://doc.rust-lang.org/std/cmp/index.html)
    module.
  prefs: []
  type: TYPE_NORMAL
- en: '[Default implementations](#default-implementations)'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The comment on `PartialEq::ne` states that "`ne` is a provided method".
  prefs: []
  type: TYPE_NORMAL
- en: It means that `PartialEq` provides a **default implementation** for `ne` in
    the trait definition—the `{ ... }` elided block in the definition snippet.
  prefs: []
  type: TYPE_NORMAL
- en: 'If we expand the elided block, it looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'It''s what you expect: `ne` is the negation of `eq`.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Since a default implementation is provided, you can skip implementing `ne`
    when you implement `PartialEq` for your type. It''s enough to implement `eq`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'You are not forced to use the default implementation though. You can choose
    to override it when you implement the trait:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: '[Exercise](#exercise)'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The exercise for this section is located in [`04_traits/03_operator_overloading`](https://github.com/mainmatter/100-exercises-to-learn-rust/tree/main/exercises/04_traits/03_operator_overloading)
  prefs: []
  type: TYPE_NORMAL
