["```py\nignore_warnings = True                                        # ignore warnings?\nimport numpy as np                                            # ndarrays for gridded data\nimport pandas as pd                                           # DataFrames for tabular data\nimport copy                                                   # for deep copies\nimport os                                                     # set working directory, run executables\nimport matplotlib.pyplot as plt                               # for plotting\nfrom matplotlib.colors import ListedColormap                  # custom color maps\nfrom matplotlib.ticker import (MultipleLocator,AutoMinorLocator,NullLocator) # control of axes ticks\nimport matplotlib.ticker as mtick                             # control tick label formatting\nfrom sklearn.neighbors import NearestNeighbors                # nearest neighbours function to calculate eps hyperparameter\nfrom sklearn.preprocessing import MinMaxScaler                # min/max normalization\nfrom sklearn.cluster import KMeans                            # k-means clustering\nfrom sklearn.cluster import DBSCAN                            # DBSCAN clustering\nplt.rc('axes', axisbelow=True)                                # plot all grids below the plot elements\nif ignore_warnings == True:                                   \n    import warnings\n    warnings.filterwarnings('ignore')\ncmap = plt.cm.inferno                                         # color map\nseed = 42                                                     # random number seed \n```", "```py\ndef add_grid():\n    plt.gca().grid(True, which='major',linewidth = 1.0); plt.gca().grid(True, which='minor',linewidth = 0.2) # add y grids\n    plt.gca().tick_params(which='major',length=7); plt.gca().tick_params(which='minor', length=4)\n    plt.gca().xaxis.set_minor_locator(AutoMinorLocator()); plt.gca().yaxis.set_minor_locator(AutoMinorLocator()) # turn on minor ticks \n```", "```py\npaired = plt.get_cmap('Paired')                               # build on categorical colormap\npaired_colors = paired(np.linspace(0, 1, paired.N))\npaired_colors[0] = [1, 1, 1, 1]                               # white in RGBA format for first value\nlcmap = ListedColormap(paired_colors) \n```", "```py\n#os.chdir(\"d:/PGE383\")                                        # set the working directory with the input data file \n```", "```py\nimport pandas as pd \n```", "```py\npd.read_csv() \n```", "```py\ndf = pd.read_csv(\"nonlinear_facies_v1.csv\") \n```", "```py\ndataset = 2 \n```", "```py\ndataset = 2                                                   # select a dataset, 1 - 4\nreduce_the_data = False; retain_fraction = 0.3                # reduce the number of samples to improve visualization and run time \nyname = 'Facies'                                              # available group label for checking\n\nif dataset == 1:\n    Xname = ['Por','Perm']; Xunit = ['%','mD']; Xlabel = ['Porosity','Brittleness'] \n    Xlabelunit = [Xlabel[0] + ' (' + Xunit[0] + ')',Xlabel[1] + ' (' + Xunit[1] + ')']\n    Xmin = [0.0,0.0]; Xmax = [25.0,1200.0]                    # set minimums and maximums for visualization \n    df = pd.read_csv(r'https://raw.githubusercontent.com/GeostatsGuy/GeoDataSets/master/nonlinear_facies_v1.csv') # load our data table \nelif dataset == 2:\n    Xname = ['AI','Por']; Xunit = [r'$kg/m2*10^3$','%']; Xlabel = ['Acoustic Impedance','Porosity'] \n    Xlabelunit = [Xlabel[0] + ' (' + Xunit[0] + ')',Xlabel[1] + ' (' + Xunit[1] + ')']\n    Xmin = [0.0,0.0]; Xmax = [1200.0,30.0]                    # set minimums and maximums for visualization \n    df = pd.read_csv(r'https://raw.githubusercontent.com/GeostatsGuy/GeoDataSets/master/nonlinear_facies_v2.csv') # load our data table\nelif dataset == 3:\n    Xname = ['AI','Por']; Xunit = [r'$kg/m2*10^3$','%']; Xlabel = ['Acoustic Impedance','Porosity'] \n    Xlabelunit = [Xlabel[0] + ' (' + Xunit[0] + ')',Xlabel[1] + ' (' + Xunit[1] + ')']\n    Xmin = [0.0,0.0]; Xmax = [1200.0,30.0]                    # set minimums and maximums for visualization \n    df = pd.read_csv(r'https://raw.githubusercontent.com/GeostatsGuy/GeoDataSets/master/nonlinear_facies_v3.csv') # load our data table\nelif dataset == 4:\n    Xname = ['AI','Por']; Xunit = [r'$kg/m2*10^3$','%']; Xlabel = ['Acoustic Impedance','Porosity'] \n    Xlabelunit = [Xlabel[0] + ' (' + Xunit[0] + ')',Xlabel[1] + ' (' + Xunit[1] + ')']\n    Xmin = [0.0,0.0]; Xmax = [7000.0,30.0]                    # set minimums and maximums for visualization \n    df = pd.read_csv(r'https://raw.githubusercontent.com/GeostatsGuy/GeoDataSets/master/sample_data_Gaussian_mixture_v1.csv') # load our data table\n\nnXname = ['n' + feature for feature in Xname]                 # labels, units and ranges for normalized features\nnXunit = ['norm[' + unit + ']' for unit in Xunit]\nnXlabel = ['Normalized ' + feature for feature in Xlabel]\nnXlabelunit = [nXlabel[0] + ' (' + nXunit[0] + ')',nXlabel[1] + ' (' + nXunit[1] + ')']\nnXmin = [0.0,0.0]; nXmax = [1.0,1.0]    \n\nif reduce_the_data == True:\n    df = df.sample(frac=retain_fraction, random_state = 73073); df = df.reset_index() # extract a fraction of the data\n\ndf = df[Xname + [yname]]                                      # make a new DataFrame with only the features of interest\ndf.head() \n```", "```py\ndf.describe().transpose()                                     # DataFrame summary statistics \n```", "```py\nplt.subplot(221)                                              # histogram feature 1\nplt.hist(df[Xname[0]],alpha=0.8,color=\"darkorange\",edgecolor=\"black\",bins=np.linspace(Xmin[0],Xmax[0],20),density = False)\nplt.title(Xlabel[0])\nplt.xlabel(Xlabelunit[0]); plt.ylabel(\"Frequency\")\nadd_grid()\n\nplt.subplot(222)                                              # histogram feature 2\nplt.hist(df[Xname[1]],alpha=0.8,color=\"darkorange\",edgecolor=\"black\",bins=np.linspace(Xmin[1],Xmax[1],20),density = False)\nplt.title(Xlabel[1])\nplt.xlabel(Xlabelunit[1]); plt.ylabel(\"Frequency\")\nadd_grid()\n\nplt.subplot(223)                                              # histogram truth label\nn, bins, patches = plt.hist(df[yname],alpha=0.8,color=\"darkorange\",edgecolor=\"black\",bins=[0.5,1.5,2.5,3.5],label = ['Shale','SandShale','Sand'],range=[0.5,2.5],density = True)\nplt.title('Facies Proportions')\nplt.xlabel('Facies'); plt.ylabel(\"Proportion\")\nax = plt.gca()\nax.set_xticks(np.arange(1.0, 3.1, 1)); ax.set_yticks(np.arange(0, 0.6, 0.2)); ax.set_yticks(np.arange(0, 0.6, 0.05), minor=True)\nax.grid(which='minor', alpha=0.1); ax.grid(which='major', alpha=0.2)\ncolors = plt.cm.YlOrBr_r(np.linspace(0, 1, len(patches)))\nfor patch, color in zip(patches, colors):\n    patch.set_facecolor(color)\n\nplt.subplots_adjust(left=0.0, bottom=0.0, right=2.0, top=2.1, wspace=0.2, hspace=0.2); plt.show() \n```", "```py\ntransform = MinMaxScaler();                                   # instantiate the normalization object\ndf['n' + Xname[0]], df['n' + Xname[1]] = transform.fit_transform(df.loc[:,Xname].values).T # normalize features\ndf.head(n = 3) \n```", "```py\ndf.describe().transpose()                                     # check normalization via summary statistics \n```", "```py\nplt.subplot(221)                                              # original histograms\nplt.hist(df[Xname[0]],alpha=0.8,color=\"darkorange\",edgecolor=\"black\",bins=np.linspace(Xmin[0],Xmax[0],20),density = False)\nplt.title(Xlabel[0])\nplt.xlabel(Xlabelunit[0]); plt.ylabel(\"Frequency\")\nadd_grid()\n\nplt.subplot(222)\nplt.hist(df[Xname[1]],alpha=0.8,color=\"darkorange\",edgecolor=\"black\",bins=np.linspace(Xmin[1],Xmax[1],20),density = False)\nplt.title(Xlabel[1])\nplt.xlabel(Xlabelunit[1]); plt.ylabel(\"Frequency\")\nadd_grid()\n\nplt.subplot(223)                                              # normalized histograms\nplt.hist(df[nXname[0]],alpha=0.8,color=\"darkorange\",edgecolor=\"black\",bins=np.linspace(nXmin[0],nXmax[0],20),density = False)\nplt.title(nXlabel[0])\nplt.xlabel(nXlabelunit[0]); plt.ylabel(\"Frequency\")\nadd_grid()\n\nplt.subplot(224)\nplt.hist(df[nXname[1]],alpha=0.8,color=\"darkorange\",edgecolor=\"black\",bins=np.linspace(nXmin[1],nXmax[1],20),density = False)\nplt.title(nXlabel[1])\nplt.xlabel(nXlabelunit[1]); plt.ylabel(\"Frequency\")\nadd_grid()\n\nplt.subplots_adjust(left=0.0, bottom=0.0, right=2.0, top=2.1, wspace=0.2, hspace=0.2); plt.show() \n```", "```py\nfacies_list = np.unique(df[yname])                            # get the facies list from loaded data\nmin_facies = min(facies_list); max_facies = max(facies_list)\nfor ifacies in facies_list:                                   # plot the labeled data\n    plt.scatter(df[df[yname] == ifacies][Xname[0]],df[df[yname] == ifacies][Xname[1]],\n        color = plt.cm.YlOrBr_r((ifacies-min_facies)/(max_facies-min_facies)),edgecolor='black',alpha = 0.8,\n        vmin = min_facies, vmax = max_facies,label = 'Facies: ' + str(ifacies))\n\nplt.xlabel(Xlabelunit[0]); plt.ylabel(Xlabelunit[1]); plt.title(Xlabel[1] + ' vs. ' + Xlabel[0] + ' with Truth ' + yname); add_grid()\nplt.xlim([Xmin[0],Xmax[0]]); plt.ylim([Xmin[1],Xmax[1]])\nplt.legend()\n\nplt.subplots_adjust(left=0.0, bottom=0.0, right=1.0, top=1.0, wspace=0.2, hspace=0.2) \n```", "```py\nplt.subplot(121)                                              # scatter plot our data\nplt.scatter(df[Xname[0]], df[Xname[1]], c=\"black\", alpha = 0.4, linewidths=1.0, edgecolors=\"black\")\nplt.title(Xlabel[1] + ' vs. ' + Xlabel[0]); plt.xlabel(Xlabelunit[0]); plt.ylabel(Xlabelunit[1])\nplt.xlim([Xmin[0],Xmax[0]]); plt.ylim([Xmin[1],Xmax[1]]); add_grid()\n\nplt.subplot(122)                                              # scatter plot our normalized data \nplt.scatter(df[nXname[0]], df[nXname[1]],c=\"black\",alpha = 0.4,linewidths=1.0, edgecolors=\"black\")\nplt.title(nXlabel[1] + ' vs. ' + nXlabel[0]); plt.xlabel(nXlabelunit[0]); plt.ylabel(nXlabelunit[1])\nplt.xlim([nXmin[0],nXmax[0]]); plt.ylim([nXmin[1],nXmax[1]]); add_grid()\n\nplt.subplots_adjust(left=0.0, bottom=0.0, right=1.6, top=0.8, wspace=0.2, hspace=0.2); plt.show() \n```", "```py\nnp.random.seed(seed)\nK = 3                                                         # number of prototypes\nignore_warnings = True                                        # ignore warnings?\n\nkmeans = KMeans(n_clusters=K, random_state=0).fit(df[nXname].values)\ndf['kMeans'] = kmeans.labels_ + 1\ncluster_list = np.unique(df['kMeans']); min_cluster = min(cluster_list); max_cluster = max(cluster_list)\n\nplt.subplot(221)                                              # plot the data unlabeled\nplt.scatter(df[Xname[0]], df[Xname[1]],c='black',alpha=0.5,edgecolor='k',cmap = cmap)\nplt.xlabel(Xlabelunit[0]); plt.ylabel(Xlabelunit[1]); plt.title(Xlabel[1] + ' vs. ' + Xlabel[0]); add_grid()\nplt.xlim([Xmin[0],Xmax[0]]); plt.ylim([Xmin[1],Xmax[1]])\n\nplt.subplot(223)                                              # plot the cluster groups\nfor icluster in cluster_list:\n    plt.scatter(df[df['kMeans'] == icluster][Xname[0]],df[df['kMeans'] == icluster][Xname[1]],\n        color = plt.cm.YlOrBr_r((icluster-min_cluster)/(max_cluster-min_cluster)),edgecolor='black',alpha = 0.8,\n        vmin = min_cluster,vmax = max_cluster,label = 'Facies: ' + str(icluster))\nplt.xlabel(Xlabelunit[0]); plt.ylabel(Xlabelunit[1]); plt.title(Xlabel[1] + ' vs. ' + Xlabel[0] + ' with Clusters'); add_grid()\nplt.xlim([Xmin[0],Xmax[0]]); plt.ylim([Xmin[1],Xmax[1]])\nplt.legend(loc='upper right')\n\nplt.subplot(224)                                              # plot the cluster groups histograms \nN, bins, patches  = plt.hist(df['kMeans'],alpha=0.8,edgecolor=\"black\",range=[min_cluster-0.5,max_cluster-0.5],\n    bins=np.insert(np.linspace(min_cluster,max_cluster,len(cluster_list))+0.5,0,min_cluster-0.5),density = False)\nfor i in range(0,len(cluster_list)):\n    patches[i].set_facecolor(plt.cm.YlOrBr_r((cluster_list[i]-min_cluster)/(max_cluster-min_cluster)));\nax = plt.gca(); ax.set_xticks(cluster_list); plt.xlabel('k-Means Clusters'); plt.ylabel('Frequency'); plt.title('k-Means Clustering Groups')\nadd_grid()   \n\nplt.subplots_adjust(left=0.0, bottom=0.0, right=2.0, top=2.1, wspace=0.2, hspace=0.2); plt.show() \n```", "```py\neps = 0.026; min_samples = 10                                 # DBSCAN model parameters\n\ndbscan = DBSCAN(eps=0.029, min_samples=15).fit(df[nXname].values)\ndf['DBSCAN'] = dbscan.labels_ + 1\ncluster_list = np.unique(df['DBSCAN']); min_cluster = min(cluster_list); max_cluster = max(cluster_list)\n\nplt.subplot(221)                                              # plot the assigned training data and K prototypes\nplt.scatter(df[Xname[0]], df[Xname[1]],c='black',alpha=0.5,edgecolor='k',cmap = cmap)\nplt.xlabel(Xlabelunit[0]); plt.ylabel(Xlabelunit[1]); plt.title(Xlabel[1] + ' vs. ' + Xlabel[0]); add_grid()\nplt.xlim([Xmin[0],Xmax[0]]); plt.ylim([Xmin[1],Xmax[1]])\n\nplt.subplot(223)                                              # plot the cluster groups\nfor icluster in cluster_list:\n    if icluster == 0:\n        plt.scatter(df[df['DBSCAN'] == icluster][Xname[0]],df[df['DBSCAN'] == icluster][Xname[1]],\n            color = lcmap((icluster-min_cluster)/(max_cluster-min_cluster)),edgecolor='black',alpha = 0.8,\n            vmin = min_cluster,vmax = max_cluster,label = 'Outliers')\n    else:\n        plt.scatter(df[df['DBSCAN'] == icluster][Xname[0]],df[df['DBSCAN'] == icluster][Xname[1]],\n            color = lcmap((icluster-min_cluster)/(max_cluster-min_cluster)),edgecolor='black',alpha = 0.8,\n            vmin = min_cluster,vmax = max_cluster,label = 'Facies: ' + str(icluster))\nplt.xlabel(Xlabelunit[0]); plt.ylabel(Xlabelunit[1]); plt.title(Xlabel[1] + ' vs. ' + Xlabel[0] + ' with Clusters'); add_grid()\nplt.xlim([Xmin[0],Xmax[0]]); plt.ylim([Xmin[1],Xmax[1]])\nplt.legend(loc='lower left',ncol = 3)\n\nplt.subplot(224)                                              # plot the cluster histogram\nN, bins, patches  = plt.hist(df['DBSCAN'],alpha=0.8,edgecolor=\"black\",range=[min_cluster-0.5,max_cluster-0.5],\n    bins=np.insert(np.linspace(min_cluster,max_cluster,len(cluster_list))+0.5,0,min_cluster-0.5),density = False)\nfor i in range(0,len(cluster_list)):\n    patches[i].set_facecolor(lcmap((cluster_list[i]-min_cluster)/(max_cluster-min_cluster)));\nax = plt.gca(); ax.set_xticks(cluster_list); plt.xlabel('DBSCAN Clusters'); plt.ylabel('Frequency'); plt.title('DBSCAN Clustering Groups')\nadd_grid()   \ncurrent_labels = plt.gca().get_xticks().astype(str)\ncurrent_labels[0] = 'Outliers'\nplt.gca().set_xticklabels(current_labels); plt.gca().xaxis.set_minor_locator(NullLocator())\n\nplt.subplots_adjust(left=0.0, bottom=0.0, right=2.0, top=2.1, wspace=0.2, hspace=0.2) \n```", "```py\neps_mat = [0.026,0.029,0.032] \nmin_sample_mat = [10, 15, 20] \n```", "```py\neps_mat = [0.026,0.029,0.032]                                 # set parameters to explore - set for 3 cases of each\nmin_sample_mat = [10, 15, 20]\n\nindex = 1\nfor eps in eps_mat:\n    for min_sample in min_sample_mat:\n        dbscan = DBSCAN(eps=eps, min_samples=min_sample).fit(df[nXname].values) # perform DBSCAN\n        df['DBSCAN'] = dbscan.labels_ + 1\n\n        cluster_list = np.unique(df['DBSCAN']); min_cluster = min(cluster_list); max_cluster = max(cluster_list) # cluster indexes\n\n        plt.subplot(3,3,index)                                # plot the cluster groups\n        for icluster in cluster_list:\n            if icluster == 0:\n                plt.scatter(df[df['DBSCAN'] == icluster][Xname[0]],df[df['DBSCAN'] == icluster][Xname[1]],\n                    color = lcmap((icluster-min_cluster)/(max_cluster-min_cluster)),edgecolor='black',alpha = 0.8,\n                    vmin = min_cluster,vmax = max_cluster,label = 'Outliers')\n            else:\n                plt.scatter(df[df['DBSCAN'] == icluster][Xname[0]],df[df['DBSCAN'] == icluster][Xname[1]],\n                    color = lcmap((icluster-min_cluster)/(max_cluster-min_cluster)),edgecolor='black',alpha = 0.8,\n                    vmin = min_cluster,vmax = max_cluster,label = 'Facies: ' + str(icluster))\n        plt.xlabel(Xlabelunit[0]); plt.ylabel(Xlabelunit[1])\n        plt.title(Xlabel[1] + ' vs. ' + Xlabel[0] + ' Clusters, eps: ' + str(eps) + r', $min_{sample}$ ' + str(min_sample))\n        plt.xlim([Xmin[0],Xmax[0]]); plt.ylim([Xmin[1],Xmax[1]]); add_grid()\n        index = index + 1\n\nplt.subplots_adjust(left=0.0, bottom=0.0, right=3.0, top=3.50, wspace=0.2, hspace=0.2) \n```", "```py\nneigh = NearestNeighbors(n_neighbors=min_sample)\nnbrs = neigh.fit(df[['nPor','nPerm']].values)\ndistances, indices = nbrs.kneighbors(df[['nPor','nPerm']].values) \n```", "```py\nmin_sample = 15                                               # set the number of neighbours for k-nearest neighbour plot\n\nneigh = NearestNeighbors(n_neighbors=min_sample,radius=999.0,algorithm='kd_tree')\nnbrs = neigh.fit(df[nXname].values)\ndistances, indices = nbrs.kneighbors(df[nXname].values)\ndistances = distances[:,min_sample-1]\ndistances = np.sort(distances)\n\nplt.plot(distances, c = 'red'); plt.xlabel('Sorted Ascending Data Index'); plt.ylabel('Intersample Distance in Feature Space')\nplt.fill_between(np.arange(1,len(df)+1,1),np.zeros((len(df))),distances,color='red',alpha=0.4)\nplt.title('Nearest Neighbour Plot'); add_grid(); plt.xlim([0,len(df)]); plt.ylim([0,np.max(distances)])\nplt.subplots_adjust(left=0.0, bottom=0.0, right=1.6, top=0.8, wspace=0.2, hspace=0.2) \n```", "```py\ndbscan_tuned = DBSCAN(eps=0.029, min_samples=15).fit(df[nXname].values) # DBSCAN with tuned/improved parameters\ndf['DBSCAN_tuned'] = dbscan_tuned.labels_ + 1 \ncluster_list = np.unique(df['DBSCAN_tuned']); min_cluster = min(cluster_list); max_cluster = max(cluster_list) # cluster statistics\n\nplt.subplot(221)                                              # plot the assigned training data and K prototypes\nplt.scatter(df[Xname[0]], df[Xname[1]],c='black',alpha=0.5,edgecolor='k',cmap = cmap)\nplt.xlabel(Xlabelunit[0]); plt.ylabel(Xlabelunit[1]); plt.title(Xlabel[1] + ' vs. ' + Xlabel[0]); add_grid()\nplt.xlim([Xmin[0],Xmax[0]]); plt.ylim([Xmin[1],Xmax[1]])\n\nplt.subplot(223)                                              # plot the cluster groups\nfor icluster in cluster_list:\n    if icluster == 0:\n        plt.scatter(df[df['DBSCAN_tuned'] == icluster][Xname[0]],df[df['DBSCAN_tuned'] == icluster][Xname[1]],\n            color = lcmap((icluster-min_cluster)/(max_cluster-min_cluster)),edgecolor='black',alpha = 0.8,\n            vmin = min_cluster,vmax = max_cluster,label = 'Outliers')\n    else:\n        plt.scatter(df[df['DBSCAN_tuned'] == icluster][Xname[0]],df[df['DBSCAN_tuned'] == icluster][Xname[1]],\n            color = lcmap((icluster-min_cluster)/(max_cluster-min_cluster)),edgecolor='black',alpha = 0.8,\n            vmin = min_cluster,vmax = max_cluster,label = 'Facies: ' + str(icluster))\nplt.xlabel(Xlabelunit[0]); plt.ylabel(Xlabelunit[1]); plt.title(Xlabel[1] + ' vs. ' + Xlabel[0] + ' with Clusters'); add_grid()\nplt.xlim([Xmin[0],Xmax[0]]); plt.ylim([Xmin[1],Xmax[1]])\nplt.legend(loc='lower left',ncol = 3)\n\nplt.subplot(224)                                              # plot cluster histogram\nN, bins, patches  = plt.hist(df['DBSCAN_tuned'],alpha=0.8,edgecolor=\"black\",range=[min_cluster-0.5,max_cluster-0.5],\n    bins=np.insert(np.linspace(min_cluster,max_cluster,len(cluster_list))+0.5,0,min_cluster-0.5),density = False)\nfor i in range(0,len(cluster_list)):\n    patches[i].set_facecolor(lcmap((cluster_list[i]-min_cluster)/(max_cluster-min_cluster)));\nax = plt.gca(); ax.set_xticks(cluster_list); plt.xlabel('Tuned DBSCAN Clusters'); plt.ylabel('Frequency'); plt.title('Tuned DBSCAN Clustering Groups')\nadd_grid()   \ncurrent_labels = plt.gca().get_xticks().astype(str)\ncurrent_labels[0] = 'Outliers'\nplt.gca().set_xticklabels(current_labels); plt.gca().xaxis.set_minor_locator(NullLocator())\n\nplt.subplots_adjust(left=0.0, bottom=0.0, right=2.0, top=2.1, wspace=0.2, hspace=0.2) \n```", "```py\nignore_warnings = True                                        # ignore warnings?\nimport numpy as np                                            # ndarrays for gridded data\nimport pandas as pd                                           # DataFrames for tabular data\nimport copy                                                   # for deep copies\nimport os                                                     # set working directory, run executables\nimport matplotlib.pyplot as plt                               # for plotting\nfrom matplotlib.colors import ListedColormap                  # custom color maps\nfrom matplotlib.ticker import (MultipleLocator,AutoMinorLocator,NullLocator) # control of axes ticks\nimport matplotlib.ticker as mtick                             # control tick label formatting\nfrom sklearn.neighbors import NearestNeighbors                # nearest neighbours function to calculate eps hyperparameter\nfrom sklearn.preprocessing import MinMaxScaler                # min/max normalization\nfrom sklearn.cluster import KMeans                            # k-means clustering\nfrom sklearn.cluster import DBSCAN                            # DBSCAN clustering\nplt.rc('axes', axisbelow=True)                                # plot all grids below the plot elements\nif ignore_warnings == True:                                   \n    import warnings\n    warnings.filterwarnings('ignore')\ncmap = plt.cm.inferno                                         # color map\nseed = 42                                                     # random number seed \n```", "```py\ndef add_grid():\n    plt.gca().grid(True, which='major',linewidth = 1.0); plt.gca().grid(True, which='minor',linewidth = 0.2) # add y grids\n    plt.gca().tick_params(which='major',length=7); plt.gca().tick_params(which='minor', length=4)\n    plt.gca().xaxis.set_minor_locator(AutoMinorLocator()); plt.gca().yaxis.set_minor_locator(AutoMinorLocator()) # turn on minor ticks \n```", "```py\npaired = plt.get_cmap('Paired')                               # build on categorical colormap\npaired_colors = paired(np.linspace(0, 1, paired.N))\npaired_colors[0] = [1, 1, 1, 1]                               # white in RGBA format for first value\nlcmap = ListedColormap(paired_colors) \n```", "```py\n#os.chdir(\"d:/PGE383\")                                        # set the working directory with the input data file \n```", "```py\nimport pandas as pd \n```", "```py\npd.read_csv() \n```", "```py\ndf = pd.read_csv(\"nonlinear_facies_v1.csv\") \n```", "```py\ndataset = 2 \n```", "```py\ndataset = 2                                                   # select a dataset, 1 - 4\nreduce_the_data = False; retain_fraction = 0.3                # reduce the number of samples to improve visualization and run time \nyname = 'Facies'                                              # available group label for checking\n\nif dataset == 1:\n    Xname = ['Por','Perm']; Xunit = ['%','mD']; Xlabel = ['Porosity','Brittleness'] \n    Xlabelunit = [Xlabel[0] + ' (' + Xunit[0] + ')',Xlabel[1] + ' (' + Xunit[1] + ')']\n    Xmin = [0.0,0.0]; Xmax = [25.0,1200.0]                    # set minimums and maximums for visualization \n    df = pd.read_csv(r'https://raw.githubusercontent.com/GeostatsGuy/GeoDataSets/master/nonlinear_facies_v1.csv') # load our data table \nelif dataset == 2:\n    Xname = ['AI','Por']; Xunit = [r'$kg/m2*10^3$','%']; Xlabel = ['Acoustic Impedance','Porosity'] \n    Xlabelunit = [Xlabel[0] + ' (' + Xunit[0] + ')',Xlabel[1] + ' (' + Xunit[1] + ')']\n    Xmin = [0.0,0.0]; Xmax = [1200.0,30.0]                    # set minimums and maximums for visualization \n    df = pd.read_csv(r'https://raw.githubusercontent.com/GeostatsGuy/GeoDataSets/master/nonlinear_facies_v2.csv') # load our data table\nelif dataset == 3:\n    Xname = ['AI','Por']; Xunit = [r'$kg/m2*10^3$','%']; Xlabel = ['Acoustic Impedance','Porosity'] \n    Xlabelunit = [Xlabel[0] + ' (' + Xunit[0] + ')',Xlabel[1] + ' (' + Xunit[1] + ')']\n    Xmin = [0.0,0.0]; Xmax = [1200.0,30.0]                    # set minimums and maximums for visualization \n    df = pd.read_csv(r'https://raw.githubusercontent.com/GeostatsGuy/GeoDataSets/master/nonlinear_facies_v3.csv') # load our data table\nelif dataset == 4:\n    Xname = ['AI','Por']; Xunit = [r'$kg/m2*10^3$','%']; Xlabel = ['Acoustic Impedance','Porosity'] \n    Xlabelunit = [Xlabel[0] + ' (' + Xunit[0] + ')',Xlabel[1] + ' (' + Xunit[1] + ')']\n    Xmin = [0.0,0.0]; Xmax = [7000.0,30.0]                    # set minimums and maximums for visualization \n    df = pd.read_csv(r'https://raw.githubusercontent.com/GeostatsGuy/GeoDataSets/master/sample_data_Gaussian_mixture_v1.csv') # load our data table\n\nnXname = ['n' + feature for feature in Xname]                 # labels, units and ranges for normalized features\nnXunit = ['norm[' + unit + ']' for unit in Xunit]\nnXlabel = ['Normalized ' + feature for feature in Xlabel]\nnXlabelunit = [nXlabel[0] + ' (' + nXunit[0] + ')',nXlabel[1] + ' (' + nXunit[1] + ')']\nnXmin = [0.0,0.0]; nXmax = [1.0,1.0]    \n\nif reduce_the_data == True:\n    df = df.sample(frac=retain_fraction, random_state = 73073); df = df.reset_index() # extract a fraction of the data\n\ndf = df[Xname + [yname]]                                      # make a new DataFrame with only the features of interest\ndf.head() \n```", "```py\ndf.describe().transpose()                                     # DataFrame summary statistics \n```", "```py\nplt.subplot(221)                                              # histogram feature 1\nplt.hist(df[Xname[0]],alpha=0.8,color=\"darkorange\",edgecolor=\"black\",bins=np.linspace(Xmin[0],Xmax[0],20),density = False)\nplt.title(Xlabel[0])\nplt.xlabel(Xlabelunit[0]); plt.ylabel(\"Frequency\")\nadd_grid()\n\nplt.subplot(222)                                              # histogram feature 2\nplt.hist(df[Xname[1]],alpha=0.8,color=\"darkorange\",edgecolor=\"black\",bins=np.linspace(Xmin[1],Xmax[1],20),density = False)\nplt.title(Xlabel[1])\nplt.xlabel(Xlabelunit[1]); plt.ylabel(\"Frequency\")\nadd_grid()\n\nplt.subplot(223)                                              # histogram truth label\nn, bins, patches = plt.hist(df[yname],alpha=0.8,color=\"darkorange\",edgecolor=\"black\",bins=[0.5,1.5,2.5,3.5],label = ['Shale','SandShale','Sand'],range=[0.5,2.5],density = True)\nplt.title('Facies Proportions')\nplt.xlabel('Facies'); plt.ylabel(\"Proportion\")\nax = plt.gca()\nax.set_xticks(np.arange(1.0, 3.1, 1)); ax.set_yticks(np.arange(0, 0.6, 0.2)); ax.set_yticks(np.arange(0, 0.6, 0.05), minor=True)\nax.grid(which='minor', alpha=0.1); ax.grid(which='major', alpha=0.2)\ncolors = plt.cm.YlOrBr_r(np.linspace(0, 1, len(patches)))\nfor patch, color in zip(patches, colors):\n    patch.set_facecolor(color)\n\nplt.subplots_adjust(left=0.0, bottom=0.0, right=2.0, top=2.1, wspace=0.2, hspace=0.2); plt.show() \n```", "```py\ntransform = MinMaxScaler();                                   # instantiate the normalization object\ndf['n' + Xname[0]], df['n' + Xname[1]] = transform.fit_transform(df.loc[:,Xname].values).T # normalize features\ndf.head(n = 3) \n```", "```py\ndf.describe().transpose()                                     # check normalization via summary statistics \n```", "```py\nplt.subplot(221)                                              # original histograms\nplt.hist(df[Xname[0]],alpha=0.8,color=\"darkorange\",edgecolor=\"black\",bins=np.linspace(Xmin[0],Xmax[0],20),density = False)\nplt.title(Xlabel[0])\nplt.xlabel(Xlabelunit[0]); plt.ylabel(\"Frequency\")\nadd_grid()\n\nplt.subplot(222)\nplt.hist(df[Xname[1]],alpha=0.8,color=\"darkorange\",edgecolor=\"black\",bins=np.linspace(Xmin[1],Xmax[1],20),density = False)\nplt.title(Xlabel[1])\nplt.xlabel(Xlabelunit[1]); plt.ylabel(\"Frequency\")\nadd_grid()\n\nplt.subplot(223)                                              # normalized histograms\nplt.hist(df[nXname[0]],alpha=0.8,color=\"darkorange\",edgecolor=\"black\",bins=np.linspace(nXmin[0],nXmax[0],20),density = False)\nplt.title(nXlabel[0])\nplt.xlabel(nXlabelunit[0]); plt.ylabel(\"Frequency\")\nadd_grid()\n\nplt.subplot(224)\nplt.hist(df[nXname[1]],alpha=0.8,color=\"darkorange\",edgecolor=\"black\",bins=np.linspace(nXmin[1],nXmax[1],20),density = False)\nplt.title(nXlabel[1])\nplt.xlabel(nXlabelunit[1]); plt.ylabel(\"Frequency\")\nadd_grid()\n\nplt.subplots_adjust(left=0.0, bottom=0.0, right=2.0, top=2.1, wspace=0.2, hspace=0.2); plt.show() \n```", "```py\nfacies_list = np.unique(df[yname])                            # get the facies list from loaded data\nmin_facies = min(facies_list); max_facies = max(facies_list)\nfor ifacies in facies_list:                                   # plot the labeled data\n    plt.scatter(df[df[yname] == ifacies][Xname[0]],df[df[yname] == ifacies][Xname[1]],\n        color = plt.cm.YlOrBr_r((ifacies-min_facies)/(max_facies-min_facies)),edgecolor='black',alpha = 0.8,\n        vmin = min_facies, vmax = max_facies,label = 'Facies: ' + str(ifacies))\n\nplt.xlabel(Xlabelunit[0]); plt.ylabel(Xlabelunit[1]); plt.title(Xlabel[1] + ' vs. ' + Xlabel[0] + ' with Truth ' + yname); add_grid()\nplt.xlim([Xmin[0],Xmax[0]]); plt.ylim([Xmin[1],Xmax[1]])\nplt.legend()\n\nplt.subplots_adjust(left=0.0, bottom=0.0, right=1.0, top=1.0, wspace=0.2, hspace=0.2) \n```", "```py\nplt.subplot(121)                                              # scatter plot our data\nplt.scatter(df[Xname[0]], df[Xname[1]], c=\"black\", alpha = 0.4, linewidths=1.0, edgecolors=\"black\")\nplt.title(Xlabel[1] + ' vs. ' + Xlabel[0]); plt.xlabel(Xlabelunit[0]); plt.ylabel(Xlabelunit[1])\nplt.xlim([Xmin[0],Xmax[0]]); plt.ylim([Xmin[1],Xmax[1]]); add_grid()\n\nplt.subplot(122)                                              # scatter plot our normalized data \nplt.scatter(df[nXname[0]], df[nXname[1]],c=\"black\",alpha = 0.4,linewidths=1.0, edgecolors=\"black\")\nplt.title(nXlabel[1] + ' vs. ' + nXlabel[0]); plt.xlabel(nXlabelunit[0]); plt.ylabel(nXlabelunit[1])\nplt.xlim([nXmin[0],nXmax[0]]); plt.ylim([nXmin[1],nXmax[1]]); add_grid()\n\nplt.subplots_adjust(left=0.0, bottom=0.0, right=1.6, top=0.8, wspace=0.2, hspace=0.2); plt.show() \n```", "```py\nnp.random.seed(seed)\nK = 3                                                         # number of prototypes\nignore_warnings = True                                        # ignore warnings?\n\nkmeans = KMeans(n_clusters=K, random_state=0).fit(df[nXname].values)\ndf['kMeans'] = kmeans.labels_ + 1\ncluster_list = np.unique(df['kMeans']); min_cluster = min(cluster_list); max_cluster = max(cluster_list)\n\nplt.subplot(221)                                              # plot the data unlabeled\nplt.scatter(df[Xname[0]], df[Xname[1]],c='black',alpha=0.5,edgecolor='k',cmap = cmap)\nplt.xlabel(Xlabelunit[0]); plt.ylabel(Xlabelunit[1]); plt.title(Xlabel[1] + ' vs. ' + Xlabel[0]); add_grid()\nplt.xlim([Xmin[0],Xmax[0]]); plt.ylim([Xmin[1],Xmax[1]])\n\nplt.subplot(223)                                              # plot the cluster groups\nfor icluster in cluster_list:\n    plt.scatter(df[df['kMeans'] == icluster][Xname[0]],df[df['kMeans'] == icluster][Xname[1]],\n        color = plt.cm.YlOrBr_r((icluster-min_cluster)/(max_cluster-min_cluster)),edgecolor='black',alpha = 0.8,\n        vmin = min_cluster,vmax = max_cluster,label = 'Facies: ' + str(icluster))\nplt.xlabel(Xlabelunit[0]); plt.ylabel(Xlabelunit[1]); plt.title(Xlabel[1] + ' vs. ' + Xlabel[0] + ' with Clusters'); add_grid()\nplt.xlim([Xmin[0],Xmax[0]]); plt.ylim([Xmin[1],Xmax[1]])\nplt.legend(loc='upper right')\n\nplt.subplot(224)                                              # plot the cluster groups histograms \nN, bins, patches  = plt.hist(df['kMeans'],alpha=0.8,edgecolor=\"black\",range=[min_cluster-0.5,max_cluster-0.5],\n    bins=np.insert(np.linspace(min_cluster,max_cluster,len(cluster_list))+0.5,0,min_cluster-0.5),density = False)\nfor i in range(0,len(cluster_list)):\n    patches[i].set_facecolor(plt.cm.YlOrBr_r((cluster_list[i]-min_cluster)/(max_cluster-min_cluster)));\nax = plt.gca(); ax.set_xticks(cluster_list); plt.xlabel('k-Means Clusters'); plt.ylabel('Frequency'); plt.title('k-Means Clustering Groups')\nadd_grid()   \n\nplt.subplots_adjust(left=0.0, bottom=0.0, right=2.0, top=2.1, wspace=0.2, hspace=0.2); plt.show() \n```", "```py\neps = 0.026; min_samples = 10                                 # DBSCAN model parameters\n\ndbscan = DBSCAN(eps=0.029, min_samples=15).fit(df[nXname].values)\ndf['DBSCAN'] = dbscan.labels_ + 1\ncluster_list = np.unique(df['DBSCAN']); min_cluster = min(cluster_list); max_cluster = max(cluster_list)\n\nplt.subplot(221)                                              # plot the assigned training data and K prototypes\nplt.scatter(df[Xname[0]], df[Xname[1]],c='black',alpha=0.5,edgecolor='k',cmap = cmap)\nplt.xlabel(Xlabelunit[0]); plt.ylabel(Xlabelunit[1]); plt.title(Xlabel[1] + ' vs. ' + Xlabel[0]); add_grid()\nplt.xlim([Xmin[0],Xmax[0]]); plt.ylim([Xmin[1],Xmax[1]])\n\nplt.subplot(223)                                              # plot the cluster groups\nfor icluster in cluster_list:\n    if icluster == 0:\n        plt.scatter(df[df['DBSCAN'] == icluster][Xname[0]],df[df['DBSCAN'] == icluster][Xname[1]],\n            color = lcmap((icluster-min_cluster)/(max_cluster-min_cluster)),edgecolor='black',alpha = 0.8,\n            vmin = min_cluster,vmax = max_cluster,label = 'Outliers')\n    else:\n        plt.scatter(df[df['DBSCAN'] == icluster][Xname[0]],df[df['DBSCAN'] == icluster][Xname[1]],\n            color = lcmap((icluster-min_cluster)/(max_cluster-min_cluster)),edgecolor='black',alpha = 0.8,\n            vmin = min_cluster,vmax = max_cluster,label = 'Facies: ' + str(icluster))\nplt.xlabel(Xlabelunit[0]); plt.ylabel(Xlabelunit[1]); plt.title(Xlabel[1] + ' vs. ' + Xlabel[0] + ' with Clusters'); add_grid()\nplt.xlim([Xmin[0],Xmax[0]]); plt.ylim([Xmin[1],Xmax[1]])\nplt.legend(loc='lower left',ncol = 3)\n\nplt.subplot(224)                                              # plot the cluster histogram\nN, bins, patches  = plt.hist(df['DBSCAN'],alpha=0.8,edgecolor=\"black\",range=[min_cluster-0.5,max_cluster-0.5],\n    bins=np.insert(np.linspace(min_cluster,max_cluster,len(cluster_list))+0.5,0,min_cluster-0.5),density = False)\nfor i in range(0,len(cluster_list)):\n    patches[i].set_facecolor(lcmap((cluster_list[i]-min_cluster)/(max_cluster-min_cluster)));\nax = plt.gca(); ax.set_xticks(cluster_list); plt.xlabel('DBSCAN Clusters'); plt.ylabel('Frequency'); plt.title('DBSCAN Clustering Groups')\nadd_grid()   \ncurrent_labels = plt.gca().get_xticks().astype(str)\ncurrent_labels[0] = 'Outliers'\nplt.gca().set_xticklabels(current_labels); plt.gca().xaxis.set_minor_locator(NullLocator())\n\nplt.subplots_adjust(left=0.0, bottom=0.0, right=2.0, top=2.1, wspace=0.2, hspace=0.2) \n```", "```py\neps_mat = [0.026,0.029,0.032] \nmin_sample_mat = [10, 15, 20] \n```", "```py\neps_mat = [0.026,0.029,0.032]                                 # set parameters to explore - set for 3 cases of each\nmin_sample_mat = [10, 15, 20]\n\nindex = 1\nfor eps in eps_mat:\n    for min_sample in min_sample_mat:\n        dbscan = DBSCAN(eps=eps, min_samples=min_sample).fit(df[nXname].values) # perform DBSCAN\n        df['DBSCAN'] = dbscan.labels_ + 1\n\n        cluster_list = np.unique(df['DBSCAN']); min_cluster = min(cluster_list); max_cluster = max(cluster_list) # cluster indexes\n\n        plt.subplot(3,3,index)                                # plot the cluster groups\n        for icluster in cluster_list:\n            if icluster == 0:\n                plt.scatter(df[df['DBSCAN'] == icluster][Xname[0]],df[df['DBSCAN'] == icluster][Xname[1]],\n                    color = lcmap((icluster-min_cluster)/(max_cluster-min_cluster)),edgecolor='black',alpha = 0.8,\n                    vmin = min_cluster,vmax = max_cluster,label = 'Outliers')\n            else:\n                plt.scatter(df[df['DBSCAN'] == icluster][Xname[0]],df[df['DBSCAN'] == icluster][Xname[1]],\n                    color = lcmap((icluster-min_cluster)/(max_cluster-min_cluster)),edgecolor='black',alpha = 0.8,\n                    vmin = min_cluster,vmax = max_cluster,label = 'Facies: ' + str(icluster))\n        plt.xlabel(Xlabelunit[0]); plt.ylabel(Xlabelunit[1])\n        plt.title(Xlabel[1] + ' vs. ' + Xlabel[0] + ' Clusters, eps: ' + str(eps) + r', $min_{sample}$ ' + str(min_sample))\n        plt.xlim([Xmin[0],Xmax[0]]); plt.ylim([Xmin[1],Xmax[1]]); add_grid()\n        index = index + 1\n\nplt.subplots_adjust(left=0.0, bottom=0.0, right=3.0, top=3.50, wspace=0.2, hspace=0.2) \n```", "```py\nneigh = NearestNeighbors(n_neighbors=min_sample)\nnbrs = neigh.fit(df[['nPor','nPerm']].values)\ndistances, indices = nbrs.kneighbors(df[['nPor','nPerm']].values) \n```", "```py\nmin_sample = 15                                               # set the number of neighbours for k-nearest neighbour plot\n\nneigh = NearestNeighbors(n_neighbors=min_sample,radius=999.0,algorithm='kd_tree')\nnbrs = neigh.fit(df[nXname].values)\ndistances, indices = nbrs.kneighbors(df[nXname].values)\ndistances = distances[:,min_sample-1]\ndistances = np.sort(distances)\n\nplt.plot(distances, c = 'red'); plt.xlabel('Sorted Ascending Data Index'); plt.ylabel('Intersample Distance in Feature Space')\nplt.fill_between(np.arange(1,len(df)+1,1),np.zeros((len(df))),distances,color='red',alpha=0.4)\nplt.title('Nearest Neighbour Plot'); add_grid(); plt.xlim([0,len(df)]); plt.ylim([0,np.max(distances)])\nplt.subplots_adjust(left=0.0, bottom=0.0, right=1.6, top=0.8, wspace=0.2, hspace=0.2) \n```", "```py\ndbscan_tuned = DBSCAN(eps=0.029, min_samples=15).fit(df[nXname].values) # DBSCAN with tuned/improved parameters\ndf['DBSCAN_tuned'] = dbscan_tuned.labels_ + 1 \ncluster_list = np.unique(df['DBSCAN_tuned']); min_cluster = min(cluster_list); max_cluster = max(cluster_list) # cluster statistics\n\nplt.subplot(221)                                              # plot the assigned training data and K prototypes\nplt.scatter(df[Xname[0]], df[Xname[1]],c='black',alpha=0.5,edgecolor='k',cmap = cmap)\nplt.xlabel(Xlabelunit[0]); plt.ylabel(Xlabelunit[1]); plt.title(Xlabel[1] + ' vs. ' + Xlabel[0]); add_grid()\nplt.xlim([Xmin[0],Xmax[0]]); plt.ylim([Xmin[1],Xmax[1]])\n\nplt.subplot(223)                                              # plot the cluster groups\nfor icluster in cluster_list:\n    if icluster == 0:\n        plt.scatter(df[df['DBSCAN_tuned'] == icluster][Xname[0]],df[df['DBSCAN_tuned'] == icluster][Xname[1]],\n            color = lcmap((icluster-min_cluster)/(max_cluster-min_cluster)),edgecolor='black',alpha = 0.8,\n            vmin = min_cluster,vmax = max_cluster,label = 'Outliers')\n    else:\n        plt.scatter(df[df['DBSCAN_tuned'] == icluster][Xname[0]],df[df['DBSCAN_tuned'] == icluster][Xname[1]],\n            color = lcmap((icluster-min_cluster)/(max_cluster-min_cluster)),edgecolor='black',alpha = 0.8,\n            vmin = min_cluster,vmax = max_cluster,label = 'Facies: ' + str(icluster))\nplt.xlabel(Xlabelunit[0]); plt.ylabel(Xlabelunit[1]); plt.title(Xlabel[1] + ' vs. ' + Xlabel[0] + ' with Clusters'); add_grid()\nplt.xlim([Xmin[0],Xmax[0]]); plt.ylim([Xmin[1],Xmax[1]])\nplt.legend(loc='lower left',ncol = 3)\n\nplt.subplot(224)                                              # plot cluster histogram\nN, bins, patches  = plt.hist(df['DBSCAN_tuned'],alpha=0.8,edgecolor=\"black\",range=[min_cluster-0.5,max_cluster-0.5],\n    bins=np.insert(np.linspace(min_cluster,max_cluster,len(cluster_list))+0.5,0,min_cluster-0.5),density = False)\nfor i in range(0,len(cluster_list)):\n    patches[i].set_facecolor(lcmap((cluster_list[i]-min_cluster)/(max_cluster-min_cluster)));\nax = plt.gca(); ax.set_xticks(cluster_list); plt.xlabel('Tuned DBSCAN Clusters'); plt.ylabel('Frequency'); plt.title('Tuned DBSCAN Clustering Groups')\nadd_grid()   \ncurrent_labels = plt.gca().get_xticks().astype(str)\ncurrent_labels[0] = 'Outliers'\nplt.gca().set_xticklabels(current_labels); plt.gca().xaxis.set_minor_locator(NullLocator())\n\nplt.subplots_adjust(left=0.0, bottom=0.0, right=2.0, top=2.1, wspace=0.2, hspace=0.2) \n```"]