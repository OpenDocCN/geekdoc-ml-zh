<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.1//EN"
  "http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd">

<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<title>Threads</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1>Threads</h1>
<blockquote>原文：<a href="https://rust-exercises.com/100-exercises/07_threads/01_threads.html">https://rust-exercises.com/100-exercises/07_threads/01_threads.html</a></blockquote>
                        
<p>Before we start writing multithreaded code, let's take a step back and talk about what threads are
and why we might want to use them.</p>
<h2 id="what-is-a-thread"><a class="header" href="#what-is-a-thread">What is a thread?</a></h2>
<p>A <strong>thread</strong> is an execution context managed by the underlying operating system.<br/>
Each thread has its own stack and instruction pointer.</p>
<p>A single <strong>process</strong> can manage multiple threads.
These threads share the same memory space, which means they can access the same data.</p>
<p>Threads are a <strong>logical</strong> construct. In the end, you can only run one set of instructions
at a time on a CPU core, the <strong>physical</strong> execution unit.<br/>
Since there can be many more threads than there are CPU cores, the operating system's
<strong>scheduler</strong> is in charge of deciding which thread to run at any given time,
partitioning CPU time among them to maximize throughput and responsiveness.</p>
<h2 id="main"><a class="header" href="#main"><code>main</code></a></h2>
<p>When a Rust program starts, it runs on a single thread, the <strong>main thread</strong>.<br/>
This thread is created by the operating system and is responsible for running the <code>main</code>
function.</p>
<pre><code class="language-rust">use std::thread;
use std::time::Duration;

fn main() {
    loop {
        thread::sleep(Duration::from_secs(2));
        println!("Hello from the main thread!");
    }
}</code></pre>
<h2 id="stdthread"><a class="header" href="#stdthread"><code>std::thread</code></a></h2>
<p>Rust's standard library provides a module, <code>std::thread</code>, that allows you to create
and manage threads.</p>
<h3 id="spawn"><a class="header" href="#spawn"><code>spawn</code></a></h3>
<p>You can use <code>std::thread::spawn</code> to create new threads and execute code on them.</p>
<p>For example:</p>
<pre><code class="language-rust">use std::thread;
use std::time::Duration;

fn main() {
    let handle = thread::spawn(|| {
        loop {
            thread::sleep(Duration::from_secs(1));
            println!("Hello from a thread!");
        }
    });
    
    loop {
        thread::sleep(Duration::from_secs(2));
        println!("Hello from the main thread!");
    }
}</code></pre>
<p>If you execute this program on the <a href="https://play.rust-lang.org/?version=stable&amp;mode=debug&amp;edition=2021&amp;gist=afedf7062298ca8f5a248bc551062eaa">Rust playground</a>
you'll see that the main thread and the spawned thread run concurrently.<br/>
Each thread makes progress independently of the other.</p>
<h3 id="process-termination"><a class="header" href="#process-termination">Process termination</a></h3>
<p>When the main thread finishes, the overall process will exit.<br/>
A spawned thread will continue running until it finishes or the main thread finishes.</p>
<pre><code class="language-rust">use std::thread;
use std::time::Duration;

fn main() {
    let handle = thread::spawn(|| {
        loop {
            thread::sleep(Duration::from_secs(1));
            println!("Hello from a thread!");
        }
    });

    thread::sleep(Duration::from_secs(5));
}</code></pre>
<p>In the example above, you can expect to see the message "Hello from a thread!" printed roughly five times.<br/>
Then the main thread will finish (when the <code>sleep</code> call returns), and the spawned thread will be terminated
since the overall process exits.</p>
<h3 id="join"><a class="header" href="#join"><code>join</code></a></h3>
<p>You can also wait for a spawned thread to finish by calling the <code>join</code> method on the <code>JoinHandle</code> that <code>spawn</code> returns.</p>
<pre><code class="language-rust">use std::thread;
fn main() {
    let handle = thread::spawn(|| {
        println!("Hello from a thread!");
    });

    handle.join().unwrap();
}</code></pre>
<p>In this example, the main thread will wait for the spawned thread to finish before exiting.<br/>
This introduces a form of <strong>synchronization</strong> between the two threads: you're guaranteed to see the message
"Hello from a thread!" printed before the program exits, because the main thread won't exit
until the spawned thread has finished.</p>
<h2 id="exercise"><a class="header" href="#exercise">Exercise</a></h2>
<p>The exercise for this section is located in <a href="https://github.com/mainmatter/100-exercises-to-learn-rust/tree/main/exercises/07_threads/01_threads"><code>07_threads/01_threads</code></a></p>

                        
</body>
</html>