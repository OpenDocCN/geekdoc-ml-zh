- en: Encapsulation
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 原文：[https://rust-exercises.com/100-exercises/03_ticket_v1/05_encapsulation.html](https://rust-exercises.com/100-exercises/03_ticket_v1/05_encapsulation.html)
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Now that we have a basic understanding of modules and visibility, let's circle
    back to **encapsulation**.
  prefs: []
  type: TYPE_NORMAL
- en: Encapsulation is the practice of hiding the internal representation of an object.
    It is most commonly used to enforce some **invariants** on the object's state.
  prefs: []
  type: TYPE_NORMAL
- en: 'Going back to our `Ticket` struct:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: If all fields are made public, there is no encapsulation.
  prefs: []
  type: TYPE_NORMAL
- en: You must assume that the fields can be modified at any time, set to any value
    that's allowed by their type. You can't rule out that a ticket might have an empty
    title or a status that doesn't make sense.
  prefs: []
  type: TYPE_NORMAL
- en: To enforce stricter rules, we must keep the fields private^([1](#footnote-newtype)).
    We can then provide public methods to interact with a `Ticket` instance. Those
    public methods will have the responsibility of upholding our invariants (e.g.
    a title must not be empty).
  prefs: []
  type: TYPE_NORMAL
- en: 'If at least one field is private it is no longer possible to create a `Ticket`
    instance directly using the struct instantiation syntax:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: You've seen this in action in the previous exercise on visibility.
  prefs: []
  type: TYPE_NORMAL
- en: We now need to provide one or more public **constructors**—i.e. static methods
    or functions that can be used from outside the module to create a new instance
    of the struct.
  prefs: []
  type: TYPE_NORMAL
- en: 'Luckily enough we already have one: `Ticket::new`, as implemented in [a previous
    exercise](/100-exercises/03_ticket_v1/02_validation).'
  prefs: []
  type: TYPE_NORMAL
- en: '[Accessor methods](#accessor-methods)'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In summary:'
  prefs: []
  type: TYPE_NORMAL
- en: All `Ticket` fields are private
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We provide a public constructor, `Ticket::new`, that enforces our validation
    rules on creation
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'That''s a good start, but it''s not enough: apart from creating a `Ticket`,
    we also need to interact with it. But how can we access the fields if they''re
    private?'
  prefs: []
  type: TYPE_NORMAL
- en: We need to provide **accessor methods**.
  prefs: []
  type: TYPE_NORMAL
- en: Accessor methods are public methods that allow you to read the value of a private
    field (or fields) of a struct.
  prefs: []
  type: TYPE_NORMAL
- en: Rust doesn't have a built-in way to generate accessor methods for you, like
    some other languages do. You have to write them yourself—they're just regular
    methods.
  prefs: []
  type: TYPE_NORMAL
- en: '[Exercise](#exercise)'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The exercise for this section is located in [`03_ticket_v1/05_encapsulation`](https://github.com/mainmatter/100-exercises-to-learn-rust/tree/main/exercises/03_ticket_v1/05_encapsulation)
  prefs: []
  type: TYPE_NORMAL
- en: '* * *'
  prefs: []
  type: TYPE_NORMAL
- en: Or refine their type, a technique we'll explore [later on](/100-exercises/05_ticket_v2/15_outro).
    [↩](#fr-newtype-1)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
