<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.1//EN"
  "http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd">

<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<title>Case-by-case behavior</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1>Case-by-case behavior</h1>
<blockquote>原文：<a href="https://rust-exercises.com/100-exercises/02_basic_calculator/09_saturating.html">https://rust-exercises.com/100-exercises/02_basic_calculator/09_saturating.html</a></blockquote>
                        
<p><code>overflow-checks</code> is a blunt tool: it's a global setting that affects the whole program.<br/>
It often happens that you want to handle integer overflows differently depending on the context: sometimes
wrapping is the right choice, other times panicking is preferable.</p>
<h2 id="wrapping_-methods"><a class="header" href="#wrapping_-methods"><code>wrapping_</code> methods</a></h2>
<p>You can opt into wrapping arithmetic on a per-operation basis by using the <code>wrapping_</code> methods<sup class="footnote-reference" id="fr-method-1"><a href="#footnote-method">1</a></sup>.<br/>
For example, you can use <code>wrapping_add</code> to add two integers with wrapping:</p>
<pre><code class="language-rust">let x = 255u8;
let y = 1u8;
let sum = x.wrapping_add(y);
assert_eq!(sum, 0);</code></pre>
<h2 id="saturating_-methods"><a class="header" href="#saturating_-methods"><code>saturating_</code> methods</a></h2>
<p>Alternatively, you can opt into <strong>saturating arithmetic</strong> by using the <code>saturating_</code> methods.<br/>
Instead of wrapping around, saturating arithmetic will return the maximum or minimum value for the integer type.
For example:</p>
<pre><code class="language-rust">let x = 255u8;
let y = 1u8;
let sum = x.saturating_add(y);
assert_eq!(sum, 255);</code></pre>
<p>Since <code>255 + 1</code> is <code>256</code>, which is bigger than <code>u8::MAX</code>, the result is <code>u8::MAX</code> (255).<br/>
The opposite happens for underflows: <code>0 - 1</code> is <code>-1</code>, which is smaller than <code>u8::MIN</code>, so the result is <code>u8::MIN</code> (0).</p>
<p>You can't get saturating arithmetic via the <code>overflow-checks</code> profile setting—you have to explicitly opt into it
when performing the arithmetic operation.</p>
<h2 id="exercise"><a class="header" href="#exercise">Exercise</a></h2>
<p>The exercise for this section is located in <a href="https://github.com/mainmatter/100-exercises-to-learn-rust/tree/main/exercises/02_basic_calculator/09_saturating"><code>02_basic_calculator/09_saturating</code></a></p>
<hr/>
<ol class="footnote-definition"><li id="footnote-method">
<p>You can think of methods as functions that are "attached" to a specific type.
We'll cover methods (and how to define them) in the next chapter. <a href="#fr-method-1">↩</a></p>
</li>
</ol>
                        
</body>
</html>