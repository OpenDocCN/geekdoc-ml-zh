<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.1//EN"
  "http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd">

<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<title>Fallibility</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1>Fallibility</h1>
<blockquote>原文：<a href="https://rust-exercises.com/100-exercises/05_ticket_v2/06_fallibility.html">https://rust-exercises.com/100-exercises/05_ticket_v2/06_fallibility.html</a></blockquote>
                        
<p>Let's revisit the <code>Ticket::new</code> function from the previous exercise:</p>
<pre><code class="language-rust">impl Ticket {
    pub fn new(
        title: String, 
        description: String, 
        status: Status
    ) -&gt; Ticket {
        if title.is_empty() {
            panic!("Title cannot be empty");
        }
        if title.len() &gt; 50 {
            panic!("Title cannot be longer than 50 bytes");
        }
        if description.is_empty() {
            panic!("Description cannot be empty");
        }
        if description.len() &gt; 500 {
            panic!("Description cannot be longer than 500 bytes");
        }

        Ticket {
            title,
            description,
            status,
        }
    }
}</code></pre>
<p>As soon as one of the checks fails, the function panics.
This is not ideal, as it doesn't give the caller a chance to <strong>handle the error</strong>.</p>
<p>It's time to introduce the <code>Result</code> type, Rust's primary mechanism for error handling.</p>
<h2 id="the-result-type"><a class="header" href="#the-result-type">The <code>Result</code> type</a></h2>
<p>The <code>Result</code> type is an enum defined in the standard library:</p>
<pre><code class="language-rust">enum Result&lt;T, E&gt; {
    Ok(T),
    Err(E),
}</code></pre>
<p>It has two variants:</p>
<ul>
<li><code>Ok(T)</code>: represents a successful operation. It holds <code>T</code>, the output of the operation.</li>
<li><code>Err(E)</code>: represents a failed operation. It holds <code>E</code>, the error that occurred.</li>
</ul>
<p>Both <code>Ok</code> and <code>Err</code> are generic, allowing you to specify your own types for the success and error cases.</p>
<h2 id="no-exceptions"><a class="header" href="#no-exceptions">No exceptions</a></h2>
<p>Recoverable errors in Rust are <strong>represented as values</strong>.<br/>
They're just an instance of a type, being passed around and manipulated like any other value.
This is a significant difference from other languages, such as Python or C#, where <strong>exceptions</strong> are used to signal errors.</p>
<p>Exceptions create a separate control flow path that can be hard to reason about.<br/>
You don't know, just by looking at a function's signature, if it can throw an exception or not.
You don't know, just by looking at a function's signature, <strong>which</strong> exception types it can throw.<br/>
You must either read the function's documentation or look at its implementation to find out.</p>
<p>Exception handling logic has very poor locality: the code that throws the exception is far removed from the code
that catches it, and there's no direct link between the two.</p>
<h2 id="fallibility-is-encoded-in-the-type-system"><a class="header" href="#fallibility-is-encoded-in-the-type-system">Fallibility is encoded in the type system</a></h2>
<p>Rust, with <code>Result</code>, forces you to <strong>encode fallibility in the function's signature</strong>.<br/>
If a function can fail (and you want the caller to have a shot at handling the error), it must return a <code>Result</code>.</p>
<pre><code class="language-rust">// Just by looking at the signature, you know that this function 
// can fail. You can also inspect `ParseIntError` to see what 
// kind of failures to expect.
fn parse_int(s: &amp;str) -&gt; Result&lt;i32, ParseIntError&gt; {
    // ...
}</code></pre>
<p>That's the big advantage of <code>Result</code>: it makes fallibility explicit.</p>
<p>Keep in mind, though, that panics exist. They aren't tracked by the type system, just like exceptions in other languages.
But they're meant for <strong>unrecoverable errors</strong> and should be used sparingly.</p>
<h2 id="exercise"><a class="header" href="#exercise">Exercise</a></h2>
<p>The exercise for this section is located in <a href="https://github.com/mainmatter/100-exercises-to-learn-rust/tree/main/exercises/05_ticket_v2/06_fallibility"><code>05_ticket_v2/06_fallibility</code></a></p>

                        
</body>
</html>