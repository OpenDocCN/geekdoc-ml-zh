<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.1//EN"
  "http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd">

<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<title>Cancellation</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1>Cancellation</h1>
<blockquote>原文：<a href="https://rust-exercises.com/100-exercises/08_futures/07_cancellation.html">https://rust-exercises.com/100-exercises/08_futures/07_cancellation.html</a></blockquote>
                        
<p>What happens when a pending future is dropped?<br/>
The runtime will no longer poll it, therefore it won't make any further progress.
In other words, its execution has been <strong>cancelled</strong>.</p>
<p>In the wild, this often happens when working with timeouts.
For example:</p>
<pre><code class="language-rust">use tokio::time::timeout;
use tokio::sync::oneshot;
use std::time::Duration;

async fn http_call() {
    // [...]
}

async fn run() {
    // Wrap the future with a `Timeout` set to expire in 10 milliseconds.
    let duration = Duration::from_millis(10);
    if let Err(_) = timeout(duration, http_call()).await {
        println!("Didn't receive a value within 10 ms");
    }
}</code></pre>
<p>When the timeout expires, the future returned by <code>http_call</code> will be cancelled.
Let's imagine that this is <code>http_call</code>'s body:</p>
<pre><code class="language-rust">use std::net::TcpStream;

async fn http_call() {
    let (stream, _) = TcpStream::connect(/* */).await.unwrap();
    let request: Vec&lt;u8&gt; = /* */;
    stream.write_all(&amp;request).await.unwrap();
}</code></pre>
<p>Each yield point becomes a <strong>cancellation point</strong>.<br/>
<code>http_call</code> can't be preempted by the runtime, so it can only be discarded after
it has yielded control back to the executor via <code>.await</code>.
This applies recursively—e.g. <code>stream.write_all(&amp;request)</code> is likely to have multiple
yield points in its implementation. It is perfectly possible to see <code>http_call</code> pushing
a <em>partial</em> request before being cancelled, thus dropping the connection and never
finishing transmitting the body.</p>
<h2 id="clean-up"><a class="header" href="#clean-up">Clean up</a></h2>
<p>Rust's cancellation mechanism is quite powerful—it allows the caller to cancel an ongoing task
without needing any form of cooperation from the task itself.<br/>
At the same time, this can be quite dangerous. It may be desirable to perform a
<strong>graceful cancellation</strong>, to ensure that some clean-up tasks are performed
before aborting the operation.</p>
<p>For example, consider this fictional API for a SQL transaction:</p>
<pre><code class="language-rust">async fn transfer_money(
    connection: SqlConnection,
    payer_id: u64,
    payee_id: u64,
    amount: u64
) -&gt; Result&lt;(), anyhow::Error&gt; {
    let transaction = connection.begin_transaction().await?;
    update_balance(payer_id, amount, &amp;transaction).await?;
    decrease_balance(payee_id, amount, &amp;transaction).await?;
    transaction.commit().await?;
}</code></pre>
<p>On cancellation, it'd be ideal to explicitly abort the pending transaction rather
than leaving it hanging.
Rust, unfortunately, doesn't provide a bullet-proof mechanism for this kind of
<strong>asynchronous</strong> clean up operations.</p>
<p>The most common strategy is to rely on the <code>Drop</code> trait to schedule the required
clean-up work. This can be by:</p>
<ul>
<li>Spawning a new task on the runtime</li>
<li>Enqueueing a message on a channel</li>
<li>Spawning a background thread</li>
</ul>
<p>The optimal choice is contextual.</p>
<h2 id="cancelling-spawned-tasks"><a class="header" href="#cancelling-spawned-tasks">Cancelling spawned tasks</a></h2>
<p>When you spawn a task using <code>tokio::spawn</code>, you can no longer drop it;
it belongs to the runtime.<br/>
Nonetheless, you can use its <code>JoinHandle</code> to cancel it if needed:</p>
<pre><code class="language-rust">async fn run() {
    let handle = tokio::spawn(/* some async task */);
    // Cancel the spawned task
    handle.abort();
}</code></pre>
<h2 id="further-reading"><a class="header" href="#further-reading">Further reading</a></h2>
<ul>
<li>Be extremely careful when using <code>tokio</code>'s <code>select!</code> macro to "race" two different futures.
Retrying the same task in a loop is dangerous unless you can ensure <strong>cancellation safety</strong>.
Check out <a href="https://tokio.rs/tokio/tutorial/select"><code>select!</code>'s documentation</a> for more details.<br/>
If you need to interleave two asynchronous streams of data (e.g. a socket and a channel), prefer using
<a href="https://docs.rs/tokio-stream/latest/tokio_stream/trait.StreamExt.html#method.merge"><code>StreamExt::merge</code></a> instead.</li>
<li>A <a href="https://docs.rs/tokio-util/latest/tokio_util/sync/struct.CancellationToken.html"><code>CancellationToken</code></a> may be
preferable to <code>JoinHandle::abort</code> in some cases.</li>
</ul>
<h2 id="exercise"><a class="header" href="#exercise">Exercise</a></h2>
<p>The exercise for this section is located in <a href="https://github.com/mainmatter/100-exercises-to-learn-rust/tree/main/exercises/08_futures/07_cancellation"><code>08_futures/07_cancellation</code></a></p>

                        
</body>
</html>