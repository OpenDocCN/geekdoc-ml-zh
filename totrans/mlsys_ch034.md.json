["```py\nimport sensor\nimport time\nimport ml\nfrom ml.utils import NMS\nimport math\nimport image\n\nsensor.reset()  # Reset and initialize the sensor.\n# Set pixel format (RGB565 or GRAYSCALE)\nsensor.set_pixformat(sensor.RGB565)\n# Set frame size to QVGA (320x240)\nsensor.set_framesize(sensor.QVGA)\nsensor.skip_frames(time=2000)  # Let the camera adjust.\n```", "```py\nmin_confidence = 0.8\n```", "```py\nthreshold_list = [(math.ceil(min_confidence * 255), 255)]\n\n# Load built-in model\nmodel = ml.Model(\"trained\")\nprint(model)\n\n# Alternatively, models can be loaded from the\n# filesystem storage.\n# model = ml.Model(\n#     '<object_detection_modelwork>.tflite',\n#     load_to_fb=True)\n# labels = [line.rstrip('\\n') for line in open(\"labels.txt\")]\n\ncolors = [ # Add more colors if you are detecting more\n           # than 7 types of classes at once.\n    (255, 255,   0), # background: yellow (not used)\n    (  0, 255,   0), # cube: green\n    (255,   0,   0), # wheel: red\n    (  0,   0, 255), # not used\n    (255,   0, 255), # not used\n    (  0, 255, 255), # not used\n    (255, 255, 255), # not used\n]\n```", "```py\n# FOMO outputs an image per class where each pixel in the\n# image is the centroid of the trained object. So, we will\n# get those output images and then run find_blobs() on them\n# to extract the centroids. We will also run get_stats() on\n# the detected blobs to determine their score.\n# The Non-Max-Suppression (NMS) object then filters out\n# overlapping detections and maps their position in the\n# output image back to the original input image. The\n# function then returns a list per class which each contain\n# a list of (rect, score) tuples representing the detected\n# objects.\n\n\ndef fomo_post_process(model, inputs, outputs):\n    n, oh, ow, oc = model.output_shape[0]\n    nms = NMS(ow, oh, inputs[0].roi)\n    for i in range(oc):\n        img = image.Image(outputs[0][0, :, :, i] * 255)\n        blobs = img.find_blobs(\n            threshold_list,\n            x_stride=1,\n            area_threshold=1,\n            pixels_threshold=1,\n        )\n        for b in blobs:\n            rect = b.rect()\n            x, y, w, h = rect\n            score = (\n                img.get_statistics(\n                    thresholds=threshold_list, roi=rect\n                ).l_mean()\n                / 255.0\n            )\n            nms.add_bounding_box(x, y, x + w, y + h, score, i)\n    return nms.get_bounding_boxes()\n\n\nclock = time.clock()\nwhile True:\n    clock.tick()\n\n    img = sensor.snapshot()\n\n    for i, detection_list in enumerate(\n        model.predict([img], callback=fomo_post_process)\n    ):\n        if i == 0:\n            continue  # background class\n        if len(detection_list) == 0:\n            continue  # no detections for this class?\n\n        print(\"********** %s **********\" % model.labels[i])\n        for (x, y, w, h), score in detection_list:\n            center_x = math.floor(x + (w / 2))\n            center_y = math.floor(y + (h / 2))\n            print(f\"x {center_x}\\ty {center_y}\\tscore {score}\")\n            img.draw_circle((center_x, center_y, 12), color=colors[i])\n\n    print(clock.fps(), \"fps\", end=\"\\n\")\n```"]