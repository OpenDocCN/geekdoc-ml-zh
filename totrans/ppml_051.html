<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.1//EN"
  "http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd">

<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<title>Error trait</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1>Error trait</h1>
<blockquote>原文：<a href="https://rust-exercises.com/100-exercises/05_ticket_v2/09_error_trait.html">https://rust-exercises.com/100-exercises/05_ticket_v2/09_error_trait.html</a></blockquote>
                        
<h2 id="error-reporting"><a class="header" href="#error-reporting">Error reporting</a></h2>
<p>In the previous exercise you had to destructure the <code>TitleError</code> variant to extract the error message and
pass it to the <code>panic!</code> macro.<br/>
This is a (rudimentary) example of <strong>error reporting</strong>: transforming an error type into a representation that can be
shown to a user, a service operator, or a developer.</p>
<p>It's not practical for each Rust developer to come up with their own error reporting strategy: it'd be a waste of time
and it wouldn't compose well across projects.
That's why Rust provides the <code>std::error::Error</code> trait.</p>
<h2 id="the-error-trait"><a class="header" href="#the-error-trait">The <code>Error</code> trait</a></h2>
<p>There are no constraints on the type of the <code>Err</code> variant in a <code>Result</code>, but it's a good practice to use a type
that implements the <code>Error</code> trait.
<code>Error</code> is the cornerstone of Rust's error handling story:</p>
<pre><code class="language-rust">// Slightly simplified definition of the `Error` trait
pub trait Error: Debug + Display {}</code></pre>
<p>You might recall the <code>:</code> syntax from <a href="/100-exercises/04_traits/09_from#supertrait--subtrait">the <code>From</code> trait</a>—it's used to specify <strong>supertraits</strong>.
For <code>Error</code>, there are two supertraits: <code>Debug</code> and <code>Display</code>. If a type wants to implement <code>Error</code>, it must also
implement <code>Debug</code> and <code>Display</code>.</p>
<h2 id="display-and-debug"><a class="header" href="#display-and-debug"><code>Display</code> and <code>Debug</code></a></h2>
<p>We've already encountered the <code>Debug</code> trait in <a href="/100-exercises/04_traits/04_derive">a previous exercise</a>—it's the trait used by
<code>assert_eq!</code> to display the values of the variables it's comparing when the assertion fails.</p>
<p>From a "mechanical" perspective, <code>Display</code> and <code>Debug</code> are identical—they encode how a type should be converted
into a string-like representation:</p>
<pre><code class="language-rust">// `Debug`
pub trait Debug {
    fn fmt(&amp;self, f: &amp;mut Formatter&lt;'_&gt;) -&gt; Result&lt;(), Error&gt;;
}

// `Display`
pub trait Display {
    fn fmt(&amp;self, f: &amp;mut Formatter&lt;'_&gt;) -&gt; Result&lt;(), Error&gt;;
}</code></pre>
<p>The difference is in their <em>purpose</em>: <code>Display</code> returns a representation that's meant for "end-users",
while <code>Debug</code> provides a low-level representation that's more suitable to developers and service operators.<br/>
That's why <code>Debug</code> can be automatically implemented using the <code>#[derive(Debug)]</code> attribute, while <code>Display</code>
<strong>requires</strong> a manual implementation.</p>
<h2 id="exercise"><a class="header" href="#exercise">Exercise</a></h2>
<p>The exercise for this section is located in <a href="https://github.com/mainmatter/100-exercises-to-learn-rust/tree/main/exercises/05_ticket_v2/09_error_trait"><code>05_ticket_v2/09_error_trait</code></a></p>

                        
</body>
</html>