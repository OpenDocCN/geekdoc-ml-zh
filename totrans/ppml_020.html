<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.1//EN"
  "http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd">

<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<title>Ownership</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1>Ownership</h1>
<blockquote>原文：<a href="https://rust-exercises.com/100-exercises/03_ticket_v1/06_ownership.html">https://rust-exercises.com/100-exercises/03_ticket_v1/06_ownership.html</a></blockquote>
                        
<p>If you solved the previous exercise using what this course has taught you so far,
your accessor methods probably look like this:</p>
<pre><code class="language-rust">impl Ticket {
    pub fn title(self) -&gt; String {
        self.title
    }

    pub fn description(self) -&gt; String {
        self.description
    }

    pub fn status(self) -&gt; String {
        self.status
    }
}</code></pre>
<p>Those methods compile and are enough to get tests to pass, but in a real-world scenario they won't get you very far.
Consider this snippet:</p>
<pre><code class="language-rust">if ticket.status() == "To-Do" {
    // We haven't covered the `println!` macro yet,
    // but for now it's enough to know that it prints 
    // a (templated) message to the console
    println!("Your next task is: {}", ticket.title());
}</code></pre>
<p>If you try to compile it, you'll get an error:</p>
<pre><code class="language-text">error[E0382]: use of moved value: `ticket`
  --&gt; src/main.rs:30:43
   |
25 |     let ticket = Ticket::new(/* */);
   |         ------ move occurs because `ticket` has type `Ticket`, 
   |                which does not implement the `Copy` trait
26 |     if ticket.status() == "To-Do" {
   |               -------- `ticket` moved due to this method call
...
30 |         println!("Your next task is: {}", ticket.title());
   |                                           ^^^^^^ 
   |                                value used here after move
   |
note: `Ticket::status` takes ownership of the receiver `self`, 
      which moves `ticket`
  --&gt; src/main.rs:12:23
   |
12 |         pub fn status(self) -&gt; String {
   |                       ^^^^
</code></pre>
<p>Congrats, this is your first borrow-checker error!</p>
<h2 id="the-perks-of-rusts-ownership-system"><a class="header" href="#the-perks-of-rusts-ownership-system">The perks of Rust's ownership system</a></h2>
<p>Rust's ownership system is designed to ensure that:</p>
<ul>
<li>Data is never mutated while it's being read</li>
<li>Data is never read while it's being mutated</li>
<li>Data is never accessed after it has been destroyed</li>
</ul>
<p>These constraints are enforced by the <strong>borrow checker</strong>, a subsystem of the Rust compiler,
often the subject of jokes and memes in the Rust community.</p>
<p>Ownership is a key concept in Rust, and it's what makes the language unique.
Ownership enables Rust to provide <strong>memory safety without compromising performance</strong>.
All these things are true at the same time for Rust:</p>
<ol>
<li>There is no runtime garbage collector</li>
<li>As a developer, you rarely have to manage memory directly</li>
<li>You can't cause dangling pointers, double frees, and other memory-related bugs</li>
</ol>
<p>Languages like Python, JavaScript, and Java give you 2. and 3., but not 1.<br/>
Language like C or C++ give you 1., but neither 2. nor 3.</p>
<p>Depending on your background, 3. might sound a bit arcane: what is a "dangling pointer"?
What is a "double free"? Why are they dangerous?<br/>
Don't worry: we'll cover these concepts in more details during the rest of the course.</p>
<p>For now, though, let's focus on learning how to work within Rust's ownership system.</p>
<h2 id="the-owner"><a class="header" href="#the-owner">The owner</a></h2>
<p>In Rust, each value has an <strong>owner</strong>, statically determined at compile-time.
There is only one owner for each value at any given time.</p>
<h2 id="move-semantics"><a class="header" href="#move-semantics">Move semantics</a></h2>
<p>Ownership can be transferred.</p>
<p>If you own a value, for example, you can transfer ownership to another variable:</p>
<pre><code class="language-rust">let a = "hello, world".to_string(); // &lt;- `a` is the owner of the String
let b = a;  // &lt;- `b` is now the owner of the String</code></pre>
<p>Rust's ownership system is baked into the type system: each function has to declare in its signature
<em>how</em> it wants to interact with its arguments.</p>
<p>So far, all our methods and functions have <strong>consumed</strong> their arguments: they've taken ownership of them.
For example:</p>
<pre><code class="language-rust">impl Ticket {
    pub fn description(self) -&gt; String {
        self.description
    }
}</code></pre>
<p><code>Ticket::description</code> takes ownership of the <code>Ticket</code> instance it's called on.<br/>
This is known as <strong>move semantics</strong>: ownership of the value (<code>self</code>) is <strong>moved</strong> from the caller to
the callee, and the caller can't use it anymore.</p>
<p>That's exactly the language used by the compiler in the error message we saw earlier:</p>
<pre><code class="language-text">error[E0382]: use of moved value: `ticket`
  --&gt; src/main.rs:30:43
   |
25 |     let ticket = Ticket::new(/* */);
   |         ------ move occurs because `ticket` has type `Ticket`, 
   |                which does not implement the `Copy` trait
26 |     if ticket.status() == "To-Do" {
   |               -------- `ticket` moved due to this method call
...
30 |         println!("Your next task is: {}", ticket.title());
   |                                           ^^^^^^ 
   |                                 value used here after move
   |
note: `Ticket::status` takes ownership of the receiver `self`, 
      which moves `ticket`
  --&gt; src/main.rs:12:23
   |
12 |         pub fn status(self) -&gt; String {
   |                       ^^^^
</code></pre>
<p>In particular, this is the sequence of events that unfold when we call <code>ticket.status()</code>:</p>
<ul>
<li><code>Ticket::status</code> takes ownership of the <code>Ticket</code> instance</li>
<li><code>Ticket::status</code> extracts <code>status</code> from <code>self</code> and transfers ownership of <code>status</code> back to the caller</li>
<li>The rest of the <code>Ticket</code> instance is discarded (<code>title</code> and <code>description</code>)</li>
</ul>
<p>When we try to use <code>ticket</code> again via <code>ticket.title()</code>, the compiler complains: the <code>ticket</code> value is gone now,
we no longer own it, therefore we can't use it anymore.</p>
<p>To build <em>useful</em> accessor methods we need to start working with <strong>references</strong>.</p>
<h2 id="borrowing"><a class="header" href="#borrowing">Borrowing</a></h2>
<p>It is desirable to have methods that can read the value of a variable without taking ownership of it.<br/>
Programming would be quite limited otherwise. In Rust, that's done via <strong>borrowing</strong>.</p>
<p>Whenever you borrow a value, you get a <strong>reference</strong> to it.<br/>
References are tagged with their privileges<sup class="footnote-reference" id="fr-refine-1"><a href="#footnote-refine">1</a></sup>:</p>
<ul>
<li>Immutable references (<code>&amp;</code>) allow you to read the value, but not to mutate it</li>
<li>Mutable references (<code>&amp;mut</code>) allow you to read and mutate the value</li>
</ul>
<p>Going back to the goals of Rust's ownership system:</p>
<ul>
<li>Data is never mutated while it's being read</li>
<li>Data is never read while it's being mutated</li>
</ul>
<p>To ensure these two properties, Rust has to introduce some restrictions on references:</p>
<ul>
<li>You can't have a mutable reference and an immutable reference to the same value at the same time</li>
<li>You can't have more than one mutable reference to the same value at the same time</li>
<li>The owner can't mutate the value while it's being borrowed</li>
<li>You can have as many immutable references as you want, as long as there are no mutable references</li>
</ul>
<p>In a way, you can think of an immutable reference as a "read-only" lock on the value,
while a mutable reference is like a "read-write" lock.</p>
<p>All these restrictions are enforced at compile-time by the borrow checker.</p>
<h3 id="syntax"><a class="header" href="#syntax">Syntax</a></h3>
<p>How do you borrow a value, in practice?<br/>
By adding <code>&amp;</code> or <code>&amp;mut</code> <strong>in front a variable</strong>, you're borrowing its value.
Careful though! The same symbols (<code>&amp;</code> and <code>&amp;mut</code>) in <strong>front of a type</strong> have a different meaning:
they denote a different type, a reference to the original type.</p>
<p>For example:</p>
<pre><code class="language-rust">struct Configuration {
    version: u32,
    active: bool,
}

fn main() {
    let config = Configuration {
        version: 1,
        active: true,
    };
    // `b` is a reference to the `version` field of `config`.
    // The type of `b` is `&amp;u32`, since it contains a reference to 
    // a `u32` value.
    // We create a reference by borrowing `config.version`, using 
    // the `&amp;` operator.
    // Same symbol (`&amp;`), different meaning depending on the context!
    let b: &amp;u32 = &amp;config.version;
    //     ^ The type annotation is not necessary, 
    //       it's just there to clarify what's going on
}</code></pre>
<p>The same concept applies to function arguments and return types:</p>
<pre><code class="language-rust">// `f` takes a mutable reference to a `u32` as an argument, 
// bound to the name `number`
fn f(number: &amp;mut u32) -&gt; &amp;u32 {
    // [...]
}</code></pre>
<h2 id="breathe-in-breathe-out"><a class="header" href="#breathe-in-breathe-out">Breathe in, breathe out</a></h2>
<p>Rust's ownership system can be a bit overwhelming at first.<br/>
But don't worry: it'll become second nature with practice.<br/>
And you're going to get a lot of practice over the rest of this chapter, as well as the rest of the course!
We'll revisit each concept multiple times to make sure you get familiar with them
and truly understand how they work.</p>
<p>Towards the end of this chapter we'll explain <em>why</em> Rust's ownership system is designed the way it is.
For the time being, focus on understanding the <em>how</em>. Take each compiler error as a learning opportunity!</p>
<h2 id="exercise"><a class="header" href="#exercise">Exercise</a></h2>
<p>The exercise for this section is located in <a href="https://github.com/mainmatter/100-exercises-to-learn-rust/tree/main/exercises/03_ticket_v1/06_ownership"><code>03_ticket_v1/06_ownership</code></a></p>
<hr/>
<ol class="footnote-definition"><li id="footnote-refine">
<p>This is a great mental model to start out, but it doesn't capture the <em>full</em> picture.
We'll refine our understanding of references <a href="/100-exercises/07_threads/06_interior_mutability">later in the course</a>. <a href="#fr-refine-1">↩</a></p>
</li>
</ol>
                        
</body>
</html>