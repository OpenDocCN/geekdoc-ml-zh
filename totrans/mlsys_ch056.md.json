["```py\nimport numpy as np\nimport matplotlib.pyplot as plt\nimport seaborn as sns\nimport math\nfrom scipy.stats import skew, kurtosis\nfrom scipy import signal\nfrom scipy.signal import welch\nfrom scipy.stats import entropy\nfrom sklearn import preprocessing\nimport pywt\n\nplt.rcParams['figure.figsize'] = (12, 6)\nplt.rcParams['lines.linewidth'] = 3\n```", "```py\nf =  62.5 # Hertz\nwind_sec = 2 # seconds\nFFT_Length = 16\naxis = ['accX', 'accY', 'accZ']\nn_sensors = len(axis)\n```", "```py\ndata = [\n    -5.6330,  0.2376,  9.8701,\n    -5.9442,  0.4830,  9.8701,\n    -5.4217, ...\n]\nNo_raw_features = len(data)\nN = int(No_raw_features/n_sensors)\n```", "```py\nfeatures = [\n    2.7322, -0.0978, -0.3813,\n    2.3980, 3.8924, 24.6841,\n    9.6303, ...\n]\nN_feat = len(features)\nN_feat_axis = int(N_feat/n_sensors)\n```", "```py\ndef plot_data(sensors, axis, title):\n    [plt.plot(x, label=y) for x,y in zip(sensors, axis)]\n    plt.legend(loc='lower right')\n    plt.title(title)\n    plt.xlabel('#Sample')\n    plt.ylabel('Value')\n    plt.box(False)\n    plt.grid()\n    plt.show()\n\naccX = data[0::3]\naccY = data[1::3]\naccZ = data[2::3]\nsensors = [accX, accY, accZ]\nplot_data(sensors, axis, 'Raw Features')\n```", "```py\ndtmean = [\n    (sum(x) / len(x))\n    for x in sensors\n]\n\n[\n    print('mean_' + x + ' =', round(y, 4))\n    for x, y in zip(axis, dtmean)\n][0]\n\naccX = [(x - dtmean[0]) for x in accX]\naccY = [(x - dtmean[1]) for x in accY]\naccZ = [(x - dtmean[2]) for x in accZ]\nsensors = [accX, accY, accZ]\n\nplot_data(sensors, axis, 'Raw Features - Subtract the Mean')\n```", "```py\n# Using numpy and standardized data (subtracting mean)\nrms = [np.sqrt(np.mean(np.square(x))) for x in sensors]\n```", "```py\n[print('rms_'+x+'= ', round(y, 4)) for x,y in zip(axis, rms)][0]\nprint(\"\\nCompare with Edge Impulse result features\")\nprint(features[0:N_feat:N_feat_axis])\n```", "```py\nfig, axes = plt.subplots(nrows=1, ncols=3, figsize=(13, 4))\nsns.kdeplot(accX, fill=True, ax=axes[0])\nsns.kdeplot(accY, fill=True, ax=axes[1])\nsns.kdeplot(accZ, fill=True, ax=axes[2])\naxes[0].set_title('accX')\naxes[1].set_title('accY')\naxes[2].set_title('accZ')\nplt.suptitle('IMU Sensors distribution', fontsize=16, y=1.02)\nplt.show()\n```", "```py\nskew = [skew(x, bias=False) for x in sensors]\n[print('skew_'+x+'= ', round(y, 4))\n  for x,y in zip(axis, skew)][0]\nprint(\"\\nCompare with Edge Impulse result features\")\nfeatures[1:N_feat:N_feat_axis]\n```", "```py\nkurt = [kurtosis(x, bias=False) for x in sensors]\n[print('kurt_'+x+'= ', round(y, 4))\n  for x,y in zip(axis, kurt)][0]\nprint(\"\\nCompare with Edge Impulse result features\")\nfeatures[2:N_feat:N_feat_axis]\n```", "```py\n# Function used by Edge Impulse instead of scipy.signal.welch().\ndef welch_max_hold(fx, sampling_freq, nfft, n_overlap):\n    n_overlap = int(n_overlap)\n    spec_powers = [0 for _ in range(nfft//2+1)]\n    ix = 0\n    while ix <= len(fx):\n        # Slicing truncates if end_idx > len,\n        # and rfft will auto-zero pad\n        fft_out = np.abs(np.fft.rfft(fx[ix:ix+nfft], nfft))\n        spec_powers = np.maximum(spec_powers, fft_out**2/nfft)\n        ix = ix + (nfft-n_overlap)\n    return np.fft.rfftfreq(nfft, 1/sampling_freq), spec_powers\n```", "```py\nfax,Pax = welch_max_hold(accX, fs, FFT_Length, 0)\nfay,Pay = welch_max_hold(accY, fs, FFT_Length, 0)\nfaz,Paz = welch_max_hold(accZ, fs, FFT_Length, 0)\nspecs = [Pax, Pay, Paz ]\n```", "```py\nplt.plot(fax,Pax, label='accX')\nplt.plot(fay,Pay, label='accY')\nplt.plot(faz,Paz, label='accZ')\nplt.legend(loc='upper right')\nplt.xlabel('Frequency (Hz)')\n#plt.ylabel('PSD [V**2/Hz]')\nplt.ylabel('Power')\nplt.title('Power spectrum P(f) using Welch's method')\nplt.grid()\nplt.box(False)\nplt.show()\n```", "```py\nspec_skew = [skew(x, bias=False) for x in specs]\nspec_kurtosis = [kurtosis(x, bias=False) for x in specs]\n```", "```py\nprint(\"EI Processed Spectral features (accX): \")\nprint(features[3:N_feat_axis][0:])\nprint(\"\\nCalculated features:\")\nprint (round(spec_skew[0],4))\nprint (round(spec_kurtosis[0],4))\n[print(round(x, 4)) for x in Pax[1:]][0]\n```", "```py\nprint(\"EI Processed Spectral features (accY): \")\nprint(features[16:26][0:]) # 13: 3+N_feat_axis;\n                           # 26 = 2x N_feat_axis\nprint(\"\\nCalculated features:\")\nprint (round(spec_skew[1],4))\nprint (round(spec_kurtosis[1],4))\n[print(round(x, 4)) for x in Pay[1:]][0]\n```", "```py\nprint(\"EI Processed Spectral features (accZ): \")\nprint(features[29:][0:]) #29: 3+(2*N_feat_axis);\nprint(\"\\nCalculated features:\")\nprint (round(spec_skew[2],4))\nprint (round(spec_kurtosis[2],4))\n[print(round(x, 4)) for x in Paz[1:]][0]\n```", "```py\nwavelet_name='bior1.3'\nnum_layer = 1\n\nwavelet = pywt.Wavelet(wavelet_name)\n[phi_d,psi_d,phi_r,psi_r,x] = wavelet.wavefun(level=5)\nplt.plot(x, psi_d, color='red')\nplt.title('Wavelet Function')\nplt.ylabel('Value')\nplt.xlabel('Time')\nplt.grid()\nplt.box(False)\nplt.show()\n```", "```py\nfeatures = [\n    3.6251, 0.0615, 0.0615,\n    -7.3517, -2.7641, 2.8462,\n    5.0924, ...\n]\nN_feat = len(features)\nN_feat_axis = int(N_feat/n_sensors)\n```", "```py\n(accX_l1, accX_d1) = pywt.dwt(accX, wavelet_name)\n(accY_l1, accY_d1) = pywt.dwt(accY, wavelet_name)\n(accZ_l1, accZ_d1) = pywt.dwt(accZ, wavelet_name)\nsensors_l1 = [accX_l1, accY_l1, accZ_l1]\n\n# Plot power spectrum versus frequency\nplt.plot(accX_l1, label='accX')\nplt.plot(accY_l1, label='accY')\nplt.plot(accZ_l1, label='accZ')\nplt.legend(loc='lower right')\nplt.xlabel('Time')\nplt.ylabel('Value')\nplt.title('Wavelet Approximation')\nplt.grid()\nplt.box(False)\nplt.show()\n```", "```py\ndef calculate_statistics(signal):\n    n5 = np.percentile(signal, 5)\n    n25 = np.percentile(signal, 25)\n    n75 = np.percentile(signal, 75)\n    n95 = np.percentile(signal, 95)\n    median = np.percentile(signal, 50)\n    mean = np.mean(signal)\n    std = np.std(signal)\n    var = np.var(signal)\n    rms = np.sqrt(np.mean(np.square(signal)))\n    return [n5, n25, n75, n95, median, mean, std, var, rms]\n\nstat_feat_l0 = [calculate_statistics(x) for x in sensors]\nstat_feat_l1 = [calculate_statistics(x) for x in sensors_l1]\n```", "```py\nskew_l0 = [skew(x, bias=False) for x in sensors]\nskew_l1 = [skew(x, bias=False) for x in sensors_l1]\nkurtosis_l0 = [kurtosis(x, bias=False) for x in sensors]\nkurtosis_l1 = [kurtosis(x, bias=False) for x in sensors_l1]\n```", "```py\ndef getZeroCrossingRate(arr):\n    my_array = np.array(arr)\n    zcross = float(\n        \"{:.2f}\".format(\n          (((my_array[:-1] * my_array[1:]) < 0).sum()) / len(arr)\n        )\n    )\n    return zcross\n\ndef getMeanCrossingRate(arr):\n    mcross = getZeroCrossingRate(np.array(arr) - np.mean(arr))\n    return mcross\n\ndef calculate_crossings(list):\n    zcross=[]\n    mcross=[]\n    for i in range(len(list)):\n        zcross_i = getZeroCrossingRate(list[i])\n        zcross.append(zcross_i)\n        mcross_i = getMeanCrossingRate(list[i])\n        mcross.append(mcross_i)\n    return zcross, mcross\n\ncross_l0 = calculate_crossings(sensors)\ncross_l1 = calculate_crossings(sensors_l1)\n```", "```py\ndef calculate_entropy(signal, base=None):\n    value, counts = np.unique(signal, return_counts=True)\n    return entropy(counts, base=base)\n\nentropy_l0 = [calculate_entropy(x) for x in sensors]\nentropy_l1 = [calculate_entropy(x) for x in sensors_l1]\n```", "```py\nL1_features_names = [\n    \"L1-n5\", \"L1-n25\", \"L1-n75\", \"L1-n95\", \"L1-median\",\n    \"L1-mean\", \"L1-std\", \"L1-var\", \"L1-rms\", \"L1-skew\",\n    \"L1-Kurtosis\", \"L1-zcross\", \"L1-mcross\", \"L1-entropy\"\n]\n\nL0_features_names = [\n    \"L0-n5\", \"L0-n25\", \"L0-n75\", \"L0-n95\", \"L0-median\",\n    \"L0-mean\", \"L0-std\", \"L0-var\", \"L0-rms\", \"L0-skew\",\n    \"L0-Kurtosis\", \"L0-zcross\", \"L0-mcross\", \"L0-entropy\"\n]\n\nall_feat_l0 = []\nfor i in range(len(axis)):\n    feat_l0 = (\n        stat_feat_l0[i]\n        + [skew_l0[i]]\n        + [kurtosis_l0[i]]\n        + [cross_l0[0][i]]\n        + [cross_l0[1][i]]\n        + [entropy_l0[i]]\n    )\n    [print(axis[i] + ' +x+= ', round(y, 4))\n       for x, y in zip(LO_features_names, feat_l0)][0]\n    all_feat_l0.append(feat_l0)\n\nall_feat_l0 = [\n    item\n    for sublist in all_feat_l0\n    for item in sublist\n]\nprint(f\"\\nAll L0 Features = {len(all_feat_l0)}\")\n\nall_feat_l1 = []\nfor i in range(len(axis)):\n    feat_l1 = (\n        stat_feat_l1[i]\n        + [skew_l1[i]]\n        + [kurtosis_l1[i]]\n        + [cross_l1[0][i]]\n        + [cross_l1[1][i]]\n        + [entropy_l1[i]]\n    )\n    [print(axis[i]+' '+x+'= ', round(y, 4))\n       for x,y in zip(L1_features_names, feat_l1)][0]\n    all_feat_l1.append(feat_l1)\n\nall_feat_l1 = [\n    item\n    for sublist in all_feat_l1\n    for item in sublist\n]\nprint(f\"\\nAll L1 Features = {len(all_feat_l1)}\")\n```"]