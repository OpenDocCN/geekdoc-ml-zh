- en: Arrays
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 原文：[https://rust-exercises.com/100-exercises/06_ticket_management/01_arrays.html](https://rust-exercises.com/100-exercises/06_ticket_management/01_arrays.html)
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'As soon as we start talking about "ticket management" we need to think about
    a way to store *multiple* tickets. In turn, this means we need to think about
    collections. In particular, homogeneous collections: we want to store multiple
    instances of the same type.'
  prefs: []
  type: TYPE_NORMAL
- en: What does Rust have to offer in this regard?
  prefs: []
  type: TYPE_NORMAL
- en: '[Arrays](#arrays-1)'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A first attempt could be to use an **array**.
  prefs: []
  type: TYPE_NORMAL
- en: Arrays in Rust are fixed-size collections of elements of the same type.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here''s how you can define an array:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: This creates an array of 3 integers, initialized with the values `1`, `2`, and
    `3`.
  prefs: []
  type: TYPE_NORMAL
- en: The type of the array is `[u32; 3]`, which reads as "an array of `u32`s with
    a length of 3".
  prefs: []
  type: TYPE_NORMAL
- en: 'If all array elements are the same, you can use a shorter syntax to initialize
    it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: '`[1; 3]` creates an array of three elements, all equal to `1`.'
  prefs: []
  type: TYPE_NORMAL
- en: '[Accessing elements](#accessing-elements)'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'You can access elements of an array using square brackets:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: The index must be of type `usize`.
  prefs: []
  type: TYPE_NORMAL
- en: Arrays are **zero-indexed**, like everything in Rust. You've seen this before
    with string slices and field indexing in tuples/tuple-like variants.
  prefs: []
  type: TYPE_NORMAL
- en: '[Out-of-bounds access](#out-of-bounds-access)'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'If you try to access an element that''s out of bounds, Rust will panic:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: This is enforced at runtime using **bounds checking**. It comes with a small
    performance overhead, but it's how Rust prevents buffer overflows.
  prefs: []
  type: TYPE_NORMAL
- en: In some scenarios the Rust compiler can optimize away bounds checks, especially
    if iterators are involved—we'll speak more about this later on.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you don''t want to panic, you can use the `get` method, which returns an
    `Option<&T>`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: '[Performance](#performance)'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Since the size of an array is known at compile-time, the compiler can allocate
    the array on the stack. If you run the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'You''ll get the following memory layout:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: In other words, the size of an array is `std::mem::size_of::<T>() * N`, where
    `T` is the type of the elements and `N` is the number of elements.
  prefs: []
  type: TYPE_NORMAL
- en: You can access and replace each element in `O(1)` time.
  prefs: []
  type: TYPE_NORMAL
- en: '[Exercise](#exercise)'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The exercise for this section is located in [`06_ticket_management/01_arrays`](https://github.com/mainmatter/100-exercises-to-learn-rust/tree/main/exercises/06_ticket_management/01_arrays)
  prefs: []
  type: TYPE_NORMAL
