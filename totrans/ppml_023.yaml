- en: Heap
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 原文：[https://rust-exercises.com/100-exercises/03_ticket_v1/09_heap.html](https://rust-exercises.com/100-exercises/03_ticket_v1/09_heap.html)
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: The stack is great, but it can't solve all our problems. What about data whose
    size is not known at compile time? Collections, strings, and other dynamically-sized
    data cannot be (entirely) stack-allocated. That's where the **heap** comes in.
  prefs: []
  type: TYPE_NORMAL
- en: '[Heap allocations](#heap-allocations)'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You can visualize the heap as a big chunk of memory—a huge array, if you will.
  prefs: []
  type: TYPE_NORMAL
- en: Whenever you need to store data on the heap, you ask a special program, the
    **allocator**, to reserve for you a subset of the heap. We call this interaction
    (and the memory you reserved) a **heap allocation**. If the allocation succeeds,
    the allocator will give you a **pointer** to the start of the reserved block.
  prefs: []
  type: TYPE_NORMAL
- en: '[No automatic de-allocation](#no-automatic-de-allocation)'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The heap is structured quite differently from the stack.
  prefs: []
  type: TYPE_NORMAL
- en: Heap allocations are not contiguous, they can be located anywhere inside the
    heap.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'It''s the allocator''s job to keep track of which parts of the heap are in
    use and which are free. The allocator won''t automatically free the memory you
    allocated, though: you need to be deliberate about it, calling the allocator again
    to **free** the memory you no longer need.'
  prefs: []
  type: TYPE_NORMAL
- en: '[Performance](#performance)'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The heap''s flexibility comes at a cost: heap allocations are **slower** than
    stack allocations. There''s a lot more bookkeeping involved!'
  prefs: []
  type: TYPE_NORMAL
- en: If you read articles about performance optimization you'll often be advised
    to minimize heap allocations and prefer stack-allocated data whenever possible.
  prefs: []
  type: TYPE_NORMAL
- en: '[`String`''s memory layout](#strings-memory-layout)'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'When you create a local variable of type `String`, Rust is forced to allocate
    on the heap^([1](#footnote-empty)): it doesn''t know in advance how much text
    you''re going to put in it, so it can''t reserve the right amount of space on
    the stack.'
  prefs: []
  type: TYPE_NORMAL
- en: 'But a `String` is not *entirely* heap-allocated, it also keeps some data on
    the stack. In particular:'
  prefs: []
  type: TYPE_NORMAL
- en: The **pointer** to the heap region you reserved.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The **length** of the string, i.e. how many bytes are in the string.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The **capacity** of the string, i.e. how many bytes have been reserved on the
    heap.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Let''s look at an example to understand this better:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'If you run this code, memory will be laid out like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: We asked for a `String` that can hold up to 5 bytes of text.
  prefs: []
  type: TYPE_NORMAL
- en: '`String::with_capacity` goes to the allocator and asks for 5 bytes of heap
    memory. The allocator returns a pointer to the start of that memory block.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The `String` is empty, though. On the stack, we keep track of this information
    by distinguishing between the length and the capacity: this `String` can hold
    up to 5 bytes, but it currently holds 0 bytes of actual text.'
  prefs: []
  type: TYPE_NORMAL
- en: 'If you push some text into the `String`, the situation will change:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: '`s` now holds 3 bytes of text. Its length is updated to 3, but capacity remains
    5. Three of the five bytes on the heap are used to store the characters `H`, `e`,
    and `y`.'
  prefs: []
  type: TYPE_NORMAL
- en: '[`usize`](#usize)'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: How much space do we need to store pointer, length and capacity on the stack?
  prefs: []
  type: TYPE_NORMAL
- en: It depends on the **architecture** of the machine you're running on.
  prefs: []
  type: TYPE_NORMAL
- en: Every memory location on your machine has an [**address**](https://en.wikipedia.org/wiki/Memory_address),
    commonly represented as an unsigned integer. Depending on the maximum size of
    the address space (i.e. how much memory your machine can address), this integer
    can have a different size. Most modern machines use either a 32-bit or a 64-bit
    address space.
  prefs: []
  type: TYPE_NORMAL
- en: 'Rust abstracts away these architecture-specific details by providing the `usize`
    type: an unsigned integer that''s as big as the number of bytes needed to address
    memory on your machine. On a 32-bit machine, `usize` is equivalent to `u32`. On
    a 64-bit machine, it matches `u64`.'
  prefs: []
  type: TYPE_NORMAL
- en: Capacity, length and pointers are all represented as `usize`s in Rust^([2](#footnote-equivalence)).
  prefs: []
  type: TYPE_NORMAL
- en: '[No `std::mem::size_of` for the heap](#no-stdmemsize_of-for-the-heap)'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '`std::mem::size_of` returns the amount of space a type would take on the stack,
    which is also known as the **size of the type**.'
  prefs: []
  type: TYPE_NORMAL
- en: What about the memory buffer that `String` is managing on the heap? Isn't that
    part of the size of `String`?
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: No!
  prefs: []
  type: TYPE_NORMAL
- en: That heap allocation is a **resource** that `String` is managing. It's not considered
    to be part of the `String` type by the compiler.
  prefs: []
  type: TYPE_NORMAL
- en: '`std::mem::size_of` doesn''t know (or care) about additional heap-allocated
    data that a type might manage or refer to via pointers, as is the case with `String`,
    therefore it doesn''t track its size.'
  prefs: []
  type: TYPE_NORMAL
- en: Unfortunately there is no equivalent of `std::mem::size_of` to measure the amount
    of heap memory that a certain value is allocating at runtime. Some types might
    provide methods to inspect their heap usage (e.g. `String`'s `capacity` method),
    but there is no general-purpose "API" to retrieve runtime heap usage in Rust.
  prefs: []
  type: TYPE_NORMAL
- en: You can, however, use a memory profiler tool (e.g. [DHAT](https://valgrind.org/docs/manual/dh-manual.html)
    or [a custom allocator](https://docs.rs/dhat/latest/dhat/)) to inspect the heap
    usage of your program.
  prefs: []
  type: TYPE_NORMAL
- en: '[Exercise](#exercise)'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The exercise for this section is located in [`03_ticket_v1/09_heap`](https://github.com/mainmatter/100-exercises-to-learn-rust/tree/main/exercises/03_ticket_v1/09_heap)
  prefs: []
  type: TYPE_NORMAL
- en: '* * *'
  prefs: []
  type: TYPE_NORMAL
- en: '`std` doesn''t allocate if you create an **empty** `String` (i.e. `String::new()`).
    Heap memory will be reserved when you push data into it for the first time. [↩](#fr-empty-1)'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The size of a pointer depends on the operating system too. In certain environments,
    a pointer is **larger** than a memory address (e.g. [CHERI](https://web.archive.org/web/20240517051950/https://blog.acolyer.org/2019/05/28/cheri-abi/)).
    Rust makes the simplifying assumption that pointers are the same size as memory
    addresses, which is true for most modern systems you're likely to encounter. [↩](#fr-equivalence-1)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
