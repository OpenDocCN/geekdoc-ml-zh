- en: Generics and associated types
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 原文：[https://rust-exercises.com/100-exercises/04_traits/10_assoc_vs_generic.html](https://rust-exercises.com/100-exercises/04_traits/10_assoc_vs_generic.html)
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'Let''s re-examine the definition for two of the traits we studied so far, `From`
    and `Deref`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: They both feature type parameters.
  prefs: []
  type: TYPE_NORMAL
- en: In the case of `From`, it's a generic parameter, `T`.
  prefs: []
  type: TYPE_NORMAL
- en: In the case of `Deref`, it's an associated type, `Target`.
  prefs: []
  type: TYPE_NORMAL
- en: What's the difference? Why use one over the other?
  prefs: []
  type: TYPE_NORMAL
- en: '[At most one implementation](#at-most-one-implementation)'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Due to how deref coercion works, there can only be one "target" type for a
    given type. E.g. `String` can only deref to `str`. It''s about avoiding ambiguity:
    if you could implement `Deref` multiple times for a type, which `Target` type
    should the compiler choose when you call a `&self` method?'
  prefs: []
  type: TYPE_NORMAL
- en: That's why `Deref` uses an associated type, `Target`.
  prefs: []
  type: TYPE_NORMAL
- en: An associated type is uniquely determined **by the trait implementation**. Since
    you can't implement `Deref` more than once, you'll only be able to specify one
    `Target` for a given type and there won't be any ambiguity.
  prefs: []
  type: TYPE_NORMAL
- en: '[Generic traits](#generic-traits)'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'On the other hand, you can implement `From` multiple times for a type, **as
    long as the input type `T` is different**. For example, you can implement `From`
    for `WrappingU32` using both `u32` and `u16` as input types:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: This works because `From<u16>` and `From<u32>` are considered **different traits**.
  prefs: []
  type: TYPE_NORMAL
- en: 'There is no ambiguity: the compiler can determine which implementation to use
    based on type of the value being converted.'
  prefs: []
  type: TYPE_NORMAL
- en: '[Case study: `Add`](#case-study-add)'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'As a closing example, consider the `Add` trait from the standard library:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'It uses both mechanisms:'
  prefs: []
  type: TYPE_NORMAL
- en: it has a generic parameter, `RHS` (right-hand side), which defaults to `Self`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: it has an associated type, `Output`, the type of the result of the addition
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[`RHS`](#rhs)'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '`RHS` is a generic parameter to allow for different types to be added together.'
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, you''ll find these two implementations in the standard library:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'This allows the following code to compile:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: because `u32` implements `Add<&u32>` *as well as* `Add<u32>`.
  prefs: []
  type: TYPE_NORMAL
- en: '[`Output`](#output)'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '`Output` represents the type of the result of the addition.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Why do we need `Output` in the first place? Can''t we just use `Self` as output,
    the type implementing `Add`? We could, but it would limit the flexibility of the
    trait. In the standard library, for example, you''ll find this implementation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: The type they're implementing the trait for is `&u32`, but the result of the
    addition is `u32`.
  prefs: []
  type: TYPE_NORMAL
- en: It would be impossible^([1](#footnote-flexible)) to provide this implementation
    if `add` had to return `Self`, i.e. `&u32` in this case. `Output` lets `std` decouple
    the implementor from the return type, thus supporting this case.
  prefs: []
  type: TYPE_NORMAL
- en: 'On the other hand, `Output` can''t be a generic parameter. The output type
    of the operation **must** be uniquely determined once the types of the operands
    are known. That''s why it''s an associated type: for a given combination of implementor
    and generic parameters, there is only one `Output` type.'
  prefs: []
  type: TYPE_NORMAL
- en: '[Conclusion](#conclusion)'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To recap:'
  prefs: []
  type: TYPE_NORMAL
- en: Use an **associated type** when the type must be uniquely determined for a given
    trait implementation.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Use a **generic parameter** when you want to allow multiple implementations
    of the trait for the same type, with different input types.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Exercise](#exercise)'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The exercise for this section is located in [`04_traits/10_assoc_vs_generic`](https://github.com/mainmatter/100-exercises-to-learn-rust/tree/main/exercises/04_traits/10_assoc_vs_generic)
  prefs: []
  type: TYPE_NORMAL
- en: '* * *'
  prefs: []
  type: TYPE_NORMAL
- en: 'Flexibility is rarely free: the trait definition is more complex due to `Output`,
    and implementors have to reason about what they want to return. The trade-off
    is only justified if that flexibility is actually needed. Keep that in mind when
    designing your own traits. [↩](#fr-flexible-1)'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
