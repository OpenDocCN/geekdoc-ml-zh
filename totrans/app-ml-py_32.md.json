["```py\nimport numpy as np\nimport pandas as pd\nimport matplotlib.pyplot as plt\nfrom matplotlib.ticker import (MultipleLocator, AutoMinorLocator, AutoLocator) # control of axes ticks\nplt.rc('axes', axisbelow=True)                            # set axes and grids in the background for all plots\nimport math\nseed = 13 \n```", "```py\ndef add_grid():\n    plt.gca().grid(True, which='major',linewidth = 1.0); plt.gca().grid(True, which='minor',linewidth = 0.2) # add y grids\n    plt.gca().tick_params(which='major',length=7); plt.gca().tick_params(which='minor', length=4)\n    plt.gca().xaxis.set_minor_locator(AutoMinorLocator()); plt.gca().yaxis.set_minor_locator(AutoMinorLocator()) # turn on minor ticks \n\ndef calculate_angle_rads(x1, y1, x2, y2):\n    dx = x2 - x1     # Calculate the differences\n    dy = y2 - y1\n    angle_rads = math.atan2(dy, dx)    # Calculate the angle in radians\n    #angle_degrees = math.degrees(angle_radians)    # Convert the angle to degrees\n    return angle_rads\n\ndef offset(pto, distance, angle_deg): # modified from ChatGPT 4.o generated\n    angle_rads = math.radians(angle_deg) # Convert angle from degrees to radians\n    x_new = pto[0] + distance * math.cos(angle_rads) # Calculate the new coordinates\n    y_new = pto[1] + distance * math.sin(angle_rads)\n    return np.array((x_new, y_new))\n\ndef offsetx(xo, distance, angle_deg): # modified from ChatGPT 4.o generated\n    angle_rads = math.radians(angle_deg) # Convert angle from degrees to radians\n    x_new = xo + distance * math.cos(angle_rads) # Calculate the new coordinates\n    return np.array((xo, x_new))\n\ndef offset_arrx(xo, distance, angle_deg,size): # modified from ChatGPT 4.o generated\n    angle_rads = math.radians(angle_deg) # Convert angle from degrees to radians\n    x_new = xo + distance * math.cos(angle_rads) # Calculate the new coordinates\n    x_arr = x_new + size * math.cos(angle_rads+2.48) # Calculate the new coordinates\n    return np.array((x_new, x_arr))\n\ndef offsety(yo, distance, angle_deg): # modified from ChatGPT 4.o generated\n    angle_rads = math.radians(angle_deg) # Convert angle from degrees to radians\n    y_new = yo + distance * math.sin(angle_rads) # Calculate the new coordinates\n    return np.array((yo, y_new))\n\ndef offset_arry(yo, distance, angle_deg,size): # modified from ChatGPT 4.o generated\n    angle_rads = math.radians(angle_deg) # Convert angle from degrees to radians\n    y_new = yo + distance * math.sin(angle_rads) # Calculate the new coordinates\n    y_arr = y_new + size * math.sin(angle_rads+2.48) # Calculate the new coordinates\n    return np.array((y_new, y_arr))\n\ndef lint(x1, y1, x2, y2, t):\n    # Calculate the interpolated coordinates\n    x = x1 + t * (x2 - x1)\n    y = y1 + t * (y2 - y1)\n    return np.array((x, y))\n\ndef lintx(x1, y1, x2, y2, t):\n    # Calculate the interpolated coordinates\n    x = x1 + t * (x2 - x1)\n    return x\n\ndef linty(x1, y1, x2, y2, t):\n    # Calculate the interpolated coordinates\n    y = y1 + t * (y2 - y1)\n    return y\n\ndef lint_intx(x1, y1, x2, y2, ts, te):\n    # Calculate the interpolated coordinates\n    xs = x1 + ts * (x2 - x1)\n    xe = x1 + te * (x2 - x1)\n    return np.array((xs,xe))\n\ndef lint_inty(x1, y1, x2, y2, ts, te):\n    # Calculate the interpolated coordinates\n    ys = y1 + ts * (y2 - y1)\n    ye = y1 + te * (y2 - y1)\n    return np.array((ys,ye))\n\ndef lint_int_arrx(x1, y1, x2, y2, ts, te, size):\n    # Calculate the interpolated coordinates\n    xe = x1 + te * (x2 - x1)\n    line_angle_rads = calculate_angle_rads(x1, y1, x2, y2)\n    x_arr = xe + size * math.cos(line_angle_rads+2.48) # Calculate the new coordinates\n    return np.array((xe,x_arr))\n\ndef lint_int_arry(x1, y1, x2, y2, ts, te, size):\n    # Calculate the interpolated coordinates\n    ye = y1 + te * (y2 - y1)\n    line_angle_rads = calculate_angle_rads(x1, y1, x2, y2)\n    y_arr = ye + size * math.sin(line_angle_rads+2.48) # Calculate the new coordinates\n    return np.array((ye,y_arr))\n\ndef as_si(x, ndp): # from xnx on StackOverflow https://stackoverflow.com/questions/31453422/displaying-numbers-with-x-instead-of-e-scientific-notation-in-matplotlib \n    s = '{x:0.{ndp:d}e}'.format(x=x, ndp=ndp)\n    m, e = s.split('e')\n    return r'{m:s}\\times 10^{{{e:d}}}'.format(m=m, e=int(e)) \n```", "```py\n# initial CNN trains on one sample\nx1 = 0.1; x2 = 0.2; x3 = 0.3; x4 = 0.4; x5 = 0.5; y = 0.1 # training data\nlr = 0.2 # learning rate\n\nnp.random.seed(seed=seed)\n\nnepoch = 1000\n\nw6 = np.zeros(nepoch); w7 = np.zeros(nepoch); w8 = np.zeros(nepoch)\nw9 = np.zeros(nepoch); w10 = np.zeros(nepoch); w11 = np.zeros(nepoch)\nbconv = np.zeros(nepoch); b12 = np.zeros(nepoch)\n\nk6i1 = np.zeros(nepoch); k6i2 = np.zeros(nepoch); k6i3 = np.zeros(nepoch)\nk7i2 = np.zeros(nepoch); k7i3 = np.zeros(nepoch); k7i4 = np.zeros(nepoch)\nk8i3 = np.zeros(nepoch); k8i4 = np.zeros(nepoch); k8i5 = np.zeros(nepoch)\n\ndk6i1 = np.zeros(nepoch); dk6i2 = np.zeros(nepoch); dk6i3 = np.zeros(nepoch)\ndk7i2 = np.zeros(nepoch); dk7i3 = np.zeros(nepoch); dk7i4 = np.zeros(nepoch)\ndk8i3 = np.zeros(nepoch); dk8i4 = np.zeros(nepoch); dk8i5 = np.zeros(nepoch)\n\nc9 = np.zeros(nepoch); c10 = np.zeros(nepoch); c11 = np.zeros(nepoch)\nd9 = np.zeros(nepoch); d10 = np.zeros(nepoch); d11 = np.zeros(nepoch)\n\no12 = np.zeros(nepoch)\n\ndw6 = np.zeros(nepoch); dw7 = np.zeros(nepoch); dw8 = np.zeros(nepoch)\ndw9 = np.zeros(nepoch); dw10 = np.zeros(nepoch); dw11 = np.zeros(nepoch)\ndbconv = np.zeros(nepoch); db12 = np.zeros(nepoch)\n\nd6 = np.zeros(nepoch); d7 = np.zeros(nepoch); d8 = np.zeros(nepoch); \nd19 = np.zeros(nepoch); d10 = np.zeros(nepoch); d11 = np.zeros(nepoch); d12 = np.zeros(nepoch); \n\n# initialize the weights - Xavier Weight Initialization \nlower, upper = -(1.0 / np.sqrt(3.0)), (1.0 / np.sqrt(3.0)) # lower and upper bound for the weights, uses inputs to node\n#lower, upper = -(sqrt(6.0) / sqrt(3.0 + 2.0)), (sqrt(6.0) / sqrt(3.0 + 2.0)) # Normalized Xavier weights, integrates ouputs also\nw6[0] = lower + np.random.random() * (upper - lower); \nw7[0] = lower + np.random.random() * (upper - lower); \nw8[0] = lower + np.random.random() * (upper - lower);\n\nlower, upper = -(1.0 / np.sqrt(2.0)), (1.0 / np.sqrt(2.0))\n#lower, upper = -(sqrt(6.0) / sqrt(2.0 + 1.0)), (sqrt(6.0) / sqrt(2.0 + 1.0)) # Normalized Xavier weights, integrates ouputs also\n\nw9[0] = lower + np.random.random() * (upper - lower); \nw10[0] = lower + np.random.random() * (upper - lower);     \nw11[0] = lower + np.random.random() * (upper - lower);     \n\n#b4[0] = np.random.random(); b5[0] = np.random.random(); b6[0] = np.random.random()\nbconv[0] = (np.random.random()-0.5)*0.5\nb12[0] = (np.random.random()-0.5)*0.5; # small random value \n\nfor i in range(0,nepoch):\n\n# forward pass of model\n    c9[i] = w6[i]*x1 + w7[i]*x2 + w8[i]*x3 + bconv[i]; \n    c9[i] = 1.0/(1 + math.exp(-1*c9[i]))\n\n    c10[i] = w6[i]*x2 + w7[i]*x3 + w8[i]*x4 + bconv[i]; \n    c10[i] = 1.0/(1 + math.exp(-1*c10[i]))\n\n    c11[i] = w6[i]*x3 + w7[i]*x4 + w8[i]*x5 + bconv[i]; \n    c11[i] = 1.0/(1 + math.exp(-1*c11[i]))\n\n    o12[i] = w9[i]*c9[i] + w10[i]*c10[i] + w11[i]*c11[i] + b12[i]\n\n# back propagate the error through the nodes\n    d12[i] = (o12[i]-y) # identity activation o at o12 - switched substraction on May 27, 2025\n    d9[i] =  c9[i]*(1-c9[i])*w9[i]*d12[i]   # propagate to the front feature map layer\n    d10[i] = c10[i]*(1-c10[i])*w10[i]*d12[i]\n    d11[i] = c11[i]*(1-c11[i])*w11[i]*d12[i]\n\n    dk6i1 = x1*d9[i]; dk7i2 = x2*d9[i]; dk8i3 = x3*d9[i] \n    dk6i2 = x2*d10[i]; dk7i3 = x3*d10[i]; dk8i4 = x4*d10[i] \n    dk6i3 = x3*d11[i]; dk7i4 = x4*d11[i]; dk8i5 = x5*d11[i] \n\n    d6[i] = dk6i1 + dk6i2 + dk6i3\n    d7[i] = dk7i2 + dk7i3 + dk7i4\n    d8[i] = dk8i3 + dk8i4 + dk8i5\n\n# calculate the change in weights\n    if i < nepoch - 1:\n        dw6[i] = lr*d6[i]; dw7[i] = lr*d7[i]; dw8[i] = lr*d8[i]\n        dw9[i] = lr*c9[i]*d12[i]; dw10[i] = lr*c10[i]*d12[i]; dw11[i] = lr*c11[i]*d12[i];\n        dbconv[i] = lr*(d9[i] + d10[i] + d11[i]); db12[i] = lr*d12[i]\n\n        w6[i+1] = w6[i] - dw6[i]; w7[i+1] = w7[i] - dw7[i]; w8[i+1] = w8[i] - dw8[i]\n        w9[i+1] = w9[i] - dw9[i]; w10[i+1] = w10[i] - dw10[i]; w11[i+1] = w11[i] - dw11[i]\n        bconv[i+1] = bconv[i] - dbconv[i]; b12[i+1] = b12[i] - db12[i] \n```", "```py\nxin = 0.1; yin_range = 0.7\nnin = 5\n\nkcolors = ['red','blue','green']\nxin = np.array([0.1,0.2,0.3,0.4,0.5])\nyout = np.array([y])\ncin = np.array([0.1,0.2,0.3])\nkx = 0.6\n\nplt.subplot(111)\n#plt.gca().set_axis_off()\n\nfor i, (xi) in enumerate(zip(xin), start=1):\n    eq1 = r\"$X_{{{}}}$\".format(i)\n    eq2 = r\"$X_{{{}}} = {}$\".format(i, xi[0])\n    eq3 = r\"$I_{{{}}}$\".format(i)\n    xpos = 0.4; ypos = yin_range - ((i-1)/nin) * yin_range \n    circle_i1 = plt.Circle((xpos,ypos), 0.015, fill=False, edgecolor = 'black',lw=1,zorder=100); \n    circle_i1b = plt.Circle((xpos,ypos), 0.025, fill=True, facecolor = 'white',edgecolor = None,lw=0.5,zorder=10);\n    plt.gca().add_patch(circle_i1); plt.gca().add_patch(circle_i1b)\n    plt.annotate(eq1, (xpos-0.2, ypos), textcoords=\"offset points\", xytext=(-12, -3), ha='center',size=15)\n    plt.annotate(eq2, (xpos, ypos), textcoords=\"offset points\", xytext=(-70, 9), ha='center')\n    plt.plot([xpos-0.2,xpos],[ypos,ypos],color='black',lw=2); plt.plot([xpos-0.2,xpos-0.07],[ypos+0.01,ypos+0.01],color='black',lw=2)\n    plt.plot([xpos-0.07,xpos-0.08],[ypos+0.01,ypos+0.02],color='black',lw=2)\n    plt.annotate(eq3, (xpos,ypos), textcoords=\"offset points\", xytext=(-15, 15), ha='center',size = 15)\n\nfor iconv in range(0,3):  \n    xpos = kx+iconv*0.2;\n    ytop = yin_range - (iconv/nin)*yin_range - ((1-1)/nin) * yin_range\n    ybot = yin_range - (iconv/nin)*yin_range - ((3-1)/nin) * yin_range  \n    plt.plot([xpos+0.12,xpos+0.12],[ytop+0.005,ybot+0.005],color='red',lw=1,ls='--',zorder=80)\n    for ik, (ki) in enumerate(zip(np.arange(1,4,1)), start=1):\n        eq4 = r\"$K_{{{}}}$\".format(ik+5)\n        ypos = yin_range - (iconv/nin)*yin_range - ((ik-1)/nin) * yin_range\n        circle_i1 = plt.Circle((xpos,ypos), 0.015, fill=True, facecolor = kcolors[ik-1],edgecolor = 'black',lw=1,zorder=200);\n        circle_i1b = plt.Circle((xpos,ypos), 0.025, fill=True, facecolor='white',edgecolor = None,lw=0.5,zorder=190);\n        plt.gca().add_patch(circle_i1); plt.gca().add_patch(circle_i1b)\n        plt.annotate(eq4, (xpos,ypos), textcoords=\"offset points\", xytext=(-15, 15), ha='center',size = 15)\n        plt.plot([0.4,xpos],[ypos,ypos],color='black',lw=1,zorder=1)\n        plt.plot([xpos,xpos+0.12],[ypos+0.005,ypos+0.005],color='red',lw=1,ls='--',zorder=80)\n        eq8 = r\"$I_{{{}}} \\cdot K_{{{}}}$\".format((iconv)+ik,ik+5)        \n        plt.annotate(eq8, (xpos+0.12, ypos), textcoords=\"offset points\", xytext=(-25, 5), ha='center',size = 10)\n\nfor ic, (ci) in enumerate(zip(np.arange(1,4,1)), start=1):\n    eq5 = r\"$C_{{{}}}$\".format(ic+8)\n    xpos = 1.2; ypos = yin_range - ((ic-1)/4) * yin_range - 0.07\n    circle_i1 = plt.Circle((xpos,ypos), 0.015, fill=True, facecolor = 'gold',edgecolor = 'black',lw=1,zorder=200);\n    circle_i1b = plt.Circle((xpos,ypos), 0.025, fill=True, facecolor='white',edgecolor = None,lw=0.5,zorder=190);\n    plt.gca().add_patch(circle_i1); plt.gca().add_patch(circle_i1b)\n    plt.annotate(eq5, (xpos,ypos), textcoords=\"offset points\", xytext=(-15, 15), ha='center',size = 15)\n    #plt.plot([0.4,x],[y,y],color='black',lw=1,zorder=1)\n    plt.plot([xpos,1.5],[ypos,yin_range - ((2-1)/4) * yin_range - 0.07],color='black',lw=1)\n    plt.plot([kx+(ic-1)*0.2+0.12,xpos],[ypos,ypos],color='red',lw=1,ls='--',zorder=80)\n\neq6 = r\"$O_{{{}}}$\".format(12)\neq7 = r\"$Y_{{{}}} = {}$\".format(i, np.round(yout[0],2))\nxpos = 1.5; ypos = yin_range - ((2-1)/4) * yin_range - 0.07\ncircle_i1 = plt.Circle((xpos,ypos), 0.015, fill=True, facecolor = 'gold',edgecolor = 'black',lw=1,zorder=200);\ncircle_i1b = plt.Circle((xpos,ypos), 0.025, fill=True, facecolor='white',edgecolor = None,lw=0.5,zorder=190);\nplt.gca().add_patch(circle_i1); plt.gca().add_patch(circle_i1b)\nplt.annotate(eq6, (xpos, ypos), textcoords=\"offset points\", xytext=(-15, 15), ha='center',size = 15)\nplt.annotate(eq7, (xpos, ypos), textcoords=\"offset points\", xytext=(130,-4), ha='center',size = 15)\nplt.plot([xpos,xpos+0.2],[ypos,ypos],color='black',lw=2); plt.plot([xpos,xpos+0.13],[ypos+0.01,ypos+0.01],color='black',lw=2)\nplt.plot([xpos+0.13,xpos+0.12],[ypos+0.01,ypos+0.02],color='black',lw=2)\nplt.annotate(eq6, (xpos, ypos), textcoords=\"offset points\", xytext=(20, 10), ha='center')\n\nplt.xlim([0.,2.]); plt.ylim([0,1])\n\nplt.subplots_adjust(left=0.0, bottom=0.0, right=2.0, top=1.3, wspace=0.2, hspace=0.2); plt.show() \n```", "```py\nplt.subplot(221)\nplt.plot(np.arange(1,nepoch+1,1),o12,color='red',label=r'$\\hat{y}$'); plt.xlim([1,nepoch]); plt.ylim([0,1])\nplt.xlabel('Epochs'); plt.ylabel(r'$\\hat{y}$'); plt.title('CNN - Prediction')\nplt.plot([1,nepoch],[y,y],color='black',ls='--'); plt.vlines(400,-1.5,1.5,color='black')\nadd_grid(); plt.legend(loc='upper right'); plt.xscale('log')\n\nplt.subplot(222)\nplt.plot(np.arange(1,nepoch+1,1),w6,color='lightcoral',label = r'$k_6$') \nplt.plot(np.arange(1,nepoch+1,1),w7,color='red',label = r'$k_7$') \nplt.plot(np.arange(1,nepoch+1,1),w8,color='darkred',label = r'$k_8$') \nplt.plot(np.arange(1,nepoch+1,1),bconv,color='dodgerblue',label = r'$b_0$') \n# plt.plot(np.arange(1,nepoch+1,1),w25,color='blue',label = r'$\\lambda_{2,5}$') \n# plt.plot(np.arange(1,nepoch+1,1),w35,color='darkblue',label = r'$\\lambda_{3,5}$')\n# plt.plot(np.arange(1,nepoch+1,1),w46,color='orange',label = r'$\\lambda_{4,6}$')\n# plt.plot(np.arange(1,nepoch+1,1),w56,color='darkorange',label = r'$\\lambda_{5,6}$')\nplt.plot([1,nepoch],[0,0],color='black',ls='--')\nplt.xlim([1,nepoch]); plt.ylim([-1.5,1.5]); plt.vlines(400,-1.5,1.5,color='black')\nplt.xlabel('Epochs'); plt.ylabel(r'$\\hat{y}$'); plt.title('CNN - Kernel')\nadd_grid(); plt.legend(loc='upper right'); plt.xscale('log')\n\nplt.subplot(223)\nplt.plot(np.arange(1,nepoch+1,1),w9,color='lightgreen',label = r'$\\lambda_{9}$') \nplt.plot(np.arange(1,nepoch+1,1),w10,color='green',label = r'$\\lambda_{10}$') \nplt.plot(np.arange(1,nepoch+1,1),w11,color='darkgreen',label = r'$\\lambda_{11}$') \nplt.plot(np.arange(1,nepoch+1,1),b12,color='darkgreen',label = r'$b_{12}$') \nplt.plot([1,nepoch],[0,0],color='black',ls='--')\nplt.xlim([1,nepoch]); plt.ylim([-1.5,1.5]); plt.vlines(400,-1.5,1.5,color='black')\nplt.xlabel('Epochs'); plt.ylabel(r'$\\hat{y}$'); plt.title('CNN - ANN Weights')\nadd_grid(); plt.legend(loc='upper right'); plt.xscale('log')\n\nplt.subplots_adjust(left=0.0, bottom=0.0, right=2.0, top=2.1, wspace=0.2, hspace=0.2); plt.show() \n```", "```py\nnp.random.seed(seed = seed+1)\nnsample = 10; nnodes = 5; delta = 0.3\nymat = np.zeros(nsample); x = np.arange(1,nnodes+1,1); Xmat = np.zeros([nsample,nnodes])\nfor isample in range(0,nsample):\n    m = np.random.uniform(low = -2.0, high = 2.0)\n    Xmat[isample] = (x-3.0)*m+ np.random.uniform(low=-delta,high=delta,size=nnodes)\n    ymat[isample] = np.dot(x, Xmat[isample]) / np.dot(x, x)\n\nisample = 9\nplt.subplot(111)\nfor isample in range(0,nsample):\n    plt.scatter(x,Xmat[isample],edgecolor='black',lw=1,zorder=10)\n    plt.plot(x,Xmat[isample],lw=1,zorder=1)\n    custom_positions = [1,2,3,4,5,5.2]\n    custom_labels = ['1','2','3','4','5','Y']\n    plt.annotate(np.round(ymat[isample],2),[5.2,Xmat[isample][-1]],size=8,color='black',ha='left')\n    plt.gca().set_xticks(custom_positions); plt.gca().set_xticklabels(custom_labels)\n    plt.xlim([0.5,5.5]); plt.ylim([-4.5,4.5]); plt.xlabel('index'); plt.ylabel('z'); add_grid(); plt.title('Synthetic 1D Images and Labels')\n\nplt.subplots_adjust(left=0.0, bottom=0.0, right=1.0, top=1.1, wspace=0.2, hspace=0.2); plt.show() \n```", "```py\nnp.random.seed(seed=seed)                                     # CNN trains over multiple samples\n\nlr = 0.2                                                 # learning rate\nnepoch = 1000                                    # number of training epochs\n\nw6 = np.zeros(nepoch); w7 = np.zeros(nepoch); w8 = np.zeros(nepoch)  # initialize the CNN weights\nw9 = np.zeros(nepoch); w10 = np.zeros(nepoch); w11 = np.zeros(nepoch)\nbconv = np.zeros(nepoch); b12 = np.zeros(nepoch)\n\nk6i1 = np.zeros(nepoch); k6i2 = np.zeros(nepoch); k6i3 = np.zeros(nepoch)\nk7i2 = np.zeros(nepoch); k7i3 = np.zeros(nepoch); k7i4 = np.zeros(nepoch)\nk8i3 = np.zeros(nepoch); k8i4 = np.zeros(nepoch); k8i5 = np.zeros(nepoch)\n\ndk6i1 = np.zeros(nepoch); dk6i2 = np.zeros(nepoch); dk6i3 = np.zeros(nepoch)\ndk7i2 = np.zeros(nepoch); dk7i3 = np.zeros(nepoch); dk7i4 = np.zeros(nepoch)\ndk8i3 = np.zeros(nepoch); dk8i4 = np.zeros(nepoch); dk8i5 = np.zeros(nepoch)\n\nc9 = np.zeros(nepoch); c10 = np.zeros(nepoch); c11 = np.zeros(nepoch)\nd9 = np.zeros(nepoch); d10 = np.zeros(nepoch); d11 = np.zeros(nepoch)\n\no12 = np.zeros(nepoch); yhat = np.zeros((nepoch,nsample))\n\ndw6 = np.zeros((nepoch,nsample)); dw7 = np.zeros((nepoch,nsample)); dw8 = np.zeros((nepoch,nsample))\ndw9 = np.zeros((nepoch,nsample)); dw10 = np.zeros((nepoch,nsample)); dw11 = np.zeros((nepoch,nsample))\ndbconv = np.zeros((nepoch,nsample)); db12 = np.zeros((nepoch,nsample))\n\nd6 = np.zeros(nepoch); d7 = np.zeros(nepoch); d8 = np.zeros(nepoch); \nd19 = np.zeros(nepoch); d10 = np.zeros(nepoch); d11 = np.zeros(nepoch); d12 = np.zeros(nepoch); \n\n# initialize the weights - Xavier Weight Initialization \nlower, upper = -(1.0 / np.sqrt(3.0)), (1.0 / np.sqrt(3.0)) # lower and upper bound for the weights, uses inputs to node\n#lower, upper = -(sqrt(6.0) / sqrt(3.0 + 2.0)), (sqrt(6.0) / sqrt(3.0 + 2.0)) # Normalized Xavier weights, integrates ouputs also\nw6[0] = lower + np.random.random() * (upper - lower); \nw7[0] = lower + np.random.random() * (upper - lower); \nw8[0] = lower + np.random.random() * (upper - lower);\n\nlower, upper = -(1.0 / np.sqrt(2.0)), (1.0 / np.sqrt(2.0))\n#lower, upper = -(sqrt(6.0) / sqrt(2.0 + 1.0)), (sqrt(6.0) / sqrt(2.0 + 1.0)) # Normalized Xavier weights, integrates ouputs also\n\nw9[0] = lower + np.random.random() * (upper - lower); \nw10[0] = lower + np.random.random() * (upper - lower);     \nw11[0] = lower + np.random.random() * (upper - lower);     \n\n#b4[0] = np.random.random(); b5[0] = np.random.random(); b6[0] = np.random.random()\nbconv[0] = (np.random.random()-0.5)*0.5\nb12[0] = (np.random.random()-0.5)*0.5; # small random value \n\nfor i in range(0,nepoch):\n    for isample in range(0,nsample):\n        x1, x2, x3, x4, x5 = Xmat[isample]; y = ymat[isample]\n\n        # forward pass of model\n        c9[i] = w6[i]*x1 + w7[i]*x2 + w8[i]*x3 + bconv[i]; \n        c9[i] = 1.0/(1 + math.exp(-1*c9[i]))\n\n        c10[i] = w6[i]*x2 + w7[i]*x3 + w8[i]*x4 + bconv[i]; \n        c10[i] = 1.0/(1 + math.exp(-1*c10[i]))\n\n        c11[i] = w6[i]*x3 + w7[i]*x4 + w8[i]*x5 + bconv[i]; \n        c11[i] = 1.0/(1 + math.exp(-1*c11[i]))\n\n        o12[i] = w9[i]*c9[i] + w10[i]*c10[i] + w11[i]*c11[i] + b12[i]\n        yhat[i,isample] = o12[i]\n\n# back propagate the error through the nodes\n        d12[i] = (o12[i]-y) # identity activation o at o12 - switched substraction on May 27, 2025\n        d9[i] =  c9[i]*(1-c9[i])*w9[i]*d12[i]   # propagate to the front feature map layer\n        d10[i] = c10[i]*(1-c10[i])*w10[i]*d12[i]\n        d11[i] = c11[i]*(1-c11[i])*w11[i]*d12[i]\n\n        dk6i1 = x1*d9[i]; dk7i2 = x2*d9[i]; dk8i3 = x3*d9[i] \n        dk6i2 = x2*d10[i]; dk7i3 = x3*d10[i]; dk8i4 = x4*d10[i] \n        dk6i3 = x3*d11[i]; dk7i4 = x4*d11[i]; dk8i5 = x5*d11[i] \n\n        d6[i] = dk6i1 + dk6i2 + dk6i3\n        d7[i] = dk7i2 + dk7i3 + dk7i4\n        d8[i] = dk8i3 + dk8i4 + dk8i5\n\n# calculate the change in weights\n        if i < nepoch - 1:\n            dw6[i,isample] = lr*d6[i]; dw7[i,isample] = lr*d7[i]; dw8[i,isample] = lr*d8[i]\n            dw9[i,isample] = lr*c9[i]*d12[i]; dw10[i,isample] = lr*c10[i]*d12[i]; dw11[i,isample] = lr*c11[i]*d12[i];\n            dbconv[i,isample] = lr*(d9[i] + d10[i] + d11[i]); db12[i,isample] = lr*d12[i]\n    if i < nepoch - 1:\n        w6[i+1] = w6[i] - np.average(dw6[i]); w7[i+1] = w7[i] - np.average(dw7[i]); w8[i+1] = w8[i] - np.average(dw8[i])\n        w9[i+1] = w9[i] - np.average(dw9[i]); w10[i+1] = w10[i] - np.average(dw10[i]); w11[i+1] = w11[i] - np.average(dw11[i])\n        bconv[i+1] = bconv[i] - np.average(dbconv[i]); b12[i+1] = b12[i] - np.average(db12[i]) \n```", "```py\nplt.subplot(221)\nfor isample in range(0,nsample):\n    plt.plot(np.arange(1,nepoch+1,1),yhat[:,isample],color=plt.cm.inferno(isample/nsample),label=r'y' + str(isample))\n    plt.plot([0,nepoch],[ymat[isample],ymat[isample]],color=plt.cm.inferno(isample/nsample),ls='--')\nplt.xlim([1,nepoch]); plt.ylim([-1,1])\nplt.xlabel('Epochs'); plt.ylabel(r'$\\hat{y}$'); plt.title('CNN - Prediction')\nplt.vlines(400,-1.5,1.5,color='black')\nadd_grid(); plt.legend(loc='upper right'); plt.xscale('log')\n\nplt.subplot(222)\nplt.plot(np.arange(1,nepoch+1,1),w6,color='lightcoral',label = r'$k_6$') \nplt.plot(np.arange(1,nepoch+1,1),w7,color='red',label = r'$k_7$') \nplt.plot(np.arange(1,nepoch+1,1),w8,color='darkred',label = r'$k_8$') \nplt.plot(np.arange(1,nepoch+1,1),bconv,color='dodgerblue',label = r'$b_0$') \nplt.plot([1,nepoch],[0,0],color='black',ls='--')\nplt.xlim([1,nepoch]); plt.ylim([-1.5,1.5]); plt.vlines(400,-1.5,1.5,color='black')\nplt.xlabel('Epochs'); plt.ylabel(r'$\\hat{y}$'); plt.title('CNN - Kernel')\nadd_grid(); plt.legend(loc='upper right'); plt.xscale('log')\n\nplt.subplot(223)\nplt.plot(np.arange(1,nepoch+1,1),w9,color='lightgreen',label = r'$\\lambda_{9}$') \nplt.plot(np.arange(1,nepoch+1,1),w10,color='green',label = r'$\\lambda_{10}$') \nplt.plot(np.arange(1,nepoch+1,1),w11,color='darkgreen',label = r'$\\lambda_{11}$') \nplt.plot(np.arange(1,nepoch+1,1),b12,color='darkgreen',label = r'$b_{12}$') \nplt.plot([1,nepoch],[0,0],color='black',ls='--')\nplt.xlim([1,nepoch]); plt.ylim([-1.5,1.5]); plt.vlines(400,-1.5,1.5,color='black')\nplt.xlabel('Epochs'); plt.ylabel(r'$\\hat{y}$'); plt.title('CNN - ANN Weights')\nadd_grid(); plt.legend(loc='upper right'); plt.xscale('log')\n\nplt.subplots_adjust(left=0.0, bottom=0.0, right=2.0, top=2.1, wspace=0.2, hspace=0.2); plt.show() \n```", "```py\nimport numpy as np\nimport pandas as pd\nimport matplotlib.pyplot as plt\nfrom matplotlib.ticker import (MultipleLocator, AutoMinorLocator, AutoLocator) # control of axes ticks\nplt.rc('axes', axisbelow=True)                            # set axes and grids in the background for all plots\nimport math\nseed = 13 \n```", "```py\ndef add_grid():\n    plt.gca().grid(True, which='major',linewidth = 1.0); plt.gca().grid(True, which='minor',linewidth = 0.2) # add y grids\n    plt.gca().tick_params(which='major',length=7); plt.gca().tick_params(which='minor', length=4)\n    plt.gca().xaxis.set_minor_locator(AutoMinorLocator()); plt.gca().yaxis.set_minor_locator(AutoMinorLocator()) # turn on minor ticks \n\ndef calculate_angle_rads(x1, y1, x2, y2):\n    dx = x2 - x1     # Calculate the differences\n    dy = y2 - y1\n    angle_rads = math.atan2(dy, dx)    # Calculate the angle in radians\n    #angle_degrees = math.degrees(angle_radians)    # Convert the angle to degrees\n    return angle_rads\n\ndef offset(pto, distance, angle_deg): # modified from ChatGPT 4.o generated\n    angle_rads = math.radians(angle_deg) # Convert angle from degrees to radians\n    x_new = pto[0] + distance * math.cos(angle_rads) # Calculate the new coordinates\n    y_new = pto[1] + distance * math.sin(angle_rads)\n    return np.array((x_new, y_new))\n\ndef offsetx(xo, distance, angle_deg): # modified from ChatGPT 4.o generated\n    angle_rads = math.radians(angle_deg) # Convert angle from degrees to radians\n    x_new = xo + distance * math.cos(angle_rads) # Calculate the new coordinates\n    return np.array((xo, x_new))\n\ndef offset_arrx(xo, distance, angle_deg,size): # modified from ChatGPT 4.o generated\n    angle_rads = math.radians(angle_deg) # Convert angle from degrees to radians\n    x_new = xo + distance * math.cos(angle_rads) # Calculate the new coordinates\n    x_arr = x_new + size * math.cos(angle_rads+2.48) # Calculate the new coordinates\n    return np.array((x_new, x_arr))\n\ndef offsety(yo, distance, angle_deg): # modified from ChatGPT 4.o generated\n    angle_rads = math.radians(angle_deg) # Convert angle from degrees to radians\n    y_new = yo + distance * math.sin(angle_rads) # Calculate the new coordinates\n    return np.array((yo, y_new))\n\ndef offset_arry(yo, distance, angle_deg,size): # modified from ChatGPT 4.o generated\n    angle_rads = math.radians(angle_deg) # Convert angle from degrees to radians\n    y_new = yo + distance * math.sin(angle_rads) # Calculate the new coordinates\n    y_arr = y_new + size * math.sin(angle_rads+2.48) # Calculate the new coordinates\n    return np.array((y_new, y_arr))\n\ndef lint(x1, y1, x2, y2, t):\n    # Calculate the interpolated coordinates\n    x = x1 + t * (x2 - x1)\n    y = y1 + t * (y2 - y1)\n    return np.array((x, y))\n\ndef lintx(x1, y1, x2, y2, t):\n    # Calculate the interpolated coordinates\n    x = x1 + t * (x2 - x1)\n    return x\n\ndef linty(x1, y1, x2, y2, t):\n    # Calculate the interpolated coordinates\n    y = y1 + t * (y2 - y1)\n    return y\n\ndef lint_intx(x1, y1, x2, y2, ts, te):\n    # Calculate the interpolated coordinates\n    xs = x1 + ts * (x2 - x1)\n    xe = x1 + te * (x2 - x1)\n    return np.array((xs,xe))\n\ndef lint_inty(x1, y1, x2, y2, ts, te):\n    # Calculate the interpolated coordinates\n    ys = y1 + ts * (y2 - y1)\n    ye = y1 + te * (y2 - y1)\n    return np.array((ys,ye))\n\ndef lint_int_arrx(x1, y1, x2, y2, ts, te, size):\n    # Calculate the interpolated coordinates\n    xe = x1 + te * (x2 - x1)\n    line_angle_rads = calculate_angle_rads(x1, y1, x2, y2)\n    x_arr = xe + size * math.cos(line_angle_rads+2.48) # Calculate the new coordinates\n    return np.array((xe,x_arr))\n\ndef lint_int_arry(x1, y1, x2, y2, ts, te, size):\n    # Calculate the interpolated coordinates\n    ye = y1 + te * (y2 - y1)\n    line_angle_rads = calculate_angle_rads(x1, y1, x2, y2)\n    y_arr = ye + size * math.sin(line_angle_rads+2.48) # Calculate the new coordinates\n    return np.array((ye,y_arr))\n\ndef as_si(x, ndp): # from xnx on StackOverflow https://stackoverflow.com/questions/31453422/displaying-numbers-with-x-instead-of-e-scientific-notation-in-matplotlib \n    s = '{x:0.{ndp:d}e}'.format(x=x, ndp=ndp)\n    m, e = s.split('e')\n    return r'{m:s}\\times 10^{{{e:d}}}'.format(m=m, e=int(e)) \n```", "```py\n# initial CNN trains on one sample\nx1 = 0.1; x2 = 0.2; x3 = 0.3; x4 = 0.4; x5 = 0.5; y = 0.1 # training data\nlr = 0.2 # learning rate\n\nnp.random.seed(seed=seed)\n\nnepoch = 1000\n\nw6 = np.zeros(nepoch); w7 = np.zeros(nepoch); w8 = np.zeros(nepoch)\nw9 = np.zeros(nepoch); w10 = np.zeros(nepoch); w11 = np.zeros(nepoch)\nbconv = np.zeros(nepoch); b12 = np.zeros(nepoch)\n\nk6i1 = np.zeros(nepoch); k6i2 = np.zeros(nepoch); k6i3 = np.zeros(nepoch)\nk7i2 = np.zeros(nepoch); k7i3 = np.zeros(nepoch); k7i4 = np.zeros(nepoch)\nk8i3 = np.zeros(nepoch); k8i4 = np.zeros(nepoch); k8i5 = np.zeros(nepoch)\n\ndk6i1 = np.zeros(nepoch); dk6i2 = np.zeros(nepoch); dk6i3 = np.zeros(nepoch)\ndk7i2 = np.zeros(nepoch); dk7i3 = np.zeros(nepoch); dk7i4 = np.zeros(nepoch)\ndk8i3 = np.zeros(nepoch); dk8i4 = np.zeros(nepoch); dk8i5 = np.zeros(nepoch)\n\nc9 = np.zeros(nepoch); c10 = np.zeros(nepoch); c11 = np.zeros(nepoch)\nd9 = np.zeros(nepoch); d10 = np.zeros(nepoch); d11 = np.zeros(nepoch)\n\no12 = np.zeros(nepoch)\n\ndw6 = np.zeros(nepoch); dw7 = np.zeros(nepoch); dw8 = np.zeros(nepoch)\ndw9 = np.zeros(nepoch); dw10 = np.zeros(nepoch); dw11 = np.zeros(nepoch)\ndbconv = np.zeros(nepoch); db12 = np.zeros(nepoch)\n\nd6 = np.zeros(nepoch); d7 = np.zeros(nepoch); d8 = np.zeros(nepoch); \nd19 = np.zeros(nepoch); d10 = np.zeros(nepoch); d11 = np.zeros(nepoch); d12 = np.zeros(nepoch); \n\n# initialize the weights - Xavier Weight Initialization \nlower, upper = -(1.0 / np.sqrt(3.0)), (1.0 / np.sqrt(3.0)) # lower and upper bound for the weights, uses inputs to node\n#lower, upper = -(sqrt(6.0) / sqrt(3.0 + 2.0)), (sqrt(6.0) / sqrt(3.0 + 2.0)) # Normalized Xavier weights, integrates ouputs also\nw6[0] = lower + np.random.random() * (upper - lower); \nw7[0] = lower + np.random.random() * (upper - lower); \nw8[0] = lower + np.random.random() * (upper - lower);\n\nlower, upper = -(1.0 / np.sqrt(2.0)), (1.0 / np.sqrt(2.0))\n#lower, upper = -(sqrt(6.0) / sqrt(2.0 + 1.0)), (sqrt(6.0) / sqrt(2.0 + 1.0)) # Normalized Xavier weights, integrates ouputs also\n\nw9[0] = lower + np.random.random() * (upper - lower); \nw10[0] = lower + np.random.random() * (upper - lower);     \nw11[0] = lower + np.random.random() * (upper - lower);     \n\n#b4[0] = np.random.random(); b5[0] = np.random.random(); b6[0] = np.random.random()\nbconv[0] = (np.random.random()-0.5)*0.5\nb12[0] = (np.random.random()-0.5)*0.5; # small random value \n\nfor i in range(0,nepoch):\n\n# forward pass of model\n    c9[i] = w6[i]*x1 + w7[i]*x2 + w8[i]*x3 + bconv[i]; \n    c9[i] = 1.0/(1 + math.exp(-1*c9[i]))\n\n    c10[i] = w6[i]*x2 + w7[i]*x3 + w8[i]*x4 + bconv[i]; \n    c10[i] = 1.0/(1 + math.exp(-1*c10[i]))\n\n    c11[i] = w6[i]*x3 + w7[i]*x4 + w8[i]*x5 + bconv[i]; \n    c11[i] = 1.0/(1 + math.exp(-1*c11[i]))\n\n    o12[i] = w9[i]*c9[i] + w10[i]*c10[i] + w11[i]*c11[i] + b12[i]\n\n# back propagate the error through the nodes\n    d12[i] = (o12[i]-y) # identity activation o at o12 - switched substraction on May 27, 2025\n    d9[i] =  c9[i]*(1-c9[i])*w9[i]*d12[i]   # propagate to the front feature map layer\n    d10[i] = c10[i]*(1-c10[i])*w10[i]*d12[i]\n    d11[i] = c11[i]*(1-c11[i])*w11[i]*d12[i]\n\n    dk6i1 = x1*d9[i]; dk7i2 = x2*d9[i]; dk8i3 = x3*d9[i] \n    dk6i2 = x2*d10[i]; dk7i3 = x3*d10[i]; dk8i4 = x4*d10[i] \n    dk6i3 = x3*d11[i]; dk7i4 = x4*d11[i]; dk8i5 = x5*d11[i] \n\n    d6[i] = dk6i1 + dk6i2 + dk6i3\n    d7[i] = dk7i2 + dk7i3 + dk7i4\n    d8[i] = dk8i3 + dk8i4 + dk8i5\n\n# calculate the change in weights\n    if i < nepoch - 1:\n        dw6[i] = lr*d6[i]; dw7[i] = lr*d7[i]; dw8[i] = lr*d8[i]\n        dw9[i] = lr*c9[i]*d12[i]; dw10[i] = lr*c10[i]*d12[i]; dw11[i] = lr*c11[i]*d12[i];\n        dbconv[i] = lr*(d9[i] + d10[i] + d11[i]); db12[i] = lr*d12[i]\n\n        w6[i+1] = w6[i] - dw6[i]; w7[i+1] = w7[i] - dw7[i]; w8[i+1] = w8[i] - dw8[i]\n        w9[i+1] = w9[i] - dw9[i]; w10[i+1] = w10[i] - dw10[i]; w11[i+1] = w11[i] - dw11[i]\n        bconv[i+1] = bconv[i] - dbconv[i]; b12[i+1] = b12[i] - db12[i] \n```", "```py\nxin = 0.1; yin_range = 0.7\nnin = 5\n\nkcolors = ['red','blue','green']\nxin = np.array([0.1,0.2,0.3,0.4,0.5])\nyout = np.array([y])\ncin = np.array([0.1,0.2,0.3])\nkx = 0.6\n\nplt.subplot(111)\n#plt.gca().set_axis_off()\n\nfor i, (xi) in enumerate(zip(xin), start=1):\n    eq1 = r\"$X_{{{}}}$\".format(i)\n    eq2 = r\"$X_{{{}}} = {}$\".format(i, xi[0])\n    eq3 = r\"$I_{{{}}}$\".format(i)\n    xpos = 0.4; ypos = yin_range - ((i-1)/nin) * yin_range \n    circle_i1 = plt.Circle((xpos,ypos), 0.015, fill=False, edgecolor = 'black',lw=1,zorder=100); \n    circle_i1b = plt.Circle((xpos,ypos), 0.025, fill=True, facecolor = 'white',edgecolor = None,lw=0.5,zorder=10);\n    plt.gca().add_patch(circle_i1); plt.gca().add_patch(circle_i1b)\n    plt.annotate(eq1, (xpos-0.2, ypos), textcoords=\"offset points\", xytext=(-12, -3), ha='center',size=15)\n    plt.annotate(eq2, (xpos, ypos), textcoords=\"offset points\", xytext=(-70, 9), ha='center')\n    plt.plot([xpos-0.2,xpos],[ypos,ypos],color='black',lw=2); plt.plot([xpos-0.2,xpos-0.07],[ypos+0.01,ypos+0.01],color='black',lw=2)\n    plt.plot([xpos-0.07,xpos-0.08],[ypos+0.01,ypos+0.02],color='black',lw=2)\n    plt.annotate(eq3, (xpos,ypos), textcoords=\"offset points\", xytext=(-15, 15), ha='center',size = 15)\n\nfor iconv in range(0,3):  \n    xpos = kx+iconv*0.2;\n    ytop = yin_range - (iconv/nin)*yin_range - ((1-1)/nin) * yin_range\n    ybot = yin_range - (iconv/nin)*yin_range - ((3-1)/nin) * yin_range  \n    plt.plot([xpos+0.12,xpos+0.12],[ytop+0.005,ybot+0.005],color='red',lw=1,ls='--',zorder=80)\n    for ik, (ki) in enumerate(zip(np.arange(1,4,1)), start=1):\n        eq4 = r\"$K_{{{}}}$\".format(ik+5)\n        ypos = yin_range - (iconv/nin)*yin_range - ((ik-1)/nin) * yin_range\n        circle_i1 = plt.Circle((xpos,ypos), 0.015, fill=True, facecolor = kcolors[ik-1],edgecolor = 'black',lw=1,zorder=200);\n        circle_i1b = plt.Circle((xpos,ypos), 0.025, fill=True, facecolor='white',edgecolor = None,lw=0.5,zorder=190);\n        plt.gca().add_patch(circle_i1); plt.gca().add_patch(circle_i1b)\n        plt.annotate(eq4, (xpos,ypos), textcoords=\"offset points\", xytext=(-15, 15), ha='center',size = 15)\n        plt.plot([0.4,xpos],[ypos,ypos],color='black',lw=1,zorder=1)\n        plt.plot([xpos,xpos+0.12],[ypos+0.005,ypos+0.005],color='red',lw=1,ls='--',zorder=80)\n        eq8 = r\"$I_{{{}}} \\cdot K_{{{}}}$\".format((iconv)+ik,ik+5)        \n        plt.annotate(eq8, (xpos+0.12, ypos), textcoords=\"offset points\", xytext=(-25, 5), ha='center',size = 10)\n\nfor ic, (ci) in enumerate(zip(np.arange(1,4,1)), start=1):\n    eq5 = r\"$C_{{{}}}$\".format(ic+8)\n    xpos = 1.2; ypos = yin_range - ((ic-1)/4) * yin_range - 0.07\n    circle_i1 = plt.Circle((xpos,ypos), 0.015, fill=True, facecolor = 'gold',edgecolor = 'black',lw=1,zorder=200);\n    circle_i1b = plt.Circle((xpos,ypos), 0.025, fill=True, facecolor='white',edgecolor = None,lw=0.5,zorder=190);\n    plt.gca().add_patch(circle_i1); plt.gca().add_patch(circle_i1b)\n    plt.annotate(eq5, (xpos,ypos), textcoords=\"offset points\", xytext=(-15, 15), ha='center',size = 15)\n    #plt.plot([0.4,x],[y,y],color='black',lw=1,zorder=1)\n    plt.plot([xpos,1.5],[ypos,yin_range - ((2-1)/4) * yin_range - 0.07],color='black',lw=1)\n    plt.plot([kx+(ic-1)*0.2+0.12,xpos],[ypos,ypos],color='red',lw=1,ls='--',zorder=80)\n\neq6 = r\"$O_{{{}}}$\".format(12)\neq7 = r\"$Y_{{{}}} = {}$\".format(i, np.round(yout[0],2))\nxpos = 1.5; ypos = yin_range - ((2-1)/4) * yin_range - 0.07\ncircle_i1 = plt.Circle((xpos,ypos), 0.015, fill=True, facecolor = 'gold',edgecolor = 'black',lw=1,zorder=200);\ncircle_i1b = plt.Circle((xpos,ypos), 0.025, fill=True, facecolor='white',edgecolor = None,lw=0.5,zorder=190);\nplt.gca().add_patch(circle_i1); plt.gca().add_patch(circle_i1b)\nplt.annotate(eq6, (xpos, ypos), textcoords=\"offset points\", xytext=(-15, 15), ha='center',size = 15)\nplt.annotate(eq7, (xpos, ypos), textcoords=\"offset points\", xytext=(130,-4), ha='center',size = 15)\nplt.plot([xpos,xpos+0.2],[ypos,ypos],color='black',lw=2); plt.plot([xpos,xpos+0.13],[ypos+0.01,ypos+0.01],color='black',lw=2)\nplt.plot([xpos+0.13,xpos+0.12],[ypos+0.01,ypos+0.02],color='black',lw=2)\nplt.annotate(eq6, (xpos, ypos), textcoords=\"offset points\", xytext=(20, 10), ha='center')\n\nplt.xlim([0.,2.]); plt.ylim([0,1])\n\nplt.subplots_adjust(left=0.0, bottom=0.0, right=2.0, top=1.3, wspace=0.2, hspace=0.2); plt.show() \n```", "```py\nplt.subplot(221)\nplt.plot(np.arange(1,nepoch+1,1),o12,color='red',label=r'$\\hat{y}$'); plt.xlim([1,nepoch]); plt.ylim([0,1])\nplt.xlabel('Epochs'); plt.ylabel(r'$\\hat{y}$'); plt.title('CNN - Prediction')\nplt.plot([1,nepoch],[y,y],color='black',ls='--'); plt.vlines(400,-1.5,1.5,color='black')\nadd_grid(); plt.legend(loc='upper right'); plt.xscale('log')\n\nplt.subplot(222)\nplt.plot(np.arange(1,nepoch+1,1),w6,color='lightcoral',label = r'$k_6$') \nplt.plot(np.arange(1,nepoch+1,1),w7,color='red',label = r'$k_7$') \nplt.plot(np.arange(1,nepoch+1,1),w8,color='darkred',label = r'$k_8$') \nplt.plot(np.arange(1,nepoch+1,1),bconv,color='dodgerblue',label = r'$b_0$') \n# plt.plot(np.arange(1,nepoch+1,1),w25,color='blue',label = r'$\\lambda_{2,5}$') \n# plt.plot(np.arange(1,nepoch+1,1),w35,color='darkblue',label = r'$\\lambda_{3,5}$')\n# plt.plot(np.arange(1,nepoch+1,1),w46,color='orange',label = r'$\\lambda_{4,6}$')\n# plt.plot(np.arange(1,nepoch+1,1),w56,color='darkorange',label = r'$\\lambda_{5,6}$')\nplt.plot([1,nepoch],[0,0],color='black',ls='--')\nplt.xlim([1,nepoch]); plt.ylim([-1.5,1.5]); plt.vlines(400,-1.5,1.5,color='black')\nplt.xlabel('Epochs'); plt.ylabel(r'$\\hat{y}$'); plt.title('CNN - Kernel')\nadd_grid(); plt.legend(loc='upper right'); plt.xscale('log')\n\nplt.subplot(223)\nplt.plot(np.arange(1,nepoch+1,1),w9,color='lightgreen',label = r'$\\lambda_{9}$') \nplt.plot(np.arange(1,nepoch+1,1),w10,color='green',label = r'$\\lambda_{10}$') \nplt.plot(np.arange(1,nepoch+1,1),w11,color='darkgreen',label = r'$\\lambda_{11}$') \nplt.plot(np.arange(1,nepoch+1,1),b12,color='darkgreen',label = r'$b_{12}$') \nplt.plot([1,nepoch],[0,0],color='black',ls='--')\nplt.xlim([1,nepoch]); plt.ylim([-1.5,1.5]); plt.vlines(400,-1.5,1.5,color='black')\nplt.xlabel('Epochs'); plt.ylabel(r'$\\hat{y}$'); plt.title('CNN - ANN Weights')\nadd_grid(); plt.legend(loc='upper right'); plt.xscale('log')\n\nplt.subplots_adjust(left=0.0, bottom=0.0, right=2.0, top=2.1, wspace=0.2, hspace=0.2); plt.show() \n```", "```py\nnp.random.seed(seed = seed+1)\nnsample = 10; nnodes = 5; delta = 0.3\nymat = np.zeros(nsample); x = np.arange(1,nnodes+1,1); Xmat = np.zeros([nsample,nnodes])\nfor isample in range(0,nsample):\n    m = np.random.uniform(low = -2.0, high = 2.0)\n    Xmat[isample] = (x-3.0)*m+ np.random.uniform(low=-delta,high=delta,size=nnodes)\n    ymat[isample] = np.dot(x, Xmat[isample]) / np.dot(x, x)\n\nisample = 9\nplt.subplot(111)\nfor isample in range(0,nsample):\n    plt.scatter(x,Xmat[isample],edgecolor='black',lw=1,zorder=10)\n    plt.plot(x,Xmat[isample],lw=1,zorder=1)\n    custom_positions = [1,2,3,4,5,5.2]\n    custom_labels = ['1','2','3','4','5','Y']\n    plt.annotate(np.round(ymat[isample],2),[5.2,Xmat[isample][-1]],size=8,color='black',ha='left')\n    plt.gca().set_xticks(custom_positions); plt.gca().set_xticklabels(custom_labels)\n    plt.xlim([0.5,5.5]); plt.ylim([-4.5,4.5]); plt.xlabel('index'); plt.ylabel('z'); add_grid(); plt.title('Synthetic 1D Images and Labels')\n\nplt.subplots_adjust(left=0.0, bottom=0.0, right=1.0, top=1.1, wspace=0.2, hspace=0.2); plt.show() \n```", "```py\nnp.random.seed(seed=seed)                                     # CNN trains over multiple samples\n\nlr = 0.2                                                 # learning rate\nnepoch = 1000                                    # number of training epochs\n\nw6 = np.zeros(nepoch); w7 = np.zeros(nepoch); w8 = np.zeros(nepoch)  # initialize the CNN weights\nw9 = np.zeros(nepoch); w10 = np.zeros(nepoch); w11 = np.zeros(nepoch)\nbconv = np.zeros(nepoch); b12 = np.zeros(nepoch)\n\nk6i1 = np.zeros(nepoch); k6i2 = np.zeros(nepoch); k6i3 = np.zeros(nepoch)\nk7i2 = np.zeros(nepoch); k7i3 = np.zeros(nepoch); k7i4 = np.zeros(nepoch)\nk8i3 = np.zeros(nepoch); k8i4 = np.zeros(nepoch); k8i5 = np.zeros(nepoch)\n\ndk6i1 = np.zeros(nepoch); dk6i2 = np.zeros(nepoch); dk6i3 = np.zeros(nepoch)\ndk7i2 = np.zeros(nepoch); dk7i3 = np.zeros(nepoch); dk7i4 = np.zeros(nepoch)\ndk8i3 = np.zeros(nepoch); dk8i4 = np.zeros(nepoch); dk8i5 = np.zeros(nepoch)\n\nc9 = np.zeros(nepoch); c10 = np.zeros(nepoch); c11 = np.zeros(nepoch)\nd9 = np.zeros(nepoch); d10 = np.zeros(nepoch); d11 = np.zeros(nepoch)\n\no12 = np.zeros(nepoch); yhat = np.zeros((nepoch,nsample))\n\ndw6 = np.zeros((nepoch,nsample)); dw7 = np.zeros((nepoch,nsample)); dw8 = np.zeros((nepoch,nsample))\ndw9 = np.zeros((nepoch,nsample)); dw10 = np.zeros((nepoch,nsample)); dw11 = np.zeros((nepoch,nsample))\ndbconv = np.zeros((nepoch,nsample)); db12 = np.zeros((nepoch,nsample))\n\nd6 = np.zeros(nepoch); d7 = np.zeros(nepoch); d8 = np.zeros(nepoch); \nd19 = np.zeros(nepoch); d10 = np.zeros(nepoch); d11 = np.zeros(nepoch); d12 = np.zeros(nepoch); \n\n# initialize the weights - Xavier Weight Initialization \nlower, upper = -(1.0 / np.sqrt(3.0)), (1.0 / np.sqrt(3.0)) # lower and upper bound for the weights, uses inputs to node\n#lower, upper = -(sqrt(6.0) / sqrt(3.0 + 2.0)), (sqrt(6.0) / sqrt(3.0 + 2.0)) # Normalized Xavier weights, integrates ouputs also\nw6[0] = lower + np.random.random() * (upper - lower); \nw7[0] = lower + np.random.random() * (upper - lower); \nw8[0] = lower + np.random.random() * (upper - lower);\n\nlower, upper = -(1.0 / np.sqrt(2.0)), (1.0 / np.sqrt(2.0))\n#lower, upper = -(sqrt(6.0) / sqrt(2.0 + 1.0)), (sqrt(6.0) / sqrt(2.0 + 1.0)) # Normalized Xavier weights, integrates ouputs also\n\nw9[0] = lower + np.random.random() * (upper - lower); \nw10[0] = lower + np.random.random() * (upper - lower);     \nw11[0] = lower + np.random.random() * (upper - lower);     \n\n#b4[0] = np.random.random(); b5[0] = np.random.random(); b6[0] = np.random.random()\nbconv[0] = (np.random.random()-0.5)*0.5\nb12[0] = (np.random.random()-0.5)*0.5; # small random value \n\nfor i in range(0,nepoch):\n    for isample in range(0,nsample):\n        x1, x2, x3, x4, x5 = Xmat[isample]; y = ymat[isample]\n\n        # forward pass of model\n        c9[i] = w6[i]*x1 + w7[i]*x2 + w8[i]*x3 + bconv[i]; \n        c9[i] = 1.0/(1 + math.exp(-1*c9[i]))\n\n        c10[i] = w6[i]*x2 + w7[i]*x3 + w8[i]*x4 + bconv[i]; \n        c10[i] = 1.0/(1 + math.exp(-1*c10[i]))\n\n        c11[i] = w6[i]*x3 + w7[i]*x4 + w8[i]*x5 + bconv[i]; \n        c11[i] = 1.0/(1 + math.exp(-1*c11[i]))\n\n        o12[i] = w9[i]*c9[i] + w10[i]*c10[i] + w11[i]*c11[i] + b12[i]\n        yhat[i,isample] = o12[i]\n\n# back propagate the error through the nodes\n        d12[i] = (o12[i]-y) # identity activation o at o12 - switched substraction on May 27, 2025\n        d9[i] =  c9[i]*(1-c9[i])*w9[i]*d12[i]   # propagate to the front feature map layer\n        d10[i] = c10[i]*(1-c10[i])*w10[i]*d12[i]\n        d11[i] = c11[i]*(1-c11[i])*w11[i]*d12[i]\n\n        dk6i1 = x1*d9[i]; dk7i2 = x2*d9[i]; dk8i3 = x3*d9[i] \n        dk6i2 = x2*d10[i]; dk7i3 = x3*d10[i]; dk8i4 = x4*d10[i] \n        dk6i3 = x3*d11[i]; dk7i4 = x4*d11[i]; dk8i5 = x5*d11[i] \n\n        d6[i] = dk6i1 + dk6i2 + dk6i3\n        d7[i] = dk7i2 + dk7i3 + dk7i4\n        d8[i] = dk8i3 + dk8i4 + dk8i5\n\n# calculate the change in weights\n        if i < nepoch - 1:\n            dw6[i,isample] = lr*d6[i]; dw7[i,isample] = lr*d7[i]; dw8[i,isample] = lr*d8[i]\n            dw9[i,isample] = lr*c9[i]*d12[i]; dw10[i,isample] = lr*c10[i]*d12[i]; dw11[i,isample] = lr*c11[i]*d12[i];\n            dbconv[i,isample] = lr*(d9[i] + d10[i] + d11[i]); db12[i,isample] = lr*d12[i]\n    if i < nepoch - 1:\n        w6[i+1] = w6[i] - np.average(dw6[i]); w7[i+1] = w7[i] - np.average(dw7[i]); w8[i+1] = w8[i] - np.average(dw8[i])\n        w9[i+1] = w9[i] - np.average(dw9[i]); w10[i+1] = w10[i] - np.average(dw10[i]); w11[i+1] = w11[i] - np.average(dw11[i])\n        bconv[i+1] = bconv[i] - np.average(dbconv[i]); b12[i+1] = b12[i] - np.average(db12[i]) \n```", "```py\nplt.subplot(221)\nfor isample in range(0,nsample):\n    plt.plot(np.arange(1,nepoch+1,1),yhat[:,isample],color=plt.cm.inferno(isample/nsample),label=r'y' + str(isample))\n    plt.plot([0,nepoch],[ymat[isample],ymat[isample]],color=plt.cm.inferno(isample/nsample),ls='--')\nplt.xlim([1,nepoch]); plt.ylim([-1,1])\nplt.xlabel('Epochs'); plt.ylabel(r'$\\hat{y}$'); plt.title('CNN - Prediction')\nplt.vlines(400,-1.5,1.5,color='black')\nadd_grid(); plt.legend(loc='upper right'); plt.xscale('log')\n\nplt.subplot(222)\nplt.plot(np.arange(1,nepoch+1,1),w6,color='lightcoral',label = r'$k_6$') \nplt.plot(np.arange(1,nepoch+1,1),w7,color='red',label = r'$k_7$') \nplt.plot(np.arange(1,nepoch+1,1),w8,color='darkred',label = r'$k_8$') \nplt.plot(np.arange(1,nepoch+1,1),bconv,color='dodgerblue',label = r'$b_0$') \nplt.plot([1,nepoch],[0,0],color='black',ls='--')\nplt.xlim([1,nepoch]); plt.ylim([-1.5,1.5]); plt.vlines(400,-1.5,1.5,color='black')\nplt.xlabel('Epochs'); plt.ylabel(r'$\\hat{y}$'); plt.title('CNN - Kernel')\nadd_grid(); plt.legend(loc='upper right'); plt.xscale('log')\n\nplt.subplot(223)\nplt.plot(np.arange(1,nepoch+1,1),w9,color='lightgreen',label = r'$\\lambda_{9}$') \nplt.plot(np.arange(1,nepoch+1,1),w10,color='green',label = r'$\\lambda_{10}$') \nplt.plot(np.arange(1,nepoch+1,1),w11,color='darkgreen',label = r'$\\lambda_{11}$') \nplt.plot(np.arange(1,nepoch+1,1),b12,color='darkgreen',label = r'$b_{12}$') \nplt.plot([1,nepoch],[0,0],color='black',ls='--')\nplt.xlim([1,nepoch]); plt.ylim([-1.5,1.5]); plt.vlines(400,-1.5,1.5,color='black')\nplt.xlabel('Epochs'); plt.ylabel(r'$\\hat{y}$'); plt.title('CNN - ANN Weights')\nadd_grid(); plt.legend(loc='upper right'); plt.xscale('log')\n\nplt.subplots_adjust(left=0.0, bottom=0.0, right=2.0, top=2.1, wspace=0.2, hspace=0.2); plt.show() \n```"]