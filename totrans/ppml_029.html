<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.1//EN"
  "http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd">

<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<title>Implementing traits</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1>Implementing traits</h1>
<blockquote>原文：<a href="https://rust-exercises.com/100-exercises/04_traits/02_orphan_rule.html">https://rust-exercises.com/100-exercises/04_traits/02_orphan_rule.html</a></blockquote>
                        
<p>When a type is defined in another crate (e.g. <code>u32</code>, from Rust's standard library), you
can't directly define new methods for it. If you try:</p>
<pre><code class="language-rust">impl u32 {
    fn is_even(&amp;self) -&gt; bool {
        self % 2 == 0
    }
}</code></pre>
<p>the compiler will complain:</p>
<pre><code class="language-text">error[E0390]: cannot define inherent `impl` for primitive types
  |
1 | impl u32 {
  | ^^^^^^^^
  |
  = help: consider using an extension trait instead
</code></pre>
<h2 id="extension-trait"><a class="header" href="#extension-trait">Extension trait</a></h2>
<p>An <strong>extension trait</strong> is a trait whose primary purpose is to attach new methods
to foreign types, such as <code>u32</code>.
That's exactly the pattern you deployed in the previous exercise, by defining
the <code>IsEven</code> trait and then implementing it for <code>i32</code> and <code>u32</code>. You are then
free to call <code>is_even</code> on those types as long as <code>IsEven</code> is in scope.</p>
<pre><code class="language-rust">// Bring the trait in scope
use my_library::IsEven;

fn main() {
    // Invoke its method on a type that implements it
    if 4.is_even() {
        // [...]
    }
}</code></pre>
<h2 id="one-implementation"><a class="header" href="#one-implementation">One implementation</a></h2>
<p>There are limitations to the trait implementations you can write.<br/>
The simplest and most straight-forward one: you can't implement the same trait twice,
in a crate, for the same type.</p>
<p>For example:</p>
<pre><code class="language-rust">trait IsEven {
    fn is_even(&amp;self) -&gt; bool;
}

impl IsEven for u32 {
    fn is_even(&amp;self) -&gt; bool {
        true
    }
}

impl IsEven for u32 {
    fn is_even(&amp;self) -&gt; bool {
        false
    }
}</code></pre>
<p>The compiler will reject it:</p>
<pre><code class="language-text">error[E0119]: conflicting implementations of trait `IsEven` for type `u32`
   |
5  | impl IsEven for u32 {
   | ------------------- first implementation here
...
11 | impl IsEven for u32 {
   | ^^^^^^^^^^^^^^^^^^^ conflicting implementation for `u32`
</code></pre>
<p>There can be no ambiguity as to what trait implementation should be used when <code>IsEven::is_even</code>
is invoked on a <code>u32</code> value, therefore there can only be one.</p>
<h2 id="orphan-rule"><a class="header" href="#orphan-rule">Orphan rule</a></h2>
<p>Things get more nuanced when multiple crates are involved.
In particular, at least one of the following must be true:</p>
<ul>
<li>The trait is defined in the current crate</li>
<li>The implementor type is defined in the current crate</li>
</ul>
<p>This is known as Rust's <strong>orphan rule</strong>. Its goal is to make the method resolution
process unambiguous.</p>
<p>Imagine the following situation:</p>
<ul>
<li>Crate <code>A</code> defines the <code>IsEven</code> trait</li>
<li>Crate <code>B</code> implements <code>IsEven</code> for <code>u32</code></li>
<li>Crate <code>C</code> provides a (different) implementation of the <code>IsEven</code> trait for <code>u32</code></li>
<li>Crate <code>D</code> depends on both <code>B</code> and <code>C</code> and calls <code>1.is_even()</code></li>
</ul>
<p>Which implementation should be used? The one defined in <code>B</code>? Or the one defined in <code>C</code>?<br/>
There's no good answer, therefore the orphan rule was defined to prevent this scenario.
Thanks to the orphan rule, neither crate <code>B</code> nor crate <code>C</code> would compile.</p>
<h2 id="further-reading"><a class="header" href="#further-reading">Further reading</a></h2>
<ul>
<li>There are some caveats and exceptions to the orphan rule as stated above.
Check out <a href="https://doc.rust-lang.org/reference/items/implementations.html#trait-implementation-coherence">the reference</a>
if you want to get familiar with its nuances.</li>
</ul>
<h2 id="exercise"><a class="header" href="#exercise">Exercise</a></h2>
<p>The exercise for this section is located in <a href="https://github.com/mainmatter/100-exercises-to-learn-rust/tree/main/exercises/04_traits/02_orphan_rule"><code>04_traits/02_orphan_rule</code></a></p>

                        
</body>
</html>