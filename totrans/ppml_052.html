<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.1//EN"
  "http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd">

<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<title>Libraries and binaries</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1>Libraries and binaries</h1>
<blockquote>原文：<a href="https://rust-exercises.com/100-exercises/05_ticket_v2/10_packages.html">https://rust-exercises.com/100-exercises/05_ticket_v2/10_packages.html</a></blockquote>
                        
<p>It took a bit of code to implement the <code>Error</code> trait for <code>TicketNewError</code>, didn't it?<br/>
A manual <code>Display</code> implementation, plus an <code>Error</code> impl block.</p>
<p>We can remove some of the boilerplate by using <a href="https://docs.rs/thiserror/latest/thiserror/"><code>thiserror</code></a>,
a Rust crate that provides a <strong>procedural macro</strong> to simplify the creation of custom error types.<br/>
But we're getting ahead of ourselves: <code>thiserror</code> is a third-party crate, it'd be our first dependency!</p>
<p>Let's take a step back to talk about Rust's packaging system before we dive into dependencies.</p>
<h2 id="what-is-a-package"><a class="header" href="#what-is-a-package">What is a package?</a></h2>
<p>A Rust package is defined by the <code>[package]</code> section in a <code>Cargo.toml</code> file, also known as its <strong>manifest</strong>.
Within <code>[package]</code> you can set the package's metadata, such as its name and version.</p>
<p>Go check the <code>Cargo.toml</code> file in the directory of this section's exercise!</p>
<h2 id="what-is-a-crate"><a class="header" href="#what-is-a-crate">What is a crate?</a></h2>
<p>Inside a package, you can have one or more <strong>crates</strong>, also known as <strong>targets</strong>.<br/>
The two most common crate types are <strong>binary crates</strong> and <strong>library crates</strong>.</p>
<h3 id="binaries"><a class="header" href="#binaries">Binaries</a></h3>
<p>A binary is a program that can be compiled to an <strong>executable file</strong>.<br/>
It must include a function named <code>main</code>—the program's entry point. <code>main</code> is invoked when the program is executed.</p>
<h3 id="libraries"><a class="header" href="#libraries">Libraries</a></h3>
<p>Libraries, on the other hand, are not executable on their own. You can't <em>run</em> a library,
but you can <em>import its code</em> from another package that depends on it.<br/>
A library groups together code (i.e. functions, types, etc.) that can be leveraged by other packages as a <strong>dependency</strong>.</p>
<p>All the exercises you've solved so far have been structured as libraries, with a test suite attached to them.</p>
<h3 id="conventions"><a class="header" href="#conventions">Conventions</a></h3>
<p>There are some conventions around Rust packages that you need to keep in mind:</p>
<ul>
<li>The package's source code is usually located in the <code>src</code> directory.</li>
<li>If there's a <code>src/lib.rs</code> file, <code>cargo</code> will infer that the package contains a library crate.</li>
<li>If there's a <code>src/main.rs</code> file, <code>cargo</code> will infer that the package contains a binary crate.</li>
</ul>
<p>You can override these defaults by explicitly declaring your targets in the <code>Cargo.toml</code> file—see
<a href="https://doc.rust-lang.org/cargo/reference/cargo-targets.html#cargo-targets"><code>cargo</code>'s documentation</a> for more details.</p>
<p>Keep in mind that while a package can contain multiple crates, it can only contain one library crate.</p>
<h2 id="exercise"><a class="header" href="#exercise">Exercise</a></h2>
<p>The exercise for this section is located in <a href="https://github.com/mainmatter/100-exercises-to-learn-rust/tree/main/exercises/05_ticket_v2/10_packages"><code>05_ticket_v2/10_packages</code></a></p>

                        
</body>
</html>