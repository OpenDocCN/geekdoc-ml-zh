- en: Bounded vs unbounded channels
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 原文：[https://rust-exercises.com/100-exercises/07_threads/09_bounded.html](https://rust-exercises.com/100-exercises/07_threads/09_bounded.html)
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: So far we've been using unbounded channels.
  prefs: []
  type: TYPE_NORMAL
- en: You can send as many messages as you want, and the channel will grow to accommodate
    them.
  prefs: []
  type: TYPE_NORMAL
- en: 'In a multi-producer single-consumer scenario, this can be problematic: if the
    producers enqueue messages at a faster rate than the consumer can process them,
    the channel will keep growing, potentially consuming all available memory.'
  prefs: []
  type: TYPE_NORMAL
- en: Our recommendation is to **never** use an unbounded channel in a production
    system.
  prefs: []
  type: TYPE_NORMAL
- en: You should always enforce an upper limit on the number of messages that can
    be enqueued using a **bounded channel**.
  prefs: []
  type: TYPE_NORMAL
- en: '[Bounded channels](#bounded-channels)'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A bounded channel has a fixed capacity.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can create one by calling `sync_channel` with a capacity greater than zero:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: '`receiver` has the same type as before, `Receiver<T>`.'
  prefs: []
  type: TYPE_NORMAL
- en: '`sender`, instead, is an instance of `SyncSender<T>`.'
  prefs: []
  type: TYPE_NORMAL
- en: '[Sending messages](#sending-messages)'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'You have two different methods to send messages through a `SyncSender`:'
  prefs: []
  type: TYPE_NORMAL
- en: '`send`: if there is space in the channel, it will enqueue the message and return
    `Ok(())`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If the channel is full, it will block and wait until there is space available.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '`try_send`: if there is space in the channel, it will enqueue the message and
    return `Ok(())`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If the channel is full, it will return `Err(TrySendError::Full(value))`, where
    `value` is the message that couldn't be sent.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Depending on your use case, you might want to use one or the other.
  prefs: []
  type: TYPE_NORMAL
- en: '[Backpressure](#backpressure)'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The main advantage of using bounded channels is that they provide a form of
    **backpressure**.
  prefs: []
  type: TYPE_NORMAL
- en: They force the producers to slow down if the consumer can't keep up. The backpressure
    can then propagate through the system, potentially affecting the whole architecture
    and preventing end users from overwhelming the system with requests.
  prefs: []
  type: TYPE_NORMAL
- en: '[Exercise](#exercise)'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The exercise for this section is located in [`07_threads/09_bounded`](https://github.com/mainmatter/100-exercises-to-learn-rust/tree/main/exercises/07_threads/09_bounded)
  prefs: []
  type: TYPE_NORMAL
