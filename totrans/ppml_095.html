<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.1//EN"
  "http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd">

<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<title>Don't block the runtime</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1>Don't block the runtime</h1>
<blockquote>原文：<a href="https://rust-exercises.com/100-exercises/08_futures/05_blocking.html">https://rust-exercises.com/100-exercises/08_futures/05_blocking.html</a></blockquote>
                        
<p>Let's circle back to yield points.<br/>
Unlike threads, <strong>Rust tasks cannot be preempted</strong>.</p>
<p><code>tokio</code> cannot, on its own, decide to pause a task and run another one in its place.
The control goes back to the executor <strong>exclusively</strong> when the task yields—i.e.
when <code>Future::poll</code> returns <code>Poll::Pending</code> or, in the case of <code>async fn</code>, when
you <code>.await</code> a future.</p>
<p>This exposes the runtime to a risk: if a task never yields, the runtime will never
be able to run another task. This is called <strong>blocking the runtime</strong>.</p>
<h2 id="what-is-blocking"><a class="header" href="#what-is-blocking">What is blocking?</a></h2>
<p>How long is too long? How much time can a task spend without yielding before it
becomes a problem?</p>
<p>It depends on the runtime, the application, the number of in-flight tasks, and
many other factors. But, as a general rule of thumb, try to spend less than 100
microseconds between yield points.</p>
<h2 id="consequences"><a class="header" href="#consequences">Consequences</a></h2>
<p>Blocking the runtime can lead to:</p>
<ul>
<li><strong>Deadlocks</strong>: if the task that's not yielding is waiting for another task to
complete, and that task is waiting for the first one to yield, you have a deadlock.
No progress can be made, unless the runtime is able to schedule the other task on
a different thread.</li>
<li><strong>Starvation</strong>: other tasks might not be able to run, or might run after a long
delay, which can lead to poor performances (e.g. high tail latencies).</li>
</ul>
<h2 id="blocking-is-not-always-obvious"><a class="header" href="#blocking-is-not-always-obvious">Blocking is not always obvious</a></h2>
<p>Some types of operations should generally be avoided in async code, like:</p>
<ul>
<li>Synchronous I/O. You can't predict how long it will take, and it's likely to be
longer than 100 microseconds.</li>
<li>Expensive CPU-bound computations.</li>
</ul>
<p>The latter category is not always obvious though. For example, sorting a vector with
a few elements is not a problem; that evaluation changes if the vector has billions
of entries.</p>
<h2 id="how-to-avoid-blocking"><a class="header" href="#how-to-avoid-blocking">How to avoid blocking</a></h2>
<p>OK, so how do you avoid blocking the runtime assuming you <em>must</em> perform an operation
that qualifies or risks qualifying as blocking?<br/>
You need to move the work to a different thread. You don't want to use the so-called
runtime threads, the ones used by <code>tokio</code> to run tasks.</p>
<p><code>tokio</code> provides a dedicated threadpool for this purpose, called the <strong>blocking pool</strong>.
You can spawn a synchronous operation on the blocking pool using the
<code>tokio::task::spawn_blocking</code> function. <code>spawn_blocking</code> returns a future that resolves
to the result of the operation when it completes.</p>
<pre><code class="language-rust">use tokio::task;

fn expensive_computation() -&gt; u64 {
    // [...]
}

async fn run() {
    let handle = task::spawn_blocking(expensive_computation);
    // Do other stuff in the meantime
    let result = handle.await.unwrap();
}</code></pre>
<p>The blocking pool is long-lived. <code>spawn_blocking</code> should be faster
than creating a new thread directly via <code>std::thread::spawn</code>
because the cost of thread initialization is amortized over multiple calls.</p>
<h2 id="further-reading"><a class="header" href="#further-reading">Further reading</a></h2>
<ul>
<li>Check out <a href="https://ryhl.io/blog/async-what-is-blocking/">Alice Ryhl's blog post</a>
on the topic.</li>
</ul>
<h2 id="exercise"><a class="header" href="#exercise">Exercise</a></h2>
<p>The exercise for this section is located in <a href="https://github.com/mainmatter/100-exercises-to-learn-rust/tree/main/exercises/08_futures/05_blocking"><code>08_futures/05_blocking</code></a></p>

                        
</body>
</html>