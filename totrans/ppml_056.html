<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.1//EN"
  "http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd">

<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<title>Error::source</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1>Error::source</h1>
<blockquote>原文：<a href="https://rust-exercises.com/100-exercises/05_ticket_v2/14_source.html">https://rust-exercises.com/100-exercises/05_ticket_v2/14_source.html</a></blockquote>
                        
<p>There's one more thing we need to talk about to complete our coverage of the <code>Error</code> trait: the <code>source</code> method.</p>
<pre><code class="language-rust">// Full definition this time!
pub trait Error: Debug + Display {
    fn source(&amp;self) -&gt; Option&lt;&amp;(dyn Error + 'static)&gt; {
        None
    }
}</code></pre>
<p>The <code>source</code> method is a way to access the <strong>error cause</strong>, if any.<br/>
Errors are often chained, meaning that one error is the cause of another: you have a high-level error (e.g.
cannot connect to the database) that is caused by a lower-level error (e.g. can't resolve the database hostname).
The <code>source</code> method allows you to "walk" the full chain of errors, often used when capturing error context in logs.</p>
<h2 id="implementing-source"><a class="header" href="#implementing-source">Implementing <code>source</code></a></h2>
<p>The <code>Error</code> trait provides a default implementation that always returns <code>None</code> (i.e. no underlying cause). That's why
you didn't have to care about <code>source</code> in the previous exercises.<br/>
You can override this default implementation to provide a cause for your error type.</p>
<pre><code class="language-rust">use std::error::Error;

#[derive(Debug)]
struct DatabaseError {
    source: std::io::Error
}

impl std::fmt::Display for DatabaseError {
    fn fmt(&amp;self, f: &amp;mut std::fmt::Formatter) -&gt; std::fmt::Result {
        write!(f, "Failed to connect to the database")
    }
}

impl std::error::Error for DatabaseError {
    fn source(&amp;self) -&gt; Option&lt;&amp;(dyn Error + 'static)&gt; {
        Some(&amp;self.source)
    }
}</code></pre>
<p>In this example, <code>DatabaseError</code> wraps an <code>std::io::Error</code> as its source.
We then override the <code>source</code> method to return this source when called.</p>
<h2 id="dyn-error--static"><a class="header" href="#dyn-error--static"><code>&amp;(dyn Error + 'static)</code></a></h2>
<p>What's this <code>&amp;(dyn Error + 'static)</code> type?<br/>
Let's unpack it:</p>
<ul>
<li><code>dyn Error</code> is a <strong>trait object</strong>. It's a way to refer to any type that implements the <code>Error</code> trait.</li>
<li><code>'static</code> is a special <strong>lifetime specifier</strong>.
<code>'static</code> implies that the reference is valid for "as long as we need it", i.e. the entire program execution.</li>
</ul>
<p>Combined: <code>&amp;(dyn Error + 'static)</code> is a reference to a trait object that implements the <code>Error</code> trait
and is valid for the entire program execution.</p>
<p>Don't worry too much about either of these concepts for now. We'll cover them in more detail in future chapters.</p>
<h2 id="implementing-source-using-thiserror"><a class="header" href="#implementing-source-using-thiserror">Implementing <code>source</code> using <code>thiserror</code></a></h2>
<p><code>thiserror</code> provides three ways to automatically implement <code>source</code> for your error types:</p>
<ul>
<li>A field named <code>source</code> will automatically be used as the source of the error.
<pre><code class="language-rust">use thiserror::Error;

#[derive(Error, Debug)]
pub enum MyError {
    #[error("Failed to connect to the database")]
    DatabaseError {
        source: std::io::Error
    }
}</code></pre>
</li>
<li>A field annotated with the <code>#[source]</code> attribute will automatically be used as the source of the error.
<pre><code class="language-rust">use thiserror::Error;

#[derive(Error, Debug)]
pub enum MyError {
    #[error("Failed to connect to the database")]
    DatabaseError {
        #[source]
        inner: std::io::Error
    }
}</code></pre>
</li>
<li>A field annotated with the <code>#[from]</code> attribute will automatically be used as the source of the error <strong>and</strong>
<code>thiserror</code> will automatically generate a <code>From</code> implementation to convert the annotated type into your error type.
<pre><code class="language-rust">use thiserror::Error;

#[derive(Error, Debug)]
pub enum MyError {
    #[error("Failed to connect to the database")]
    DatabaseError {
        #[from]
        inner: std::io::Error
    }
}</code></pre>
</li>
</ul>
<h2 id="the--operator"><a class="header" href="#the--operator">The <code>?</code> operator</a></h2>
<p>The <code>?</code> operator is a shorthand for propagating errors.<br/>
When used in a function that returns a <code>Result</code>, it will return early with an error if the <code>Result</code> is <code>Err</code>.</p>
<p>For example:</p>
<pre><code class="language-rust">use std::fs::File;

fn read_file() -&gt; Result&lt;String, std::io::Error&gt; {
    let mut file = File::open("file.txt")?;
    let mut contents = String::new();
    file.read_to_string(&amp;mut contents)?;
    Ok(contents)
}</code></pre>
<p>is equivalent to:</p>
<pre><code class="language-rust">use std::fs::File;

fn read_file() -&gt; Result&lt;String, std::io::Error&gt; {
    let mut file = match File::open("file.txt") {
        Ok(file) =&gt; file,
        Err(e) =&gt; {
            return Err(e);
        }
    };
    let mut contents = String::new();
    match file.read_to_string(&amp;mut contents) {
        Ok(_) =&gt; (),
        Err(e) =&gt; {
            return Err(e);
        }
    }
    Ok(contents)
}</code></pre>
<p>You can use the <code>?</code> operator to shorten your error handling code significantly.<br/>
In particular, the <code>?</code> operator will automatically convert the error type of the fallible operation into the error type
of the function, if a conversion is possible (i.e. if there is a suitable <code>From</code> implementation)</p>
<h2 id="exercise"><a class="header" href="#exercise">Exercise</a></h2>
<p>The exercise for this section is located in <a href="https://github.com/mainmatter/100-exercises-to-learn-rust/tree/main/exercises/05_ticket_v2/14_source"><code>05_ticket_v2/14_source</code></a></p>

                        
</body>
</html>