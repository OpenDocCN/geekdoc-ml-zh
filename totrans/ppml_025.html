<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.1//EN"
  "http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd">

<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<title>Destructors</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1>Destructors</h1>
<blockquote>原文：<a href="https://rust-exercises.com/100-exercises/03_ticket_v1/11_destructor.html">https://rust-exercises.com/100-exercises/03_ticket_v1/11_destructor.html</a></blockquote>
                        
<p>When introducing the heap, we mentioned that you're responsible for freeing the memory you allocate.<br/>
When introducing the borrow-checker, we also stated that you rarely have to manage memory directly in Rust.</p>
<p>These two statements might seem contradictory at first.
Let's see how they fit together by introducing <strong>scopes</strong> and <strong>destructors</strong>.</p>
<h2 id="scopes"><a class="header" href="#scopes">Scopes</a></h2>
<p>The <strong>scope</strong> of a variable is the region of Rust code where that variable is valid, or <strong>alive</strong>.</p>
<p>The scope of a variable starts with its declaration.
It ends when one of the following happens:</p>
<ol>
<li>the block (i.e. the code between <code>{}</code>) where the variable was declared ends
<pre><code class="language-rust">fn main() {
   // `x` is not yet in scope here
   let y = "Hello".to_string();
   let x = "World".to_string(); // &lt;-- x's scope starts here...
   let h = "!".to_string(); //   |
} //  &lt;-------------- ...and ends here</code></pre>
</li>
<li>ownership of the variable is transferred to someone else (e.g. a function or another variable)
<pre><code class="language-rust">fn compute(t: String) {
   // Do something [...]
}

fn main() {
    let s = "Hello".to_string(); // &lt;-- s's scope starts here...
                //                    | 
    compute(s); // &lt;------------------- ..and ends here
                //   because `s` is moved into `compute`
}</code></pre>
</li>
</ol>
<h2 id="destructors-1"><a class="header" href="#destructors-1">Destructors</a></h2>
<p>When the owner of a value goes out of scope, Rust invokes its <strong>destructor</strong>.<br/>
The destructor tries to clean up the resources used by that value—in particular, whatever memory it allocated.</p>
<p>You can manually invoke the destructor of a value by passing it to <code>std::mem::drop</code>.<br/>
That's why you'll often hear Rust developers saying "that value has been <strong>dropped</strong>" as a way to state that a value
has gone out of scope and its destructor has been invoked.</p>
<h3 id="visualizing-drop-points"><a class="header" href="#visualizing-drop-points">Visualizing drop points</a></h3>
<p>We can insert explicit calls to <code>drop</code> to "spell out" what the compiler does for us. Going back to the previous example:</p>
<pre><code class="language-rust">fn main() {
   let y = "Hello".to_string();
   let x = "World".to_string();
   let h = "!".to_string();
}</code></pre>
<p>It's equivalent to:</p>
<pre><code class="language-rust">fn main() {
   let y = "Hello".to_string();
   let x = "World".to_string();
   let h = "!".to_string();
   // Variables are dropped in reverse order of declaration
   drop(h);
   drop(x);
   drop(y);
}</code></pre>
<p>Let's look at the second example instead, where <code>s</code>'s ownership is transferred to <code>compute</code>:</p>
<pre><code class="language-rust">fn compute(s: String) {
   // Do something [...]
}

fn main() {
   let s = "Hello".to_string();
   compute(s);
}</code></pre>
<p>It's equivalent to this:</p>
<pre><code class="language-rust">fn compute(t: String) {
    // Do something [...]
    drop(t); // &lt;-- Assuming `t` wasn't dropped or moved 
             //     before this point, the compiler will call 
             //     `drop` here, when it goes out of scope
}

fn main() {
    let s = "Hello".to_string();
    compute(s);
}</code></pre>
<p>Notice the difference: even though <code>s</code> is no longer valid after <code>compute</code> is called in <code>main</code>, there is no <code>drop(s)</code>
in <code>main</code>.
When you transfer ownership of a value to a function, you're also <strong>transferring the responsibility of cleaning it up</strong>.</p>
<p>This ensures that the destructor for a value is called <strong>at most<sup class="footnote-reference" id="fr-leak-1"><a href="#footnote-leak">1</a></sup> once</strong>, preventing
<a href="https://owasp.org/www-community/vulnerabilities/Doubly_freeing_memory">double free bugs</a> by design.</p>
<h3 id="use-after-drop"><a class="header" href="#use-after-drop">Use after drop</a></h3>
<p>What happens if you try to use a value after it's been dropped?</p>
<pre><code class="language-rust">let x = "Hello".to_string();
drop(x);
println!("{}", x);</code></pre>
<p>If you try to compile this code, you'll get an error:</p>
<pre><code class="language-rust">error[E0382]: use of moved value: `x`
 --&gt; src/main.rs:4:20
  |
3 |     drop(x);
  |          - value moved here
4 |     println!("{}", x);
  |                    ^ value used here after move</code></pre>
<p>Drop <strong>consumes</strong> the value it's called on, meaning that the value is no longer valid after the call.<br/>
The compiler will therefore prevent you from using it, avoiding <a href="https://owasp.org/www-community/vulnerabilities/Using_freed_memory">use-after-free bugs</a>.</p>
<h3 id="dropping-references"><a class="header" href="#dropping-references">Dropping references</a></h3>
<p>What if a variable contains a reference?<br/>
For example:</p>
<pre><code class="language-rust">let x = 42i32;
let y = &amp;x;
drop(y);</code></pre>
<p>When you call <code>drop(y)</code>... nothing happens.<br/>
If you actually try to compile this code, you'll get a warning:</p>
<pre><code class="language-text">warning: calls to `std::mem::drop` with a reference 
         instead of an owned value does nothing
 --&gt; src/main.rs:4:5
  |
4 |     drop(y);
  |     ^^^^^-^
  |          |
  |          argument has type `&amp;i32`
  |
</code></pre>
<p>It goes back to what we said earlier: we only want to call the destructor once.<br/>
You can have multiple references to the same value—if we called the destructor for the value they point at
when one of them goes out of scope, what would happen to the others?
They would refer to a memory location that's no longer valid: a so-called <a href="https://en.wikipedia.org/wiki/Dangling_pointer"><strong>dangling pointer</strong></a>,
a close relative of <a href="https://owasp.org/www-community/vulnerabilities/Using_freed_memory"><strong>use-after-free bugs</strong></a>.
Rust's ownership system rules out these kinds of bugs by design.</p>
<h2 id="exercise"><a class="header" href="#exercise">Exercise</a></h2>
<p>The exercise for this section is located in <a href="https://github.com/mainmatter/100-exercises-to-learn-rust/tree/main/exercises/03_ticket_v1/11_destructor"><code>03_ticket_v1/11_destructor</code></a></p>
<hr/>
<ol class="footnote-definition"><li id="footnote-leak">
<p>Rust doesn't guarantee that destructors will run. They won't, for example, if
you explicitly choose to <a href="/100-exercises/07_threads/03_leak">leak memory</a>. <a href="#fr-leak-1">↩</a></p>
</li>
</ol>
                        
</body>
</html>