<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.1//EN"
  "http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd">

<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<title>Lifetimes</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1>Lifetimes</h1>
<blockquote>原文：<a href="https://rust-exercises.com/100-exercises/06_ticket_management/06_lifetimes.html">https://rust-exercises.com/100-exercises/06_ticket_management/06_lifetimes.html</a></blockquote>
                        
<p>Let's try to complete the previous exercise by adding an implementation of <code>IntoIterator</code> for <code>&amp;TicketStore</code>, for
maximum convenience in <code>for</code> loops.</p>
<p>Let's start by filling in the most "obvious" parts of the implementation:</p>
<pre><code class="language-rust">impl IntoIterator for &amp;TicketStore {
    type Item = &amp;Ticket;
    type IntoIter = // What goes here?

    fn into_iter(self) -&gt; Self::IntoIter {
        self.tickets.iter()
    }
}</code></pre>
<p>What should <code>type IntoIter</code> be set to?<br/>
Intuitively, it should be the type returned by <code>self.tickets.iter()</code>, i.e. the type returned by <code>Vec::iter()</code>.<br/>
If you check the standard library documentation, you'll find that <code>Vec::iter()</code> returns an <code>std::slice::Iter</code>.
The definition of <code>Iter</code> is:</p>
<pre><code class="language-rust">pub struct Iter&lt;'a, T&gt; { /* fields omitted */ }</code></pre>
<p><code>'a</code> is a <strong>lifetime parameter</strong>.</p>
<h2 id="lifetime-parameters"><a class="header" href="#lifetime-parameters">Lifetime parameters</a></h2>
<p>Lifetimes are <strong>labels</strong> used by the Rust compiler to keep track of how long a reference (either mutable or
immutable) is valid.<br/>
The lifetime of a reference is constrained by the scope of the value it refers to. Rust always makes sure, at compile-time,
that references are not used after the value they refer to has been dropped, to avoid dangling pointers and use-after-free bugs.</p>
<p>This should sound familiar: we've already seen these concepts in action when we discussed ownership and borrowing.
Lifetimes are just a way to <strong>name</strong> how long a specific reference is valid.</p>
<p>Naming becomes important when you have multiple references and you need to clarify how they <strong>relate to each other</strong>.
Let's look at the signature of <code>Vec::iter()</code>:</p>
<pre><code class="language-rust">impl &lt;T&gt; Vec&lt;T&gt; {
    // Slightly simplified
    pub fn iter&lt;'a&gt;(&amp;'a self) -&gt; Iter&lt;'a, T&gt; {
        // [...]
    }
}</code></pre>
<p><code>Vec::iter()</code> is generic over a lifetime parameter, named <code>'a</code>.<br/>
<code>'a</code> is used to <strong>tie together</strong> the lifetime of the <code>Vec</code> and the lifetime of the <code>Iter</code> returned by <code>iter()</code>.
In plain English: the <code>Iter</code> returned by <code>iter()</code> cannot outlive the <code>Vec</code> reference (<code>&amp;self</code>) it was created from.</p>
<p>This is important because <code>Vec::iter</code>, as we discussed, returns an iterator over <strong>references</strong> to the <code>Vec</code>'s elements.
If the <code>Vec</code> is dropped, the references returned by the iterator would be invalid. Rust must make sure this doesn't happen,
and lifetimes are the tool it uses to enforce this rule.</p>
<h2 id="lifetime-elision"><a class="header" href="#lifetime-elision">Lifetime elision</a></h2>
<p>Rust has a set of rules, called <strong>lifetime elision rules</strong>, that allow you to omit explicit lifetime annotations in many cases.
For example, <code>Vec::iter</code>'s definition looks like this in <code>std</code>'s source code:</p>
<pre><code class="language-rust">impl &lt;T&gt; Vec&lt;T&gt; {
    pub fn iter(&amp;self) -&gt; Iter&lt;'_, T&gt; {
        // [...]
    }
}</code></pre>
<p>No explicit lifetime parameter is present in the signature of <code>Vec::iter()</code>.
Elision rules imply that the lifetime of the <code>Iter</code> returned by <code>iter()</code> is tied to the lifetime of the <code>&amp;self</code> reference.
You can think of <code>'_</code> as a <strong>placeholder</strong> for the lifetime of the <code>&amp;self</code> reference.</p>
<p>See the <a href="#references">References</a> section for a link to the official documentation on lifetime elision.<br/>
In most cases, you can rely on the compiler telling you when you need to add explicit lifetime annotations.</p>
<h2 id="references"><a class="header" href="#references">References</a></h2>
<ul>
<li><a href="https://doc.rust-lang.org/std/vec/struct.Vec.html#method.iter">std::vec::Vec::iter</a></li>
<li><a href="https://doc.rust-lang.org/std/slice/struct.Iter.html">std::slice::Iter</a></li>
<li><a href="https://doc.rust-lang.org/reference/lifetime-elision.html">Lifetime elision rules</a></li>
</ul>
<h2 id="exercise"><a class="header" href="#exercise">Exercise</a></h2>
<p>The exercise for this section is located in <a href="https://github.com/mainmatter/100-exercises-to-learn-rust/tree/main/exercises/06_ticket_management/06_lifetimes"><code>06_ticket_management/06_lifetimes</code></a></p>

                        
</body>
</html>