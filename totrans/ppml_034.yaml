- en: Deref trait
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 原文：[https://rust-exercises.com/100-exercises/04_traits/07_deref.html](https://rust-exercises.com/100-exercises/04_traits/07_deref.html)
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: In the previous exercise you didn't have to do much, did you?
  prefs: []
  type: TYPE_NORMAL
- en: Changing
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: to
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: was all you needed to do to get the code to compile and the tests to pass. Some
    alarm bells should be ringing in your head though.
  prefs: []
  type: TYPE_NORMAL
- en: '[It shouldn''t work, but it does](#it-shouldnt-work-but-it-does)'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let''s review the facts:'
  prefs: []
  type: TYPE_NORMAL
- en: '`self.title` is a `String`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`&self.title` is, therefore, a `&String`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The output of the (modified) `title` method is `&str`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You would expect a compiler error, wouldn't you? `Expected &String, found &str`
    or something similar. Instead, it just works. **Why**?
  prefs: []
  type: TYPE_NORMAL
- en: '[`Deref` to the rescue](#deref-to-the-rescue)'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `Deref` trait is the mechanism behind the language feature known as [**deref
    coercion**](https://doc.rust-lang.org/std/ops/trait.Deref.html#deref-coercion).
  prefs: []
  type: TYPE_NORMAL
- en: 'The trait is defined in the standard library, in the `std::ops` module:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: '`type Target` is an **associated type**.'
  prefs: []
  type: TYPE_NORMAL
- en: It's a placeholder for a concrete type that must be specified when the trait
    is implemented.
  prefs: []
  type: TYPE_NORMAL
- en: '[Deref coercion](#deref-coercion)'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: By implementing `Deref<Target = U>` for a type `T` you're telling the compiler
    that `&T` and `&U` are somewhat interchangeable.
  prefs: []
  type: TYPE_NORMAL
- en: 'In particular, you get the following behavior:'
  prefs: []
  type: TYPE_NORMAL
- en: References to `T` are implicitly converted into references to `U` (i.e. `&T`
    becomes `&U`)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You can call on `&T` all the methods defined on `U` that take `&self` as input.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: There is one more thing around the dereference operator, `*`, but we don't need
    it yet (see `std`'s docs if you're curious).
  prefs: []
  type: TYPE_NORMAL
- en: '[`String` implements `Deref`](#string-implements-deref)'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '`String` implements `Deref` with `Target = str`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Thanks to this implementation and deref coercion, a `&String` is automatically
    converted into a `&str` when needed.
  prefs: []
  type: TYPE_NORMAL
- en: '[Don''t abuse deref coercion](#dont-abuse-deref-coercion)'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Deref coercion is a powerful feature, but it can lead to confusion.
  prefs: []
  type: TYPE_NORMAL
- en: Automatically converting types can make the code harder to read and understand.
    If a method with the same name is defined on both `T` and `U`, which one will
    be called?
  prefs: []
  type: TYPE_NORMAL
- en: 'We''ll examine later in the course the "safest" use cases for deref coercion:
    smart pointers.'
  prefs: []
  type: TYPE_NORMAL
- en: '[Exercise](#exercise)'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The exercise for this section is located in [`04_traits/07_deref`](https://github.com/mainmatter/100-exercises-to-learn-rust/tree/main/exercises/04_traits/07_deref)
  prefs: []
  type: TYPE_NORMAL
