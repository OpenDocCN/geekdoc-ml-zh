- en: Implementing traits
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 原文：[https://rust-exercises.com/100-exercises/04_traits/02_orphan_rule.html](https://rust-exercises.com/100-exercises/04_traits/02_orphan_rule.html)
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'When a type is defined in another crate (e.g. `u32`, from Rust''s standard
    library), you can''t directly define new methods for it. If you try:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'the compiler will complain:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: '[Extension trait](#extension-trait)'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: An **extension trait** is a trait whose primary purpose is to attach new methods
    to foreign types, such as `u32`. That's exactly the pattern you deployed in the
    previous exercise, by defining the `IsEven` trait and then implementing it for
    `i32` and `u32`. You are then free to call `is_even` on those types as long as
    `IsEven` is in scope.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: '[One implementation](#one-implementation)'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: There are limitations to the trait implementations you can write.
  prefs: []
  type: TYPE_NORMAL
- en: 'The simplest and most straight-forward one: you can''t implement the same trait
    twice, in a crate, for the same type.'
  prefs: []
  type: TYPE_NORMAL
- en: 'For example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'The compiler will reject it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: There can be no ambiguity as to what trait implementation should be used when
    `IsEven::is_even` is invoked on a `u32` value, therefore there can only be one.
  prefs: []
  type: TYPE_NORMAL
- en: '[Orphan rule](#orphan-rule)'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Things get more nuanced when multiple crates are involved. In particular, at
    least one of the following must be true:'
  prefs: []
  type: TYPE_NORMAL
- en: The trait is defined in the current crate
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The implementor type is defined in the current crate
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: This is known as Rust's **orphan rule**. Its goal is to make the method resolution
    process unambiguous.
  prefs: []
  type: TYPE_NORMAL
- en: 'Imagine the following situation:'
  prefs: []
  type: TYPE_NORMAL
- en: Crate `A` defines the `IsEven` trait
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Crate `B` implements `IsEven` for `u32`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Crate `C` provides a (different) implementation of the `IsEven` trait for `u32`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Crate `D` depends on both `B` and `C` and calls `1.is_even()`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Which implementation should be used? The one defined in `B`? Or the one defined
    in `C`?
  prefs: []
  type: TYPE_NORMAL
- en: There's no good answer, therefore the orphan rule was defined to prevent this
    scenario. Thanks to the orphan rule, neither crate `B` nor crate `C` would compile.
  prefs: []
  type: TYPE_NORMAL
- en: '[Further reading](#further-reading)'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: There are some caveats and exceptions to the orphan rule as stated above. Check
    out [the reference](https://doc.rust-lang.org/reference/items/implementations.html#trait-implementation-coherence)
    if you want to get familiar with its nuances.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Exercise](#exercise)'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The exercise for this section is located in [`04_traits/02_orphan_rule`](https://github.com/mainmatter/100-exercises-to-learn-rust/tree/main/exercises/04_traits/02_orphan_rule)
  prefs: []
  type: TYPE_NORMAL
