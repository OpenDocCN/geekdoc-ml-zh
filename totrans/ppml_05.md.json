["```py\nsqrt(2) *  sqrt(2) ==  2\n```", "```py\n## [1] FALSE\n```", "```py\nall.equal(sqrt(2) *  sqrt(2), 2, tol = sqrt(.Machine$double.eps))\n```", "```py\n## [1] TRUE\n```", "```py\n1e99 ==  1e99 +  1\n```", "```py\n## [1] TRUE\n```", "```py\n1 -  1e-20 ==  1\n```", "```py\n## [1] TRUE\n```", "```py\nprint(0.6 +  0.7 +  0.8, digits = 20)\n```", "```py\n## [1] 2.0999999999999996447\n```", "```py\nprint(0.8 +  0.7 +  0.6, digits = 20)\n```", "```py\n## [1] 2.1000000000000000888\n```", "```py\nprobs =  runif(10^2, min = 10^-6, max = 10^-3)\nsqrt(prod(probs))\n```", "```py\n## [1] 0\n```", "```py\nexp(0.5 *  sum(log(probs)))\n```", "```py\n## [1] 1.33e-169\n```", "```py\nlibrary(microbenchmark)\nfloats.vec1 =  rnorm(2 *  10^7)\nfloats.vec2 =  rnorm(2 *  10^7)\nintegers.vec1 =  sample(10, 2 *  10^7, replace = TRUE)\nintegers.vec2 =  sample(10, 2 *  10^7, replace = TRUE)\n\nmicrobenchmark(integers.vec1 %*%  integers.vec2,\n floats.vec1 %*%  floats.vec2, times = 200)\n```", "```py\nimport timeit\nimport numpy as np\n\nITERATION = 200\n\nfloat_vector1 = np.random.normal(0, 1, 2 * pow(10, 7))\nfloat_vector2 = np.random.normal(0, 1, 2 * pow(10, 7))\n\nint_vector1 = np.random.choice(10, size=2 * pow(10, 7))\nint_vector2 = np.random.choice(10, size=2 * pow(10, 7))\n\ndef product_int():\n np.dot(int_vector1, int_vector2)\n\ndef product_float():\n np.dot(float_vector1, float_vector2)\n\nprint(\"Inner product with int by\", ITERATION, \"iteration, avg:\",\n np.mean(timeit.repeat(\n repeat=ITERATION,\n stmt=product_int,\n number=1)))\n\nprint(\"Inner product with float by\", ITERATION, \"iteration, avg:\",\n np.mean(timeit.repeat(\n repeat=ITERATION,\n stmt=product_float,\n number=1)))\n```"]