<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.1//EN"
  "http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd">

<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<title>Structs</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1>Structs</h1>
<blockquote>原文：<a href="https://rust-exercises.com/100-exercises/03_ticket_v1/01_struct.html">https://rust-exercises.com/100-exercises/03_ticket_v1/01_struct.html</a></blockquote>
                        
<p>We need to keep track of three pieces of information for each ticket:</p>
<ul>
<li>A title</li>
<li>A description</li>
<li>A status</li>
</ul>
<p>We can start by using a <a href="https://doc.rust-lang.org/std/string/struct.String.html"><code>String</code></a>
to represent them. <code>String</code> is the type defined in Rust's standard library to represent
<a href="https://en.wikipedia.org/wiki/UTF-8">UTF-8 encoded</a> text.</p>
<p>But how do we <strong>combine</strong> these three pieces of information into a single entity?</p>
<h2 id="defining-a-struct"><a class="header" href="#defining-a-struct">Defining a <code>struct</code></a></h2>
<p>A <code>struct</code> defines a <strong>new Rust type</strong>.</p>
<pre><code class="language-rust">struct Ticket {
    title: String,
    description: String,
    status: String
}</code></pre>
<p>A struct is quite similar to what you would call a class or an object in other programming languages.</p>
<h2 id="defining-fields"><a class="header" href="#defining-fields">Defining fields</a></h2>
<p>The new type is built by combining other types as <strong>fields</strong>.<br/>
Each field must have a name and a type, separated by a colon, <code>:</code>. If there are multiple fields, they are separated by a comma, <code>,</code>.</p>
<p>Fields don't have to be of the same type, as you can see in the <code>Configuration</code> struct below:</p>
<pre><code class="language-rust">struct Configuration {
   version: u32,
   active: bool
}</code></pre>
<h2 id="instantiation"><a class="header" href="#instantiation">Instantiation</a></h2>
<p>You can create an instance of a struct by specifying the values for each field:</p>
<pre><code class="language-rust">// Syntax: &lt;StructName&gt; { &lt;field_name&gt;: &lt;value&gt;, ... }
let ticket = Ticket {
    title: "Build a ticket system".into(),
    description: "A Kanban board".into(),
    status: "Open".into()
};</code></pre>
<h2 id="accessing-fields"><a class="header" href="#accessing-fields">Accessing fields</a></h2>
<p>You can access the fields of a struct using the <code>.</code> operator:</p>
<pre><code class="language-rust">// Field access
let x = ticket.description;</code></pre>
<h2 id="methods"><a class="header" href="#methods">Methods</a></h2>
<p>We can attach behaviour to our structs by defining <strong>methods</strong>.<br/>
Using the <code>Ticket</code> struct as an example:</p>
<pre><code class="language-rust">impl Ticket {
    fn is_open(self) -&gt; bool {
        self.status == "Open"
    }
}

// Syntax:
// impl &lt;StructName&gt; {
//    fn &lt;method_name&gt;(&lt;parameters&gt;) -&gt; &lt;return_type&gt; {
//        // Method body
//    }
// }</code></pre>
<p>Methods are pretty similar to functions, with two key differences:</p>
<ol>
<li>methods must be defined inside an <strong><code>impl</code> block</strong></li>
<li>methods may use <code>self</code> as their first parameter.
<code>self</code> is a keyword and represents the instance of the struct the method is being called on.</li>
</ol>
<h3 id="self"><a class="header" href="#self"><code>self</code></a></h3>
<p>If a method takes <code>self</code> as its first parameter, it can be called using the <strong>method call syntax</strong>:</p>
<pre><code class="language-rust">// Method call syntax: &lt;instance&gt;.&lt;method_name&gt;(&lt;parameters&gt;)
let is_open = ticket.is_open();</code></pre>
<p>This is the same calling syntax you used to perform saturating arithmetic operations on <code>u32</code> values
in <a href="/100-exercises/02_basic_calculator/09_saturating">the previous chapter</a>.</p>
<h3 id="static-methods"><a class="header" href="#static-methods">Static methods</a></h3>
<p>If a method doesn't take <code>self</code> as its first parameter, it's a <strong>static method</strong>.</p>
<pre><code class="language-rust">struct Configuration {
    version: u32,
    active: bool
}

impl Configuration {
    // `default` is a static method on `Configuration`
    fn default() -&gt; Configuration {
        Configuration { version: 0, active: false }
    }
}</code></pre>
<p>The only way to call a static method is by using the <strong>function call syntax</strong>:</p>
<pre><code class="language-rust">// Function call syntax: &lt;StructName&gt;::&lt;method_name&gt;(&lt;parameters&gt;)
let default_config = Configuration::default();</code></pre>
<h3 id="equivalence"><a class="header" href="#equivalence">Equivalence</a></h3>
<p>You can use the function call syntax even for methods that take <code>self</code> as their first parameter:</p>
<pre><code class="language-rust">// Function call syntax:
//   &lt;StructName&gt;::&lt;method_name&gt;(&lt;instance&gt;, &lt;parameters&gt;)
let is_open = Ticket::is_open(ticket);</code></pre>
<p>The function call syntax makes it quite clear that <code>ticket</code> is being used as <code>self</code>, the first parameter of the method,
but it's definitely more verbose. Prefer the method call syntax when possible.</p>
<h2 id="exercise"><a class="header" href="#exercise">Exercise</a></h2>
<p>The exercise for this section is located in <a href="https://github.com/mainmatter/100-exercises-to-learn-rust/tree/main/exercises/03_ticket_v1/01_struct"><code>03_ticket_v1/01_struct</code></a></p>

                        
</body>
</html>