["```py\nignore_warnings = True                                        # ignore warnings?\nimport numpy as np                                            # ndarrays for gridded data\nimport pandas as pd                                           # DataFrames for tabular data\nimport copy                                                   # for deep copies\nimport os                                                     # set working directory, run executables\nimport matplotlib.pyplot as plt                               # for plotting\nfrom matplotlib.ticker import (MultipleLocator, AutoMinorLocator) # control of axes ticks\nimport matplotlib.ticker as mtick                             # control tick label formatting\nimport seaborn as sns                                         # for matrix scatter plots\nfrom sklearn.preprocessing import MinMaxScaler                # min/max normalization\nfrom sklearn.metrics import silhouette_score                  # calculating the optimum K number of clusters\nfrom sklearn.cluster import KMeans                            # k-means clustering\nplt.rc('axes', axisbelow=True)                                # plot all grids below the plot elements\nif ignore_warnings == True:                                   \n    import warnings\n    warnings.filterwarnings('ignore')\ncmap = plt.cm.inferno                                         # color map\nseed = 42                                                     # random number seed \n```", "```py\n# Assignment function to assigned training data to the nearest prototype (code modified from Ben Keen, http://benalexkeen.com/k-means-clustering-in-python/)\ndef assignment(df,centroids):\n    for i in centroids.keys():\n        df['distance_from_{}'.format(i)] = (                  # use the normalized features and centroids\n            np.sqrt(\n                (df['Norm_Porosity'] - centroids[i][2]) ** 2\n                + (df['Norm_AI'] - centroids[i][3]) ** 2\n            )\n        )\n    centroid_distance_cols = ['distance_from_{}'.format(i) for i in centroids.keys()]\n    df['closest'] = df.loc[:, centroid_distance_cols].idxmin(axis=1)\n    df['closest'] = df['closest'].map(lambda x: int(x.lstrip('distance_from_')))\n    df['color'] = df['closest'].map(lambda x: colmap[x])\n    return\n\n# Update function to shift the prototype to the centroid of the training data assigned to the prototype (code modified from Ben Keen, http://benalexkeen.com/k-means-clustering-in-python/)\ndef update(df,centroids,x1min,x1max,x2min,x2max):\n    for i in centroids.keys():\n        centroids[i][2] = np.mean(df[df['closest'] == i]['Norm_Porosity'])\n        centroids[i][3] = np.mean(df[df['closest'] == i]['Norm_AI'])\n        centroids[i][0] = centroids[i][2] * (x1max-x1min) + x1min\n        centroids[i][1] = centroids[i][3] * (x2max-x2min) + x2min\n    return\n\ndef add_grid():\n    plt.gca().grid(True, which='major',linewidth = 1.0); plt.gca().grid(True, which='minor',linewidth = 0.2) # add y grids\n    plt.gca().tick_params(which='major',length=7); plt.gca().tick_params(which='minor', length=4)\n    plt.gca().xaxis.set_minor_locator(AutoMinorLocator()); plt.gca().yaxis.set_minor_locator(AutoMinorLocator()) # turn on minor ticks \n```", "```py\n#os.chdir(\"C:/PGE383\")                                        # set the working directory with the input data file \n```", "```py\nimport pandas as pd \n```", "```py\npd.read_csv() \n```", "```py\ndf = pd.read_csv(\"12_sample_data.csv\") \n```", "```py\ndf = df.sample(frac=.30, random_state = 73073); \ndf = df.reset_index() \n```", "```py\n#df = pd.read_csv('12_sample_data.csv')                       # load our data table from the current directory\ndf = pd.read_csv('https://raw.githubusercontent.com/GeostatsGuy/GeoDataSets/master/12_sample_data.csv') # or from GtiHub\ndf = df.iloc[:,1:]                                            # remove a null column \ndf = df.sample(frac=.30, random_state = seed); df = df.reset_index(drop=True) # extract 30% random to reduce the number of data \n```", "```py\ndf.describe().transpose()                                     # DataFrame summary statistics \n```", "```py\npormin = df['Porosity'].min(); pormax = df['Porosity'].max()  # find min and max for each feature\nAImin = df['AI'].min(); AImax = df['AI'].max()\n\ndf['Norm_Porosity'] = (df['Porosity']-pormin)/(pormax - pormin) # normalize each feature, this broadcasts over all samples in the DataFrame\ndf['Norm_AI'] = (df['AI']-AImin)/(AImax - AImin)                            # and appends a new normalized feature for each \n```", "```py\nfrom sklearn.preprocessing import MinMaxScaler\nscaler = MinMaxScaler()\nX_normalized = scaler.fit_transform(X) \n```", "```py\ndf.describe().transpose()                                     # summary statistics for the DataFrame \n```", "```py\ndf_subset = df.iloc[:,[3,5,6,7]]                              # extract Porosity and AI for a simple 2D example\ndf_subset.head()                                              # preview the new DataFrame \n```", "```py\npor_min = 0.12; por_max = 0.28                                # min and max values for plotting\nAI_min = 1500; AI_max = 6500                                  \nK = 6; max_iter = 100                                         # number of prototypes / categories\ncolmap = {1: 'r', 2: 'g', 3: 'b', 4: 'm', 5: 'c', 6: 'k', 7: 'w'} # color dictionary for up to 7 categories\nprototypes = np.zeros((K,max_iter,2))                         # store the prototypes over iterations\nnorm_prototypes = np.zeros((K,max_iter,2))                    # store the prototypes for the standardized features over iterations \n```", "```py\nplt.subplot(121)                                              # scatter plot our training data \nplt.scatter(df_subset['Porosity'], df['AI'], c=\"black\", alpha = 0.4, linewidths=1.0, edgecolors=\"black\")\nplt.title('Acoustic Impedance vs. Porosity'); plt.xlabel('Porosity (fraction)'); plt.ylabel('Acoustic Impedance (kg/m^3 x m/s x 10^3)')\nplt.xlim(por_min, por_max); plt.ylim(AI_min, AI_max); add_grid();\n\nplt.subplot(122)                                              # scatter plot our normalized training data \nplt.scatter(df_subset['Norm_Porosity'], df['Norm_AI'], c=\"black\", alpha = 0.4, linewidths=1.0, edgecolors=\"black\")\nplt.title('Normalized Acoustic Impedance vs. Porosity'); plt.xlabel('Porosity (normalized)'); plt.ylabel('Acoustic Impedance (normalized)')\nplt.xlim(0.0,1.0); plt.ylim(0.0,1.0); add_grid();\nplt.subplots_adjust(left=0.0, bottom=0.0, right=2.0, top=1.0, wspace=0.2, hspace=0.2); plt.show() \n```", "```py\nnp.random.seed(seed)                                          # random number seed for repeatability of the results\ncentroids = {}\nfor i in range(K):                                            # Assign Initial Prototypes \n    norm_por = np.random.random(); por = norm_por * (pormax-pormin) + pormin\n    norm_AI = np.random.random(); AI = norm_AI * (AImax-AImin) + AImin\n    centroids[i+1] = [por,AI,norm_por,norm_AI]; prototypes[i,0] = [por,AI]; norm_prototypes[i,0] = [norm_por,norm_AI]\n\nplt.subplot(121)                                              # plot the training data and K prototypes\nplt.scatter(df_subset['Porosity'], df['AI'],c=\"black\",alpha = 0.4,linewidths=1.0,edgecolors=\"black\",zorder=1,label='Samples')\nfor i in centroids.keys():\n    plt.scatter(centroids.get(i)[0], centroids.get(i)[1],color='white',s=120,marker='o',linewidths=1.0, edgecolors=\"black\",zorder=10)\n    plt.scatter(centroids.get(i)[0], centroids.get(i)[1],color=colmap[i],s=90,marker='*',linewidths=0.5, edgecolors=\"black\",zorder=20,\n                label='Prototype #'+str(i))\nplt.title('Acoustic Impedance vs. Porosity with Initial Prototypes'); plt.xlabel('Porosity (fraction)')\nplt.ylabel('Acoustic Impedance (kg/m^3 x m/s x 10^3)')\nplt.xlim(por_min, por_max); plt.ylim(AI_min, AI_max); add_grid(); plt.legend(loc='upper right')\n\nplt.subplot(122)                                              # plot the training data and K prototypes\nplt.scatter(df_subset['Norm_Porosity'], df['Norm_AI'], c=\"black\", alpha = 0.4, linewidths=1.0, edgecolors=\"black\",label='Samples')\nfor i in centroids.keys():\n    plt.scatter(centroids.get(i)[2], centroids.get(i)[3],color='white',s=120,marker='o',linewidths=1.0, edgecolors=\"black\",zorder=10)\n    plt.scatter(centroids.get(i)[2], centroids.get(i)[3],color=colmap[i],s=90,marker='*',linewidths=0.5, edgecolors=\"black\",zorder=20,\n                label='Prototype #'+str(i))\nplt.title('Normalized Acoustic Impedance vs. Porosity with Initial Prototypes'); plt.xlabel('Porosity (normalized)')\nplt.ylabel('Acoustic Impedance (normalized)')\nplt.xlim([0, 1]); plt.ylim([0, 1]); add_grid(); plt.legend(loc='upper right')\nplt.subplots_adjust(left=0.0, bottom=0.0, right=2.0, top=1.0, wspace=0.2, hspace=0.2); plt.show() \n```", "```py\ndf = assignment(df, centroids) \n```", "```py\nassignment(df, centroids)                                     # assign training data to the nearest prototype\n\nplt.subplot(121)                                              # plot the assigned training data and K prototypes\nplt.scatter(df['Porosity'], df['AI'], color=df['color'], alpha=0.5, edgecolor='k'); plt.scatter(-999,-999,color='white',edgecolors='black',\n                label='Samples')\nfor i in centroids.keys():\n    plt.scatter(centroids.get(i)[0], centroids.get(i)[1],color='white',s=120,marker='o',linewidths=1.0, edgecolors=\"black\",zorder=10)\n    plt.scatter(centroids.get(i)[0], centroids.get(i)[1],color=colmap[i],s=90,marker='*',linewidths=0.5, edgecolors=\"black\",zorder=20,\n                label='Prototype #'+str(i))\nplt.title('Acoustic Impedance vs. Porosity with Initial Prototypes'); plt.xlabel('Porosity (fraction)')\nplt.ylabel('Acoustic Impedance (kg/m^3 x m/s x 10^3)')\nplt.xlim(por_min, por_max); plt.ylim(AI_min, AI_max); add_grid(); plt.legend(loc='upper right')\n\nplt.subplot(122)                                              # plot the normalized training data and K prototypes\nplt.scatter(df_subset['Norm_Porosity'], df['Norm_AI'], c=df['color'], alpha = 0.5, linewidths=1.0, edgecolors=\"black\")\nplt.scatter(-999,-999,color='white',edgecolors='black',label='Samples')\nfor i in centroids.keys():\n    plt.scatter(centroids.get(i)[2], centroids.get(i)[3],color='white',s=120,marker='o',linewidths=1.0, edgecolors=\"black\",zorder=10)\n    plt.scatter(centroids.get(i)[2], centroids.get(i)[3],color=colmap[i],s=90,marker='*',linewidths=0.5, edgecolors=\"black\",zorder=20,\n                label='Prototype #'+str(i))\nplt.title('Normalized Acoustic Impedance vs. Porosity with Initial Prototypes'); plt.xlabel('Porosity (normalized)')\nplt.ylabel('Acoustic Impedance (normalized)')\nplt.xlim([0, 1]); plt.ylim([0, 1]); add_grid(); plt.legend(loc='upper right')\nplt.subplots_adjust(left=0.0, bottom=0.0, right=2.0, top=1.0, wspace=0.2, hspace=0.2); plt.show() \n```", "```py\nold_centroids = copy.deepcopy(centroids)                      # make a deep copy of the centroids for plotting vectors below\nupdate(df,centroids,pormin,pormax,AImin,AImax)                # update the centroids to the new data assignments\n\nplt.subplot(121)                                              # plot the assigned training data and k prototypes\nax = plt.gca()\nplt.scatter(df['Porosity'], df['AI'], color=df['color'], alpha=0.5, edgecolor='k')\nplt.scatter(-999,-999,color='white',edgecolors='black',label='Samples')\nfor i in centroids.keys():\n    plt.scatter(old_centroids.get(i)[0], old_centroids.get(i)[1],color='white',s=120,marker='o',linewidths=1.0,alpha=0.5,\n            edgecolors=\"black\",zorder=10)\n    plt.scatter(old_centroids.get(i)[0], old_centroids.get(i)[1],color=colmap[i],s=90,marker='*',linewidths=0.5,alpha=0.5,\n            edgecolors=\"black\",zorder=20)\n    plt.scatter(centroids.get(i)[0], centroids.get(i)[1],color='white',s=150,marker='o',linewidths=1.0, edgecolors=\"black\",zorder=10)\n    plt.scatter(centroids.get(i)[0], centroids.get(i)[1],color=colmap[i],s=120,marker='*',linewidths=0.5,\n            edgecolors=\"black\",zorder=20,label='Prototype #'+str(i))\n    prototypes[i-1,1] = [centroids[i][0],centroids[i][1]]; norm_prototypes[i-1,1] = [centroids[i][2],centroids[i][3]]\nplt.title('Acoustic Impedance vs. Porosity with Updated Prototypes and Vectors'); plt.xlabel('Porosity (fraction)')\nplt.ylabel('Acoustic Impedance (kg/m^3 x m/s x 10^3)')\nplt.xlim(por_min, por_max); plt.ylim(AI_min, AI_max); add_grid(); plt.legend(loc='upper right')\n\nfor i in old_centroids.keys():                                # plot the vectors\n    old_x = old_centroids[i][0]\n    old_y = old_centroids[i][1]\n    dx = (centroids[i][0] - old_centroids[i][0]) \n    dy = (centroids[i][1] - old_centroids[i][1]) \n    ax.arrow(old_x, old_y, dx, dy,fc=colmap[i], ec=colmap[i]); \n\nplt.subplot(122)                                              # plot the normalized assigned training data and k prototypes\nax = plt.gca()\nplt.scatter(df['Norm_Porosity'], df['Norm_AI'], color=df['color'], alpha=0.5, edgecolor='k')\nplt.scatter(-999,-999,color='white',edgecolors='black',label='Samples')\nfor i in centroids.keys():\n    plt.scatter(old_centroids.get(i)[2], old_centroids.get(i)[3],color='white',s=120,marker='o',linewidths=1.0,alpha=0.5,\n        edgecolors=\"black\",zorder=10)\n    plt.scatter(old_centroids.get(i)[2], old_centroids.get(i)[3],color=colmap[i],s=90,marker='*',linewidths=0.5,alpha=0.5,\n        edgecolors=\"black\",zorder=20)\n    plt.scatter(centroids.get(i)[2], centroids.get(i)[3],color='white',s=150,marker='o',linewidths=1.0, edgecolors=\"black\",zorder=10)\n    plt.scatter(centroids.get(i)[2], centroids.get(i)[3],color=colmap[i],s=120,marker='*',linewidths=0.5, edgecolors=\"black\",zorder=20,\n        label='Prototype #'+str(i))\nplt.title('Normalized Acoustic Impedance vs. Porosity with Updated Prototypes and Vectors'); plt.xlabel('Porosity (normalized)')\nplt.ylabel('Acoustic Impedance (normalized)')\nplt.xlim([0, 1]); plt.ylim([0, 1]); add_grid(); plt.legend(loc='upper right')\n\nfor i in old_centroids.keys():                                # plot the vectors\n    old_x = old_centroids[i][2]\n    old_y = old_centroids[i][3]\n    dx = (centroids[i][2] - old_centroids[i][2]) \n    dy = (centroids[i][3] - old_centroids[i][3]) \n    ax.arrow(old_x, old_y, dx, dy,fc=colmap[i], ec=colmap[i])\n\nplt.subplots_adjust(left=0.0, bottom=0.0, right=2.0, top=1.0, wspace=0.2, hspace=0.2); plt.show() \n```", "```py\nassignment(df, centroids)                                     # assign samples to nearest prototype\n\nplt.subplot(121)                                              # plot the assigned training data and K prototypes\nplt.scatter(df['Porosity'], df['AI'], color=df['color'], alpha=0.5, edgecolor='k'); plt.scatter(-999,-999,color='white',\n    edgecolors='black',label='Samples')\nfor i in centroids.keys():\n    plt.scatter(centroids.get(i)[0], centroids.get(i)[1],color='white',s=120,marker='o',linewidths=1.0, edgecolors=\"black\",zorder=10)\n    plt.scatter(centroids.get(i)[0], centroids.get(i)[1],color=colmap[i],s=90,marker='*',linewidths=0.5, edgecolors=\"black\",zorder=20,\n            label='Prototype #'+str(i))\nplt.title('Acoustic Impedance vs. Porosity with Updated Training Data'); plt.xlabel('Porosity (fraction)')\nplt.ylabel('Acoustic Impedance (kg/m^3 x m/s x 10^3)')\nplt.xlim(por_min, por_max); plt.ylim(AI_min, AI_max); add_grid(); plt.legend(loc='upper right')\n\nplt.subplot(122)                                              # plot the normalized training data and K prototypes\nplt.scatter(df_subset['Norm_Porosity'], df['Norm_AI'], c=df['color'], alpha = 0.4, linewidths=1.0, edgecolors=\"black\")\nplt.scatter(-999,-999,color='white',edgecolors='black',label='Samples')\nfor i in centroids.keys():\n    plt.scatter(centroids.get(i)[2], centroids.get(i)[3],color='white',s=120,marker='o',linewidths=1.0, edgecolors=\"black\",zorder=10)\n    plt.scatter(centroids.get(i)[2], centroids.get(i)[3],color=colmap[i],s=90,marker='*',linewidths=0.5, edgecolors=\"black\",\n            zorder=20,label='Prototype #'+str(i))\nplt.title('Normalized Acoustic Impedance vs. Porosity with Updated Training Data'); plt.xlabel('Porosity (normalized)')\nplt.ylabel('Acoustic Impedance (normalized)')\nplt.xlim([0, 1]); plt.ylim([0, 1]); add_grid(); plt.legend(loc='upper right')\nplt.subplots_adjust(left=0.0, bottom=0.0, right=2.0, top=1.0, wspace=0.2, hspace=0.2); plt.show() \n```", "```py\niteration = 2                                                 # initialize a counter, we already completed iteration 0 and 1 above\nwhile True:\n    closest_centroids = df['closest'].copy(deep=True)\n    update(df,centroids,pormin,pormax,AImin,AImax)\n    for i in centroids.keys():\n        prototypes[i-1,iteration] = [centroids[i][0],centroids[i][1]]\n        norm_prototypes[i-1,iteration] = [centroids[i][2],centroids[i][3]]\n    assignment(df, centroids)\n    if closest_centroids.equals(df['closest']):\n        break\n    iteration = iteration + 1\n\nplt.subplot(121)                                              # plot the assigned training data and K prototypes\nplt.scatter(df['Porosity'], df['AI'], color=df['color'], alpha=0.5, edgecolor='k')\nfor i in centroids.keys():\n    plt.scatter(prototypes[i-1,0,0], prototypes[i-1,0,1],color='white',s=120,marker='o',linewidths=1.0,alpha=0.5,edgecolors=\"black\",zorder=10)\n    plt.scatter(prototypes[i-1,0,0], prototypes[i-1,0,1],color=colmap[i],s=90,marker='*',linewidths=0.5,alpha=0.5,edgecolors=\"black\",zorder=20)\n    plt.scatter(centroids.get(i)[0], centroids.get(i)[1],color='white',s=120,marker='o',linewidths=1.0, edgecolors=\"black\",zorder=10)\n    plt.scatter(centroids.get(i)[0], centroids.get(i)[1],color=colmap[i],s=90,marker='*',linewidths=0.5, edgecolors=\"black\",\n        zorder=20,label='Prototype #'+str(i))\n    plt.plot(prototypes[i-1,:iteration+1,0],prototypes[i-1,:iteration+1,1],color=colmap[i],zorder = 1)\nplt.title('Acoustic Impedance vs. Porosity with Final Prototypes'); plt.xlabel('Porosity (fraction)')\nplt.ylabel('Acoustic Impedance (kg/m^3 x m/s x 10^3)')\nplt.xlim(por_min, por_max); plt.ylim(AI_min, AI_max); add_grid(); plt.legend(loc='upper right')\n\nplt.subplot(122)                                              # plot the training data and K prototypes\nplt.scatter(df_subset['Norm_Porosity'], df['Norm_AI'], c=df['color'], alpha = 0.4, linewidths=1.0, edgecolors=\"black\")\nfor i in centroids.keys():\n    plt.scatter(norm_prototypes[i-1,0,0], norm_prototypes[i-1,0,1],color='white',s=120,marker='o',linewidths=1.0,alpha=0.5,\n            edgecolors=\"black\",zorder=10)\n    plt.scatter(norm_prototypes[i-1,0,0], norm_prototypes[i-1,0,1],color=colmap[i],s=90,marker='*',linewidths=0.5,alpha=0.5,\n            edgecolors=\"black\",zorder=20)\n    plt.scatter(centroids.get(i)[2], centroids.get(i)[3],color='white',s=120,marker='o',linewidths=1.0, edgecolors=\"black\",zorder=10)\n    plt.scatter(centroids.get(i)[2], centroids.get(i)[3],color=colmap[i],s=90,marker='*',linewidths=0.5, edgecolors=\"black\",\n            zorder=20,label='Prototype #'+str(i))\n    plt.plot(norm_prototypes[i-1,:iteration+1,0],norm_prototypes[i-1,:iteration+1,1],color=colmap[i],zorder = 1)\nplt.title('Normalized Acoustic Impedance vs. Porosity with Final Prototypes'); plt.xlabel('Porosity (normalized)')\nplt.ylabel('Acoustic Impedance (normalized)')\nplt.xlim([0, 1]); plt.ylim([0, 1]); add_grid(); plt.legend(loc='upper right')\nplt.subplots_adjust(left=0.0, bottom=0.0, right=2.0, top=1.0, wspace=0.2, hspace=0.2); plt.show() \n```", "```py\nK = 2                                                         # number categories / clusters \n\nkmeans = KMeans(n_clusters=K, random_state=seed, n_init = 100).fit(df.loc[:,['Norm_Porosity','Norm_AI']]) # k-means clustering\ndf['kMeans'] = kmeans.labels_ + 1\n\nplt.subplot(111)                                              # plot the training data and K prototypes\nplt.scatter(df_subset['Norm_Porosity'], df['Norm_AI'], c=df['kMeans'], alpha = 0.4, linewidths=1.0, edgecolors=\"black\")\nplt.title('Normalized Acoustic Impedance vs. Porosity with Final Prototypes'); plt.xlabel('Porosity (normalized)')\nplt.ylabel('Acoustic Impedance (normalized)')\nplt.xlim([0, 1]); plt.ylim([0, 1]); add_grid()\nplt.subplots_adjust(left=0.0, bottom=0.0, right=1.0, top=1.1, wspace=0.2, hspace=0.2) \n```", "```py\nmax_K = 50                                                    # maximum number of clusters, k\noptimal_k = 13\n\ninertia = []\nfor k in range(2,max_K+1):                                    # loop over number of clusters and store the inertia\n    kmeans_iter = KMeans(n_clusters=k, random_state=14, n_init = 10).fit(df.loc[:,['Norm_Porosity','Norm_AI']].values)\n    inertia.append(kmeans_iter.inertia_)\n\nplt.scatter(range(2,max_K+1),inertia,c='red',edgecolor='black',zorder=10)\nplt.plot(range(2,max_K+1),inertia,c='red',ls='--',zorder=1)\nplt.xlim(2,max_K); plt.xlabel('Number of Clusters'); plt.ylabel('Inertia'); plt.ylim(bottom=0)\nplt.vlines(optimal_k,0,np.max(inertia),color='black'); plt.annotate('Optimum K = ' + str(optimal_k),[optimal_k+0.5,4.0],rotation=90.0)\nplt.grid(True); plt.title('k-Means Clustering Inertia vs. Number of Clusters')\nplt.xlim([0,max_K+1]); plt.ylim([0, np.max(inertia)]); add_grid()\nplt.subplots_adjust(left=0.0, bottom=0.0, right=1.0, top=1.1, wspace=0.2, hspace=0.2); plt.show() \n```", "```py\nmax_K = 50                                                    # maximum number of clusters, k\n\nsilhouette = []\nfor k in range(2,max_K+1):                                    # loop over number of clusters and store the inertia\n    kmeans_iter = KMeans(n_clusters=k, random_state=14, n_init = 10).fit(df.loc[:,['Norm_Porosity','Norm_AI']].values)\n    score = silhouette_score(df.loc[:,['Norm_Porosity','Norm_AI']].values, kmeans_iter.labels_)\n    silhouette.append(score)\noptimal_k = np.argmax(silhouette) + 2 \n\nplt.scatter(range(2,max_K+1),silhouette,c='red',edgecolor='black',zorder=10)\nplt.annotate('Good Fit',[0.8,0.7],rotation = 90); plt.annotate('Poor Fit',[0.8,-0.9],rotation = 90)\nplt.plot(range(2,max_K+1),silhouette,c='red',ls='--',zorder=1)\nplt.xlim(2,max_K); plt.xlabel('Number of Clusters'); plt.ylabel('Silhouetter Score'); plt.ylim(bottom=0)\nplt.vlines(optimal_k,-1,1,color='black'); plt.annotate('Optimum K = ' + str(optimal_k),[optimal_k+0.5,-0.75],rotation=90.0)\nplt.grid(True); plt.title('Silhouetter Score vs. Number of Clusters')\nplt.xlim([0,max_K+1]); plt.ylim([-1,1]); add_grid()\nplt.subplots_adjust(left=0.0, bottom=0.0, right=1.0, top=1.1, wspace=0.2, hspace=0.2); plt.show() \n```", "```py\nplt.subplot(121)                                              # scatter plot our training data \nplt.scatter(df_subset['Porosity'], df['AI'], c=\"black\", alpha = 0.4, linewidths=1.0, edgecolors=\"black\")\nplt.title('Acoustic Impedance vs. Porosity'); plt.xlabel('Porosity (fraction)'); plt.ylabel('Acoustic Impedance (kg/m^3 x m/s x 10^3)')\nplt.xlim(por_min, por_max); plt.ylim(AI_min, AI_max); add_grid();\nplt.gca().set_aspect('equal', adjustable='box') \n```", "```py\nK = 5                                                         # number categories / clusters \n\nkmeans = KMeans(n_clusters=K, random_state=seed, n_init = 100).fit(df.loc[:,['Porosity','AI']]) # k-means clustering\ndf['kMeans_Orig'] = kmeans.labels_ + 1\n\nplt.subplot(111)                                              # plot the training data and K prototypes\nplt.scatter(df_subset['Norm_Porosity'], df['Norm_AI'], c=df['kMeans_Orig'], alpha = 0.4, linewidths=1.0, edgecolors=\"black\")\nplt.title('Normalized Acoustic Impedance vs. Porosity with Final Prototypes'); plt.xlabel('Porosity (normalized)')\nplt.ylabel('Acoustic Impedance (normalized)')\nplt.xlim([0, 1]); plt.ylim([0, 1]); add_grid()\nplt.subplots_adjust(left=0.0, bottom=0.0, right=1.0, top=1.1, wspace=0.2, hspace=0.2) \n```", "```py\nidata = 0                                                     # select the dataset\n\nif idata == 0:\n    df_new = pd.read_csv('https://raw.githubusercontent.com/GeostatsGuy/GeoDataSets/master/unconv_MV_v4.csv') # load data from Dr. Pyrcz's GitHub repository \n    df_new.drop(['Well','Prod'],axis=1,inplace=True)          # remove well index and response feature\n\n    features = df_new.columns.values.tolist()                 # store the names of the features\n\n    xmin_new = [6.0,0.0,1.0,10.0,0.0,0.9]; xmax_new = [24.0,10.0,5.0,85.0,2.2,2.9] # set the minimum and maximum values for plotting\n\n    flabel_new = ['Porosity (%)','Permeability (mD)','Acoustic Impedance (kg/m2s*10^6)','Brittleness Ratio (%)', # set the names for plotting\n             'Total Organic Carbon (%)','Vitrinite Reflectance (%)']\n\n    ftitle_new = ['Porosity','Permeability','Acoustic Impedance','Brittleness Ratio', # set the units for plotting\n             'Total Organic Carbon','Vitrinite Reflectance']\n\nelif idata == 1:\n    names = {'Porosity':'Por'}\n\n    df_new = pd.read_csv('https://raw.githubusercontent.com/GeostatsGuy/GeoDataSets/master/12_sample_data.csv') # load data from Dr. Pyrcz's GitHub repository \n    df_new.drop(['X','Y','Unnamed: 0'],axis=1,inplace=True)   # remove response feature\n    df_new = df_new.rename(columns=names)\n\n    features = df_new.columns.values.tolist()                 # store the names of the features\n\n    xmin_new = [0.0,0.0,0.0,4.0,0.0,6.5,1.4,1600.0,10.0,1300.0,1.6]; xmax_new = [10000.0,10000.0,1.0,19.0,500.0,8.3,3.6,6200.0,50.0,2000.0,12.0] # set the minimum and maximum values for plotting\n\n    flabel_new = ['Well (ID)','X (m)','Y (m)','Depth (m)','Porosity (fraction)','Permeability (mD)','Acoustic Impedance (kg/m2s*10^6)','Facies (categorical)',\n              'Density (g/cm^3)','Compressible velocity (m/s)','Youngs modulus (GPa)', 'Shear velocity (m/s)', 'Shear modulus (GPa)'] # set the names for plotting\n\n    ftitle_new = ['Well','X','Y','Depth','Porosity','Permeability','Acoustic Impedance','Facies',\n              'Density','Compressible velocity','Youngs modulus', 'Shear velocity', 'Shear modulus']\n\nelif idata == 2:  \n    df_new = pd.read_csv('https://raw.githubusercontent.com/GeostatsGuy/GeoDataSets/master/res21_2D_wells.csv') # load data from Dr. Pyrcz's GitHub repository \n    df_new.drop(['Well_ID','X','Y','CumulativeOil'],axis=1,inplace=True) # remove Well Index, X and Y coordinates, and response feature\n    df_new = df_new.dropna(how='any',inplace=False)\n\n    features = df_new.columns.values.tolist()                 # store the names of the features\n\n    xmin_new = [1,0.0,0.0,4.0,0.0,6.5,1.4,1600.0,10.0,1300.0,1.6]; xmax_new = [73,10000.0,10000.0,19.0,500.0,8.3,3.6,6200.0,50.0,2000.0,12.0] # set the minimum and maximum values for plotting\n\n    flabel_new = ['Well (ID)','X (m)','Y (m)','Depth (m)','Porosity (fraction)','Permeability (mD)','Acoustic Impedance (kg/m2s*10^6)','Facies (categorical)',\n              'Density (g/cm^3)','Compressible velocity (m/s)','Youngs modulus (GPa)', 'Shear velocity (m/s)', 'Shear modulus (GPa)'] # set the names for plotting\n\n    ftitle_new = ['Well','X','Y','Depth','Porosity','Permeability','Acoustic Impedance','Facies',\n              'Density','Compressible velocity','Youngs modulus', 'Shear velocity', 'Shear modulus']\n\ndf_new[df_new.columns] = MinMaxScaler().fit_transform(df_new) # min/max normalize all the features\ndf_new.head(n=13) \n```", "```py\nmax_K = min(len(df_new)-1,20)                                 # maximum number of clusters, K\n\nsilhouette = []\nfor k in range(2,max_K+1):                                    # loop over number of clusters and store the inertia\n    kmeans_iter = KMeans(n_clusters=k, random_state=14, n_init = 10).fit(df_new.values)\n    score = silhouette_score(df_new.values, kmeans_iter.labels_)\n    silhouette.append(score)\noptimal_k = np.argmax(silhouette) + 2 \n\nkmeans = KMeans(n_clusters=optimal_k, random_state=seed, n_init = 100).fit(df_new.values) # k-means clustering\ndf_new['Kmeans'] = kmeans.labels_ + 1\n\nplt.subplot(111)\nplt.scatter(range(2,max_K+1),silhouette,c='red',edgecolor='black',zorder=10)\nplt.annotate('Good Fit',[0.8,0.7],rotation = 90); plt.annotate('Poor Fit',[0.8,-0.9],rotation = 90)\nplt.plot(range(2,max_K+1),silhouette,c='red',ls='--',zorder=1)\nplt.xlim(2,max_K); plt.xlabel('Number of Clusters'); plt.ylabel('Silhouetter Score'); plt.ylim(bottom=0)\nplt.vlines(optimal_k,-1,1,color='black'); plt.annotate('Optimum K = ' + str(optimal_k),[optimal_k+0.5,-0.75],rotation=90.0)\nplt.grid(True); plt.title('Silhouetter Score vs. Number of Clusters')\nplt.xlim([0,max_K+1]); plt.ylim([-1,1]); add_grid()\n\nplt.subplots_adjust(left=0.0, bottom=0.0, right=1.0, top=1.1, wspace=0.2, hspace=0.2); plt.show() \n```", "```py\nsns.pairplot(df_new.iloc[:,:], hue=\"Kmeans\", plot_kws={'alpha':1.0,'s':50}, palette = 'colorblind', corner=True) # matrix scatter plot\nplt.subplots_adjust(left=0.0, bottom=0.0, right=0.6, top=0.7, wspace=0.2, hspace=0.2); plt.show() \n```", "```py\nsave_clusters = False                                         # save the imputed DataFrame?\n\nif save_clusters == True:\n    folder = r'C:\\Local'\n    file_name = r'dataframe_cluster.csv'\n\n    df_new.to_csv(folder + \"/\" + file_name, index=False) \n```", "```py\nignore_warnings = True                                        # ignore warnings?\nimport numpy as np                                            # ndarrays for gridded data\nimport pandas as pd                                           # DataFrames for tabular data\nimport copy                                                   # for deep copies\nimport os                                                     # set working directory, run executables\nimport matplotlib.pyplot as plt                               # for plotting\nfrom matplotlib.ticker import (MultipleLocator, AutoMinorLocator) # control of axes ticks\nimport matplotlib.ticker as mtick                             # control tick label formatting\nimport seaborn as sns                                         # for matrix scatter plots\nfrom sklearn.preprocessing import MinMaxScaler                # min/max normalization\nfrom sklearn.metrics import silhouette_score                  # calculating the optimum K number of clusters\nfrom sklearn.cluster import KMeans                            # k-means clustering\nplt.rc('axes', axisbelow=True)                                # plot all grids below the plot elements\nif ignore_warnings == True:                                   \n    import warnings\n    warnings.filterwarnings('ignore')\ncmap = plt.cm.inferno                                         # color map\nseed = 42                                                     # random number seed \n```", "```py\n# Assignment function to assigned training data to the nearest prototype (code modified from Ben Keen, http://benalexkeen.com/k-means-clustering-in-python/)\ndef assignment(df,centroids):\n    for i in centroids.keys():\n        df['distance_from_{}'.format(i)] = (                  # use the normalized features and centroids\n            np.sqrt(\n                (df['Norm_Porosity'] - centroids[i][2]) ** 2\n                + (df['Norm_AI'] - centroids[i][3]) ** 2\n            )\n        )\n    centroid_distance_cols = ['distance_from_{}'.format(i) for i in centroids.keys()]\n    df['closest'] = df.loc[:, centroid_distance_cols].idxmin(axis=1)\n    df['closest'] = df['closest'].map(lambda x: int(x.lstrip('distance_from_')))\n    df['color'] = df['closest'].map(lambda x: colmap[x])\n    return\n\n# Update function to shift the prototype to the centroid of the training data assigned to the prototype (code modified from Ben Keen, http://benalexkeen.com/k-means-clustering-in-python/)\ndef update(df,centroids,x1min,x1max,x2min,x2max):\n    for i in centroids.keys():\n        centroids[i][2] = np.mean(df[df['closest'] == i]['Norm_Porosity'])\n        centroids[i][3] = np.mean(df[df['closest'] == i]['Norm_AI'])\n        centroids[i][0] = centroids[i][2] * (x1max-x1min) + x1min\n        centroids[i][1] = centroids[i][3] * (x2max-x2min) + x2min\n    return\n\ndef add_grid():\n    plt.gca().grid(True, which='major',linewidth = 1.0); plt.gca().grid(True, which='minor',linewidth = 0.2) # add y grids\n    plt.gca().tick_params(which='major',length=7); plt.gca().tick_params(which='minor', length=4)\n    plt.gca().xaxis.set_minor_locator(AutoMinorLocator()); plt.gca().yaxis.set_minor_locator(AutoMinorLocator()) # turn on minor ticks \n```", "```py\n#os.chdir(\"C:/PGE383\")                                        # set the working directory with the input data file \n```", "```py\nimport pandas as pd \n```", "```py\npd.read_csv() \n```", "```py\ndf = pd.read_csv(\"12_sample_data.csv\") \n```", "```py\ndf = df.sample(frac=.30, random_state = 73073); \ndf = df.reset_index() \n```", "```py\n#df = pd.read_csv('12_sample_data.csv')                       # load our data table from the current directory\ndf = pd.read_csv('https://raw.githubusercontent.com/GeostatsGuy/GeoDataSets/master/12_sample_data.csv') # or from GtiHub\ndf = df.iloc[:,1:]                                            # remove a null column \ndf = df.sample(frac=.30, random_state = seed); df = df.reset_index(drop=True) # extract 30% random to reduce the number of data \n```", "```py\ndf.describe().transpose()                                     # DataFrame summary statistics \n```", "```py\npormin = df['Porosity'].min(); pormax = df['Porosity'].max()  # find min and max for each feature\nAImin = df['AI'].min(); AImax = df['AI'].max()\n\ndf['Norm_Porosity'] = (df['Porosity']-pormin)/(pormax - pormin) # normalize each feature, this broadcasts over all samples in the DataFrame\ndf['Norm_AI'] = (df['AI']-AImin)/(AImax - AImin)                            # and appends a new normalized feature for each \n```", "```py\nfrom sklearn.preprocessing import MinMaxScaler\nscaler = MinMaxScaler()\nX_normalized = scaler.fit_transform(X) \n```", "```py\ndf.describe().transpose()                                     # summary statistics for the DataFrame \n```", "```py\ndf_subset = df.iloc[:,[3,5,6,7]]                              # extract Porosity and AI for a simple 2D example\ndf_subset.head()                                              # preview the new DataFrame \n```", "```py\npor_min = 0.12; por_max = 0.28                                # min and max values for plotting\nAI_min = 1500; AI_max = 6500                                  \nK = 6; max_iter = 100                                         # number of prototypes / categories\ncolmap = {1: 'r', 2: 'g', 3: 'b', 4: 'm', 5: 'c', 6: 'k', 7: 'w'} # color dictionary for up to 7 categories\nprototypes = np.zeros((K,max_iter,2))                         # store the prototypes over iterations\nnorm_prototypes = np.zeros((K,max_iter,2))                    # store the prototypes for the standardized features over iterations \n```", "```py\nplt.subplot(121)                                              # scatter plot our training data \nplt.scatter(df_subset['Porosity'], df['AI'], c=\"black\", alpha = 0.4, linewidths=1.0, edgecolors=\"black\")\nplt.title('Acoustic Impedance vs. Porosity'); plt.xlabel('Porosity (fraction)'); plt.ylabel('Acoustic Impedance (kg/m^3 x m/s x 10^3)')\nplt.xlim(por_min, por_max); plt.ylim(AI_min, AI_max); add_grid();\n\nplt.subplot(122)                                              # scatter plot our normalized training data \nplt.scatter(df_subset['Norm_Porosity'], df['Norm_AI'], c=\"black\", alpha = 0.4, linewidths=1.0, edgecolors=\"black\")\nplt.title('Normalized Acoustic Impedance vs. Porosity'); plt.xlabel('Porosity (normalized)'); plt.ylabel('Acoustic Impedance (normalized)')\nplt.xlim(0.0,1.0); plt.ylim(0.0,1.0); add_grid();\nplt.subplots_adjust(left=0.0, bottom=0.0, right=2.0, top=1.0, wspace=0.2, hspace=0.2); plt.show() \n```", "```py\nnp.random.seed(seed)                                          # random number seed for repeatability of the results\ncentroids = {}\nfor i in range(K):                                            # Assign Initial Prototypes \n    norm_por = np.random.random(); por = norm_por * (pormax-pormin) + pormin\n    norm_AI = np.random.random(); AI = norm_AI * (AImax-AImin) + AImin\n    centroids[i+1] = [por,AI,norm_por,norm_AI]; prototypes[i,0] = [por,AI]; norm_prototypes[i,0] = [norm_por,norm_AI]\n\nplt.subplot(121)                                              # plot the training data and K prototypes\nplt.scatter(df_subset['Porosity'], df['AI'],c=\"black\",alpha = 0.4,linewidths=1.0,edgecolors=\"black\",zorder=1,label='Samples')\nfor i in centroids.keys():\n    plt.scatter(centroids.get(i)[0], centroids.get(i)[1],color='white',s=120,marker='o',linewidths=1.0, edgecolors=\"black\",zorder=10)\n    plt.scatter(centroids.get(i)[0], centroids.get(i)[1],color=colmap[i],s=90,marker='*',linewidths=0.5, edgecolors=\"black\",zorder=20,\n                label='Prototype #'+str(i))\nplt.title('Acoustic Impedance vs. Porosity with Initial Prototypes'); plt.xlabel('Porosity (fraction)')\nplt.ylabel('Acoustic Impedance (kg/m^3 x m/s x 10^3)')\nplt.xlim(por_min, por_max); plt.ylim(AI_min, AI_max); add_grid(); plt.legend(loc='upper right')\n\nplt.subplot(122)                                              # plot the training data and K prototypes\nplt.scatter(df_subset['Norm_Porosity'], df['Norm_AI'], c=\"black\", alpha = 0.4, linewidths=1.0, edgecolors=\"black\",label='Samples')\nfor i in centroids.keys():\n    plt.scatter(centroids.get(i)[2], centroids.get(i)[3],color='white',s=120,marker='o',linewidths=1.0, edgecolors=\"black\",zorder=10)\n    plt.scatter(centroids.get(i)[2], centroids.get(i)[3],color=colmap[i],s=90,marker='*',linewidths=0.5, edgecolors=\"black\",zorder=20,\n                label='Prototype #'+str(i))\nplt.title('Normalized Acoustic Impedance vs. Porosity with Initial Prototypes'); plt.xlabel('Porosity (normalized)')\nplt.ylabel('Acoustic Impedance (normalized)')\nplt.xlim([0, 1]); plt.ylim([0, 1]); add_grid(); plt.legend(loc='upper right')\nplt.subplots_adjust(left=0.0, bottom=0.0, right=2.0, top=1.0, wspace=0.2, hspace=0.2); plt.show() \n```", "```py\ndf = assignment(df, centroids) \n```", "```py\nassignment(df, centroids)                                     # assign training data to the nearest prototype\n\nplt.subplot(121)                                              # plot the assigned training data and K prototypes\nplt.scatter(df['Porosity'], df['AI'], color=df['color'], alpha=0.5, edgecolor='k'); plt.scatter(-999,-999,color='white',edgecolors='black',\n                label='Samples')\nfor i in centroids.keys():\n    plt.scatter(centroids.get(i)[0], centroids.get(i)[1],color='white',s=120,marker='o',linewidths=1.0, edgecolors=\"black\",zorder=10)\n    plt.scatter(centroids.get(i)[0], centroids.get(i)[1],color=colmap[i],s=90,marker='*',linewidths=0.5, edgecolors=\"black\",zorder=20,\n                label='Prototype #'+str(i))\nplt.title('Acoustic Impedance vs. Porosity with Initial Prototypes'); plt.xlabel('Porosity (fraction)')\nplt.ylabel('Acoustic Impedance (kg/m^3 x m/s x 10^3)')\nplt.xlim(por_min, por_max); plt.ylim(AI_min, AI_max); add_grid(); plt.legend(loc='upper right')\n\nplt.subplot(122)                                              # plot the normalized training data and K prototypes\nplt.scatter(df_subset['Norm_Porosity'], df['Norm_AI'], c=df['color'], alpha = 0.5, linewidths=1.0, edgecolors=\"black\")\nplt.scatter(-999,-999,color='white',edgecolors='black',label='Samples')\nfor i in centroids.keys():\n    plt.scatter(centroids.get(i)[2], centroids.get(i)[3],color='white',s=120,marker='o',linewidths=1.0, edgecolors=\"black\",zorder=10)\n    plt.scatter(centroids.get(i)[2], centroids.get(i)[3],color=colmap[i],s=90,marker='*',linewidths=0.5, edgecolors=\"black\",zorder=20,\n                label='Prototype #'+str(i))\nplt.title('Normalized Acoustic Impedance vs. Porosity with Initial Prototypes'); plt.xlabel('Porosity (normalized)')\nplt.ylabel('Acoustic Impedance (normalized)')\nplt.xlim([0, 1]); plt.ylim([0, 1]); add_grid(); plt.legend(loc='upper right')\nplt.subplots_adjust(left=0.0, bottom=0.0, right=2.0, top=1.0, wspace=0.2, hspace=0.2); plt.show() \n```", "```py\nold_centroids = copy.deepcopy(centroids)                      # make a deep copy of the centroids for plotting vectors below\nupdate(df,centroids,pormin,pormax,AImin,AImax)                # update the centroids to the new data assignments\n\nplt.subplot(121)                                              # plot the assigned training data and k prototypes\nax = plt.gca()\nplt.scatter(df['Porosity'], df['AI'], color=df['color'], alpha=0.5, edgecolor='k')\nplt.scatter(-999,-999,color='white',edgecolors='black',label='Samples')\nfor i in centroids.keys():\n    plt.scatter(old_centroids.get(i)[0], old_centroids.get(i)[1],color='white',s=120,marker='o',linewidths=1.0,alpha=0.5,\n            edgecolors=\"black\",zorder=10)\n    plt.scatter(old_centroids.get(i)[0], old_centroids.get(i)[1],color=colmap[i],s=90,marker='*',linewidths=0.5,alpha=0.5,\n            edgecolors=\"black\",zorder=20)\n    plt.scatter(centroids.get(i)[0], centroids.get(i)[1],color='white',s=150,marker='o',linewidths=1.0, edgecolors=\"black\",zorder=10)\n    plt.scatter(centroids.get(i)[0], centroids.get(i)[1],color=colmap[i],s=120,marker='*',linewidths=0.5,\n            edgecolors=\"black\",zorder=20,label='Prototype #'+str(i))\n    prototypes[i-1,1] = [centroids[i][0],centroids[i][1]]; norm_prototypes[i-1,1] = [centroids[i][2],centroids[i][3]]\nplt.title('Acoustic Impedance vs. Porosity with Updated Prototypes and Vectors'); plt.xlabel('Porosity (fraction)')\nplt.ylabel('Acoustic Impedance (kg/m^3 x m/s x 10^3)')\nplt.xlim(por_min, por_max); plt.ylim(AI_min, AI_max); add_grid(); plt.legend(loc='upper right')\n\nfor i in old_centroids.keys():                                # plot the vectors\n    old_x = old_centroids[i][0]\n    old_y = old_centroids[i][1]\n    dx = (centroids[i][0] - old_centroids[i][0]) \n    dy = (centroids[i][1] - old_centroids[i][1]) \n    ax.arrow(old_x, old_y, dx, dy,fc=colmap[i], ec=colmap[i]); \n\nplt.subplot(122)                                              # plot the normalized assigned training data and k prototypes\nax = plt.gca()\nplt.scatter(df['Norm_Porosity'], df['Norm_AI'], color=df['color'], alpha=0.5, edgecolor='k')\nplt.scatter(-999,-999,color='white',edgecolors='black',label='Samples')\nfor i in centroids.keys():\n    plt.scatter(old_centroids.get(i)[2], old_centroids.get(i)[3],color='white',s=120,marker='o',linewidths=1.0,alpha=0.5,\n        edgecolors=\"black\",zorder=10)\n    plt.scatter(old_centroids.get(i)[2], old_centroids.get(i)[3],color=colmap[i],s=90,marker='*',linewidths=0.5,alpha=0.5,\n        edgecolors=\"black\",zorder=20)\n    plt.scatter(centroids.get(i)[2], centroids.get(i)[3],color='white',s=150,marker='o',linewidths=1.0, edgecolors=\"black\",zorder=10)\n    plt.scatter(centroids.get(i)[2], centroids.get(i)[3],color=colmap[i],s=120,marker='*',linewidths=0.5, edgecolors=\"black\",zorder=20,\n        label='Prototype #'+str(i))\nplt.title('Normalized Acoustic Impedance vs. Porosity with Updated Prototypes and Vectors'); plt.xlabel('Porosity (normalized)')\nplt.ylabel('Acoustic Impedance (normalized)')\nplt.xlim([0, 1]); plt.ylim([0, 1]); add_grid(); plt.legend(loc='upper right')\n\nfor i in old_centroids.keys():                                # plot the vectors\n    old_x = old_centroids[i][2]\n    old_y = old_centroids[i][3]\n    dx = (centroids[i][2] - old_centroids[i][2]) \n    dy = (centroids[i][3] - old_centroids[i][3]) \n    ax.arrow(old_x, old_y, dx, dy,fc=colmap[i], ec=colmap[i])\n\nplt.subplots_adjust(left=0.0, bottom=0.0, right=2.0, top=1.0, wspace=0.2, hspace=0.2); plt.show() \n```", "```py\nassignment(df, centroids)                                     # assign samples to nearest prototype\n\nplt.subplot(121)                                              # plot the assigned training data and K prototypes\nplt.scatter(df['Porosity'], df['AI'], color=df['color'], alpha=0.5, edgecolor='k'); plt.scatter(-999,-999,color='white',\n    edgecolors='black',label='Samples')\nfor i in centroids.keys():\n    plt.scatter(centroids.get(i)[0], centroids.get(i)[1],color='white',s=120,marker='o',linewidths=1.0, edgecolors=\"black\",zorder=10)\n    plt.scatter(centroids.get(i)[0], centroids.get(i)[1],color=colmap[i],s=90,marker='*',linewidths=0.5, edgecolors=\"black\",zorder=20,\n            label='Prototype #'+str(i))\nplt.title('Acoustic Impedance vs. Porosity with Updated Training Data'); plt.xlabel('Porosity (fraction)')\nplt.ylabel('Acoustic Impedance (kg/m^3 x m/s x 10^3)')\nplt.xlim(por_min, por_max); plt.ylim(AI_min, AI_max); add_grid(); plt.legend(loc='upper right')\n\nplt.subplot(122)                                              # plot the normalized training data and K prototypes\nplt.scatter(df_subset['Norm_Porosity'], df['Norm_AI'], c=df['color'], alpha = 0.4, linewidths=1.0, edgecolors=\"black\")\nplt.scatter(-999,-999,color='white',edgecolors='black',label='Samples')\nfor i in centroids.keys():\n    plt.scatter(centroids.get(i)[2], centroids.get(i)[3],color='white',s=120,marker='o',linewidths=1.0, edgecolors=\"black\",zorder=10)\n    plt.scatter(centroids.get(i)[2], centroids.get(i)[3],color=colmap[i],s=90,marker='*',linewidths=0.5, edgecolors=\"black\",\n            zorder=20,label='Prototype #'+str(i))\nplt.title('Normalized Acoustic Impedance vs. Porosity with Updated Training Data'); plt.xlabel('Porosity (normalized)')\nplt.ylabel('Acoustic Impedance (normalized)')\nplt.xlim([0, 1]); plt.ylim([0, 1]); add_grid(); plt.legend(loc='upper right')\nplt.subplots_adjust(left=0.0, bottom=0.0, right=2.0, top=1.0, wspace=0.2, hspace=0.2); plt.show() \n```", "```py\niteration = 2                                                 # initialize a counter, we already completed iteration 0 and 1 above\nwhile True:\n    closest_centroids = df['closest'].copy(deep=True)\n    update(df,centroids,pormin,pormax,AImin,AImax)\n    for i in centroids.keys():\n        prototypes[i-1,iteration] = [centroids[i][0],centroids[i][1]]\n        norm_prototypes[i-1,iteration] = [centroids[i][2],centroids[i][3]]\n    assignment(df, centroids)\n    if closest_centroids.equals(df['closest']):\n        break\n    iteration = iteration + 1\n\nplt.subplot(121)                                              # plot the assigned training data and K prototypes\nplt.scatter(df['Porosity'], df['AI'], color=df['color'], alpha=0.5, edgecolor='k')\nfor i in centroids.keys():\n    plt.scatter(prototypes[i-1,0,0], prototypes[i-1,0,1],color='white',s=120,marker='o',linewidths=1.0,alpha=0.5,edgecolors=\"black\",zorder=10)\n    plt.scatter(prototypes[i-1,0,0], prototypes[i-1,0,1],color=colmap[i],s=90,marker='*',linewidths=0.5,alpha=0.5,edgecolors=\"black\",zorder=20)\n    plt.scatter(centroids.get(i)[0], centroids.get(i)[1],color='white',s=120,marker='o',linewidths=1.0, edgecolors=\"black\",zorder=10)\n    plt.scatter(centroids.get(i)[0], centroids.get(i)[1],color=colmap[i],s=90,marker='*',linewidths=0.5, edgecolors=\"black\",\n        zorder=20,label='Prototype #'+str(i))\n    plt.plot(prototypes[i-1,:iteration+1,0],prototypes[i-1,:iteration+1,1],color=colmap[i],zorder = 1)\nplt.title('Acoustic Impedance vs. Porosity with Final Prototypes'); plt.xlabel('Porosity (fraction)')\nplt.ylabel('Acoustic Impedance (kg/m^3 x m/s x 10^3)')\nplt.xlim(por_min, por_max); plt.ylim(AI_min, AI_max); add_grid(); plt.legend(loc='upper right')\n\nplt.subplot(122)                                              # plot the training data and K prototypes\nplt.scatter(df_subset['Norm_Porosity'], df['Norm_AI'], c=df['color'], alpha = 0.4, linewidths=1.0, edgecolors=\"black\")\nfor i in centroids.keys():\n    plt.scatter(norm_prototypes[i-1,0,0], norm_prototypes[i-1,0,1],color='white',s=120,marker='o',linewidths=1.0,alpha=0.5,\n            edgecolors=\"black\",zorder=10)\n    plt.scatter(norm_prototypes[i-1,0,0], norm_prototypes[i-1,0,1],color=colmap[i],s=90,marker='*',linewidths=0.5,alpha=0.5,\n            edgecolors=\"black\",zorder=20)\n    plt.scatter(centroids.get(i)[2], centroids.get(i)[3],color='white',s=120,marker='o',linewidths=1.0, edgecolors=\"black\",zorder=10)\n    plt.scatter(centroids.get(i)[2], centroids.get(i)[3],color=colmap[i],s=90,marker='*',linewidths=0.5, edgecolors=\"black\",\n            zorder=20,label='Prototype #'+str(i))\n    plt.plot(norm_prototypes[i-1,:iteration+1,0],norm_prototypes[i-1,:iteration+1,1],color=colmap[i],zorder = 1)\nplt.title('Normalized Acoustic Impedance vs. Porosity with Final Prototypes'); plt.xlabel('Porosity (normalized)')\nplt.ylabel('Acoustic Impedance (normalized)')\nplt.xlim([0, 1]); plt.ylim([0, 1]); add_grid(); plt.legend(loc='upper right')\nplt.subplots_adjust(left=0.0, bottom=0.0, right=2.0, top=1.0, wspace=0.2, hspace=0.2); plt.show() \n```", "```py\nnp.random.seed(seed)                                          # random number seed for repeatability of the results\ncentroids = {}\nfor i in range(K):                                            # Assign Initial Prototypes \n    norm_por = np.random.random(); por = norm_por * (pormax-pormin) + pormin\n    norm_AI = np.random.random(); AI = norm_AI * (AImax-AImin) + AImin\n    centroids[i+1] = [por,AI,norm_por,norm_AI]; prototypes[i,0] = [por,AI]; norm_prototypes[i,0] = [norm_por,norm_AI]\n\nplt.subplot(121)                                              # plot the training data and K prototypes\nplt.scatter(df_subset['Porosity'], df['AI'],c=\"black\",alpha = 0.4,linewidths=1.0,edgecolors=\"black\",zorder=1,label='Samples')\nfor i in centroids.keys():\n    plt.scatter(centroids.get(i)[0], centroids.get(i)[1],color='white',s=120,marker='o',linewidths=1.0, edgecolors=\"black\",zorder=10)\n    plt.scatter(centroids.get(i)[0], centroids.get(i)[1],color=colmap[i],s=90,marker='*',linewidths=0.5, edgecolors=\"black\",zorder=20,\n                label='Prototype #'+str(i))\nplt.title('Acoustic Impedance vs. Porosity with Initial Prototypes'); plt.xlabel('Porosity (fraction)')\nplt.ylabel('Acoustic Impedance (kg/m^3 x m/s x 10^3)')\nplt.xlim(por_min, por_max); plt.ylim(AI_min, AI_max); add_grid(); plt.legend(loc='upper right')\n\nplt.subplot(122)                                              # plot the training data and K prototypes\nplt.scatter(df_subset['Norm_Porosity'], df['Norm_AI'], c=\"black\", alpha = 0.4, linewidths=1.0, edgecolors=\"black\",label='Samples')\nfor i in centroids.keys():\n    plt.scatter(centroids.get(i)[2], centroids.get(i)[3],color='white',s=120,marker='o',linewidths=1.0, edgecolors=\"black\",zorder=10)\n    plt.scatter(centroids.get(i)[2], centroids.get(i)[3],color=colmap[i],s=90,marker='*',linewidths=0.5, edgecolors=\"black\",zorder=20,\n                label='Prototype #'+str(i))\nplt.title('Normalized Acoustic Impedance vs. Porosity with Initial Prototypes'); plt.xlabel('Porosity (normalized)')\nplt.ylabel('Acoustic Impedance (normalized)')\nplt.xlim([0, 1]); plt.ylim([0, 1]); add_grid(); plt.legend(loc='upper right')\nplt.subplots_adjust(left=0.0, bottom=0.0, right=2.0, top=1.0, wspace=0.2, hspace=0.2); plt.show() \n```", "```py\ndf = assignment(df, centroids) \n```", "```py\nassignment(df, centroids)                                     # assign training data to the nearest prototype\n\nplt.subplot(121)                                              # plot the assigned training data and K prototypes\nplt.scatter(df['Porosity'], df['AI'], color=df['color'], alpha=0.5, edgecolor='k'); plt.scatter(-999,-999,color='white',edgecolors='black',\n                label='Samples')\nfor i in centroids.keys():\n    plt.scatter(centroids.get(i)[0], centroids.get(i)[1],color='white',s=120,marker='o',linewidths=1.0, edgecolors=\"black\",zorder=10)\n    plt.scatter(centroids.get(i)[0], centroids.get(i)[1],color=colmap[i],s=90,marker='*',linewidths=0.5, edgecolors=\"black\",zorder=20,\n                label='Prototype #'+str(i))\nplt.title('Acoustic Impedance vs. Porosity with Initial Prototypes'); plt.xlabel('Porosity (fraction)')\nplt.ylabel('Acoustic Impedance (kg/m^3 x m/s x 10^3)')\nplt.xlim(por_min, por_max); plt.ylim(AI_min, AI_max); add_grid(); plt.legend(loc='upper right')\n\nplt.subplot(122)                                              # plot the normalized training data and K prototypes\nplt.scatter(df_subset['Norm_Porosity'], df['Norm_AI'], c=df['color'], alpha = 0.5, linewidths=1.0, edgecolors=\"black\")\nplt.scatter(-999,-999,color='white',edgecolors='black',label='Samples')\nfor i in centroids.keys():\n    plt.scatter(centroids.get(i)[2], centroids.get(i)[3],color='white',s=120,marker='o',linewidths=1.0, edgecolors=\"black\",zorder=10)\n    plt.scatter(centroids.get(i)[2], centroids.get(i)[3],color=colmap[i],s=90,marker='*',linewidths=0.5, edgecolors=\"black\",zorder=20,\n                label='Prototype #'+str(i))\nplt.title('Normalized Acoustic Impedance vs. Porosity with Initial Prototypes'); plt.xlabel('Porosity (normalized)')\nplt.ylabel('Acoustic Impedance (normalized)')\nplt.xlim([0, 1]); plt.ylim([0, 1]); add_grid(); plt.legend(loc='upper right')\nplt.subplots_adjust(left=0.0, bottom=0.0, right=2.0, top=1.0, wspace=0.2, hspace=0.2); plt.show() \n```", "```py\nold_centroids = copy.deepcopy(centroids)                      # make a deep copy of the centroids for plotting vectors below\nupdate(df,centroids,pormin,pormax,AImin,AImax)                # update the centroids to the new data assignments\n\nplt.subplot(121)                                              # plot the assigned training data and k prototypes\nax = plt.gca()\nplt.scatter(df['Porosity'], df['AI'], color=df['color'], alpha=0.5, edgecolor='k')\nplt.scatter(-999,-999,color='white',edgecolors='black',label='Samples')\nfor i in centroids.keys():\n    plt.scatter(old_centroids.get(i)[0], old_centroids.get(i)[1],color='white',s=120,marker='o',linewidths=1.0,alpha=0.5,\n            edgecolors=\"black\",zorder=10)\n    plt.scatter(old_centroids.get(i)[0], old_centroids.get(i)[1],color=colmap[i],s=90,marker='*',linewidths=0.5,alpha=0.5,\n            edgecolors=\"black\",zorder=20)\n    plt.scatter(centroids.get(i)[0], centroids.get(i)[1],color='white',s=150,marker='o',linewidths=1.0, edgecolors=\"black\",zorder=10)\n    plt.scatter(centroids.get(i)[0], centroids.get(i)[1],color=colmap[i],s=120,marker='*',linewidths=0.5,\n            edgecolors=\"black\",zorder=20,label='Prototype #'+str(i))\n    prototypes[i-1,1] = [centroids[i][0],centroids[i][1]]; norm_prototypes[i-1,1] = [centroids[i][2],centroids[i][3]]\nplt.title('Acoustic Impedance vs. Porosity with Updated Prototypes and Vectors'); plt.xlabel('Porosity (fraction)')\nplt.ylabel('Acoustic Impedance (kg/m^3 x m/s x 10^3)')\nplt.xlim(por_min, por_max); plt.ylim(AI_min, AI_max); add_grid(); plt.legend(loc='upper right')\n\nfor i in old_centroids.keys():                                # plot the vectors\n    old_x = old_centroids[i][0]\n    old_y = old_centroids[i][1]\n    dx = (centroids[i][0] - old_centroids[i][0]) \n    dy = (centroids[i][1] - old_centroids[i][1]) \n    ax.arrow(old_x, old_y, dx, dy,fc=colmap[i], ec=colmap[i]); \n\nplt.subplot(122)                                              # plot the normalized assigned training data and k prototypes\nax = plt.gca()\nplt.scatter(df['Norm_Porosity'], df['Norm_AI'], color=df['color'], alpha=0.5, edgecolor='k')\nplt.scatter(-999,-999,color='white',edgecolors='black',label='Samples')\nfor i in centroids.keys():\n    plt.scatter(old_centroids.get(i)[2], old_centroids.get(i)[3],color='white',s=120,marker='o',linewidths=1.0,alpha=0.5,\n        edgecolors=\"black\",zorder=10)\n    plt.scatter(old_centroids.get(i)[2], old_centroids.get(i)[3],color=colmap[i],s=90,marker='*',linewidths=0.5,alpha=0.5,\n        edgecolors=\"black\",zorder=20)\n    plt.scatter(centroids.get(i)[2], centroids.get(i)[3],color='white',s=150,marker='o',linewidths=1.0, edgecolors=\"black\",zorder=10)\n    plt.scatter(centroids.get(i)[2], centroids.get(i)[3],color=colmap[i],s=120,marker='*',linewidths=0.5, edgecolors=\"black\",zorder=20,\n        label='Prototype #'+str(i))\nplt.title('Normalized Acoustic Impedance vs. Porosity with Updated Prototypes and Vectors'); plt.xlabel('Porosity (normalized)')\nplt.ylabel('Acoustic Impedance (normalized)')\nplt.xlim([0, 1]); plt.ylim([0, 1]); add_grid(); plt.legend(loc='upper right')\n\nfor i in old_centroids.keys():                                # plot the vectors\n    old_x = old_centroids[i][2]\n    old_y = old_centroids[i][3]\n    dx = (centroids[i][2] - old_centroids[i][2]) \n    dy = (centroids[i][3] - old_centroids[i][3]) \n    ax.arrow(old_x, old_y, dx, dy,fc=colmap[i], ec=colmap[i])\n\nplt.subplots_adjust(left=0.0, bottom=0.0, right=2.0, top=1.0, wspace=0.2, hspace=0.2); plt.show() \n```", "```py\nassignment(df, centroids)                                     # assign samples to nearest prototype\n\nplt.subplot(121)                                              # plot the assigned training data and K prototypes\nplt.scatter(df['Porosity'], df['AI'], color=df['color'], alpha=0.5, edgecolor='k'); plt.scatter(-999,-999,color='white',\n    edgecolors='black',label='Samples')\nfor i in centroids.keys():\n    plt.scatter(centroids.get(i)[0], centroids.get(i)[1],color='white',s=120,marker='o',linewidths=1.0, edgecolors=\"black\",zorder=10)\n    plt.scatter(centroids.get(i)[0], centroids.get(i)[1],color=colmap[i],s=90,marker='*',linewidths=0.5, edgecolors=\"black\",zorder=20,\n            label='Prototype #'+str(i))\nplt.title('Acoustic Impedance vs. Porosity with Updated Training Data'); plt.xlabel('Porosity (fraction)')\nplt.ylabel('Acoustic Impedance (kg/m^3 x m/s x 10^3)')\nplt.xlim(por_min, por_max); plt.ylim(AI_min, AI_max); add_grid(); plt.legend(loc='upper right')\n\nplt.subplot(122)                                              # plot the normalized training data and K prototypes\nplt.scatter(df_subset['Norm_Porosity'], df['Norm_AI'], c=df['color'], alpha = 0.4, linewidths=1.0, edgecolors=\"black\")\nplt.scatter(-999,-999,color='white',edgecolors='black',label='Samples')\nfor i in centroids.keys():\n    plt.scatter(centroids.get(i)[2], centroids.get(i)[3],color='white',s=120,marker='o',linewidths=1.0, edgecolors=\"black\",zorder=10)\n    plt.scatter(centroids.get(i)[2], centroids.get(i)[3],color=colmap[i],s=90,marker='*',linewidths=0.5, edgecolors=\"black\",\n            zorder=20,label='Prototype #'+str(i))\nplt.title('Normalized Acoustic Impedance vs. Porosity with Updated Training Data'); plt.xlabel('Porosity (normalized)')\nplt.ylabel('Acoustic Impedance (normalized)')\nplt.xlim([0, 1]); plt.ylim([0, 1]); add_grid(); plt.legend(loc='upper right')\nplt.subplots_adjust(left=0.0, bottom=0.0, right=2.0, top=1.0, wspace=0.2, hspace=0.2); plt.show() \n```", "```py\niteration = 2                                                 # initialize a counter, we already completed iteration 0 and 1 above\nwhile True:\n    closest_centroids = df['closest'].copy(deep=True)\n    update(df,centroids,pormin,pormax,AImin,AImax)\n    for i in centroids.keys():\n        prototypes[i-1,iteration] = [centroids[i][0],centroids[i][1]]\n        norm_prototypes[i-1,iteration] = [centroids[i][2],centroids[i][3]]\n    assignment(df, centroids)\n    if closest_centroids.equals(df['closest']):\n        break\n    iteration = iteration + 1\n\nplt.subplot(121)                                              # plot the assigned training data and K prototypes\nplt.scatter(df['Porosity'], df['AI'], color=df['color'], alpha=0.5, edgecolor='k')\nfor i in centroids.keys():\n    plt.scatter(prototypes[i-1,0,0], prototypes[i-1,0,1],color='white',s=120,marker='o',linewidths=1.0,alpha=0.5,edgecolors=\"black\",zorder=10)\n    plt.scatter(prototypes[i-1,0,0], prototypes[i-1,0,1],color=colmap[i],s=90,marker='*',linewidths=0.5,alpha=0.5,edgecolors=\"black\",zorder=20)\n    plt.scatter(centroids.get(i)[0], centroids.get(i)[1],color='white',s=120,marker='o',linewidths=1.0, edgecolors=\"black\",zorder=10)\n    plt.scatter(centroids.get(i)[0], centroids.get(i)[1],color=colmap[i],s=90,marker='*',linewidths=0.5, edgecolors=\"black\",\n        zorder=20,label='Prototype #'+str(i))\n    plt.plot(prototypes[i-1,:iteration+1,0],prototypes[i-1,:iteration+1,1],color=colmap[i],zorder = 1)\nplt.title('Acoustic Impedance vs. Porosity with Final Prototypes'); plt.xlabel('Porosity (fraction)')\nplt.ylabel('Acoustic Impedance (kg/m^3 x m/s x 10^3)')\nplt.xlim(por_min, por_max); plt.ylim(AI_min, AI_max); add_grid(); plt.legend(loc='upper right')\n\nplt.subplot(122)                                              # plot the training data and K prototypes\nplt.scatter(df_subset['Norm_Porosity'], df['Norm_AI'], c=df['color'], alpha = 0.4, linewidths=1.0, edgecolors=\"black\")\nfor i in centroids.keys():\n    plt.scatter(norm_prototypes[i-1,0,0], norm_prototypes[i-1,0,1],color='white',s=120,marker='o',linewidths=1.0,alpha=0.5,\n            edgecolors=\"black\",zorder=10)\n    plt.scatter(norm_prototypes[i-1,0,0], norm_prototypes[i-1,0,1],color=colmap[i],s=90,marker='*',linewidths=0.5,alpha=0.5,\n            edgecolors=\"black\",zorder=20)\n    plt.scatter(centroids.get(i)[2], centroids.get(i)[3],color='white',s=120,marker='o',linewidths=1.0, edgecolors=\"black\",zorder=10)\n    plt.scatter(centroids.get(i)[2], centroids.get(i)[3],color=colmap[i],s=90,marker='*',linewidths=0.5, edgecolors=\"black\",\n            zorder=20,label='Prototype #'+str(i))\n    plt.plot(norm_prototypes[i-1,:iteration+1,0],norm_prototypes[i-1,:iteration+1,1],color=colmap[i],zorder = 1)\nplt.title('Normalized Acoustic Impedance vs. Porosity with Final Prototypes'); plt.xlabel('Porosity (normalized)')\nplt.ylabel('Acoustic Impedance (normalized)')\nplt.xlim([0, 1]); plt.ylim([0, 1]); add_grid(); plt.legend(loc='upper right')\nplt.subplots_adjust(left=0.0, bottom=0.0, right=2.0, top=1.0, wspace=0.2, hspace=0.2); plt.show() \n```", "```py\nK = 2                                                         # number categories / clusters \n\nkmeans = KMeans(n_clusters=K, random_state=seed, n_init = 100).fit(df.loc[:,['Norm_Porosity','Norm_AI']]) # k-means clustering\ndf['kMeans'] = kmeans.labels_ + 1\n\nplt.subplot(111)                                              # plot the training data and K prototypes\nplt.scatter(df_subset['Norm_Porosity'], df['Norm_AI'], c=df['kMeans'], alpha = 0.4, linewidths=1.0, edgecolors=\"black\")\nplt.title('Normalized Acoustic Impedance vs. Porosity with Final Prototypes'); plt.xlabel('Porosity (normalized)')\nplt.ylabel('Acoustic Impedance (normalized)')\nplt.xlim([0, 1]); plt.ylim([0, 1]); add_grid()\nplt.subplots_adjust(left=0.0, bottom=0.0, right=1.0, top=1.1, wspace=0.2, hspace=0.2) \n```", "```py\nmax_K = 50                                                    # maximum number of clusters, k\noptimal_k = 13\n\ninertia = []\nfor k in range(2,max_K+1):                                    # loop over number of clusters and store the inertia\n    kmeans_iter = KMeans(n_clusters=k, random_state=14, n_init = 10).fit(df.loc[:,['Norm_Porosity','Norm_AI']].values)\n    inertia.append(kmeans_iter.inertia_)\n\nplt.scatter(range(2,max_K+1),inertia,c='red',edgecolor='black',zorder=10)\nplt.plot(range(2,max_K+1),inertia,c='red',ls='--',zorder=1)\nplt.xlim(2,max_K); plt.xlabel('Number of Clusters'); plt.ylabel('Inertia'); plt.ylim(bottom=0)\nplt.vlines(optimal_k,0,np.max(inertia),color='black'); plt.annotate('Optimum K = ' + str(optimal_k),[optimal_k+0.5,4.0],rotation=90.0)\nplt.grid(True); plt.title('k-Means Clustering Inertia vs. Number of Clusters')\nplt.xlim([0,max_K+1]); plt.ylim([0, np.max(inertia)]); add_grid()\nplt.subplots_adjust(left=0.0, bottom=0.0, right=1.0, top=1.1, wspace=0.2, hspace=0.2); plt.show() \n```", "```py\nmax_K = 50                                                    # maximum number of clusters, k\n\nsilhouette = []\nfor k in range(2,max_K+1):                                    # loop over number of clusters and store the inertia\n    kmeans_iter = KMeans(n_clusters=k, random_state=14, n_init = 10).fit(df.loc[:,['Norm_Porosity','Norm_AI']].values)\n    score = silhouette_score(df.loc[:,['Norm_Porosity','Norm_AI']].values, kmeans_iter.labels_)\n    silhouette.append(score)\noptimal_k = np.argmax(silhouette) + 2 \n\nplt.scatter(range(2,max_K+1),silhouette,c='red',edgecolor='black',zorder=10)\nplt.annotate('Good Fit',[0.8,0.7],rotation = 90); plt.annotate('Poor Fit',[0.8,-0.9],rotation = 90)\nplt.plot(range(2,max_K+1),silhouette,c='red',ls='--',zorder=1)\nplt.xlim(2,max_K); plt.xlabel('Number of Clusters'); plt.ylabel('Silhouetter Score'); plt.ylim(bottom=0)\nplt.vlines(optimal_k,-1,1,color='black'); plt.annotate('Optimum K = ' + str(optimal_k),[optimal_k+0.5,-0.75],rotation=90.0)\nplt.grid(True); plt.title('Silhouetter Score vs. Number of Clusters')\nplt.xlim([0,max_K+1]); plt.ylim([-1,1]); add_grid()\nplt.subplots_adjust(left=0.0, bottom=0.0, right=1.0, top=1.1, wspace=0.2, hspace=0.2); plt.show() \n```", "```py\nplt.subplot(121)                                              # scatter plot our training data \nplt.scatter(df_subset['Porosity'], df['AI'], c=\"black\", alpha = 0.4, linewidths=1.0, edgecolors=\"black\")\nplt.title('Acoustic Impedance vs. Porosity'); plt.xlabel('Porosity (fraction)'); plt.ylabel('Acoustic Impedance (kg/m^3 x m/s x 10^3)')\nplt.xlim(por_min, por_max); plt.ylim(AI_min, AI_max); add_grid();\nplt.gca().set_aspect('equal', adjustable='box') \n```", "```py\nK = 5                                                         # number categories / clusters \n\nkmeans = KMeans(n_clusters=K, random_state=seed, n_init = 100).fit(df.loc[:,['Porosity','AI']]) # k-means clustering\ndf['kMeans_Orig'] = kmeans.labels_ + 1\n\nplt.subplot(111)                                              # plot the training data and K prototypes\nplt.scatter(df_subset['Norm_Porosity'], df['Norm_AI'], c=df['kMeans_Orig'], alpha = 0.4, linewidths=1.0, edgecolors=\"black\")\nplt.title('Normalized Acoustic Impedance vs. Porosity with Final Prototypes'); plt.xlabel('Porosity (normalized)')\nplt.ylabel('Acoustic Impedance (normalized)')\nplt.xlim([0, 1]); plt.ylim([0, 1]); add_grid()\nplt.subplots_adjust(left=0.0, bottom=0.0, right=1.0, top=1.1, wspace=0.2, hspace=0.2) \n```", "```py\nidata = 0                                                     # select the dataset\n\nif idata == 0:\n    df_new = pd.read_csv('https://raw.githubusercontent.com/GeostatsGuy/GeoDataSets/master/unconv_MV_v4.csv') # load data from Dr. Pyrcz's GitHub repository \n    df_new.drop(['Well','Prod'],axis=1,inplace=True)          # remove well index and response feature\n\n    features = df_new.columns.values.tolist()                 # store the names of the features\n\n    xmin_new = [6.0,0.0,1.0,10.0,0.0,0.9]; xmax_new = [24.0,10.0,5.0,85.0,2.2,2.9] # set the minimum and maximum values for plotting\n\n    flabel_new = ['Porosity (%)','Permeability (mD)','Acoustic Impedance (kg/m2s*10^6)','Brittleness Ratio (%)', # set the names for plotting\n             'Total Organic Carbon (%)','Vitrinite Reflectance (%)']\n\n    ftitle_new = ['Porosity','Permeability','Acoustic Impedance','Brittleness Ratio', # set the units for plotting\n             'Total Organic Carbon','Vitrinite Reflectance']\n\nelif idata == 1:\n    names = {'Porosity':'Por'}\n\n    df_new = pd.read_csv('https://raw.githubusercontent.com/GeostatsGuy/GeoDataSets/master/12_sample_data.csv') # load data from Dr. Pyrcz's GitHub repository \n    df_new.drop(['X','Y','Unnamed: 0'],axis=1,inplace=True)   # remove response feature\n    df_new = df_new.rename(columns=names)\n\n    features = df_new.columns.values.tolist()                 # store the names of the features\n\n    xmin_new = [0.0,0.0,0.0,4.0,0.0,6.5,1.4,1600.0,10.0,1300.0,1.6]; xmax_new = [10000.0,10000.0,1.0,19.0,500.0,8.3,3.6,6200.0,50.0,2000.0,12.0] # set the minimum and maximum values for plotting\n\n    flabel_new = ['Well (ID)','X (m)','Y (m)','Depth (m)','Porosity (fraction)','Permeability (mD)','Acoustic Impedance (kg/m2s*10^6)','Facies (categorical)',\n              'Density (g/cm^3)','Compressible velocity (m/s)','Youngs modulus (GPa)', 'Shear velocity (m/s)', 'Shear modulus (GPa)'] # set the names for plotting\n\n    ftitle_new = ['Well','X','Y','Depth','Porosity','Permeability','Acoustic Impedance','Facies',\n              'Density','Compressible velocity','Youngs modulus', 'Shear velocity', 'Shear modulus']\n\nelif idata == 2:  \n    df_new = pd.read_csv('https://raw.githubusercontent.com/GeostatsGuy/GeoDataSets/master/res21_2D_wells.csv') # load data from Dr. Pyrcz's GitHub repository \n    df_new.drop(['Well_ID','X','Y','CumulativeOil'],axis=1,inplace=True) # remove Well Index, X and Y coordinates, and response feature\n    df_new = df_new.dropna(how='any',inplace=False)\n\n    features = df_new.columns.values.tolist()                 # store the names of the features\n\n    xmin_new = [1,0.0,0.0,4.0,0.0,6.5,1.4,1600.0,10.0,1300.0,1.6]; xmax_new = [73,10000.0,10000.0,19.0,500.0,8.3,3.6,6200.0,50.0,2000.0,12.0] # set the minimum and maximum values for plotting\n\n    flabel_new = ['Well (ID)','X (m)','Y (m)','Depth (m)','Porosity (fraction)','Permeability (mD)','Acoustic Impedance (kg/m2s*10^6)','Facies (categorical)',\n              'Density (g/cm^3)','Compressible velocity (m/s)','Youngs modulus (GPa)', 'Shear velocity (m/s)', 'Shear modulus (GPa)'] # set the names for plotting\n\n    ftitle_new = ['Well','X','Y','Depth','Porosity','Permeability','Acoustic Impedance','Facies',\n              'Density','Compressible velocity','Youngs modulus', 'Shear velocity', 'Shear modulus']\n\ndf_new[df_new.columns] = MinMaxScaler().fit_transform(df_new) # min/max normalize all the features\ndf_new.head(n=13) \n```", "```py\nmax_K = min(len(df_new)-1,20)                                 # maximum number of clusters, K\n\nsilhouette = []\nfor k in range(2,max_K+1):                                    # loop over number of clusters and store the inertia\n    kmeans_iter = KMeans(n_clusters=k, random_state=14, n_init = 10).fit(df_new.values)\n    score = silhouette_score(df_new.values, kmeans_iter.labels_)\n    silhouette.append(score)\noptimal_k = np.argmax(silhouette) + 2 \n\nkmeans = KMeans(n_clusters=optimal_k, random_state=seed, n_init = 100).fit(df_new.values) # k-means clustering\ndf_new['Kmeans'] = kmeans.labels_ + 1\n\nplt.subplot(111)\nplt.scatter(range(2,max_K+1),silhouette,c='red',edgecolor='black',zorder=10)\nplt.annotate('Good Fit',[0.8,0.7],rotation = 90); plt.annotate('Poor Fit',[0.8,-0.9],rotation = 90)\nplt.plot(range(2,max_K+1),silhouette,c='red',ls='--',zorder=1)\nplt.xlim(2,max_K); plt.xlabel('Number of Clusters'); plt.ylabel('Silhouetter Score'); plt.ylim(bottom=0)\nplt.vlines(optimal_k,-1,1,color='black'); plt.annotate('Optimum K = ' + str(optimal_k),[optimal_k+0.5,-0.75],rotation=90.0)\nplt.grid(True); plt.title('Silhouetter Score vs. Number of Clusters')\nplt.xlim([0,max_K+1]); plt.ylim([-1,1]); add_grid()\n\nplt.subplots_adjust(left=0.0, bottom=0.0, right=1.0, top=1.1, wspace=0.2, hspace=0.2); plt.show() \n```", "```py\nsns.pairplot(df_new.iloc[:,:], hue=\"Kmeans\", plot_kws={'alpha':1.0,'s':50}, palette = 'colorblind', corner=True) # matrix scatter plot\nplt.subplots_adjust(left=0.0, bottom=0.0, right=0.6, top=0.7, wspace=0.2, hspace=0.2); plt.show() \n```", "```py\nsave_clusters = False                                         # save the imputed DataFrame?\n\nif save_clusters == True:\n    folder = r'C:\\Local'\n    file_name = r'dataframe_cluster.csv'\n\n    df_new.to_csv(folder + \"/\" + file_name, index=False) \n```", "```py\nidata = 0                                                     # select the dataset\n\nif idata == 0:\n    df_new = pd.read_csv('https://raw.githubusercontent.com/GeostatsGuy/GeoDataSets/master/unconv_MV_v4.csv') # load data from Dr. Pyrcz's GitHub repository \n    df_new.drop(['Well','Prod'],axis=1,inplace=True)          # remove well index and response feature\n\n    features = df_new.columns.values.tolist()                 # store the names of the features\n\n    xmin_new = [6.0,0.0,1.0,10.0,0.0,0.9]; xmax_new = [24.0,10.0,5.0,85.0,2.2,2.9] # set the minimum and maximum values for plotting\n\n    flabel_new = ['Porosity (%)','Permeability (mD)','Acoustic Impedance (kg/m2s*10^6)','Brittleness Ratio (%)', # set the names for plotting\n             'Total Organic Carbon (%)','Vitrinite Reflectance (%)']\n\n    ftitle_new = ['Porosity','Permeability','Acoustic Impedance','Brittleness Ratio', # set the units for plotting\n             'Total Organic Carbon','Vitrinite Reflectance']\n\nelif idata == 1:\n    names = {'Porosity':'Por'}\n\n    df_new = pd.read_csv('https://raw.githubusercontent.com/GeostatsGuy/GeoDataSets/master/12_sample_data.csv') # load data from Dr. Pyrcz's GitHub repository \n    df_new.drop(['X','Y','Unnamed: 0'],axis=1,inplace=True)   # remove response feature\n    df_new = df_new.rename(columns=names)\n\n    features = df_new.columns.values.tolist()                 # store the names of the features\n\n    xmin_new = [0.0,0.0,0.0,4.0,0.0,6.5,1.4,1600.0,10.0,1300.0,1.6]; xmax_new = [10000.0,10000.0,1.0,19.0,500.0,8.3,3.6,6200.0,50.0,2000.0,12.0] # set the minimum and maximum values for plotting\n\n    flabel_new = ['Well (ID)','X (m)','Y (m)','Depth (m)','Porosity (fraction)','Permeability (mD)','Acoustic Impedance (kg/m2s*10^6)','Facies (categorical)',\n              'Density (g/cm^3)','Compressible velocity (m/s)','Youngs modulus (GPa)', 'Shear velocity (m/s)', 'Shear modulus (GPa)'] # set the names for plotting\n\n    ftitle_new = ['Well','X','Y','Depth','Porosity','Permeability','Acoustic Impedance','Facies',\n              'Density','Compressible velocity','Youngs modulus', 'Shear velocity', 'Shear modulus']\n\nelif idata == 2:  \n    df_new = pd.read_csv('https://raw.githubusercontent.com/GeostatsGuy/GeoDataSets/master/res21_2D_wells.csv') # load data from Dr. Pyrcz's GitHub repository \n    df_new.drop(['Well_ID','X','Y','CumulativeOil'],axis=1,inplace=True) # remove Well Index, X and Y coordinates, and response feature\n    df_new = df_new.dropna(how='any',inplace=False)\n\n    features = df_new.columns.values.tolist()                 # store the names of the features\n\n    xmin_new = [1,0.0,0.0,4.0,0.0,6.5,1.4,1600.0,10.0,1300.0,1.6]; xmax_new = [73,10000.0,10000.0,19.0,500.0,8.3,3.6,6200.0,50.0,2000.0,12.0] # set the minimum and maximum values for plotting\n\n    flabel_new = ['Well (ID)','X (m)','Y (m)','Depth (m)','Porosity (fraction)','Permeability (mD)','Acoustic Impedance (kg/m2s*10^6)','Facies (categorical)',\n              'Density (g/cm^3)','Compressible velocity (m/s)','Youngs modulus (GPa)', 'Shear velocity (m/s)', 'Shear modulus (GPa)'] # set the names for plotting\n\n    ftitle_new = ['Well','X','Y','Depth','Porosity','Permeability','Acoustic Impedance','Facies',\n              'Density','Compressible velocity','Youngs modulus', 'Shear velocity', 'Shear modulus']\n\ndf_new[df_new.columns] = MinMaxScaler().fit_transform(df_new) # min/max normalize all the features\ndf_new.head(n=13) \n```", "```py\nmax_K = min(len(df_new)-1,20)                                 # maximum number of clusters, K\n\nsilhouette = []\nfor k in range(2,max_K+1):                                    # loop over number of clusters and store the inertia\n    kmeans_iter = KMeans(n_clusters=k, random_state=14, n_init = 10).fit(df_new.values)\n    score = silhouette_score(df_new.values, kmeans_iter.labels_)\n    silhouette.append(score)\noptimal_k = np.argmax(silhouette) + 2 \n\nkmeans = KMeans(n_clusters=optimal_k, random_state=seed, n_init = 100).fit(df_new.values) # k-means clustering\ndf_new['Kmeans'] = kmeans.labels_ + 1\n\nplt.subplot(111)\nplt.scatter(range(2,max_K+1),silhouette,c='red',edgecolor='black',zorder=10)\nplt.annotate('Good Fit',[0.8,0.7],rotation = 90); plt.annotate('Poor Fit',[0.8,-0.9],rotation = 90)\nplt.plot(range(2,max_K+1),silhouette,c='red',ls='--',zorder=1)\nplt.xlim(2,max_K); plt.xlabel('Number of Clusters'); plt.ylabel('Silhouetter Score'); plt.ylim(bottom=0)\nplt.vlines(optimal_k,-1,1,color='black'); plt.annotate('Optimum K = ' + str(optimal_k),[optimal_k+0.5,-0.75],rotation=90.0)\nplt.grid(True); plt.title('Silhouetter Score vs. Number of Clusters')\nplt.xlim([0,max_K+1]); plt.ylim([-1,1]); add_grid()\n\nplt.subplots_adjust(left=0.0, bottom=0.0, right=1.0, top=1.1, wspace=0.2, hspace=0.2); plt.show() \n```", "```py\nsns.pairplot(df_new.iloc[:,:], hue=\"Kmeans\", plot_kws={'alpha':1.0,'s':50}, palette = 'colorblind', corner=True) # matrix scatter plot\nplt.subplots_adjust(left=0.0, bottom=0.0, right=0.6, top=0.7, wspace=0.2, hspace=0.2); plt.show() \n```", "```py\nsave_clusters = False                                         # save the imputed DataFrame?\n\nif save_clusters == True:\n    folder = r'C:\\Local'\n    file_name = r'dataframe_cluster.csv'\n\n    df_new.to_csv(folder + \"/\" + file_name, index=False) \n```"]