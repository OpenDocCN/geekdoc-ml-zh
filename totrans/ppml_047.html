<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.1//EN"
  "http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd">

<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<title>Nullability</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1>Nullability</h1>
<blockquote>原文：<a href="https://rust-exercises.com/100-exercises/05_ticket_v2/05_nullability.html">https://rust-exercises.com/100-exercises/05_ticket_v2/05_nullability.html</a></blockquote>
                        
<p>Our implementation of the <code>assigned</code> method is fairly blunt: panicking for to-do and done tickets is far from ideal.<br/>
We can do better using <strong>Rust's <code>Option</code> type</strong>.</p>
<h2 id="option"><a class="header" href="#option"><code>Option</code></a></h2>
<p><code>Option</code> is a Rust type that represents <strong>nullable values</strong>.<br/>
It is an enum, defined in Rust's standard library:</p>
<pre><code class="language-rust">enum Option&lt;T&gt; {
    Some(T),
    None,
}</code></pre>
<p><code>Option</code> encodes the idea that a value might be present (<code>Some(T)</code>) or absent (<code>None</code>).<br/>
It also forces you to <strong>explicitly handle both cases</strong>. You'll get a compiler error if you are working with
a nullable value and you forget to handle the <code>None</code> case.<br/>
This is a significant improvement over "implicit" nullability in other languages, where you can forget to check
for <code>null</code> and thus trigger a runtime error.</p>
<h2 id="options-definition"><a class="header" href="#options-definition"><code>Option</code>'s definition</a></h2>
<p><code>Option</code>'s definition uses a Rust construct that you haven't seen before: <strong>tuple-like variants</strong>.</p>
<h3 id="tuple-like-variants"><a class="header" href="#tuple-like-variants">Tuple-like variants</a></h3>
<p><code>Option</code> has two variants: <code>Some(T)</code> and <code>None</code>.<br/>
<code>Some</code> is a <strong>tuple-like variant</strong>: it's a variant that holds <strong>unnamed fields</strong>.</p>
<p>Tuple-like variants are often used when there is a single field to store, especially when we're looking at a
"wrapper" type like <code>Option</code>.</p>
<h3 id="tuple-like-structs"><a class="header" href="#tuple-like-structs">Tuple-like structs</a></h3>
<p>They're not specific to enums—you can define tuple-like structs too:</p>
<pre><code class="language-rust">struct Point(i32, i32);</code></pre>
<p>You can then access the two fields of a <code>Point</code> instance using their positional index:</p>
<pre><code class="language-rust">let point = Point(3, 4);
let x = point.0;
let y = point.1;</code></pre>
<h3 id="tuples"><a class="header" href="#tuples">Tuples</a></h3>
<p>It's weird to say that something is tuple-like when we haven't seen tuples yet!<br/>
Tuples are another example of a primitive Rust type.
They group together a fixed number of values with (potentially different) types:</p>
<pre><code class="language-rust">// Two values, same type
let first: (i32, i32) = (3, 4);
// Three values, different types
let second: (i32, u32, u8) = (-42, 3, 8);</code></pre>
<p>The syntax is simple: you list the types of the values between parentheses, separated by commas.
You can access the fields of a tuple using the dot notation and the field index:</p>
<pre><code class="language-rust">assert_eq!(second.0, -42);
assert_eq!(second.1, 3);
assert_eq!(second.2, 8);</code></pre>
<p>Tuples are a convenient way of grouping values together when you can't be bothered to define a dedicated struct type.</p>
<h2 id="exercise"><a class="header" href="#exercise">Exercise</a></h2>
<p>The exercise for this section is located in <a href="https://github.com/mainmatter/100-exercises-to-learn-rust/tree/main/exercises/05_ticket_v2/05_nullability"><code>05_ticket_v2/05_nullability</code></a></p>

                        
</body>
</html>