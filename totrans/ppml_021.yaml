- en: Mutable references
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 原文：[https://rust-exercises.com/100-exercises/03_ticket_v1/07_setters.html](https://rust-exercises.com/100-exercises/03_ticket_v1/07_setters.html)
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'Your accessor methods should look like this now:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: A sprinkle of `&` here and there did the trick!
  prefs: []
  type: TYPE_NORMAL
- en: We now have a way to access the fields of a `Ticket` instance without consuming
    it in the process. Let's see how we can enhance our `Ticket` struct with **setter
    methods** next.
  prefs: []
  type: TYPE_NORMAL
- en: '[Setters](#setters)'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Setter methods allow users to change the values of `Ticket`'s private fields
    while making sure that its invariants are respected (i.e. you can't set a `Ticket`'s
    title to an empty string).
  prefs: []
  type: TYPE_NORMAL
- en: 'There are two common ways to implement setters in Rust:'
  prefs: []
  type: TYPE_NORMAL
- en: Taking `self` as input.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Taking `&mut self` as input.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Taking `self` as input](#taking-self-as-input)'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The first approach looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: It takes ownership of `self`, changes the title, and returns the modified `Ticket`
    instance.
  prefs: []
  type: TYPE_NORMAL
- en: 'This is how you''d use it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Since `set_title` takes ownership of `self` (i.e. it **consumes it**), we need
    to reassign the result to a variable. In the example above we take advantage of
    **variable shadowing** to reuse the same variable name: when you declare a new
    variable with the same name as an existing one, the new variable **shadows** the
    old one. This is a common pattern in Rust code.'
  prefs: []
  type: TYPE_NORMAL
- en: '`self`-setters work quite nicely when you need to change multiple fields at
    once: you can chain multiple calls together!'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: '[Taking `&mut self` as input](#taking-mut-self-as-input)'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The second approach to setters, using `&mut self`, looks like this instead:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: This time the method takes a mutable reference to `self` as input, changes the
    title, and that's it. Nothing is returned.
  prefs: []
  type: TYPE_NORMAL
- en: 'You''d use it like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: Ownership stays with the caller, so the original `ticket` variable is still
    valid. We don't need to reassign the result. We need to mark `ticket` as mutable
    though, because we're taking a mutable reference to it.
  prefs: []
  type: TYPE_NORMAL
- en: '`&mut`-setters have a downside: you can''t chain multiple calls together. Since
    they don''t return the modified `Ticket` instance, you can''t call another setter
    on the result of the first one. You have to call each setter separately:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: '[Exercise](#exercise)'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The exercise for this section is located in [`03_ticket_v1/07_setters`](https://github.com/mainmatter/100-exercises-to-learn-rust/tree/main/exercises/03_ticket_v1/07_setters)
  prefs: []
  type: TYPE_NORMAL
