- en: Interior mutability
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 原文：[https://rust-exercises.com/100-exercises/07_threads/06_interior_mutability.html](https://rust-exercises.com/100-exercises/07_threads/06_interior_mutability.html)
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'Let''s take a moment to reason about the signature of `Sender`''s `send`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: '`send` takes `&self` as its argument.'
  prefs: []
  type: TYPE_NORMAL
- en: 'But it''s clearly causing a mutation: it''s adding a new message to the channel.
    What''s even more interesting is that `Sender` is cloneable: we can have multiple
    instances of `Sender` trying to modify the channel state **at the same time**,
    from different threads.'
  prefs: []
  type: TYPE_NORMAL
- en: That's the key property we are using to build this client-server architecture.
    But why does it work? Doesn't it violate Rust's rules about borrowing? How are
    we performing mutations via an *immutable* reference?
  prefs: []
  type: TYPE_NORMAL
- en: '[Shared rather than immutable references](#shared-rather-than-immutable-references)'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'When we introduced the borrow-checker, we named the two types of references
    we can have in Rust:'
  prefs: []
  type: TYPE_NORMAL
- en: immutable references (`&T`)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: mutable references (`&mut T`)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'It would have been more accurate to name them:'
  prefs: []
  type: TYPE_NORMAL
- en: shared references (`&T`)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: exclusive references (`&mut T`)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Immutable/mutable is a mental model that works for the vast majority of cases,
    and it''s a great one to get started with Rust. But it''s not the whole story,
    as you''ve just seen: `&T` doesn''t actually guarantee that the data it points
    to is immutable.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Don''t worry, though: Rust is still keeping its promises. It''s just that the
    terms are a bit more nuanced than they might seem at first.'
  prefs: []
  type: TYPE_NORMAL
- en: '[`UnsafeCell`](#unsafecell)'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Whenever a type allows you to mutate data through a shared reference, you're
    dealing with **interior mutability**.
  prefs: []
  type: TYPE_NORMAL
- en: By default, the Rust compiler assumes that shared references are immutable.
    It **optimises your code** based on that assumption.
  prefs: []
  type: TYPE_NORMAL
- en: The compiler can reorder operations, cache values, and do all sorts of magic
    to make your code faster.
  prefs: []
  type: TYPE_NORMAL
- en: You can tell the compiler "No, this shared reference is actually mutable" by
    wrapping the data in an `UnsafeCell`.
  prefs: []
  type: TYPE_NORMAL
- en: Every time you see a type that allows interior mutability, you can be certain
    that `UnsafeCell` is involved, either directly or indirectly.
  prefs: []
  type: TYPE_NORMAL
- en: Using `UnsafeCell`, raw pointers and `unsafe` code, you can mutate data through
    shared references.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s be clear, though: `UnsafeCell` isn''t a magic wand that allows you to
    ignore the borrow-checker!'
  prefs: []
  type: TYPE_NORMAL
- en: '`unsafe` code is still subject to Rust''s rules about borrowing and aliasing.
    It''s an (advanced) tool that you can leverage to build **safe abstractions**
    whose safety can''t be directly expressed in Rust''s type system. Whenever you
    use the `unsafe` keyword you''re telling the compiler: "I know what I''m doing,
    I won''t violate your invariants, trust me."'
  prefs: []
  type: TYPE_NORMAL
- en: 'Every time you call an `unsafe` function, there will be documentation explaining
    its **safety preconditions**: under what circumstances it''s safe to execute its
    `unsafe` block. You can find the ones for `UnsafeCell` [in `std`''s documentation](https://doc.rust-lang.org/std/cell/struct.UnsafeCell.html).'
  prefs: []
  type: TYPE_NORMAL
- en: We won't be using `UnsafeCell` directly in this course, nor will we be writing
    `unsafe` code. But it's important to know that it's there, why it exists and how
    it relates to the types you use every day in Rust.
  prefs: []
  type: TYPE_NORMAL
- en: '[Key examples](#key-examples)'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Let's go through a couple of important `std` types that leverage interior mutability.
  prefs: []
  type: TYPE_NORMAL
- en: These are types that you'll encounter somewhat often in Rust code, especially
    if you peek under the hood of some the libraries you use.
  prefs: []
  type: TYPE_NORMAL
- en: '[Reference counting](#reference-counting)'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '`Rc` is a reference-counted pointer.'
  prefs: []
  type: TYPE_NORMAL
- en: It wraps around a value and keeps track of how many references to the value
    exist. When the last reference is dropped, the value is deallocated.
  prefs: []
  type: TYPE_NORMAL
- en: 'The value wrapped in an `Rc` is immutable: you can only get shared references
    to it.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: '`Rc` uses `UnsafeCell` internally to allow shared references to increment and
    decrement the reference count.'
  prefs: []
  type: TYPE_NORMAL
- en: '[`RefCell`](#refcell)'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '`RefCell` is one of the most common examples of interior mutability in Rust.
    It allows you to mutate the value wrapped in a `RefCell` even if you only have
    an immutable reference to the `RefCell` itself.'
  prefs: []
  type: TYPE_NORMAL
- en: This is done via **runtime borrow checking**. The `RefCell` keeps track of the
    number (and type) of references to the value it contains at runtime. If you try
    to borrow the value mutably while it's already borrowed immutably, the program
    will panic, ensuring that Rust's borrowing rules are always enforced.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: '[Exercise](#exercise)'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The exercise for this section is located in [`07_threads/06_interior_mutability`](https://github.com/mainmatter/100-exercises-to-learn-rust/tree/main/exercises/07_threads/06_interior_mutability)
  prefs: []
  type: TYPE_NORMAL
