- en: From and Into
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 原文：[https://rust-exercises.com/100-exercises/04_traits/09_from.html](https://rust-exercises.com/100-exercises/04_traits/09_from.html)
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'Let''s go back to where our string journey started:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: We now know enough to start unpacking what `.into()` is doing here.
  prefs: []
  type: TYPE_NORMAL
- en: '[The problem](#the-problem)'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'This is the signature of the `new` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: We've also seen that string literals (such as `"A title"`) are of type `&str`.
  prefs: []
  type: TYPE_NORMAL
- en: 'We have a type mismatch here: a `String` is expected, but we have a `&str`.
    No magical coercion will come to save us this time; we need **to perform a conversion**.'
  prefs: []
  type: TYPE_NORMAL
- en: '[`From` and `Into`](#from-and-into-1)'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The Rust standard library defines two traits for **infallible conversions**:
    `From` and `Into`, in the `std::convert` module.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'These trait definitions showcase a few concepts that we haven''t seen before:
    **supertraits** and **implicit trait bounds**. Let''s unpack those first.'
  prefs: []
  type: TYPE_NORMAL
- en: '[Supertrait / Subtrait](#supertrait--subtrait)'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The `From: Sized` syntax implies that `From` is a **subtrait** of `Sized`:
    any type that implements `From` must also implement `Sized`. Alternatively, you
    could say that `Sized` is a **supertrait** of `From`.'
  prefs: []
  type: TYPE_NORMAL
- en: '[Implicit trait bounds](#implicit-trait-bounds)'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Every time you have a generic type parameter, the compiler implicitly assumes
    that it's `Sized`.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'is actually equivalent to:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'In the case of `From<T>`, the trait definition is equivalent to:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: In other words, *both* `T` and the type implementing `From<T>` must be `Sized`,
    even though the former bound is implicit.
  prefs: []
  type: TYPE_NORMAL
- en: '[Negative trait bounds](#negative-trait-bounds)'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'You can opt out of the implicit `Sized` bound with a **negative trait bound**:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'This syntax reads as "`T` may or may not be `Sized`", and it allows you to
    bind `T` to a DST (e.g. `Foo<str>`). It is a special case, though: negative trait
    bounds are exclusive to `Sized`, you can''t use them with other traits.'
  prefs: []
  type: TYPE_NORMAL
- en: '[`&str` to `String`](#str-to-string)'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In [`std`'s documentation](https://doc.rust-lang.org/std/convert/trait.From.html#implementors)
    you can see which `std` types implement the `From` trait.
  prefs: []
  type: TYPE_NORMAL
- en: 'You''ll find that `String` implements `From<&str> for String`. Thus, we can
    write:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: We've been primarily using `.into()`, though.
  prefs: []
  type: TYPE_NORMAL
- en: If you check out the [implementors of `Into`](https://doc.rust-lang.org/std/convert/trait.Into.html#implementors)
    you won't find `Into<String> for &str`. What's going on?
  prefs: []
  type: TYPE_NORMAL
- en: '`From` and `Into` are **dual traits**.'
  prefs: []
  type: TYPE_NORMAL
- en: 'In particular, `Into` is implemented for any type that implements `From` using
    a **blanket implementation**:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: If a type `U` implements `From<T>`, then `Into<U> for T` is automatically implemented.
    That's why we can write `let title = "A title".into();`.
  prefs: []
  type: TYPE_NORMAL
- en: '[`.into()`](#into)'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Every time you see `.into()`, you're witnessing a conversion between types.
  prefs: []
  type: TYPE_NORMAL
- en: What's the target type, though?
  prefs: []
  type: TYPE_NORMAL
- en: 'In most cases, the target type is either:'
  prefs: []
  type: TYPE_NORMAL
- en: Specified by the signature of a function/method (e.g. `Ticket::new` in our example
    above)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Specified in the variable declaration with a type annotation (e.g. `let title:
    String = "A title".into();`)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`.into()` will work out of the box as long as the compiler can infer the target
    type from the context without ambiguity.'
  prefs: []
  type: TYPE_NORMAL
- en: '[Exercise](#exercise)'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The exercise for this section is located in [`04_traits/09_from`](https://github.com/mainmatter/100-exercises-to-learn-rust/tree/main/exercises/04_traits/09_from)
  prefs: []
  type: TYPE_NORMAL
