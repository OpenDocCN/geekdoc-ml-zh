<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.1//EN"
  "http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd">

<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<title>Types, part 1</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1>Types, part 1</h1>
<blockquote>原文：<a href="https://rust-exercises.com/100-exercises/02_basic_calculator/01_integers.html">https://rust-exercises.com/100-exercises/02_basic_calculator/01_integers.html</a></blockquote>
                        
<p>In the <a href="/100-exercises/01_intro/01_syntax">"Syntax" section</a> <code>compute</code>'s input parameters were of type <code>u32</code>.<br/>
Let's unpack what that <em>means</em>.</p>
<h2 id="primitive-types"><a class="header" href="#primitive-types">Primitive types</a></h2>
<p><code>u32</code> is one of Rust's <strong>primitive types</strong>. Primitive types are the most basic building blocks of a language.
They're built into the language itself—i.e. they are not defined in terms of other types.</p>
<p>You can combine these primitive types to create more complex types. We'll see how soon enough.</p>
<h2 id="integers"><a class="header" href="#integers">Integers</a></h2>
<p><code>u32</code>, in particular, is an <strong>unsigned 32-bit integer</strong>.</p>
<p>An integer is a number that can be written without a fractional component. E.g. <code>1</code> is an integer, while <code>1.2</code> is not.</p>
<h3 id="signed-vs-unsigned"><a class="header" href="#signed-vs-unsigned">Signed vs. unsigned</a></h3>
<p>An integer can be <strong>signed</strong> or <strong>unsigned</strong>.<br/>
An unsigned integer can only represent non-negative numbers (i.e. <code>0</code> or greater).
A signed integer can represent both positive and negative numbers (e.g. <code>-1</code>, <code>12</code>, etc.).</p>
<p>The <code>u</code> in <code>u32</code> stands for <strong>unsigned</strong>.<br/>
The equivalent type for signed integer is <code>i32</code>, where the <code>i</code> stands for integer (i.e. any integer, positive or
negative).</p>
<h3 id="bit-width"><a class="header" href="#bit-width">Bit width</a></h3>
<p>The <code>32</code> in <code>u32</code> refers to the <strong>number of bits<sup class="footnote-reference" id="fr-bit-1"><a href="#footnote-bit">1</a></sup></strong> used to represent the number in memory.<br/>
The more bits, the larger the range of numbers that can be represented.</p>
<p>Rust supports multiple bit widths for integers: <code>8</code>, <code>16</code>, <code>32</code>, <code>64</code>, <code>128</code>.</p>
<p>With 32 bits, <code>u32</code> can represent numbers from <code>0</code> to <code>2^32 - 1</code> (a.k.a. <a href="https://doc.rust-lang.org/std/primitive.u32.html#associatedconstant.MAX"><code>u32::MAX</code></a>).<br/>
With the same number of bits, a signed integer (<code>i32</code>) can represent numbers from <code>-2^31</code> to <code>2^31 - 1</code>
(i.e. from <a href="https://doc.rust-lang.org/std/primitive.i32.html#associatedconstant.MIN"><code>i32::MIN</code></a>
to <a href="https://doc.rust-lang.org/std/primitive.i32.html#associatedconstant.MAX"><code>i32::MAX</code></a>).<br/>
The maximum value for <code>i32</code> is smaller than the maximum value for <code>u32</code> because one bit is used to represent
the sign of the number. Check out the <a href="https://en.wikipedia.org/wiki/Two%27s_complement">two's complement</a>
representation for more details on how signed integers are represented in memory.</p>
<h3 id="summary"><a class="header" href="#summary">Summary</a></h3>
<p>Combining the two variables (signed/unsigned and bit width), we get the following integer types:</p>
<div class="table-wrapper"><table><thead><tr><th>Bit width</th><th>Signed</th><th>Unsigned</th></tr></thead><tbody>
<tr><td>8-bit</td><td><code>i8</code></td><td><code>u8</code></td></tr>
<tr><td>16-bit</td><td><code>i16</code></td><td><code>u16</code></td></tr>
<tr><td>32-bit</td><td><code>i32</code></td><td><code>u32</code></td></tr>
<tr><td>64-bit</td><td><code>i64</code></td><td><code>u64</code></td></tr>
<tr><td>128-bit</td><td><code>i128</code></td><td><code>u128</code></td></tr>
</tbody></table>
</div>
<h2 id="literals"><a class="header" href="#literals">Literals</a></h2>
<p>A <strong>literal</strong> is a notation for representing a fixed value in source code.<br/>
For example, <code>42</code> is a Rust literal for the number forty-two.</p>
<h3 id="type-annotations-for-literals"><a class="header" href="#type-annotations-for-literals">Type annotations for literals</a></h3>
<p>But all values in Rust have a type, so... what's the type of <code>42</code>?</p>
<p>The Rust compiler will try to infer the type of a literal based on how it's used.<br/>
If you don't provide any context, the compiler will default to <code>i32</code> for integer literals.<br/>
If you want to use a different type, you can add the desired integer type as a suffix—e.g. <code>2u64</code> is a 2 that's
explicitly typed as a <code>u64</code>.</p>
<h3 id="underscores-in-literals"><a class="header" href="#underscores-in-literals">Underscores in literals</a></h3>
<p>You can use underscores <code>_</code> to improve the readability of large numbers.<br/>
For example, <code>1_000_000</code> is the same as <code>1000000</code>.</p>
<h2 id="arithmetic-operators"><a class="header" href="#arithmetic-operators">Arithmetic operators</a></h2>
<p>Rust supports the following arithmetic operators<sup class="footnote-reference" id="fr-traits-1"><a href="#footnote-traits">2</a></sup> for integers:</p>
<ul>
<li><code>+</code> for addition</li>
<li><code>-</code> for subtraction</li>
<li><code>*</code> for multiplication</li>
<li><code>/</code> for division</li>
<li><code>%</code> for remainder</li>
</ul>
<p>Precedence and associativity rules for these operators are the same as in mathematics.<br/>
You can use parentheses to override the default precedence. E.g. <code>2 * (3 + 4)</code>.</p>
<blockquote>
<p>⚠️ <strong>Warning</strong></p>
<p>The division operator <code>/</code> performs integer division when used with integer types.
I.e. the result is truncated towards zero. For example, <code>5 / 2</code> is <code>2</code>, not <code>2.5</code>.</p>
</blockquote>
<h2 id="no-automatic-type-coercion"><a class="header" href="#no-automatic-type-coercion">No automatic type coercion</a></h2>
<p>As we discussed in the previous exercise, Rust is a statically typed language.<br/>
In particular, Rust is quite strict about type coercion. It won't automatically convert a value from one type to
another<sup class="footnote-reference" id="fr-coercion-1"><a href="#footnote-coercion">3</a></sup>,
even if the conversion is lossless. You have to do it explicitly.</p>
<p>For example, you can't assign a <code>u8</code> value to a variable with type <code>u32</code>, even though all <code>u8</code> values are valid <code>u32</code>
values:</p>
<pre><code class="language-rust">let b: u8 = 100;
let a: u32 = b;</code></pre>
<p>It'll throw a compilation error:</p>
<pre><code class="language-text">error[E0308]: mismatched types
  |
3 |     let a: u32 = b;
  |            ---   ^ expected `u32`, found `u8`
  |            |
  |            expected due to this
  |
</code></pre>
<p>We'll see how to convert between types <a href="/100-exercises/04_traits/09_from">later in this course</a>.</p>
<h2 id="further-reading"><a class="header" href="#further-reading">Further reading</a></h2>
<ul>
<li><a href="https://doc.rust-lang.org/book/ch03-02-data-types.html#integer-types">The integer types section</a> in the official Rust book</li>
</ul>
<h2 id="exercise"><a class="header" href="#exercise">Exercise</a></h2>
<p>The exercise for this section is located in <a href="https://github.com/mainmatter/100-exercises-to-learn-rust/tree/main/exercises/02_basic_calculator/01_integers"><code>02_basic_calculator/01_integers</code></a></p>
<hr/>
<ol class="footnote-definition"><li id="footnote-bit">
<p>A bit is the smallest unit of data in a computer. It can only have two values: <code>0</code> or <code>1</code>. <a href="#fr-bit-1">↩</a></p>
</li>
<li id="footnote-traits">
<p>Rust doesn't let you define custom operators, but it puts you in control of how the built-in operators
behave.
We'll talk about operator overloading <a href="/100-exercises/04_traits/03_operator_overloading">later in the course</a>, after we've covered traits. <a href="#fr-traits-1">↩</a></p>
</li>
<li id="footnote-coercion">
<p>There are some exceptions to this rule, mostly related to references, smart pointers and ergonomics. We'll
cover those <a href="/100-exercises/04_traits/07_deref">later on</a>.
A mental model of "all conversions are explicit" will serve you well in the meantime. <a href="#fr-coercion-1">↩</a></p>
</li>
</ol>
                        
</body>
</html>