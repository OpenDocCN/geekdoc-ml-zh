<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.1//EN"
  "http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd">

<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<title>From and Into</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1>From and Into</h1>
<blockquote>原文：<a href="https://rust-exercises.com/100-exercises/04_traits/09_from.html">https://rust-exercises.com/100-exercises/04_traits/09_from.html</a></blockquote>
                        
<p>Let's go back to where our string journey started:</p>
<pre><code class="language-rust">let ticket = Ticket::new(
    "A title".into(), 
    "A description".into(), 
    "To-Do".into()
);</code></pre>
<p>We now know enough to start unpacking what <code>.into()</code> is doing here.</p>
<h2 id="the-problem"><a class="header" href="#the-problem">The problem</a></h2>
<p>This is the signature of the <code>new</code> method:</p>
<pre><code class="language-rust">impl Ticket {
    pub fn new(
        title: String, 
        description: String, 
        status: String
    ) -&gt; Self {
        // [...]
    }
}</code></pre>
<p>We've also seen that string literals (such as <code>"A title"</code>) are of type <code>&amp;str</code>.<br/>
We have a type mismatch here: a <code>String</code> is expected, but we have a <code>&amp;str</code>.
No magical coercion will come to save us this time; we need <strong>to perform a conversion</strong>.</p>
<h2 id="from-and-into-1"><a class="header" href="#from-and-into-1"><code>From</code> and <code>Into</code></a></h2>
<p>The Rust standard library defines two traits for <strong>infallible conversions</strong>: <code>From</code> and <code>Into</code>,
in the <code>std::convert</code> module.</p>
<pre><code class="language-rust">pub trait From&lt;T&gt;: Sized {
    fn from(value: T) -&gt; Self;
}

pub trait Into&lt;T&gt;: Sized {
    fn into(self) -&gt; T;
}</code></pre>
<p>These trait definitions showcase a few concepts that we haven't seen before: <strong>supertraits</strong> and <strong>implicit trait bounds</strong>.
Let's unpack those first.</p>
<h3 id="supertrait--subtrait"><a class="header" href="#supertrait--subtrait">Supertrait / Subtrait</a></h3>
<p>The <code>From: Sized</code> syntax implies that <code>From</code> is a <strong>subtrait</strong> of <code>Sized</code>: any type that
implements <code>From</code> must also implement <code>Sized</code>.
Alternatively, you could say that <code>Sized</code> is a <strong>supertrait</strong> of <code>From</code>.</p>
<h3 id="implicit-trait-bounds"><a class="header" href="#implicit-trait-bounds">Implicit trait bounds</a></h3>
<p>Every time you have a generic type parameter, the compiler implicitly assumes that it's <code>Sized</code>.</p>
<p>For example:</p>
<pre><code class="language-rust">pub struct Foo&lt;T&gt; {
    inner: T,
}</code></pre>
<p>is actually equivalent to:</p>
<pre><code class="language-rust">pub struct Foo&lt;T: Sized&gt; 
{
    inner: T,
}</code></pre>
<p>In the case of <code>From&lt;T&gt;</code>, the trait definition is equivalent to:</p>
<pre><code class="language-rust">pub trait From&lt;T: Sized&gt;: Sized {
    fn from(value: T) -&gt; Self;
}</code></pre>
<p>In other words, <em>both</em> <code>T</code> and the type implementing <code>From&lt;T&gt;</code> must be <code>Sized</code>, even
though the former bound is implicit.</p>
<h3 id="negative-trait-bounds"><a class="header" href="#negative-trait-bounds">Negative trait bounds</a></h3>
<p>You can opt out of the implicit <code>Sized</code> bound with a <strong>negative trait bound</strong>:</p>
<pre><code class="language-rust">pub struct Foo&lt;T: ?Sized&gt; {
    //            ^^^^^^^
    //            This is a negative trait bound
    inner: T,
}</code></pre>
<p>This syntax reads as "<code>T</code> may or may not be <code>Sized</code>", and it allows you to
bind <code>T</code> to a DST (e.g. <code>Foo&lt;str&gt;</code>). It is a special case, though: negative trait bounds are exclusive to <code>Sized</code>,
you can't use them with other traits.</p>
<h2 id="str-to-string"><a class="header" href="#str-to-string"><code>&amp;str</code> to <code>String</code></a></h2>
<p>In <a href="https://doc.rust-lang.org/std/convert/trait.From.html#implementors"><code>std</code>'s documentation</a>
you can see which <code>std</code> types implement the <code>From</code> trait.<br/>
You'll find that <code>String</code> implements <code>From&lt;&amp;str&gt; for String</code>. Thus, we can write:</p>
<pre><code class="language-rust">let title = String::from("A title");</code></pre>
<p>We've been primarily using <code>.into()</code>, though.<br/>
If you check out the <a href="https://doc.rust-lang.org/std/convert/trait.Into.html#implementors">implementors of <code>Into</code></a>
you won't find <code>Into&lt;String&gt; for &amp;str</code>. What's going on?</p>
<p><code>From</code> and <code>Into</code> are <strong>dual traits</strong>.<br/>
In particular, <code>Into</code> is implemented for any type that implements <code>From</code> using a <strong>blanket implementation</strong>:</p>
<pre><code class="language-rust">impl&lt;T, U&gt; Into&lt;U&gt; for T
where
    U: From&lt;T&gt;,
{
    fn into(self) -&gt; U {
        U::from(self)
    }
}</code></pre>
<p>If a type <code>U</code> implements <code>From&lt;T&gt;</code>, then <code>Into&lt;U&gt; for T</code> is automatically implemented. That's why
we can write <code>let title = "A title".into();</code>.</p>
<h2 id="into"><a class="header" href="#into"><code>.into()</code></a></h2>
<p>Every time you see <code>.into()</code>, you're witnessing a conversion between types.<br/>
What's the target type, though?</p>
<p>In most cases, the target type is either:</p>
<ul>
<li>Specified by the signature of a function/method (e.g. <code>Ticket::new</code> in our example above)</li>
<li>Specified in the variable declaration with a type annotation (e.g. <code>let title: String = "A title".into();</code>)</li>
</ul>
<p><code>.into()</code> will work out of the box as long as the compiler can infer the target type from the context without ambiguity.</p>
<h2 id="exercise"><a class="header" href="#exercise">Exercise</a></h2>
<p>The exercise for this section is located in <a href="https://github.com/mainmatter/100-exercises-to-learn-rust/tree/main/exercises/04_traits/09_from"><code>04_traits/09_from</code></a></p>

                        
</body>
</html>