- en: Copying values, pt. 2
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 原文：[https://rust-exercises.com/100-exercises/04_traits/12_copy.html](https://rust-exercises.com/100-exercises/04_traits/12_copy.html)
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'Let''s consider the same example as before, but with a slight twist: using
    `u32` rather than `String` as a type.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: It'll compile without errors! What's going on here? What's the difference between
    `String` and `u32` that makes the latter work without `.clone()`?
  prefs: []
  type: TYPE_NORMAL
- en: '[`Copy`](#copy)'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '`Copy` is another trait defined in Rust''s standard library:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: It is a marker trait, just like `Sized`.
  prefs: []
  type: TYPE_NORMAL
- en: 'If a type implements `Copy`, there''s no need to call `.clone()` to create
    a new instance of the type: Rust does it **implicitly** for you.'
  prefs: []
  type: TYPE_NORMAL
- en: '`u32` is an example of a type that implements `Copy`, which is why the example
    above compiles without errors: when `consumer(s)` is called, Rust creates a new
    `u32` instance by performing a **bitwise copy** of `s`, and then passes that new
    instance to `consumer`. It all happens behind the scenes, without you having to
    do anything.'
  prefs: []
  type: TYPE_NORMAL
- en: '[What can be `Copy`?](#what-can-be-copy)'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '`Copy` is not equivalent to "automatic cloning", although it implies it.'
  prefs: []
  type: TYPE_NORMAL
- en: Types must meet a few requirements in order to be allowed to implement `Copy`.
  prefs: []
  type: TYPE_NORMAL
- en: 'First of all, it must implement `Clone`, since `Copy` is a subtrait of `Clone`.
    This makes sense: if Rust can create a new instance of a type *implicitly*, it
    should also be able to create a new instance *explicitly* by calling `.clone()`.'
  prefs: []
  type: TYPE_NORMAL
- en: 'That''s not all, though. A few more conditions must be met:'
  prefs: []
  type: TYPE_NORMAL
- en: The type doesn't manage any *additional* resources (e.g. heap memory, file handles,
    etc.) beyond the `std::mem::size_of` bytes that it occupies in memory.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The type is not a mutable reference (`&mut T`).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If both conditions are met, then Rust can safely create a new instance of the
    type by performing a **bitwise copy** of the original instance—this is often referred
    to as a `memcpy` operation, after the C standard library function that performs
    the bitwise copy.
  prefs: []
  type: TYPE_NORMAL
- en: '[Case study 1: `String`](#case-study-1-string)'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '`String` is a type that doesn''t implement `Copy`.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Why? Because it manages an additional resource: the heap-allocated memory buffer
    that stores the string''s data.'
  prefs: []
  type: TYPE_NORMAL
- en: Let's imagine that Rust allowed `String` to implement `Copy`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Then, when a new `String` instance is created by performing a bitwise copy
    of the original instance, both the original and the new instance would point to
    the same memory buffer:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: This is bad! Both `String` instances would try to free the memory buffer when
    they go out of scope, leading to a double-free error. You could also create two
    distinct `&mut String` references that point to the same memory buffer, violating
    Rust's borrowing rules.
  prefs: []
  type: TYPE_NORMAL
- en: '[Case study 2: `u32`](#case-study-2-u32)'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '`u32` implements `Copy`. All integer types do, in fact.'
  prefs: []
  type: TYPE_NORMAL
- en: An integer is "just" the bytes that represent the number in memory. There's
    nothing more! If you copy those bytes, you get another perfectly valid integer
    instance. Nothing bad can happen, so Rust allows it.
  prefs: []
  type: TYPE_NORMAL
- en: '[Case study 3: `&mut u32`](#case-study-3-mut-u32)'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'When we introduced ownership and mutable borrows, we stated one rule quite
    clearly: there can only ever be *one* mutable borrow of a value at any given time.'
  prefs: []
  type: TYPE_NORMAL
- en: That's why `&mut u32` doesn't implement `Copy`, even though `u32` does.
  prefs: []
  type: TYPE_NORMAL
- en: If `&mut u32` implemented `Copy`, you could create multiple mutable references
    to the same value and modify it in multiple places at the same time. That'd be
    a violation of Rust's borrowing rules! It follows that `&mut T` never implements
    `Copy`, no matter what `T` is.
  prefs: []
  type: TYPE_NORMAL
- en: '[Implementing `Copy`](#implementing-copy)'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In most cases, you don''t need to manually implement `Copy`. You can just derive
    it, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: '[Exercise](#exercise)'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The exercise for this section is located in [`04_traits/12_copy`](https://github.com/mainmatter/100-exercises-to-learn-rust/tree/main/exercises/04_traits/12_copy)
  prefs: []
  type: TYPE_NORMAL
