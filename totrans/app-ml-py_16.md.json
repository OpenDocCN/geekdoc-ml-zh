["```py\nignore_warnings = True                                        # ignore warnings?\nimport numpy as np                                            # ndarrays for gridded data\nimport pandas as pd                                           # DataFrames for tabular data\nimport copy                                                   # for deep copies\nimport os                                                     # set working directory, run executables\nimport matplotlib.pyplot as plt                               # for plotting\nfrom matplotlib.colors import ListedColormap                  # custom color maps\nfrom matplotlib.ticker import (MultipleLocator,AutoMinorLocator,NullLocator,FuncFormatter) # control of axes ticks\nfrom scipy import stats                                       # summary statistics\nimport math                                                   # trigonometry etc.\nimport scipy.signal as signal                                 # kernel for moving window calculation\nimport random                                                 # for random numbers\nimport seaborn as sns                                         # for matrix scatter plots\nfrom scipy import linalg                                      # for linear regression\nfrom sklearn.preprocessing import StandardScaler # feature standardization\nfrom sklearn.manifold import MDS                              # multidimensional scaling\nfrom sklearn.metrics.pairwise import euclidean_distances\nplt.rc('axes', axisbelow=True)                                # plot all grids below the plot elements\nif ignore_warnings == True:                                   \n    import warnings\n    warnings.filterwarnings('ignore')\ncmap = plt.cm.inferno                                         # color map\nseed = 42                                                     # random number seed \n```", "```py\ndef comma_format(x, pos):\n    return f'{int(x):,}'\n\ndef add_grid():                                            \n    plt.gca().grid(True, which='major',linewidth = 1.0); plt.gca().grid(True, which='minor',linewidth = 0.2) # add y grids\n    plt.gca().tick_params(which='major',length=7); plt.gca().tick_params(which='minor', length=4)\n    plt.gca().xaxis.set_minor_locator(AutoMinorLocator()); plt.gca().yaxis.set_minor_locator(AutoMinorLocator()) # turn on minor ticks \n```", "```py\n#os.chdir(\"c:/PGE383\")                     # set the working directory \n```", "```py\nimport pandas as pd \n```", "```py\npd.read_csv() \n```", "```py\ndf = pd.read_csv(\"unconv_MV.csv\") \n```", "```py\ndf = df.sample(frac=.30, random_state = 73073); \ndf = df.reset_index() \n```", "```py\ndf = pd.read_csv(r'https://raw.githubusercontent.com/GeostatsGuy/GeoDataSets/master/unconv_MV_v4.csv')\n\nindex = ['Well']\nXname = ['Por','AI','TOC']                                    # specify features of interest\n\nyname = ['Prod']\ndf =  df[index + Xname + yname]\n\nXunit = ['%',r'$kg/m2 \\times 10^6$','%']; Xlabel = ['Porosity','Acoustic Impedance','Total Organic Carbon'] # specify features' metadata\nXlabelunit = [f\"{s1} ({s2})\" for s1, s2 in zip(Xlabel, Xunit)]\nXmin = [0.0,0.0,0.0]; Xmax = [30.0,5.0,100.0]                 # set minimums and maximums for visualization \nnXname = ['n' + feature for feature in Xname]                 # labels, units and ranges for normalized features\n\nnormalized = StandardScaler().fit_transform(df[Xname])        # standardize the features\n\nfor col_name, new_col in zip(nXname, normalized.T):           # add standardized features to the DataFrame\n    df[col_name] = new_col\n\nnXunit = ['norm[' + unit + ']' for unit in Xunit]             # specify the standardized features' metadata\nnXlabel = ['Normalized ' + feature for feature in Xlabel]\nnXlabelunit = [f\"{s1} ({s2})\" for s1, s2 in zip(nXlabel, nXunit)]\nnXmin = [-3.0,-3.0,-3.0]; nXmax = [3.0,3.0,3.0] \n```", "```py\ndf.head(n=4)                                                  # we could also use this command for a table preview \n```", "```py\ndf.describe() \n```", "```py\npairplot = sns.pairplot(df,vars=nXname,markers='o',plot_kws={'color':'grey','alpha': 0.8},)\npairplot.map_diag(sns.histplot, color='grey', kde=False)\npairplot.x_vars = Xlabelunit; pairplot.y_vars = Xlabelunit; pairplot._add_axis_labels()\nplt.subplots_adjust(left=0.0, bottom=0.0, right=1.2, top=1.2, wspace=0.3, hspace=0.2); plt.show() \n```", "```py\nbins = [0,2500,5000,7500,10000]                               # assign the production bins (these are the fence posts)\n\nlabels = ['low', 'med', 'high', 'vhigh']                      # assign the labels\ncategory = pd.cut(df[yname].values.reshape(-1),bins,labels=labels) # make the 1D array with the labels for our data\ndf['tProd'] = category                                        # add the new ordinal production feature to our DataFrames \ndf.head()\ndpalette = sns.color_palette(\"rocket_r\",n_colors = 4)\npalette = sns.color_palette(\"rocket\") \n```", "```py\npairplot2 = sns.pairplot(df[nXname + ['tProd']],markers='o',hue = 'tProd', palette = dpalette,diag_kws={'edgecolor':'black'},\n                    plot_kws=dict(s=50, edgecolor=\"black\", linewidth=0.5))\npairplot2.x_vars = Xlabelunit; pairplot2.y_vars = Xlabelunit; pairplot2._add_axis_labels()\nplt.subplots_adjust(left=0.0, bottom=0.0, right=1.5, top=1.5, wspace=0.3, hspace=0.2); plt.show() \n```", "```py\nnp.random.seed(seed)                                          # set the random number seed, so we all get the same answer\nn_components = 2                                              # p, reduced dimensionality space\nembedding = MDS(n_components=2,n_init = 20,max_iter = 1000,random_state = 73073) # instantiate and set the hyperparameter\nMDS_transformed = embedding.fit_transform(df[nXname])\nMDS_transformed.shape \n```", "```py\n(200, 2) \n```", "```py\ndf['MDS1'] = MDS_transformed[:,0]                             # add MDS projections to DataFrame\ndf['MDS2'] = MDS_transformed[:,1]\ndf.head() \n```", "```py\nplt.subplot(121)                                              # plot labeled MDS projection\npairplot = sns.scatterplot(x = df['MDS1'],y = df['MDS2'],hue = df['tProd'],markers='o',palette = dpalette,edgecolor=\"black\")\n\nplt.subplot(122)\npairplot = sns.scatterplot(x = df['MDS1'],y = df['MDS2'],hue = df['Well'],markers='o',edgecolor=\"black\")\n\nplt.subplots_adjust(left=0.0, bottom=0.0, right=2., top=1.1, wspace=0.3, hspace=0.2,); plt.show() \n```", "```py\ndists = euclidean_distances(df[nXname], squared=False).ravel() # calculate pairwise distance\nnonzero = dists != 0                                          # select only non-identical samples pairs\ndists = dists[nonzero]\nprojected_dists = euclidean_distances(MDS_transformed, squared=False).ravel()[nonzero] # calculate projected pairwise distance\n\nplt.subplot(221)                                              # scatter plot original and projected pairwise distance\nplt.scatter(dists,projected_dists,c='darkorange',alpha=0.4,edgecolor = 'black')\nplt.arrow(0,0,200,200,width=0.02,color='black',head_length=0.0,head_width=0.0)\nplt.xlim(0,15); plt.ylim(0,15); add_grid()\nplt.xlabel(\"Pairwise Distance: original space\"); plt.ylabel(\"Pairwise Distance: projected space\")\nplt.title(\"MDS Pairwise Distance: Projected to %d Components\" % n_components)\n\nratio = projected_dists / dists                               # calculate projected distance/original distance ratio\n\nplt.subplot(222)                                              # histogram of distance ratio\nplt.hist(ratio, bins=50, range=(0.5, 1.5),color = 'darkorange',alpha = 0.8,edgecolor='k')\nplt.xlabel(\"Distance Ratio: projected / original\"); plt.ylabel(\"Frequency\"); add_grid()\nplt.title(\"MDS Pairwise Distance: Projected to %d Components\" % n_components)\nplt.annotate('Distance Ratio:',[0.55,9000])\nplt.annotate('mean = ' + str(round(np.mean(ratio),2)),[0.61,8300])\nplt.annotate('st.dev. = ' + str(round(np.std(ratio),2)),[0.61,7600])\n\nplt.subplot(223)                                               # histogram of original pairwise distance\nplt.hist(dists, bins=50, range=(0., 15.),color = 'darkorange',alpha = 0.8,edgecolor='k'); add_grid()\nplt.xlabel(\"Pairwise Distance\"); plt.ylabel(\"Frequency\"); plt.title(\"MDS Pairwise Distance: Original Data\"); plt.xlim(xmin=0)\nplt.annotate('Original Pairwise Distance:',[9,4000]); plt.ylim([0,5500])\nplt.annotate('mean = ' + str(round(np.mean(dists),2)),[10,3700])\nplt.annotate('st.dev. = ' + str(round(np.std(dists),2)),[10,3400])\n\nplt.subplot(224)                                               # histogram of projected pairwise distance\nplt.hist(projected_dists, bins=50, range=(0., 15.),color = 'darkorange',alpha = 0.8, edgecolor='k')\nplt.xlabel(\"Pairwise Distance\"); plt.ylabel(\"Frequency\"); add_grid(); plt.xlim(xmin=0); plt.ylim([0,5500])\nplt.title(\"MDS Pairwise Distance: Projected to %d Components\" % n_components)\nplt.annotate('Original Pairwise Distance:',[9,4000])\nplt.annotate('mean = ' + str(round(np.mean(projected_dists),2)),[10,3700])\nplt.annotate('st.dev. = ' + str(round(np.std(projected_dists),2)),[10,3400])\n\nplt.subplots_adjust(left=0.0, bottom=0.0, right=1.6, top=1.7, wspace=0.2, hspace=0.3); plt.show() \n```", "```py\ndf_subset = df.sample(n = 30,random_state = seed+5).copy(deep = True)           # randomly sample 30 data without replacement\ndf_subset = df_subset.reset_index() \n```", "```py\nplt.subplot(311)\npairplot = sns.scatterplot(x = df_subset[nXname[0]],y = df_subset[nXname[1]],s=60,\n        hue = df_subset['tProd'],edgecolor=\"black\",markers='o')\nplt.xlabel(nXlabelunit[0]); plt.ylabel(nXlabelunit[1]); add_grid();\nplt.xlim([nXmin[0],nXmax[0]]); plt.ylim([nXmin[1],nXmax[1]]); plt.title('30 Samples, ' + str(Xlabel[1]) + ' vs. ' + str(Xlabel[0]))\nfor i, txt in enumerate(df_subset['Well']):\n    pairplot.annotate(txt, (df_subset[nXname[0]][i]+0.1, df_subset[nXname[1]][i]+0.1))\n\nplt.subplot(312)\npairplot = sns.scatterplot(x = df_subset[nXname[1]],y = df_subset[nXname[2]],s=60,\n        hue = df_subset['tProd'],edgecolor=\"black\",markers='o')\nplt.xlabel(nXlabelunit[1]); plt.ylabel(nXlabelunit[2]); add_grid();\nplt.xlim([nXmin[1],nXmax[1]]); plt.ylim([nXmin[2],nXmax[2]]); plt.title('30 Samples, ' + str(Xlabel[2]) + ' vs. ' + str(Xlabel[1]))\nfor i, txt in enumerate(df_subset['Well']):\n    pairplot.annotate(txt, (df_subset[nXname[1]][i]+0.1, df_subset[nXname[2]][i]+0.1))\n\nplt.subplot(313)\npairplot = sns.scatterplot(x = df_subset[nXname[0]],y = df_subset[nXname[2]],s=60,\n        hue = df_subset['tProd'],edgecolor=\"black\",markers='o')\nplt.xlabel(nXlabelunit[0]); plt.ylabel(nXlabelunit[2]); add_grid();\nplt.xlim([nXmin[0],nXmax[0]]); plt.ylim([nXmin[2],nXmax[2]]); plt.title('30 Samples, ' + str(Xlabel[2]) + ' vs. ' + str(Xlabel[0]))\nfor i, txt in enumerate(df_subset['Well']):\n    pairplot.annotate(txt, (df_subset[nXname[0]][i]+0.1, df_subset[nXname[2]][i]+0.1))\n\nplt.subplots_adjust(left=0.0, bottom=0.0, right=1.0, top=3.1, wspace=0.3, hspace=0.2); plt.show() \n```", "```py\nembedding_subset = MDS(n_components=2)                        # MDS projection\nMDS_transformed_subset = embedding_subset.fit_transform(df_subset[nXname]) \n```", "```py\nplt.subplot(121)                                              # plot data samples in MDS space\npairplot = sns.scatterplot(x = MDS_transformed_subset[:,0],y = MDS_transformed_subset[:,1],s=60,\n        hue = df_subset['tProd'],edgecolor=\"black\",markers='o')\nfor i, txt in enumerate(df_subset['Well'].values):\n    plt.annotate(txt, [MDS_transformed_subset[:,0][i]+0.1,MDS_transformed_subset[:,1][i]+0.1])\nplt.xlim([-3.5,3.5]); plt.ylim([-3.5,3.5]); plt.title('30 Samples, MDS#2 vs. MDS#1')\npairplot.set_xlabel('MDS1'); pairplot.set_ylabel('MDS2')  \npairplot.legend(loc='lower right'); add_grid(); plt.legend(loc = 'upper right')\n\ndists = euclidean_distances(df_subset[nXname], squared=False).ravel() # calculate all pairwise distances\nnonzero = dists != 0                                          # select only non-identical samples pairs\ndists = dists[nonzero]\nprojected_dists = euclidean_distances(MDS_transformed_subset, squared=False).ravel()[nonzero] # calculate projected pairwise distance\n\nplt.subplot(122)                                              # scatter plot original and projected pairwise distance\nplt.scatter(dists,projected_dists,c='darkorange',alpha=0.4,edgecolor = 'black')\nplt.arrow(0,0,200,200,width=0.02,color='black',head_length=0.0,head_width=0.0)\nplt.xlim(0,15); plt.ylim(0,15); add_grid()\nplt.xlabel(\"Pairwise Distance: original space\"); plt.ylabel(\"Pairwise Distance: projected space\")\nplt.title(\"MDS Pairwise Distance: Projected to %d Components\" % n_components)\n\nplt.subplots_adjust(left=0.0, bottom=0.0, right=2., top=1.1, wspace=0.3, hspace=0.2); plt.show() \n```", "```py\nignore_warnings = True                                        # ignore warnings?\nimport numpy as np                                            # ndarrays for gridded data\nimport pandas as pd                                           # DataFrames for tabular data\nimport copy                                                   # for deep copies\nimport os                                                     # set working directory, run executables\nimport matplotlib.pyplot as plt                               # for plotting\nfrom matplotlib.colors import ListedColormap                  # custom color maps\nfrom matplotlib.ticker import (MultipleLocator,AutoMinorLocator,NullLocator,FuncFormatter) # control of axes ticks\nfrom scipy import stats                                       # summary statistics\nimport math                                                   # trigonometry etc.\nimport scipy.signal as signal                                 # kernel for moving window calculation\nimport random                                                 # for random numbers\nimport seaborn as sns                                         # for matrix scatter plots\nfrom scipy import linalg                                      # for linear regression\nfrom sklearn.preprocessing import StandardScaler # feature standardization\nfrom sklearn.manifold import MDS                              # multidimensional scaling\nfrom sklearn.metrics.pairwise import euclidean_distances\nplt.rc('axes', axisbelow=True)                                # plot all grids below the plot elements\nif ignore_warnings == True:                                   \n    import warnings\n    warnings.filterwarnings('ignore')\ncmap = plt.cm.inferno                                         # color map\nseed = 42                                                     # random number seed \n```", "```py\ndef comma_format(x, pos):\n    return f'{int(x):,}'\n\ndef add_grid():                                            \n    plt.gca().grid(True, which='major',linewidth = 1.0); plt.gca().grid(True, which='minor',linewidth = 0.2) # add y grids\n    plt.gca().tick_params(which='major',length=7); plt.gca().tick_params(which='minor', length=4)\n    plt.gca().xaxis.set_minor_locator(AutoMinorLocator()); plt.gca().yaxis.set_minor_locator(AutoMinorLocator()) # turn on minor ticks \n```", "```py\n#os.chdir(\"c:/PGE383\")                     # set the working directory \n```", "```py\nimport pandas as pd \n```", "```py\npd.read_csv() \n```", "```py\ndf = pd.read_csv(\"unconv_MV.csv\") \n```", "```py\ndf = df.sample(frac=.30, random_state = 73073); \ndf = df.reset_index() \n```", "```py\ndf = pd.read_csv(r'https://raw.githubusercontent.com/GeostatsGuy/GeoDataSets/master/unconv_MV_v4.csv')\n\nindex = ['Well']\nXname = ['Por','AI','TOC']                                    # specify features of interest\n\nyname = ['Prod']\ndf =  df[index + Xname + yname]\n\nXunit = ['%',r'$kg/m2 \\times 10^6$','%']; Xlabel = ['Porosity','Acoustic Impedance','Total Organic Carbon'] # specify features' metadata\nXlabelunit = [f\"{s1} ({s2})\" for s1, s2 in zip(Xlabel, Xunit)]\nXmin = [0.0,0.0,0.0]; Xmax = [30.0,5.0,100.0]                 # set minimums and maximums for visualization \nnXname = ['n' + feature for feature in Xname]                 # labels, units and ranges for normalized features\n\nnormalized = StandardScaler().fit_transform(df[Xname])        # standardize the features\n\nfor col_name, new_col in zip(nXname, normalized.T):           # add standardized features to the DataFrame\n    df[col_name] = new_col\n\nnXunit = ['norm[' + unit + ']' for unit in Xunit]             # specify the standardized features' metadata\nnXlabel = ['Normalized ' + feature for feature in Xlabel]\nnXlabelunit = [f\"{s1} ({s2})\" for s1, s2 in zip(nXlabel, nXunit)]\nnXmin = [-3.0,-3.0,-3.0]; nXmax = [3.0,3.0,3.0] \n```", "```py\ndf.head(n=4)                                                  # we could also use this command for a table preview \n```", "```py\ndf.describe() \n```", "```py\npairplot = sns.pairplot(df,vars=nXname,markers='o',plot_kws={'color':'grey','alpha': 0.8},)\npairplot.map_diag(sns.histplot, color='grey', kde=False)\npairplot.x_vars = Xlabelunit; pairplot.y_vars = Xlabelunit; pairplot._add_axis_labels()\nplt.subplots_adjust(left=0.0, bottom=0.0, right=1.2, top=1.2, wspace=0.3, hspace=0.2); plt.show() \n```", "```py\nbins = [0,2500,5000,7500,10000]                               # assign the production bins (these are the fence posts)\n\nlabels = ['low', 'med', 'high', 'vhigh']                      # assign the labels\ncategory = pd.cut(df[yname].values.reshape(-1),bins,labels=labels) # make the 1D array with the labels for our data\ndf['tProd'] = category                                        # add the new ordinal production feature to our DataFrames \ndf.head()\ndpalette = sns.color_palette(\"rocket_r\",n_colors = 4)\npalette = sns.color_palette(\"rocket\") \n```", "```py\npairplot2 = sns.pairplot(df[nXname + ['tProd']],markers='o',hue = 'tProd', palette = dpalette,diag_kws={'edgecolor':'black'},\n                    plot_kws=dict(s=50, edgecolor=\"black\", linewidth=0.5))\npairplot2.x_vars = Xlabelunit; pairplot2.y_vars = Xlabelunit; pairplot2._add_axis_labels()\nplt.subplots_adjust(left=0.0, bottom=0.0, right=1.5, top=1.5, wspace=0.3, hspace=0.2); plt.show() \n```", "```py\nnp.random.seed(seed)                                          # set the random number seed, so we all get the same answer\nn_components = 2                                              # p, reduced dimensionality space\nembedding = MDS(n_components=2,n_init = 20,max_iter = 1000,random_state = 73073) # instantiate and set the hyperparameter\nMDS_transformed = embedding.fit_transform(df[nXname])\nMDS_transformed.shape \n```", "```py\n(200, 2) \n```", "```py\ndf['MDS1'] = MDS_transformed[:,0]                             # add MDS projections to DataFrame\ndf['MDS2'] = MDS_transformed[:,1]\ndf.head() \n```", "```py\nplt.subplot(121)                                              # plot labeled MDS projection\npairplot = sns.scatterplot(x = df['MDS1'],y = df['MDS2'],hue = df['tProd'],markers='o',palette = dpalette,edgecolor=\"black\")\n\nplt.subplot(122)\npairplot = sns.scatterplot(x = df['MDS1'],y = df['MDS2'],hue = df['Well'],markers='o',edgecolor=\"black\")\n\nplt.subplots_adjust(left=0.0, bottom=0.0, right=2., top=1.1, wspace=0.3, hspace=0.2,); plt.show() \n```", "```py\ndists = euclidean_distances(df[nXname], squared=False).ravel() # calculate pairwise distance\nnonzero = dists != 0                                          # select only non-identical samples pairs\ndists = dists[nonzero]\nprojected_dists = euclidean_distances(MDS_transformed, squared=False).ravel()[nonzero] # calculate projected pairwise distance\n\nplt.subplot(221)                                              # scatter plot original and projected pairwise distance\nplt.scatter(dists,projected_dists,c='darkorange',alpha=0.4,edgecolor = 'black')\nplt.arrow(0,0,200,200,width=0.02,color='black',head_length=0.0,head_width=0.0)\nplt.xlim(0,15); plt.ylim(0,15); add_grid()\nplt.xlabel(\"Pairwise Distance: original space\"); plt.ylabel(\"Pairwise Distance: projected space\")\nplt.title(\"MDS Pairwise Distance: Projected to %d Components\" % n_components)\n\nratio = projected_dists / dists                               # calculate projected distance/original distance ratio\n\nplt.subplot(222)                                              # histogram of distance ratio\nplt.hist(ratio, bins=50, range=(0.5, 1.5),color = 'darkorange',alpha = 0.8,edgecolor='k')\nplt.xlabel(\"Distance Ratio: projected / original\"); plt.ylabel(\"Frequency\"); add_grid()\nplt.title(\"MDS Pairwise Distance: Projected to %d Components\" % n_components)\nplt.annotate('Distance Ratio:',[0.55,9000])\nplt.annotate('mean = ' + str(round(np.mean(ratio),2)),[0.61,8300])\nplt.annotate('st.dev. = ' + str(round(np.std(ratio),2)),[0.61,7600])\n\nplt.subplot(223)                                               # histogram of original pairwise distance\nplt.hist(dists, bins=50, range=(0., 15.),color = 'darkorange',alpha = 0.8,edgecolor='k'); add_grid()\nplt.xlabel(\"Pairwise Distance\"); plt.ylabel(\"Frequency\"); plt.title(\"MDS Pairwise Distance: Original Data\"); plt.xlim(xmin=0)\nplt.annotate('Original Pairwise Distance:',[9,4000]); plt.ylim([0,5500])\nplt.annotate('mean = ' + str(round(np.mean(dists),2)),[10,3700])\nplt.annotate('st.dev. = ' + str(round(np.std(dists),2)),[10,3400])\n\nplt.subplot(224)                                               # histogram of projected pairwise distance\nplt.hist(projected_dists, bins=50, range=(0., 15.),color = 'darkorange',alpha = 0.8, edgecolor='k')\nplt.xlabel(\"Pairwise Distance\"); plt.ylabel(\"Frequency\"); add_grid(); plt.xlim(xmin=0); plt.ylim([0,5500])\nplt.title(\"MDS Pairwise Distance: Projected to %d Components\" % n_components)\nplt.annotate('Original Pairwise Distance:',[9,4000])\nplt.annotate('mean = ' + str(round(np.mean(projected_dists),2)),[10,3700])\nplt.annotate('st.dev. = ' + str(round(np.std(projected_dists),2)),[10,3400])\n\nplt.subplots_adjust(left=0.0, bottom=0.0, right=1.6, top=1.7, wspace=0.2, hspace=0.3); plt.show() \n```", "```py\ndf_subset = df.sample(n = 30,random_state = seed+5).copy(deep = True)           # randomly sample 30 data without replacement\ndf_subset = df_subset.reset_index() \n```", "```py\nplt.subplot(311)\npairplot = sns.scatterplot(x = df_subset[nXname[0]],y = df_subset[nXname[1]],s=60,\n        hue = df_subset['tProd'],edgecolor=\"black\",markers='o')\nplt.xlabel(nXlabelunit[0]); plt.ylabel(nXlabelunit[1]); add_grid();\nplt.xlim([nXmin[0],nXmax[0]]); plt.ylim([nXmin[1],nXmax[1]]); plt.title('30 Samples, ' + str(Xlabel[1]) + ' vs. ' + str(Xlabel[0]))\nfor i, txt in enumerate(df_subset['Well']):\n    pairplot.annotate(txt, (df_subset[nXname[0]][i]+0.1, df_subset[nXname[1]][i]+0.1))\n\nplt.subplot(312)\npairplot = sns.scatterplot(x = df_subset[nXname[1]],y = df_subset[nXname[2]],s=60,\n        hue = df_subset['tProd'],edgecolor=\"black\",markers='o')\nplt.xlabel(nXlabelunit[1]); plt.ylabel(nXlabelunit[2]); add_grid();\nplt.xlim([nXmin[1],nXmax[1]]); plt.ylim([nXmin[2],nXmax[2]]); plt.title('30 Samples, ' + str(Xlabel[2]) + ' vs. ' + str(Xlabel[1]))\nfor i, txt in enumerate(df_subset['Well']):\n    pairplot.annotate(txt, (df_subset[nXname[1]][i]+0.1, df_subset[nXname[2]][i]+0.1))\n\nplt.subplot(313)\npairplot = sns.scatterplot(x = df_subset[nXname[0]],y = df_subset[nXname[2]],s=60,\n        hue = df_subset['tProd'],edgecolor=\"black\",markers='o')\nplt.xlabel(nXlabelunit[0]); plt.ylabel(nXlabelunit[2]); add_grid();\nplt.xlim([nXmin[0],nXmax[0]]); plt.ylim([nXmin[2],nXmax[2]]); plt.title('30 Samples, ' + str(Xlabel[2]) + ' vs. ' + str(Xlabel[0]))\nfor i, txt in enumerate(df_subset['Well']):\n    pairplot.annotate(txt, (df_subset[nXname[0]][i]+0.1, df_subset[nXname[2]][i]+0.1))\n\nplt.subplots_adjust(left=0.0, bottom=0.0, right=1.0, top=3.1, wspace=0.3, hspace=0.2); plt.show() \n```", "```py\nembedding_subset = MDS(n_components=2)                        # MDS projection\nMDS_transformed_subset = embedding_subset.fit_transform(df_subset[nXname]) \n```", "```py\nplt.subplot(121)                                              # plot data samples in MDS space\npairplot = sns.scatterplot(x = MDS_transformed_subset[:,0],y = MDS_transformed_subset[:,1],s=60,\n        hue = df_subset['tProd'],edgecolor=\"black\",markers='o')\nfor i, txt in enumerate(df_subset['Well'].values):\n    plt.annotate(txt, [MDS_transformed_subset[:,0][i]+0.1,MDS_transformed_subset[:,1][i]+0.1])\nplt.xlim([-3.5,3.5]); plt.ylim([-3.5,3.5]); plt.title('30 Samples, MDS#2 vs. MDS#1')\npairplot.set_xlabel('MDS1'); pairplot.set_ylabel('MDS2')  \npairplot.legend(loc='lower right'); add_grid(); plt.legend(loc = 'upper right')\n\ndists = euclidean_distances(df_subset[nXname], squared=False).ravel() # calculate all pairwise distances\nnonzero = dists != 0                                          # select only non-identical samples pairs\ndists = dists[nonzero]\nprojected_dists = euclidean_distances(MDS_transformed_subset, squared=False).ravel()[nonzero] # calculate projected pairwise distance\n\nplt.subplot(122)                                              # scatter plot original and projected pairwise distance\nplt.scatter(dists,projected_dists,c='darkorange',alpha=0.4,edgecolor = 'black')\nplt.arrow(0,0,200,200,width=0.02,color='black',head_length=0.0,head_width=0.0)\nplt.xlim(0,15); plt.ylim(0,15); add_grid()\nplt.xlabel(\"Pairwise Distance: original space\"); plt.ylabel(\"Pairwise Distance: projected space\")\nplt.title(\"MDS Pairwise Distance: Projected to %d Components\" % n_components)\n\nplt.subplots_adjust(left=0.0, bottom=0.0, right=2., top=1.1, wspace=0.3, hspace=0.2); plt.show() \n```"]