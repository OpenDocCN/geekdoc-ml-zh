["```py\n# Implements the data augmentation policy\ndef augment_image(image, label):\n    # Flips the image randomly\n    image = tf.image.random_flip_left_right(image)\n\n    # Increase the image size, then randomly crop it down to\n    # the original dimensions\n    resize_factor = random.uniform(1, 1.2)\n    new_height = math.floor(resize_factor * INPUT_SHAPE[0])\n    new_width = math.floor(resize_factor * INPUT_SHAPE[1])\n    image = tf.image.resize_with_crop_or_pad(image, new_height,\n                                             new_width)\n    image = tf.image.random_crop(image, size=INPUT_SHAPE)\n\n    # Vary the brightness of the image\n    image = tf.image.random_brightness(image, max_delta=0.2)\n\n    return image, label\n```", "```py\n#include <Box_versus_Wheel_-_XIAO_ESP32S3_inferencing.h>\n#include \"edge-impulse-sdk/dsp/image/image.hpp\"\n#include \"esp_camera.h\"\n```", "```py\n// Configuration 1: Most common OV2640 configuration\n#define CONFIG_1_XCLK_GPIO_NUM 10\n#define CONFIG_1_SIOD_GPIO_NUM 40\n#define CONFIG_1_SIOC_GPIO_NUM 39\n// ... more pins\n```", "```py\n#define EI_CAMERA_RAW_FRAME_BUFFER_COLS 320\n#define EI_CAMERA_RAW_FRAME_BUFFER_ROWS 240\n#define EI_CLASSIFIER_ALLOCATION_HEAP 1\n```", "```py\nvoid setup() {\n    Serial.begin(115200);\n    while (!Serial);\n\n    if (ei_camera_init() == false) {\n        ei_printf(\"Failed to initialize Camera!\\r\\n\");\n    } else {\n        ei_printf(\"Camera initialized\\r\\n\");\n    }\n\n    ei_sleep(2000);  // Wait 2 seconds before starting\n}\n```", "```py\nsnapshot_buf = (uint8_t*)ps_malloc(EI_CAMERA_RAW_FRAME_BUFFER_COLS *\n                                   EI_CAMERA_RAW_FRAME_BUFFER_ROWS *\n                                   EI_CAMERA_FRAME_BYTE_SIZE);\n```", "```py\nif (ei_camera_capture((size_t)EI_CLASSIFIER_INPUT_WIDTH,\n                     (size_t)EI_CLASSIFIER_INPUT_HEIGHT,\n                     snapshot_buf) == false) {\n    ei_printf(\"Failed to capture image\\r\\n\");\n    free(snapshot_buf);\n    return;\n}\n```", "```py\nei_impulse_result_t result = { 0 };\nEI_IMPULSE_ERROR err = run_classifier(&signal, &result, false);\n```", "```py\nfor (uint16_t i = 0; i < EI_CLASSIFIER_LABEL_COUNT; i++) {\n    ei_printf(\" %s: %.5f\\r\\n\",\n              ei_classifier_inferencing_categories[i],\n              result.classification[i].value);\n}\n```", "```py\nbool ei_camera_init(void) {\n    // Try Configuration 1 (OV2640 common)\n    update_camera_config(1);\n    esp_err_t err = esp_camera_init(&camera_config);\n    if (err == ESP_OK) goto camera_init_success;\n\n    // Try Configuration 2 (OV3660)\n    esp_camera_deinit();\n    update_camera_config(2);\n    err = esp_camera_init(&camera_config);\n    if (err == ESP_OK) goto camera_init_success;\n\n    // Continue trying other configurations...\n}\n```", "```py\nbool ei_camera_capture(uint32_t img_width, uint32_t img_height, uint8_t *out_buf) {\n    // 1\\. Get frame from camera\n    camera_fb_t *fb = esp_camera_fb_get();\n\n    // 2\\. Convert JPEG to RGB888 format\n    bool converted = fmt2rgb888(fb->buf, fb->len, PIXFORMAT_JPEG, snapshot_buf);\n\n    // 3\\. Return frame buffer to camera driver\n    esp_camera_fb_return(fb);\n\n    // 4\\. Resize if needed\n    if (do_resize) {\n        ei::image::processing::crop_and_interpolate_rgb888(...);\n    }\n}\n```"]