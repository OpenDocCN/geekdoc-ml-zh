["```py\nimport geostatspy.GSLIB as GSLIB                              # GSLIB utilities, visualization and wrapper\nimport geostatspy.geostats as geostats                        # GSLIB methods convert to Python \nimport geostatspy\nprint('GeostatsPy version: ' + str(geostatspy.__version__)) \n```", "```py\nGeostatsPy version: 0.0.71 \n```", "```py\nignore_warnings = True                                        # ignore warnings?\n\nfrom tqdm import tqdm                                         # suppress the status bar\nfrom functools import partialmethod\ntqdm.__init__ = partialmethod(tqdm.__init__, disable=True)\n\nimport numpy as np                                            # ndarrays for gridded data\nimport pandas as pd                                           # DataFrames for tabular data\nimport os                                                     # set working directory, run executables\nimport matplotlib.pyplot as plt                               # for plotting\nfrom matplotlib.ticker import (MultipleLocator, AutoMinorLocator,FuncFormatter) # control of axes ticks\nimport matplotlib.dates as mdates                             # manually format date display\nfrom statsmodels.tsa.stattools import acf, pacf               # autocorrelation and partical autocorrelation\nfrom scipy import stats                                       # summary statistics\nimport math                                                   # trig etc.\nfrom statsmodels.tsa.stattools import acf, pacf               # autocorrelation and partial autocorrelation\nfrom statsmodels.tsa.stattools import adfuller                # Dickey-Fulley test for stationarity\nfrom statsmodels.tsa.seasonal import seasonal_decompose       # decomposition time series model\nfrom statsmodels.tsa.arima.model import ARIMA                 # ARIMA time series model\nimport pmdarima as pm                                         # autotune for ARIMA\nplt.rc('axes', axisbelow=True)                                # plot all grids below the plot elements\nif ignore_warnings == True:                                   \n    import warnings\n    warnings.filterwarnings('ignore')\ncmap = plt.cm.inferno                                         # color map \n```", "```py\n---------------------------------------------------------------------------\nModuleNotFoundError  Traceback (most recent call last)\nCell In[2], line 20\n  18 from statsmodels.tsa.seasonal import seasonal_decompose       # decomposition time series model\n  19 from statsmodels.tsa.arima.model import ARIMA                 # ARIMA time series model\n---> 20 import pmdarima as pm                                         # autotune for ARIMA\n  21 plt.rc('axes', axisbelow=True)                                # plot all grids below the plot elements\n  22 if ignore_warnings == True:                                   \n\nModuleNotFoundError: No module named 'pmdarima' \n```", "```py\ndef comma_format(x, pos):\n    return f'{int(x):,}'\n\ndef add_grid():\n    plt.gca().grid(True, which='major',linewidth = 1.0); plt.gca().grid(True, which='minor',linewidth = 0.2) # add y grids\n    plt.gca().tick_params(which='major',length=7); plt.gca().tick_params(which='minor', length=4)\n    plt.gca().xaxis.set_minor_locator(AutoMinorLocator()); plt.gca().yaxis.set_minor_locator(AutoMinorLocator()) # turn on minor ticks \n```", "```py\n#os.chdir(\"c:/PGE383\")                                        # set the working directory \n```", "```py\n%%capture --no-display    \n\ntarget_mean = 100.0; target_stdev = 20.0                      # target mean and standard deviation of the synthetic dataset\n\nprop_trend = 0.3; prop_cycle = 0.5; prop_noise = 1 - (prop_trend + prop_cycle)\ntrend_mean = target_mean; cycle_mean = 0.0; noise_mean = 0.0\nnoise_stdev = math.sqrt(prop_noise*(target_stdev**2.0))\ntrend_stdev = math.sqrt(prop_trend*(target_stdev**2.0)); cycle_stdev = math.sqrt(prop_cycle*(target_stdev**2.0))\nnoise_stdev = math.sqrt(prop_noise*(target_stdev**2.0))\n\nnx = 1000; ny = 1; xsiz = 1.0; ysiz = 10.0; xmn = 5.0; ymn = 5.0; nxdis = 1; nydis = 1 # model window\nxmin = 0.0; xmax = nx*xsiz; ymin = 0.0; ymax = ny*ysiz; cmap = plt.cm.inferno\n\nndmin = 0; ndmax = 30; radius = 1000; ktype = 0; skmean = 0; tmin = -999; tmax = 999 # geostatistical simulation parameters\n\nx_value = np.linspace(1,nx,nx)                                # array with the days for the observations\n\nvario_noise = GSLIB.make_variogram(nug=0.0,nst=1,it1=3,cc1=1.0,azi1=90.0,hmaj1=10,hmin1=1) # assumed spatial continuity models \n\nx = np.ones(10)*-9999; y = np.ones(10)*-9999; value = np.random.normal(10) # reference data for forward and back transformation\ndf_null = pd.DataFrame({'x': x, 'y': y, 'value':value})           # make a new DataFrame from the vectors\nseries_noise = geostats.sgsim(df_null,'x','y','value',wcol=-1,scol=-1,tmin=tmin,tmax=tmax,itrans=0,ismooth=0,dftrans=0,tcol=0, # noise component\n            twtcol=0,zmin=0.0,zmax=0.3,ltail=1,ltpar=0.0,utail=1,utpar=0.3,nsim=1,\n            nx=nx,xmn=xmn,xsiz=xsiz,ny=ny,ymn=ymn,ysiz=ysiz,seed=75053,\n            ndmin=ndmin,ndmax=ndmax,nodmax=20,mults=1,nmult=3,noct=-1,ktype=ktype,colocorr=0.0,sec_map=0,vario=vario_noise)[0][0]\nseries_noise = GSLIB.affine(series_noise,noise_mean,noise_stdev)  # correct the mean and variance of the noise field\n\nseries_cycle = np.sin(np.linspace(0,nx*xsiz,nx)/20)           # calculate a cyclic component\nseries_cycle = GSLIB.affine(series_cycle,cycle_mean,cycle_stdev) # correct the cyclic component mean and variance\n\nseries_trend = x_value; series_trend = GSLIB.affine(series_trend,trend_mean,trend_stdev) # trend component\n\nseries_total = series_trend + series_cycle + series_noise; series_total = GSLIB.affine(series_total,target_mean,target_stdev)\n\nplt.subplot(211)\nplt.plot(x_value,series_noise,color='green',linewidth=3,label = 'Noise Residual')\nplt.plot(x_value,series_cycle,color='red',linewidth=3,label = 'Cyclic Residual')\nplt.plot(x_value,series_trend,color='blue',linewidth=3,label = 'Trend'); plt.plot([xmin,xmax],[0,0],color='black',ls='--')\nplt.legend(loc='best'); plt.xlabel('Time (Days)'); plt.ylabel('Lithium Production (tonnes / day)'); \nplt.title('Additive Components for Synthetic Production Time Series')\nplt.gca().xaxis.set_major_formatter(FuncFormatter(comma_format)); add_grid()\nplt.xlim([np.min(x_value),np.max(x_value)]); plt.ylim([-40,140])\n\nplt.subplot(212)\nplt.plot(x_value,series_total,color='black',linewidth=3, label = 'Lithium Production')\nplt.legend(loc='best'); plt.xlabel('Time (Days)'); plt.ylabel('Lithium Production (Li tonnes / day)'); \nplt.title('Synthetic Lithium Production Time Series')\nplt.xlim([np.min(x_value),np.max(x_value)]); plt.ylim([0.0,160]); add_grid()\nplt.gca().xaxis.set_major_formatter(FuncFormatter(comma_format)); add_grid()\nplt.subplots_adjust(left=0.0, bottom=0.0, right=2.0, top=2.0, wspace=0.2, hspace=0.2); plt.show() \n```", "```py\nstart_date = '2016-01-01'; periods = nx\ndate = pd.date_range(start_date,periods=periods,freq='D')     # make a list of dates for DataFrame index and plotting\n\ndf = pd.DataFrame({'date':date[:],'production':series_total[:]}) # make time DataFrame\ndf = df.set_index(['date']); df.head()\ndate_list = date.tolist() \n```", "```py\nax = df['production'].plot(color='black',lw=3)\nax.grid(which='major', axis='x', linestyle='--')              # customize major gridlines\nax.xaxis.set_major_locator(mdates.WeekdayLocator(interval=4)) # major tick every 2 weeks\nax.xaxis.set_major_formatter(mdates.DateFormatter('%Y-%m-%d')) # set the date format for the major ticks\nplt.xticks(rotation=45); add_grid()                           # rotate date labels for better readability\nplt.xlabel('Time (Days)'); plt.ylabel('Lithium Production (tonnes / day)'); plt.title('Synthetic Lithium Production Time Series')\nplt.subplots_adjust(left=0.0, bottom=0.0, right=2.0, top=1.0, wspace=0.2, hspace=0.2); plt.show() \n```", "```py\nnlag = 499                                                    # number of lags for autocorrelation analysis \n\nlag_acf = acf(df['production'], nlags=nlag)                   # calculate autocorrelation and partial autocorrelation functions\nlag_pacf = pacf(df['production'], nlags=nlag, method='ols')\nlags = np.linspace(0,(nlag+1)*xsiz,nlag+1)\n\n#Plot ACF: \nplt.subplot(121)                                              # plot autocorrelation function\nplt.plot(lags,lag_acf,color='red',lw=3,zorder=10)\nplt.axhline(y=0,linewidth = 2,color='black')\nplt.axhline(y=-1.96/np.sqrt(len(series_noise)),linestyle='--',color='gray')\nplt.axhline(y=1.96/np.sqrt(len(series_noise)),linestyle='--',color='gray')\nplt.fill_between(lags,-1.96/np.sqrt(len(series_noise)),1.96/np.sqrt(len(series_noise)),color='grey',alpha=0.4,zorder=1)\nplt.title('Autocorrelation Function'); plt.xlabel('Lags (Days)'); plt.ylabel('Autocorrelation')\nadd_grid(); plt.xlim([0,nlag+1]); plt.ylim([-1.0,1.0])\n\nplt.subplot(122)                                              # plot partial autocorrelation function\nplt.plot(lags,lag_pacf,color='red',lw=3)\nplt.axhline(y=0,linewidth = 2,color='black')\nplt.axhline(y=-1.96/np.sqrt(len(series_noise)),linestyle='--',color='gray')\nplt.axhline(y=1.96/np.sqrt(len(series_noise)),linestyle='--',color='gray')\nplt.fill_between(lags,-1.96/np.sqrt(len(series_noise)),1.96/np.sqrt(len(series_noise)),color='grey',alpha=0.4,zorder=1)\nplt.title('Partial Autocorrelation Function'); plt.title('Autocorrelation Function'); plt.xlabel('Lags (Days)'); plt.ylabel('Autocorrelation')\nadd_grid(); plt.xlim([0,nlag+1]); plt.ylim([-1.0,1.0])\nplt.tight_layout()\n\nplt.subplots_adjust(left=0.0, bottom=0.0, right=2.0, top=1.0, wspace=0.2, hspace=0.2); plt.show() \n```", "```py\nprint('Dickey-Fuller Test Results:')\ndftest = adfuller(df['production'], autolag='AIC')            # perfrom the Dickey-Fuller test for non-stationarity\ndfoutput = pd.Series(dftest[0:4], index=['Test Statistic','p-value','#Lags Used','Number of Observations Used'])\nfor key,value in dftest[4].items():\n    dfoutput['Critical Value (%s)'%key] = value\nprint(dfoutput[0:7]) \n```", "```py\nDickey-Fuller Test Results:\nTest Statistic                  -3.639408\np-value                          0.005051\n#Lags Used                       8.000000\nNumber of Observations Used    991.000000\nCritical Value (1%)             -3.436966\nCritical Value (5%)             -2.864461\nCritical Value (10%)            -2.568325\ndtype: float64 \n```", "```py\nwindow_size = 50                                              # assume window size of 10 days\nalpha = 0.40                                                  # alpha for percentiles, symmetric probability interval = 1 - alpha\n\ndf['rolling_mean'] = df['production'].rolling(window = window_size, center = True).mean() # moving window statistics\ndf['rolling_std'] = df['production'].rolling(window = window_size, center = True).std()\ndf['rolling_lower'] = df['production'].rolling(window = window_size, center = True).quantile(alpha/2.0)\ndf['rolling_upper'] = df['production'].rolling(window = window_size, center = True).quantile(1-alpha/2.0)\n\nplt.subplot(211)                                              # plot rolling statistics:\nax = df['production'].plot(color='black',lw=2,ls='--',zorder=50)\ndf['rolling_mean'].plot(color='red',lw=3,label='Rolling Mean',zorder=20)\ndf['rolling_lower'].plot(color='red',lw=1,label='Rolling P' + str(int(alpha*100/2)),zorder=20)\ndf['rolling_upper'].plot(color='red',lw=1,label='Rolling P' + str(int(100-alpha*100/2)),zorder=20)\nplt.fill_between(date,df['rolling_lower'],df['rolling_upper'],color='red',alpha=0.4)\nax.xaxis.set_major_locator(mdates.WeekdayLocator(interval=4)) # major tick every 2 weeks\nax.xaxis.set_major_formatter(mdates.DateFormatter('%Y-%m-%d')) # set the date format for the major ticks\nplt.xticks(rotation=45); add_grid(); plt.legend(loc='lower right') # rotate date labels for better readability\nplt.xlabel('Time (Days)'); plt.ylabel('Lithium Production (Li tonnes / day)')\nplt.title('Synthetic Lithium Production and Rolling Mean and Percentiles')\n\nplt.subplot(212)\nax = df['rolling_std'].plot(color='red',lw=3,label='Rolling Standard Deviation')\nplt.legend(loc='best'); plt.title('Rolling Standard Deviation')\nplt.xlim([date[0],date[-1]]); plt.ylim([0,30]); add_grid()\nax.xaxis.set_major_locator(mdates.WeekdayLocator(interval=4)) # major tick every 2 weeks\nax.xaxis.set_major_formatter(mdates.DateFormatter('%Y-%m-%d')) # set the date format for the major ticks\nplt.xticks(rotation=45); add_grid()                           # rotate date labels for better readability\nplt.xlabel('Time (Days)'); plt.ylabel('Rolling St. Dev. Lithium Production (Li tonnes / day)')\nplt.title('Rolling Standard Deviation of Synthetic Lithium Production')\n\nplt.subplots_adjust(left=0.0, bottom=0.0, right=2.0, top=2.0, wspace=0.2, hspace=0.35); plt.show() \n```", "```py\ndf['residual'] = df['production'].values - df['rolling_mean'].values # calculate residual\ndf.head(n=13) \n```", "```py\nnlag = 499                                                    # number of lags for autocorrelation analysis \n\nax = df['residual'].plot(color='red',lw=3,label='Rolling Standard Deviation')\nplt.legend(loc='best'); plt.title('Rolling Standard Deviation')\nplt.xlim([date[0],date[-1]]); plt.ylim([-30,30])\nplt.plot([date[0],date[-1]],[0,0],color='black',ls='--')\nax.xaxis.set_major_locator(mdates.WeekdayLocator(interval=4)) # major tick every 2 weeks\nax.xaxis.set_major_formatter(mdates.DateFormatter('%Y-%m-%d')) # set the date format for the major ticks\nplt.xticks(rotation=45); add_grid()                           # rotate date labels for better readability\nplt.xlabel('Time (Days)'); plt.ylabel('Rolling Residual Lithium Production (Li tonnes / day)')\nplt.title('Rolling Residual (Data - Mean) Lithium Production')\nplt.subplots_adjust(left=0.0, bottom=0.0, right=2.0, top=1.0, wspace=0.2, hspace=0.2); plt.show() \n```", "```py\nwindows = [20,40,100]                                         # specify 3 moving window sizes\n\nfor iwin,window in enumerate(windows):                        # calculate rolling window mean and residual\n    df['rolling_mean_'+str(window)] = df['production'].rolling(window = window, center = True).mean()\n    df['rolling_res_'+str(window)] = df['rolling_mean_'+str(window)] - df['production']\n\n    plt.subplot(3,2,iwin*2+1)                                 # plot rolling mean\n    ax = df['rolling_mean_'+str(window)].plot(color='red',lw=3,label='Lithium Production',zorder=20)\n    ax.xaxis.set_major_locator(mdates.WeekdayLocator(interval=8))  # major tick every 2 weeks\n    ax.xaxis.set_major_formatter(mdates.DateFormatter('%Y-%m-%d')) # set the date format for the major ticks\n    plt.xticks(rotation=45); add_grid(); plt.xlim([date[0],date[-1]]); plt.ylim([0,140])  # rotate date labels for better readability\n    plt.xlabel('Time (Days)'); plt.title('Rolling Mean Lithium Production (Window = ' + str(window) + ')')\n    plt.ylabel('Lithium Production (tonnes / day)')\n\n    plt.subplot(3,2,iwin*2+2)                                 # plot detrended residual\n    ax = df['rolling_res_'+str(window)].plot(color='red',lw=3,label='Lithium Production',zorder=20)\n    plt.plot([date[0],date[-1]],[0,0],color='black',ls='--',zorder=50)\n    ax.xaxis.set_major_locator(mdates.WeekdayLocator(interval=8)) # major tick every 2 weeks\n    ax.xaxis.set_major_formatter(mdates.DateFormatter('%Y-%m-%d')) # set the date format for the major ticks\n    plt.xticks(rotation=45); add_grid(); plt.xlim([date[0],date[-1]]); plt.ylim([-40,40])  # rotate date labels for better readability\n    plt.xlabel('Time (Days)'); plt.title('Detrended Lithium Production (Data - Rolling Mean) (Window = ' + str(window) + ')')\n    plt.ylabel('Lithium Production Residual (tonnes / day)') \n\nplt.subplots_adjust(left=0.0, bottom=0.0, right=2.0, top=3.0, wspace=0.2, hspace=0.4); plt.show() \n```", "```py\nvariance = np.var(df['production'])\n\nfor iwin,window in enumerate(windows):                        # calculate rolling window mean and residual\n    variance_trend = df['rolling_mean_'+str(window)].var()\n    variance_residual = df['rolling_res_'+str(window)].var()\n\n    prop_trend = variance_trend/variance\n    prop_resid = variance_residual/variance\n    prop_cov = 1 - prop_trend - prop_resid\n\n    variance_prop = [prop_trend, prop_resid, prop_cov]\n    labels = 'Trend', 'Residual', '2 x Covariance'\n    colors = 'orange', 'red', 'green'\n    explode = (0.1, 0.1,0.1)\n\n    plt.subplot(3,3,iwin*3+1)                                 # plot rolling mean \n    ax = df['rolling_mean_'+str(window)].plot(color='red',lw=3,label='Lithium Production',zorder=20)\n    df['production'].plot(color='black',lw=2,zorder=10)\n    ax.xaxis.set_major_locator(mdates.WeekdayLocator(interval=8))  # major tick every 2 weeks\n    ax.xaxis.set_major_formatter(mdates.DateFormatter('%Y-%m-%d')) # set the date format for the major ticks\n    plt.xticks(rotation=45); add_grid(); plt.xlim([date[0],date[-1]]); plt.ylim([0,140])  # rotate date labels for better readability\n    plt.xlabel('Time (Days)'); plt.title('Rolling Mean Lithium Production (Window = ' + str(window) + ')')\n    plt.ylabel('Lithium Production (tonnes / day)')\n\n    plt.subplot(3,3,iwin*3+2)                                 # plot rolling mean residual distribution\n    plt.hist(df['rolling_res_'+str(window)],bins=np.linspace(-40,40,41),color='red',edgecolor='black',alpha=1.0,zorder=10)\n    plt.xlim([-40,40]); plt.ylim([0,300]); add_grid()\n    plt.vlines(0,0,300,color='black',ls='--',zorder=30)\n    plt.xlabel('Residual Lithium Production (tonnes/day)'); plt.ylabel('Frequency')\n    plt.title('Detrended Residual Lithium Production (Window = ' + str(window) + ')')\n    plt.annotate('Residual:',[18,260])\n    plt.annotate('Mean = ' + str(round((df['rolling_res_'+str(window)]).mean(),2)),[20,240])\n    plt.annotate('Min = ' + str(round((df['rolling_res_'+str(window)]).min(),2)),[20,220])\n    plt.annotate('Max = ' + str(round((df['rolling_res_'+str(window)]).max(),2)),[20,200])\n\n    plt.subplot(3,3,iwin*3+3)                                 # plot rolling mean\n    plt.pie(variance_prop, explode=explode, colors = colors, labels=labels, autopct='%1.1f%%',\n            shadow=True, startangle=90)\n    plt.title('Lithium Production Variance Components (Window = ' + str(window) + ')')\n    plt.gca().axis('equal')                                   # equal aspect ratio ensures that pie plot is drawn as a circle\n\nplt.subplots_adjust(left=0.0, bottom=0.0, right=3.0, top=3.0, wspace=0.2, hspace=0.4); plt.show() \n```", "```py\nprint('Dickey-Fuller Test Results:')\nresidual = df['residual'] \nresidual = residual[~pd.isnull(residual)]                     # remove null values\ndftest = adfuller(residual, autolag='AIC')                    # perform Dickey-Fuller test for stationarity\ndfoutput = pd.Series(dftest[0:4], index=['Test Statistic','p-value','#Lags Used','Number of Observations Used'])\nfor key,value in dftest[4].items():\n    dfoutput['Critical Value (%s)'%key] = value\nprint(dfoutput[0:7]) \n```", "```py\nDickey-Fuller Test Results:\nTest Statistic                -9.362547e+00\np-value                        7.753045e-16\n#Lags Used                     8.000000e+00\nNumber of Observations Used    9.420000e+02\nCritical Value (1%)           -3.437311e+00\nCritical Value (5%)           -2.864613e+00\nCritical Value (10%)          -2.568406e+00\ndtype: float64 \n```", "```py\nnp.diff(df[0].values) \n```", "```py\ndiff1 = np.diff(df['production'].values)\ndiff1 = np.append(diff1,diff1[diff1.size-1])                  # double the last value to keep the length the same\ndf['first_difference'] = diff1\n\ndiff2 = np.diff(df['first_difference'].values)\ndiff2 = np.append(diff2,diff2[diff2.size-1])                  # double the last value to keep the length the same\ndf['second_difference'] = diff2\ndf.head() \n```", "```py\ncases = ['production','first_difference','second_difference'] # differencing cases\n\nnlag = 200\nlags = np.linspace(0,(nlag+1)*xsiz,nlag+1); prod_lag_acf = []\n\nfor icase, case in enumerate(cases):\n    prod_lag_acf.append(acf(df[case], nlags=nlag))\n\n    plt.subplot(3,2,icase*2+1)                                # plot values \n    ax = df[case].plot(color='black',lw=3)\n    ax.grid(which='major', axis='x', linestyle='--')          # customize major gridlines\n    ax.xaxis.set_major_locator(mdates.WeekdayLocator(interval=8)) # major tick every 2 weeks\n    ax.xaxis.set_major_formatter(mdates.DateFormatter('%Y-%m-%d')) # set the date format for the major ticks\n    plt.xticks(rotation=45); add_grid()                       # rotate date labels for better readability\n    plt.xlabel('Time (Days)'); plt.ylabel('Lithium Production (tonnes / day)'); plt.title(case + ' Lithium Production Time Series')\n\n    plt.subplot(3,2,icase*2+2)                                # plot autocorrelation\n    plt.plot(lags,prod_lag_acf[icase],color='red')\n    plt.axhline(y=0,linewidth = 2,color='black')\n    plt.axhline(y=-1.96/np.sqrt(len(series_noise)),linestyle='--',color='gray')\n    plt.axhline(y=1.96/np.sqrt(len(series_noise)),linestyle='--',color='gray')\n    plt.fill_between(lags,-1.96/np.sqrt(len(series_noise)),1.96/np.sqrt(len(series_noise)),color='grey',alpha=0.4,zorder=1)\n    plt.title(case + ' Autocorrelation Function'); plt.xlabel('Lags (Days)'); plt.ylabel('Autocorrelation')\n    add_grid(); plt.xlim([0,nlag+1]); plt.ylim([-1.0,1.0])\n\nplt.subplots_adjust(left=0.0, bottom=0.0, right=2.0, top=3.0, wspace=0.2, hspace=0.4); plt.show() \n```", "```py\nprint('Dickey-Fuller Test Results - First Differenced Production:')\nresidual = df['first_difference'] \nresidual = residual[~pd.isnull(residual)]                     # remove null values\ndftest = adfuller(residual, autolag='AIC')                    # perform Dickey-Fuller test\ndfoutput = pd.Series(dftest[0:4], index=['Test Statistic','p-value','#Lags Used','Number of Observations Used'])\nfor key,value in dftest[4].items():\n    dfoutput['Critical Value (%s)'%key] = value\nprint(dfoutput[0:7])\n\nprint('Dickey-Fuller Test Results - Second Differenced Production:')\nresidual = df['second_difference'] \nresidual = residual[~pd.isnull(residual)]                     # remove null values\ndftest = adfuller(residual, autolag='AIC')                    # perform Dickey-Fuller test\ndfoutput = pd.Series(dftest[0:4], index=['Test Statistic','p-value','#Lags Used','Number of Observations Used'])\nfor key,value in dftest[4].items():\n    dfoutput['Critical Value (%s)'%key] = value\nprint(dfoutput[0:7]) \n```", "```py\nDickey-Fuller Test Results - First Differenced Production:\nTest Statistic                -1.022681e+01\np-value                        5.151322e-18\n#Lags Used                     1.000000e+01\nNumber of Observations Used    9.890000e+02\nCritical Value (1%)           -3.436979e+00\nCritical Value (5%)           -2.864467e+00\nCritical Value (10%)          -2.568328e+00\ndtype: float64\nDickey-Fuller Test Results - Second Differenced Production:\nTest Statistic                -1.266754e+01\np-value                        1.265190e-23\n#Lags Used                     1.900000e+01\nNumber of Observations Used    9.800000e+02\nCritical Value (1%)           -3.437040e+00\nCritical Value (5%)           -2.864494e+00\nCritical Value (10%)          -2.568343e+00\ndtype: float64 \n```", "```py\ndecomposition = seasonal_decompose(df['production'], model='additive',extrapolate_trend=1,period=110,filt=np.ones(20)/20,two_sided = True)\ndecomp_trend = decomposition.trend; decomp_seasonal = decomposition.seasonal; decomp_residual = decomposition.resid\nfig = decomposition.plot()\nplt.subplots_adjust(left=0.0, bottom=0.0, right=2.0, top=1.0, wspace=0.2, hspace=0.2); plt.show() \n```", "```py\nvar_decomp_trend = np.var(decomp_trend.values); var_decomp_seasonal = np.var(decomp_seasonal.values) # calculate variance components\nvar_decomp_residual = np.var(decomp_residual.values); var_total = np.var(df['production'])\n\nvariance_prop = [var_decomp_trend, var_decomp_seasonal, var_decomp_residual]\nlabels = ['Trend', 'Seasonal', 'Residual']; colors = ['orange','cyan','red']; explode = [0.1,0.1,0.1]\n\nplt.subplot(111)                                              # plot the decompositional model variance components\nplt.pie(variance_prop, explode=explode, colors = colors, labels=labels, autopct='%1.1f%%',\n        shadow=True, startangle=90)\nplt.title('Lithium Production Decomposition Model Variance Components')\nplt.gca().axis('equal')                                       # equal aspect ratio ensures that pie is drawn as a circle.\nplt.subplots_adjust(left=0.0, bottom=0.0, right=2.0, top=1.0, wspace=0.2, hspace=0.2) \n```", "```py\nprint('Dickey-Fuller Test Results:')\ndecomp_residual = decomp_residual[~pd.isnull(decomp_residual)]  # remove null values\ndf['decomp_res'] = decomp_residual\ndftest = adfuller(decomp_residual, autolag='AIC')             # perform Dickey-Fuller test\ndfoutput = pd.Series(dftest[0:4], index=['Test Statistic','p-value','#Lags Used','Number of Observations Used'])\nfor key,value in dftest[4].items():\n    dfoutput['Critical Value (%s)'%key] = value\nprint(dfoutput[0:7]) \n```", "```py\nDickey-Fuller Test Results:\nTest Statistic                -9.629883e+00\np-value                        1.622897e-16\n#Lags Used                     2.100000e+01\nNumber of Observations Used    9.780000e+02\nCritical Value (1%)           -3.437054e+00\nCritical Value (5%)           -2.864500e+00\nCritical Value (10%)          -2.568346e+00\ndtype: float64 \n```", "```py\nnlags = 200                                                   # number of autocorrelation lags\nlag_acf_decomp_resid = acf(decomp_residual, nlags=nlags)      # autocorrelation\nlags = np.linspace(0,(nlags+1)*xsiz,nlags+1)\n\nplt.subplot(121)                                              # plot decomposition model residual\nax = df['decomp_res'].plot(color='black',lw=3)\nax.xaxis.set_major_locator(mdates.WeekdayLocator(interval=8))  # major tick every 2 weeks\nax.xaxis.set_major_formatter(mdates.DateFormatter('%Y-%m-%d')) # set the date format for the major ticks\nplt.xticks(rotation=45); add_grid(); plt.xlim([date[0],date[-1]]); plt.ylim([-40,40]) # rotate date labels for better readability\nplt.xlabel('Time (Days)'); plt.title('Decomposition Time Series Model Residual')\nplt.ylabel('Lithium Production (tonnes / day)')\n\nplt.subplot(122)                                              # plot autocorrelation of decomposition residual\nplt.plot(lags,lag_acf_decomp_resid,color='red')\nplt.axhline(y=0,linewidth = 2,color='black')\nplt.axhline(y=-1.96/np.sqrt(len(series_noise)),linestyle='--',color='gray')\nplt.axhline(y=1.96/np.sqrt(len(series_noise)),linestyle='--',color='gray')\nplt.fill_between(lags,-1.96/np.sqrt(len(series_noise)),1.96/np.sqrt(len(series_noise)),color='grey',alpha=0.4,zorder=1)\nplt.title('Time Series Decomposition Model Residual Autocorrelation Function'); plt.xlabel('Lags (Days)'); plt.ylabel('Autocorrelation')\nadd_grid(); plt.xlim([0,nlag+1]); plt.ylim([-1.0,1.0])\n\nplt.subplots_adjust(left=0.0, bottom=0.0, right=2.0, top=1.0, wspace=0.2, hspace=0.2); plt.show() \n```", "```py\ntrain_frac = 0.8; split_index = int(len(df)*train_frac)       # specify train and test split\n\ntrain = df['production'][:split_index]                        # perform split\ntest = df['production'][split_index:]\ntrain_date_list = pd.date_range(start=date[0], end=date[split_index-1]).tolist() # date ranges for train and test for plotting\ntest_date_list = pd.date_range(start=date[split_index],end=date[len(df)-1]).tolist()\n\nprint('Train samples = ' + str(len(train)) + ', Test samples = ' + str(len(test))) # check train and test counts\nprint('Train samples dates = ' + str(len(train_date_list)) + ', Test samples dates = ' + str(len(test_date_list))) \n```", "```py\nTrain samples = 800, Test samples = 200\nTrain samples dates = 800, Test samples dates = 200 \n```", "```py\np = 1; d = 0; q = 2                                           # set ARIMA parameters\n\nsP = 1; sD = 1; sQ = 2; s = 5                                 # seasonal orders\n\nARIMA_model = ARIMA(train, order=(p, d, q),trend='t',seasonal_order=(sP,sD,sQ,s)) # instantiate ARIMA model\nARIMA_model_fit = ARIMA_model.fit()                           # fit ARIM model\n\nprint(ARIMA_model_fit.summary())                              # print diagnostics from ARIMA model \n```", "```py\n SARIMAX Results                                    \n=======================================================================================\nDep. Variable:                      production   No. Observations:                  800\nModel:             ARIMA(1, 0, 2)x(1, 1, 2, 5)   Log Likelihood               -1782.678\nDate:                         Tue, 08 Oct 2024   AIC                           3581.357\nTime:                                 11:06:15   BIC                           3618.784\nSample:                             01-01-2016   HQIC                          3595.739\n                                  - 03-10-2018                                         \nCovariance Type:                           opg                                         \n==============================================================================\n                 coef    std err          z      P>|z|      [0.025      0.975]\n------------------------------------------------------------------------------\nx1             0.0497      0.026      1.943      0.052      -0.000       0.100\nar.L1          0.9844      0.009    109.383      0.000       0.967       1.002\nma.L1          0.2957      0.023     13.071      0.000       0.251       0.340\nma.L2          0.4662      0.020     23.536      0.000       0.427       0.505\nar.S.L5        0.1298      0.249      0.521      0.602      -0.358       0.618\nma.S.L5       -1.3116      0.234     -5.597      0.000      -1.771      -0.852\nma.S.L10       0.3133      0.240      1.308      0.191      -0.156       0.783\nsigma2         5.0306      0.337     14.947      0.000       4.371       5.690\n===================================================================================\nLjung-Box (L1) (Q):                  12.96   Jarque-Bera (JB):              2704.23\nProb(Q):                              0.00   Prob(JB):                         0.00\nHeteroskedasticity (H):               1.22   Skew:                             0.02\nProb(H) (two-sided):                  0.11   Kurtosis:                        12.04\n===================================================================================\n\nWarnings:\n[1] Covariance matrix calculated using the outer product of gradients (complex-step). \n```", "```py\nresiduals = pd.DataFrame(ARIMA_model_fit.resid)               # add ARIMA residuals to DataFrame\n\nplt.subplot(121)                                              # plot ARIMA residuals\norig = plt.plot(residuals, color='red',linewidth = 3, label='Residual')\nplt.plot([date[0],date[-1]],[0,0],color='black')\nplt.title('ARIMA Model Residual'); plt.legend(loc='best'); plt.ylim(-10,10); plt.xlim([date[0],date[-1]])\n\nplt.subplot(122)                                               # plot histogram of ARIMA residuals\nplt.hist(residuals[0].values,bins = np.linspace(-10,10,30),color = 'red',alpha = 1.0,edgecolor = 'black')\nplt.xlabel('Residual'); plt.ylabel('Frequency'); plt.title('ARIMA Model Residual'), plt.xlim(-10,10)\n\nplt.subplots_adjust(left=0.0, bottom=0.0, right=3.0, top=1.0, wspace=0.2, hspace=0.2); plt.show() \n```", "```py\nforecast_steps = 200                                          # number of forecast steps\n\nforecast = ARIMA_model_fit.forecast(steps=forecast_steps)\nforecast_date_list = pd.date_range(start=test_date_list[0], end=test_date_list[0] + pd.Timedelta(days=forecast_steps-1)).tolist()\n\nplt.subplot(111)                                              # plot data, train and test and ARIMA forecast\nplt.plot(date_list,df['production'],color='black',label='Actual Data',zorder=10) # plot data\nplt.plot(train_date_list,train.values,lw=3,color='lightgreen',label='Train Data',zorder=1) # plot data\nplt.plot(test_date_list,test.values,lw=3,color='lightblue',label='Test Data',zorder=1) # plot data\nplt.plot(forecast_date_list,forecast.values, label='ARIMA Forecast', color='red') # plot forecast\nax.xaxis.set_major_locator(mdates.WeekdayLocator(interval=4))  # major tick every 2 weeks\nax.xaxis.set_major_formatter(mdates.DateFormatter('%Y-%m-%d')) # set the date format for the major ticks\nplt.xticks(rotation=45); add_grid(); plt.ylim([0,160])  # rotate date labels for better readability\nplt.xlabel('Time (Days)'); plt.title('Decomposition Time Series Model Residual')\nplt.ylabel('Lithium Production (tonnes / day)'); plt.xlim(date_list[0],date_list[-1])\nplt.plot([test_date_list[0],test_date_list[0]],[-40,160],color='black',ls='--') # vertical line at end of train time period\nplt.title('ARIMA Model Forecasts'); plt.ylabel('Lithium Production (tonnes / day)'); plt.xlabel('Time (Days)')\nplt.legend(loc='lower left')\nplt.subplots_adjust(left=0.0, bottom=0.0, right=1.0, top=1.0, wspace=0.2, hspace=0.2); plt.show() \n```", "```py\nimport geostatspy.GSLIB as GSLIB                              # GSLIB utilities, visualization and wrapper\nimport geostatspy.geostats as geostats                        # GSLIB methods convert to Python \nimport geostatspy\nprint('GeostatsPy version: ' + str(geostatspy.__version__)) \n```", "```py\nGeostatsPy version: 0.0.71 \n```", "```py\nignore_warnings = True                                        # ignore warnings?\n\nfrom tqdm import tqdm                                         # suppress the status bar\nfrom functools import partialmethod\ntqdm.__init__ = partialmethod(tqdm.__init__, disable=True)\n\nimport numpy as np                                            # ndarrays for gridded data\nimport pandas as pd                                           # DataFrames for tabular data\nimport os                                                     # set working directory, run executables\nimport matplotlib.pyplot as plt                               # for plotting\nfrom matplotlib.ticker import (MultipleLocator, AutoMinorLocator,FuncFormatter) # control of axes ticks\nimport matplotlib.dates as mdates                             # manually format date display\nfrom statsmodels.tsa.stattools import acf, pacf               # autocorrelation and partical autocorrelation\nfrom scipy import stats                                       # summary statistics\nimport math                                                   # trig etc.\nfrom statsmodels.tsa.stattools import acf, pacf               # autocorrelation and partial autocorrelation\nfrom statsmodels.tsa.stattools import adfuller                # Dickey-Fulley test for stationarity\nfrom statsmodels.tsa.seasonal import seasonal_decompose       # decomposition time series model\nfrom statsmodels.tsa.arima.model import ARIMA                 # ARIMA time series model\nimport pmdarima as pm                                         # autotune for ARIMA\nplt.rc('axes', axisbelow=True)                                # plot all grids below the plot elements\nif ignore_warnings == True:                                   \n    import warnings\n    warnings.filterwarnings('ignore')\ncmap = plt.cm.inferno                                         # color map \n```", "```py\n---------------------------------------------------------------------------\nModuleNotFoundError  Traceback (most recent call last)\nCell In[2], line 20\n  18 from statsmodels.tsa.seasonal import seasonal_decompose       # decomposition time series model\n  19 from statsmodels.tsa.arima.model import ARIMA                 # ARIMA time series model\n---> 20 import pmdarima as pm                                         # autotune for ARIMA\n  21 plt.rc('axes', axisbelow=True)                                # plot all grids below the plot elements\n  22 if ignore_warnings == True:                                   \n\nModuleNotFoundError: No module named 'pmdarima' \n```", "```py\ndef comma_format(x, pos):\n    return f'{int(x):,}'\n\ndef add_grid():\n    plt.gca().grid(True, which='major',linewidth = 1.0); plt.gca().grid(True, which='minor',linewidth = 0.2) # add y grids\n    plt.gca().tick_params(which='major',length=7); plt.gca().tick_params(which='minor', length=4)\n    plt.gca().xaxis.set_minor_locator(AutoMinorLocator()); plt.gca().yaxis.set_minor_locator(AutoMinorLocator()) # turn on minor ticks \n```", "```py\n#os.chdir(\"c:/PGE383\")                                        # set the working directory \n```", "```py\n%%capture --no-display    \n\ntarget_mean = 100.0; target_stdev = 20.0                      # target mean and standard deviation of the synthetic dataset\n\nprop_trend = 0.3; prop_cycle = 0.5; prop_noise = 1 - (prop_trend + prop_cycle)\ntrend_mean = target_mean; cycle_mean = 0.0; noise_mean = 0.0\nnoise_stdev = math.sqrt(prop_noise*(target_stdev**2.0))\ntrend_stdev = math.sqrt(prop_trend*(target_stdev**2.0)); cycle_stdev = math.sqrt(prop_cycle*(target_stdev**2.0))\nnoise_stdev = math.sqrt(prop_noise*(target_stdev**2.0))\n\nnx = 1000; ny = 1; xsiz = 1.0; ysiz = 10.0; xmn = 5.0; ymn = 5.0; nxdis = 1; nydis = 1 # model window\nxmin = 0.0; xmax = nx*xsiz; ymin = 0.0; ymax = ny*ysiz; cmap = plt.cm.inferno\n\nndmin = 0; ndmax = 30; radius = 1000; ktype = 0; skmean = 0; tmin = -999; tmax = 999 # geostatistical simulation parameters\n\nx_value = np.linspace(1,nx,nx)                                # array with the days for the observations\n\nvario_noise = GSLIB.make_variogram(nug=0.0,nst=1,it1=3,cc1=1.0,azi1=90.0,hmaj1=10,hmin1=1) # assumed spatial continuity models \n\nx = np.ones(10)*-9999; y = np.ones(10)*-9999; value = np.random.normal(10) # reference data for forward and back transformation\ndf_null = pd.DataFrame({'x': x, 'y': y, 'value':value})           # make a new DataFrame from the vectors\nseries_noise = geostats.sgsim(df_null,'x','y','value',wcol=-1,scol=-1,tmin=tmin,tmax=tmax,itrans=0,ismooth=0,dftrans=0,tcol=0, # noise component\n            twtcol=0,zmin=0.0,zmax=0.3,ltail=1,ltpar=0.0,utail=1,utpar=0.3,nsim=1,\n            nx=nx,xmn=xmn,xsiz=xsiz,ny=ny,ymn=ymn,ysiz=ysiz,seed=75053,\n            ndmin=ndmin,ndmax=ndmax,nodmax=20,mults=1,nmult=3,noct=-1,ktype=ktype,colocorr=0.0,sec_map=0,vario=vario_noise)[0][0]\nseries_noise = GSLIB.affine(series_noise,noise_mean,noise_stdev)  # correct the mean and variance of the noise field\n\nseries_cycle = np.sin(np.linspace(0,nx*xsiz,nx)/20)           # calculate a cyclic component\nseries_cycle = GSLIB.affine(series_cycle,cycle_mean,cycle_stdev) # correct the cyclic component mean and variance\n\nseries_trend = x_value; series_trend = GSLIB.affine(series_trend,trend_mean,trend_stdev) # trend component\n\nseries_total = series_trend + series_cycle + series_noise; series_total = GSLIB.affine(series_total,target_mean,target_stdev)\n\nplt.subplot(211)\nplt.plot(x_value,series_noise,color='green',linewidth=3,label = 'Noise Residual')\nplt.plot(x_value,series_cycle,color='red',linewidth=3,label = 'Cyclic Residual')\nplt.plot(x_value,series_trend,color='blue',linewidth=3,label = 'Trend'); plt.plot([xmin,xmax],[0,0],color='black',ls='--')\nplt.legend(loc='best'); plt.xlabel('Time (Days)'); plt.ylabel('Lithium Production (tonnes / day)'); \nplt.title('Additive Components for Synthetic Production Time Series')\nplt.gca().xaxis.set_major_formatter(FuncFormatter(comma_format)); add_grid()\nplt.xlim([np.min(x_value),np.max(x_value)]); plt.ylim([-40,140])\n\nplt.subplot(212)\nplt.plot(x_value,series_total,color='black',linewidth=3, label = 'Lithium Production')\nplt.legend(loc='best'); plt.xlabel('Time (Days)'); plt.ylabel('Lithium Production (Li tonnes / day)'); \nplt.title('Synthetic Lithium Production Time Series')\nplt.xlim([np.min(x_value),np.max(x_value)]); plt.ylim([0.0,160]); add_grid()\nplt.gca().xaxis.set_major_formatter(FuncFormatter(comma_format)); add_grid()\nplt.subplots_adjust(left=0.0, bottom=0.0, right=2.0, top=2.0, wspace=0.2, hspace=0.2); plt.show() \n```", "```py\nstart_date = '2016-01-01'; periods = nx\ndate = pd.date_range(start_date,periods=periods,freq='D')     # make a list of dates for DataFrame index and plotting\n\ndf = pd.DataFrame({'date':date[:],'production':series_total[:]}) # make time DataFrame\ndf = df.set_index(['date']); df.head()\ndate_list = date.tolist() \n```", "```py\nax = df['production'].plot(color='black',lw=3)\nax.grid(which='major', axis='x', linestyle='--')              # customize major gridlines\nax.xaxis.set_major_locator(mdates.WeekdayLocator(interval=4)) # major tick every 2 weeks\nax.xaxis.set_major_formatter(mdates.DateFormatter('%Y-%m-%d')) # set the date format for the major ticks\nplt.xticks(rotation=45); add_grid()                           # rotate date labels for better readability\nplt.xlabel('Time (Days)'); plt.ylabel('Lithium Production (tonnes / day)'); plt.title('Synthetic Lithium Production Time Series')\nplt.subplots_adjust(left=0.0, bottom=0.0, right=2.0, top=1.0, wspace=0.2, hspace=0.2); plt.show() \n```", "```py\nnlag = 499                                                    # number of lags for autocorrelation analysis \n\nlag_acf = acf(df['production'], nlags=nlag)                   # calculate autocorrelation and partial autocorrelation functions\nlag_pacf = pacf(df['production'], nlags=nlag, method='ols')\nlags = np.linspace(0,(nlag+1)*xsiz,nlag+1)\n\n#Plot ACF: \nplt.subplot(121)                                              # plot autocorrelation function\nplt.plot(lags,lag_acf,color='red',lw=3,zorder=10)\nplt.axhline(y=0,linewidth = 2,color='black')\nplt.axhline(y=-1.96/np.sqrt(len(series_noise)),linestyle='--',color='gray')\nplt.axhline(y=1.96/np.sqrt(len(series_noise)),linestyle='--',color='gray')\nplt.fill_between(lags,-1.96/np.sqrt(len(series_noise)),1.96/np.sqrt(len(series_noise)),color='grey',alpha=0.4,zorder=1)\nplt.title('Autocorrelation Function'); plt.xlabel('Lags (Days)'); plt.ylabel('Autocorrelation')\nadd_grid(); plt.xlim([0,nlag+1]); plt.ylim([-1.0,1.0])\n\nplt.subplot(122)                                              # plot partial autocorrelation function\nplt.plot(lags,lag_pacf,color='red',lw=3)\nplt.axhline(y=0,linewidth = 2,color='black')\nplt.axhline(y=-1.96/np.sqrt(len(series_noise)),linestyle='--',color='gray')\nplt.axhline(y=1.96/np.sqrt(len(series_noise)),linestyle='--',color='gray')\nplt.fill_between(lags,-1.96/np.sqrt(len(series_noise)),1.96/np.sqrt(len(series_noise)),color='grey',alpha=0.4,zorder=1)\nplt.title('Partial Autocorrelation Function'); plt.title('Autocorrelation Function'); plt.xlabel('Lags (Days)'); plt.ylabel('Autocorrelation')\nadd_grid(); plt.xlim([0,nlag+1]); plt.ylim([-1.0,1.0])\nplt.tight_layout()\n\nplt.subplots_adjust(left=0.0, bottom=0.0, right=2.0, top=1.0, wspace=0.2, hspace=0.2); plt.show() \n```", "```py\nprint('Dickey-Fuller Test Results:')\ndftest = adfuller(df['production'], autolag='AIC')            # perfrom the Dickey-Fuller test for non-stationarity\ndfoutput = pd.Series(dftest[0:4], index=['Test Statistic','p-value','#Lags Used','Number of Observations Used'])\nfor key,value in dftest[4].items():\n    dfoutput['Critical Value (%s)'%key] = value\nprint(dfoutput[0:7]) \n```", "```py\nDickey-Fuller Test Results:\nTest Statistic                  -3.639408\np-value                          0.005051\n#Lags Used                       8.000000\nNumber of Observations Used    991.000000\nCritical Value (1%)             -3.436966\nCritical Value (5%)             -2.864461\nCritical Value (10%)            -2.568325\ndtype: float64 \n```", "```py\nwindow_size = 50                                              # assume window size of 10 days\nalpha = 0.40                                                  # alpha for percentiles, symmetric probability interval = 1 - alpha\n\ndf['rolling_mean'] = df['production'].rolling(window = window_size, center = True).mean() # moving window statistics\ndf['rolling_std'] = df['production'].rolling(window = window_size, center = True).std()\ndf['rolling_lower'] = df['production'].rolling(window = window_size, center = True).quantile(alpha/2.0)\ndf['rolling_upper'] = df['production'].rolling(window = window_size, center = True).quantile(1-alpha/2.0)\n\nplt.subplot(211)                                              # plot rolling statistics:\nax = df['production'].plot(color='black',lw=2,ls='--',zorder=50)\ndf['rolling_mean'].plot(color='red',lw=3,label='Rolling Mean',zorder=20)\ndf['rolling_lower'].plot(color='red',lw=1,label='Rolling P' + str(int(alpha*100/2)),zorder=20)\ndf['rolling_upper'].plot(color='red',lw=1,label='Rolling P' + str(int(100-alpha*100/2)),zorder=20)\nplt.fill_between(date,df['rolling_lower'],df['rolling_upper'],color='red',alpha=0.4)\nax.xaxis.set_major_locator(mdates.WeekdayLocator(interval=4)) # major tick every 2 weeks\nax.xaxis.set_major_formatter(mdates.DateFormatter('%Y-%m-%d')) # set the date format for the major ticks\nplt.xticks(rotation=45); add_grid(); plt.legend(loc='lower right') # rotate date labels for better readability\nplt.xlabel('Time (Days)'); plt.ylabel('Lithium Production (Li tonnes / day)')\nplt.title('Synthetic Lithium Production and Rolling Mean and Percentiles')\n\nplt.subplot(212)\nax = df['rolling_std'].plot(color='red',lw=3,label='Rolling Standard Deviation')\nplt.legend(loc='best'); plt.title('Rolling Standard Deviation')\nplt.xlim([date[0],date[-1]]); plt.ylim([0,30]); add_grid()\nax.xaxis.set_major_locator(mdates.WeekdayLocator(interval=4)) # major tick every 2 weeks\nax.xaxis.set_major_formatter(mdates.DateFormatter('%Y-%m-%d')) # set the date format for the major ticks\nplt.xticks(rotation=45); add_grid()                           # rotate date labels for better readability\nplt.xlabel('Time (Days)'); plt.ylabel('Rolling St. Dev. Lithium Production (Li tonnes / day)')\nplt.title('Rolling Standard Deviation of Synthetic Lithium Production')\n\nplt.subplots_adjust(left=0.0, bottom=0.0, right=2.0, top=2.0, wspace=0.2, hspace=0.35); plt.show() \n```", "```py\ndf['residual'] = df['production'].values - df['rolling_mean'].values # calculate residual\ndf.head(n=13) \n```", "```py\nnlag = 499                                                    # number of lags for autocorrelation analysis \n\nax = df['residual'].plot(color='red',lw=3,label='Rolling Standard Deviation')\nplt.legend(loc='best'); plt.title('Rolling Standard Deviation')\nplt.xlim([date[0],date[-1]]); plt.ylim([-30,30])\nplt.plot([date[0],date[-1]],[0,0],color='black',ls='--')\nax.xaxis.set_major_locator(mdates.WeekdayLocator(interval=4)) # major tick every 2 weeks\nax.xaxis.set_major_formatter(mdates.DateFormatter('%Y-%m-%d')) # set the date format for the major ticks\nplt.xticks(rotation=45); add_grid()                           # rotate date labels for better readability\nplt.xlabel('Time (Days)'); plt.ylabel('Rolling Residual Lithium Production (Li tonnes / day)')\nplt.title('Rolling Residual (Data - Mean) Lithium Production')\nplt.subplots_adjust(left=0.0, bottom=0.0, right=2.0, top=1.0, wspace=0.2, hspace=0.2); plt.show() \n```", "```py\nwindows = [20,40,100]                                         # specify 3 moving window sizes\n\nfor iwin,window in enumerate(windows):                        # calculate rolling window mean and residual\n    df['rolling_mean_'+str(window)] = df['production'].rolling(window = window, center = True).mean()\n    df['rolling_res_'+str(window)] = df['rolling_mean_'+str(window)] - df['production']\n\n    plt.subplot(3,2,iwin*2+1)                                 # plot rolling mean\n    ax = df['rolling_mean_'+str(window)].plot(color='red',lw=3,label='Lithium Production',zorder=20)\n    ax.xaxis.set_major_locator(mdates.WeekdayLocator(interval=8))  # major tick every 2 weeks\n    ax.xaxis.set_major_formatter(mdates.DateFormatter('%Y-%m-%d')) # set the date format for the major ticks\n    plt.xticks(rotation=45); add_grid(); plt.xlim([date[0],date[-1]]); plt.ylim([0,140])  # rotate date labels for better readability\n    plt.xlabel('Time (Days)'); plt.title('Rolling Mean Lithium Production (Window = ' + str(window) + ')')\n    plt.ylabel('Lithium Production (tonnes / day)')\n\n    plt.subplot(3,2,iwin*2+2)                                 # plot detrended residual\n    ax = df['rolling_res_'+str(window)].plot(color='red',lw=3,label='Lithium Production',zorder=20)\n    plt.plot([date[0],date[-1]],[0,0],color='black',ls='--',zorder=50)\n    ax.xaxis.set_major_locator(mdates.WeekdayLocator(interval=8)) # major tick every 2 weeks\n    ax.xaxis.set_major_formatter(mdates.DateFormatter('%Y-%m-%d')) # set the date format for the major ticks\n    plt.xticks(rotation=45); add_grid(); plt.xlim([date[0],date[-1]]); plt.ylim([-40,40])  # rotate date labels for better readability\n    plt.xlabel('Time (Days)'); plt.title('Detrended Lithium Production (Data - Rolling Mean) (Window = ' + str(window) + ')')\n    plt.ylabel('Lithium Production Residual (tonnes / day)') \n\nplt.subplots_adjust(left=0.0, bottom=0.0, right=2.0, top=3.0, wspace=0.2, hspace=0.4); plt.show() \n```", "```py\nvariance = np.var(df['production'])\n\nfor iwin,window in enumerate(windows):                        # calculate rolling window mean and residual\n    variance_trend = df['rolling_mean_'+str(window)].var()\n    variance_residual = df['rolling_res_'+str(window)].var()\n\n    prop_trend = variance_trend/variance\n    prop_resid = variance_residual/variance\n    prop_cov = 1 - prop_trend - prop_resid\n\n    variance_prop = [prop_trend, prop_resid, prop_cov]\n    labels = 'Trend', 'Residual', '2 x Covariance'\n    colors = 'orange', 'red', 'green'\n    explode = (0.1, 0.1,0.1)\n\n    plt.subplot(3,3,iwin*3+1)                                 # plot rolling mean \n    ax = df['rolling_mean_'+str(window)].plot(color='red',lw=3,label='Lithium Production',zorder=20)\n    df['production'].plot(color='black',lw=2,zorder=10)\n    ax.xaxis.set_major_locator(mdates.WeekdayLocator(interval=8))  # major tick every 2 weeks\n    ax.xaxis.set_major_formatter(mdates.DateFormatter('%Y-%m-%d')) # set the date format for the major ticks\n    plt.xticks(rotation=45); add_grid(); plt.xlim([date[0],date[-1]]); plt.ylim([0,140])  # rotate date labels for better readability\n    plt.xlabel('Time (Days)'); plt.title('Rolling Mean Lithium Production (Window = ' + str(window) + ')')\n    plt.ylabel('Lithium Production (tonnes / day)')\n\n    plt.subplot(3,3,iwin*3+2)                                 # plot rolling mean residual distribution\n    plt.hist(df['rolling_res_'+str(window)],bins=np.linspace(-40,40,41),color='red',edgecolor='black',alpha=1.0,zorder=10)\n    plt.xlim([-40,40]); plt.ylim([0,300]); add_grid()\n    plt.vlines(0,0,300,color='black',ls='--',zorder=30)\n    plt.xlabel('Residual Lithium Production (tonnes/day)'); plt.ylabel('Frequency')\n    plt.title('Detrended Residual Lithium Production (Window = ' + str(window) + ')')\n    plt.annotate('Residual:',[18,260])\n    plt.annotate('Mean = ' + str(round((df['rolling_res_'+str(window)]).mean(),2)),[20,240])\n    plt.annotate('Min = ' + str(round((df['rolling_res_'+str(window)]).min(),2)),[20,220])\n    plt.annotate('Max = ' + str(round((df['rolling_res_'+str(window)]).max(),2)),[20,200])\n\n    plt.subplot(3,3,iwin*3+3)                                 # plot rolling mean\n    plt.pie(variance_prop, explode=explode, colors = colors, labels=labels, autopct='%1.1f%%',\n            shadow=True, startangle=90)\n    plt.title('Lithium Production Variance Components (Window = ' + str(window) + ')')\n    plt.gca().axis('equal')                                   # equal aspect ratio ensures that pie plot is drawn as a circle\n\nplt.subplots_adjust(left=0.0, bottom=0.0, right=3.0, top=3.0, wspace=0.2, hspace=0.4); plt.show() \n```", "```py\nprint('Dickey-Fuller Test Results:')\nresidual = df['residual'] \nresidual = residual[~pd.isnull(residual)]                     # remove null values\ndftest = adfuller(residual, autolag='AIC')                    # perform Dickey-Fuller test for stationarity\ndfoutput = pd.Series(dftest[0:4], index=['Test Statistic','p-value','#Lags Used','Number of Observations Used'])\nfor key,value in dftest[4].items():\n    dfoutput['Critical Value (%s)'%key] = value\nprint(dfoutput[0:7]) \n```", "```py\nDickey-Fuller Test Results:\nTest Statistic                -9.362547e+00\np-value                        7.753045e-16\n#Lags Used                     8.000000e+00\nNumber of Observations Used    9.420000e+02\nCritical Value (1%)           -3.437311e+00\nCritical Value (5%)           -2.864613e+00\nCritical Value (10%)          -2.568406e+00\ndtype: float64 \n```", "```py\nnp.diff(df[0].values) \n```", "```py\ndiff1 = np.diff(df['production'].values)\ndiff1 = np.append(diff1,diff1[diff1.size-1])                  # double the last value to keep the length the same\ndf['first_difference'] = diff1\n\ndiff2 = np.diff(df['first_difference'].values)\ndiff2 = np.append(diff2,diff2[diff2.size-1])                  # double the last value to keep the length the same\ndf['second_difference'] = diff2\ndf.head() \n```", "```py\ncases = ['production','first_difference','second_difference'] # differencing cases\n\nnlag = 200\nlags = np.linspace(0,(nlag+1)*xsiz,nlag+1); prod_lag_acf = []\n\nfor icase, case in enumerate(cases):\n    prod_lag_acf.append(acf(df[case], nlags=nlag))\n\n    plt.subplot(3,2,icase*2+1)                                # plot values \n    ax = df[case].plot(color='black',lw=3)\n    ax.grid(which='major', axis='x', linestyle='--')          # customize major gridlines\n    ax.xaxis.set_major_locator(mdates.WeekdayLocator(interval=8)) # major tick every 2 weeks\n    ax.xaxis.set_major_formatter(mdates.DateFormatter('%Y-%m-%d')) # set the date format for the major ticks\n    plt.xticks(rotation=45); add_grid()                       # rotate date labels for better readability\n    plt.xlabel('Time (Days)'); plt.ylabel('Lithium Production (tonnes / day)'); plt.title(case + ' Lithium Production Time Series')\n\n    plt.subplot(3,2,icase*2+2)                                # plot autocorrelation\n    plt.plot(lags,prod_lag_acf[icase],color='red')\n    plt.axhline(y=0,linewidth = 2,color='black')\n    plt.axhline(y=-1.96/np.sqrt(len(series_noise)),linestyle='--',color='gray')\n    plt.axhline(y=1.96/np.sqrt(len(series_noise)),linestyle='--',color='gray')\n    plt.fill_between(lags,-1.96/np.sqrt(len(series_noise)),1.96/np.sqrt(len(series_noise)),color='grey',alpha=0.4,zorder=1)\n    plt.title(case + ' Autocorrelation Function'); plt.xlabel('Lags (Days)'); plt.ylabel('Autocorrelation')\n    add_grid(); plt.xlim([0,nlag+1]); plt.ylim([-1.0,1.0])\n\nplt.subplots_adjust(left=0.0, bottom=0.0, right=2.0, top=3.0, wspace=0.2, hspace=0.4); plt.show() \n```", "```py\nprint('Dickey-Fuller Test Results - First Differenced Production:')\nresidual = df['first_difference'] \nresidual = residual[~pd.isnull(residual)]                     # remove null values\ndftest = adfuller(residual, autolag='AIC')                    # perform Dickey-Fuller test\ndfoutput = pd.Series(dftest[0:4], index=['Test Statistic','p-value','#Lags Used','Number of Observations Used'])\nfor key,value in dftest[4].items():\n    dfoutput['Critical Value (%s)'%key] = value\nprint(dfoutput[0:7])\n\nprint('Dickey-Fuller Test Results - Second Differenced Production:')\nresidual = df['second_difference'] \nresidual = residual[~pd.isnull(residual)]                     # remove null values\ndftest = adfuller(residual, autolag='AIC')                    # perform Dickey-Fuller test\ndfoutput = pd.Series(dftest[0:4], index=['Test Statistic','p-value','#Lags Used','Number of Observations Used'])\nfor key,value in dftest[4].items():\n    dfoutput['Critical Value (%s)'%key] = value\nprint(dfoutput[0:7]) \n```", "```py\nDickey-Fuller Test Results - First Differenced Production:\nTest Statistic                -1.022681e+01\np-value                        5.151322e-18\n#Lags Used                     1.000000e+01\nNumber of Observations Used    9.890000e+02\nCritical Value (1%)           -3.436979e+00\nCritical Value (5%)           -2.864467e+00\nCritical Value (10%)          -2.568328e+00\ndtype: float64\nDickey-Fuller Test Results - Second Differenced Production:\nTest Statistic                -1.266754e+01\np-value                        1.265190e-23\n#Lags Used                     1.900000e+01\nNumber of Observations Used    9.800000e+02\nCritical Value (1%)           -3.437040e+00\nCritical Value (5%)           -2.864494e+00\nCritical Value (10%)          -2.568343e+00\ndtype: float64 \n```", "```py\ndecomposition = seasonal_decompose(df['production'], model='additive',extrapolate_trend=1,period=110,filt=np.ones(20)/20,two_sided = True)\ndecomp_trend = decomposition.trend; decomp_seasonal = decomposition.seasonal; decomp_residual = decomposition.resid\nfig = decomposition.plot()\nplt.subplots_adjust(left=0.0, bottom=0.0, right=2.0, top=1.0, wspace=0.2, hspace=0.2); plt.show() \n```", "```py\nvar_decomp_trend = np.var(decomp_trend.values); var_decomp_seasonal = np.var(decomp_seasonal.values) # calculate variance components\nvar_decomp_residual = np.var(decomp_residual.values); var_total = np.var(df['production'])\n\nvariance_prop = [var_decomp_trend, var_decomp_seasonal, var_decomp_residual]\nlabels = ['Trend', 'Seasonal', 'Residual']; colors = ['orange','cyan','red']; explode = [0.1,0.1,0.1]\n\nplt.subplot(111)                                              # plot the decompositional model variance components\nplt.pie(variance_prop, explode=explode, colors = colors, labels=labels, autopct='%1.1f%%',\n        shadow=True, startangle=90)\nplt.title('Lithium Production Decomposition Model Variance Components')\nplt.gca().axis('equal')                                       # equal aspect ratio ensures that pie is drawn as a circle.\nplt.subplots_adjust(left=0.0, bottom=0.0, right=2.0, top=1.0, wspace=0.2, hspace=0.2) \n```", "```py\nprint('Dickey-Fuller Test Results:')\ndecomp_residual = decomp_residual[~pd.isnull(decomp_residual)]  # remove null values\ndf['decomp_res'] = decomp_residual\ndftest = adfuller(decomp_residual, autolag='AIC')             # perform Dickey-Fuller test\ndfoutput = pd.Series(dftest[0:4], index=['Test Statistic','p-value','#Lags Used','Number of Observations Used'])\nfor key,value in dftest[4].items():\n    dfoutput['Critical Value (%s)'%key] = value\nprint(dfoutput[0:7]) \n```", "```py\nDickey-Fuller Test Results:\nTest Statistic                -9.629883e+00\np-value                        1.622897e-16\n#Lags Used                     2.100000e+01\nNumber of Observations Used    9.780000e+02\nCritical Value (1%)           -3.437054e+00\nCritical Value (5%)           -2.864500e+00\nCritical Value (10%)          -2.568346e+00\ndtype: float64 \n```", "```py\nnlags = 200                                                   # number of autocorrelation lags\nlag_acf_decomp_resid = acf(decomp_residual, nlags=nlags)      # autocorrelation\nlags = np.linspace(0,(nlags+1)*xsiz,nlags+1)\n\nplt.subplot(121)                                              # plot decomposition model residual\nax = df['decomp_res'].plot(color='black',lw=3)\nax.xaxis.set_major_locator(mdates.WeekdayLocator(interval=8))  # major tick every 2 weeks\nax.xaxis.set_major_formatter(mdates.DateFormatter('%Y-%m-%d')) # set the date format for the major ticks\nplt.xticks(rotation=45); add_grid(); plt.xlim([date[0],date[-1]]); plt.ylim([-40,40]) # rotate date labels for better readability\nplt.xlabel('Time (Days)'); plt.title('Decomposition Time Series Model Residual')\nplt.ylabel('Lithium Production (tonnes / day)')\n\nplt.subplot(122)                                              # plot autocorrelation of decomposition residual\nplt.plot(lags,lag_acf_decomp_resid,color='red')\nplt.axhline(y=0,linewidth = 2,color='black')\nplt.axhline(y=-1.96/np.sqrt(len(series_noise)),linestyle='--',color='gray')\nplt.axhline(y=1.96/np.sqrt(len(series_noise)),linestyle='--',color='gray')\nplt.fill_between(lags,-1.96/np.sqrt(len(series_noise)),1.96/np.sqrt(len(series_noise)),color='grey',alpha=0.4,zorder=1)\nplt.title('Time Series Decomposition Model Residual Autocorrelation Function'); plt.xlabel('Lags (Days)'); plt.ylabel('Autocorrelation')\nadd_grid(); plt.xlim([0,nlag+1]); plt.ylim([-1.0,1.0])\n\nplt.subplots_adjust(left=0.0, bottom=0.0, right=2.0, top=1.0, wspace=0.2, hspace=0.2); plt.show() \n```", "```py\ntrain_frac = 0.8; split_index = int(len(df)*train_frac)       # specify train and test split\n\ntrain = df['production'][:split_index]                        # perform split\ntest = df['production'][split_index:]\ntrain_date_list = pd.date_range(start=date[0], end=date[split_index-1]).tolist() # date ranges for train and test for plotting\ntest_date_list = pd.date_range(start=date[split_index],end=date[len(df)-1]).tolist()\n\nprint('Train samples = ' + str(len(train)) + ', Test samples = ' + str(len(test))) # check train and test counts\nprint('Train samples dates = ' + str(len(train_date_list)) + ', Test samples dates = ' + str(len(test_date_list))) \n```", "```py\nTrain samples = 800, Test samples = 200\nTrain samples dates = 800, Test samples dates = 200 \n```", "```py\np = 1; d = 0; q = 2                                           # set ARIMA parameters\n\nsP = 1; sD = 1; sQ = 2; s = 5                                 # seasonal orders\n\nARIMA_model = ARIMA(train, order=(p, d, q),trend='t',seasonal_order=(sP,sD,sQ,s)) # instantiate ARIMA model\nARIMA_model_fit = ARIMA_model.fit()                           # fit ARIM model\n\nprint(ARIMA_model_fit.summary())                              # print diagnostics from ARIMA model \n```", "```py\n SARIMAX Results                                    \n=======================================================================================\nDep. Variable:                      production   No. Observations:                  800\nModel:             ARIMA(1, 0, 2)x(1, 1, 2, 5)   Log Likelihood               -1782.678\nDate:                         Tue, 08 Oct 2024   AIC                           3581.357\nTime:                                 11:06:15   BIC                           3618.784\nSample:                             01-01-2016   HQIC                          3595.739\n                                  - 03-10-2018                                         \nCovariance Type:                           opg                                         \n==============================================================================\n                 coef    std err          z      P>|z|      [0.025      0.975]\n------------------------------------------------------------------------------\nx1             0.0497      0.026      1.943      0.052      -0.000       0.100\nar.L1          0.9844      0.009    109.383      0.000       0.967       1.002\nma.L1          0.2957      0.023     13.071      0.000       0.251       0.340\nma.L2          0.4662      0.020     23.536      0.000       0.427       0.505\nar.S.L5        0.1298      0.249      0.521      0.602      -0.358       0.618\nma.S.L5       -1.3116      0.234     -5.597      0.000      -1.771      -0.852\nma.S.L10       0.3133      0.240      1.308      0.191      -0.156       0.783\nsigma2         5.0306      0.337     14.947      0.000       4.371       5.690\n===================================================================================\nLjung-Box (L1) (Q):                  12.96   Jarque-Bera (JB):              2704.23\nProb(Q):                              0.00   Prob(JB):                         0.00\nHeteroskedasticity (H):               1.22   Skew:                             0.02\nProb(H) (two-sided):                  0.11   Kurtosis:                        12.04\n===================================================================================\n\nWarnings:\n[1] Covariance matrix calculated using the outer product of gradients (complex-step). \n```", "```py\nresiduals = pd.DataFrame(ARIMA_model_fit.resid)               # add ARIMA residuals to DataFrame\n\nplt.subplot(121)                                              # plot ARIMA residuals\norig = plt.plot(residuals, color='red',linewidth = 3, label='Residual')\nplt.plot([date[0],date[-1]],[0,0],color='black')\nplt.title('ARIMA Model Residual'); plt.legend(loc='best'); plt.ylim(-10,10); plt.xlim([date[0],date[-1]])\n\nplt.subplot(122)                                               # plot histogram of ARIMA residuals\nplt.hist(residuals[0].values,bins = np.linspace(-10,10,30),color = 'red',alpha = 1.0,edgecolor = 'black')\nplt.xlabel('Residual'); plt.ylabel('Frequency'); plt.title('ARIMA Model Residual'), plt.xlim(-10,10)\n\nplt.subplots_adjust(left=0.0, bottom=0.0, right=3.0, top=1.0, wspace=0.2, hspace=0.2); plt.show() \n```", "```py\nforecast_steps = 200                                          # number of forecast steps\n\nforecast = ARIMA_model_fit.forecast(steps=forecast_steps)\nforecast_date_list = pd.date_range(start=test_date_list[0], end=test_date_list[0] + pd.Timedelta(days=forecast_steps-1)).tolist()\n\nplt.subplot(111)                                              # plot data, train and test and ARIMA forecast\nplt.plot(date_list,df['production'],color='black',label='Actual Data',zorder=10) # plot data\nplt.plot(train_date_list,train.values,lw=3,color='lightgreen',label='Train Data',zorder=1) # plot data\nplt.plot(test_date_list,test.values,lw=3,color='lightblue',label='Test Data',zorder=1) # plot data\nplt.plot(forecast_date_list,forecast.values, label='ARIMA Forecast', color='red') # plot forecast\nax.xaxis.set_major_locator(mdates.WeekdayLocator(interval=4))  # major tick every 2 weeks\nax.xaxis.set_major_formatter(mdates.DateFormatter('%Y-%m-%d')) # set the date format for the major ticks\nplt.xticks(rotation=45); add_grid(); plt.ylim([0,160])  # rotate date labels for better readability\nplt.xlabel('Time (Days)'); plt.title('Decomposition Time Series Model Residual')\nplt.ylabel('Lithium Production (tonnes / day)'); plt.xlim(date_list[0],date_list[-1])\nplt.plot([test_date_list[0],test_date_list[0]],[-40,160],color='black',ls='--') # vertical line at end of train time period\nplt.title('ARIMA Model Forecasts'); plt.ylabel('Lithium Production (tonnes / day)'); plt.xlabel('Time (Days)')\nplt.legend(loc='lower left')\nplt.subplots_adjust(left=0.0, bottom=0.0, right=1.0, top=1.0, wspace=0.2, hspace=0.2); plt.show() \n```"]