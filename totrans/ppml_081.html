<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.1//EN"
  "http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd">

<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<title>Interior mutability</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1>Interior mutability</h1>
<blockquote>原文：<a href="https://rust-exercises.com/100-exercises/07_threads/06_interior_mutability.html">https://rust-exercises.com/100-exercises/07_threads/06_interior_mutability.html</a></blockquote>
                        
<p>Let's take a moment to reason about the signature of <code>Sender</code>'s <code>send</code>:</p>
<pre><code class="language-rust">impl&lt;T&gt; Sender&lt;T&gt; {
    pub fn send(&amp;self, t: T) -&gt; Result&lt;(), SendError&lt;T&gt;&gt; {
        // [...]
    }
}</code></pre>
<p><code>send</code> takes <code>&amp;self</code> as its argument.<br/>
But it's clearly causing a mutation: it's adding a new message to the channel.
What's even more interesting is that <code>Sender</code> is cloneable: we can have multiple instances of <code>Sender</code>
trying to modify the channel state <strong>at the same time</strong>, from different threads.</p>
<p>That's the key property we are using to build this client-server architecture. But why does it work?
Doesn't it violate Rust's rules about borrowing? How are we performing mutations via an <em>immutable</em> reference?</p>
<h2 id="shared-rather-than-immutable-references"><a class="header" href="#shared-rather-than-immutable-references">Shared rather than immutable references</a></h2>
<p>When we introduced the borrow-checker, we named the two types of references we can have in Rust:</p>
<ul>
<li>immutable references (<code>&amp;T</code>)</li>
<li>mutable references (<code>&amp;mut T</code>)</li>
</ul>
<p>It would have been more accurate to name them:</p>
<ul>
<li>shared references (<code>&amp;T</code>)</li>
<li>exclusive references (<code>&amp;mut T</code>)</li>
</ul>
<p>Immutable/mutable is a mental model that works for the vast majority of cases, and it's a great one to get started
with Rust. But it's not the whole story, as you've just seen: <code>&amp;T</code> doesn't actually guarantee that the data it
points to is immutable.<br/>
Don't worry, though: Rust is still keeping its promises.
It's just that the terms are a bit more nuanced than they might seem at first.</p>
<h2 id="unsafecell"><a class="header" href="#unsafecell"><code>UnsafeCell</code></a></h2>
<p>Whenever a type allows you to mutate data through a shared reference, you're dealing with <strong>interior mutability</strong>.</p>
<p>By default, the Rust compiler assumes that shared references are immutable. It <strong>optimises your code</strong> based on that assumption.<br/>
The compiler can reorder operations, cache values, and do all sorts of magic to make your code faster.</p>
<p>You can tell the compiler "No, this shared reference is actually mutable" by wrapping the data in an <code>UnsafeCell</code>.<br/>
Every time you see a type that allows interior mutability, you can be certain that <code>UnsafeCell</code> is involved,
either directly or indirectly.<br/>
Using <code>UnsafeCell</code>, raw pointers and <code>unsafe</code> code, you can mutate data through shared references.</p>
<p>Let's be clear, though: <code>UnsafeCell</code> isn't a magic wand that allows you to ignore the borrow-checker!<br/>
<code>unsafe</code> code is still subject to Rust's rules about borrowing and aliasing.
It's an (advanced) tool that you can leverage to build <strong>safe abstractions</strong> whose safety can't be directly expressed
in Rust's type system. Whenever you use the <code>unsafe</code> keyword you're telling the compiler:
"I know what I'm doing, I won't violate your invariants, trust me."</p>
<p>Every time you call an <code>unsafe</code> function, there will be documentation explaining its <strong>safety preconditions</strong>:
under what circumstances it's safe to execute its <code>unsafe</code> block. You can find the ones for <code>UnsafeCell</code>
<a href="https://doc.rust-lang.org/std/cell/struct.UnsafeCell.html">in <code>std</code>'s documentation</a>.</p>
<p>We won't be using <code>UnsafeCell</code> directly in this course, nor will we be writing <code>unsafe</code> code.
But it's important to know that it's there, why it exists and how it relates to the types you use
every day in Rust.</p>
<h2 id="key-examples"><a class="header" href="#key-examples">Key examples</a></h2>
<p>Let's go through a couple of important <code>std</code> types that leverage interior mutability.<br/>
These are types that you'll encounter somewhat often in Rust code, especially if you peek under the hood of
some the libraries you use.</p>
<h3 id="reference-counting"><a class="header" href="#reference-counting">Reference counting</a></h3>
<p><code>Rc</code> is a reference-counted pointer.<br/>
It wraps around a value and keeps track of how many references to the value exist.
When the last reference is dropped, the value is deallocated.<br/>
The value wrapped in an <code>Rc</code> is immutable: you can only get shared references to it.</p>
<pre><code class="language-rust">use std::rc::Rc;

let a: Rc&lt;String&gt; = Rc::new("My string".to_string());
// Only one reference to the string data exists.
assert_eq!(Rc::strong_count(&amp;a), 1);

// When we call `clone`, the string data is not copied!
// Instead, the reference count for `Rc` is incremented.
let b = Rc::clone(&amp;a);
assert_eq!(Rc::strong_count(&amp;a), 2);
assert_eq!(Rc::strong_count(&amp;b), 2);
// ^ Both `a` and `b` point to the same string data
//   and share the same reference counter.</code></pre>
<p><code>Rc</code> uses <code>UnsafeCell</code> internally to allow shared references to increment and decrement the reference count.</p>
<h3 id="refcell"><a class="header" href="#refcell"><code>RefCell</code></a></h3>
<p><code>RefCell</code> is one of the most common examples of interior mutability in Rust.
It allows you to mutate the value wrapped in a <code>RefCell</code> even if you only have an
immutable reference to the <code>RefCell</code> itself.</p>
<p>This is done via <strong>runtime borrow checking</strong>.
The <code>RefCell</code> keeps track of the number (and type) of references to the value it contains at runtime.
If you try to borrow the value mutably while it's already borrowed immutably,
the program will panic, ensuring that Rust's borrowing rules are always enforced.</p>
<pre><code class="language-rust">use std::cell::RefCell;

let x = RefCell::new(42);

let y = x.borrow(); // Immutable borrow
let z = x.borrow_mut(); // Panics! There is an active immutable borrow.</code></pre>
<h2 id="exercise"><a class="header" href="#exercise">Exercise</a></h2>
<p>The exercise for this section is located in <a href="https://github.com/mainmatter/100-exercises-to-learn-rust/tree/main/exercises/07_threads/06_interior_mutability"><code>07_threads/06_interior_mutability</code></a></p>

                        
</body>
</html>