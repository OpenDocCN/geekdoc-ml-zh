- en: Copying values, pt. 1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 原文：[https://rust-exercises.com/100-exercises/04_traits/11_clone.html](https://rust-exercises.com/100-exercises/04_traits/11_clone.html)
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: In the previous chapter we introduced ownership and borrowing.
  prefs: []
  type: TYPE_NORMAL
- en: 'We stated, in particular, that:'
  prefs: []
  type: TYPE_NORMAL
- en: Every value in Rust has a single owner at any given time.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When a function takes ownership of a value ("it consumes it"), the caller can't
    use that value anymore.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: These restrictions can be somewhat limiting.
  prefs: []
  type: TYPE_NORMAL
- en: Sometimes we might have to call a function that takes ownership of a value,
    but we still need to use that value afterward.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: That's where `Clone` comes in.
  prefs: []
  type: TYPE_NORMAL
- en: '[`Clone`](#clone)'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '`Clone` is a trait defined in Rust''s standard library:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Its method, `clone`, takes a reference to `self` and returns a new **owned**
    instance of the same type.
  prefs: []
  type: TYPE_NORMAL
- en: '[In action](#in-action)'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Going back to the example above, we can use `clone` to create a new `String`
    instance before calling `consumer`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Instead of giving ownership of `s` to `consumer`, we create a new `String` (by
    cloning `s`) and give that to `consumer` instead.
  prefs: []
  type: TYPE_NORMAL
- en: '`s` remains valid and usable after the call to `consumer`.'
  prefs: []
  type: TYPE_NORMAL
- en: '[In memory](#in-memory)'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let''s look at what happened in memory in the example above. When `let mut
    s = String::from("hello");` is executed, the memory looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'When `let t = s.clone()` is executed, a whole new region is allocated on the
    heap to store a copy of the data:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: If you're coming from a language like Java, you can think of `clone` as a way
    to create a deep copy of an object.
  prefs: []
  type: TYPE_NORMAL
- en: '[Implementing `Clone`](#implementing-clone)'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To make a type `Clone`-able, we have to implement the `Clone` trait for it.
  prefs: []
  type: TYPE_NORMAL
- en: 'You almost always implement `Clone` by deriving it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'The compiler implements `Clone` for `MyType` as you would expect: it clones
    each field of `MyType` individually and then constructs a new `MyType` instance
    using the cloned fields.'
  prefs: []
  type: TYPE_NORMAL
- en: Remember that you can use `cargo expand` (or your IDE) to explore the code generated
    by `derive` macros.
  prefs: []
  type: TYPE_NORMAL
- en: '[Exercise](#exercise)'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The exercise for this section is located in [`04_traits/11_clone`](https://github.com/mainmatter/100-exercises-to-learn-rust/tree/main/exercises/04_traits/11_clone)
  prefs: []
  type: TYPE_NORMAL
