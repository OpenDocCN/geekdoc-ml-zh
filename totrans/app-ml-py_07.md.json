["```py\nimport geostatspy.GSLIB as GSLIB          # GSLIB utilities, visualization and wrapper\nimport geostatspy.geostats as geostats    # GSLIB methods convert to Python \n```", "```py\nimport os                                                     # set working directory, run executables\n\nfrom tqdm import tqdm                                         # suppress the status bar\nfrom functools import partialmethod\ntqdm.__init__ = partialmethod(tqdm.__init__, disable=True)\n\nignore_warnings = True                                        # ignore warnings?\nimport numpy as np                                            # ndarrays for gridded data\nimport pandas as pd                                           # DataFrames for tabular data\nimport matplotlib.pyplot as plt                               # for plotting\nfrom matplotlib.ticker import (MultipleLocator, AutoMinorLocator) # control of axes ticks\nfrom scipy import stats                                       # summary statistics\nimport seaborn as sns                                         # advanced plotting\nplt.rc('axes', axisbelow=True)                                # plot all grids below the plot elements\nif ignore_warnings == True:                                   \n    import warnings\n    warnings.filterwarnings('ignore')\nfrom IPython.utils import io                                  # mute output from simulation\ncmap = plt.cm.inferno                                         # color map \n```", "```py\ndef add_grid():\n    plt.gca().grid(True, which='major',linewidth = 1.0); plt.gca().grid(True, which='minor',linewidth = 0.2) # add y grids\n    plt.gca().tick_params(which='major',length=7); plt.gca().tick_params(which='minor', length=4)\n    plt.gca().xaxis.set_minor_locator(AutoMinorLocator()); plt.gca().yaxis.set_minor_locator(AutoMinorLocator()) # turn on minor ticks \n```", "```py\n#os.chdir(\"c:/PGE383\")                                        # set the working directory \n```", "```py\ndf = pd.read_csv('sample_data_cow.csv')                       # load our data table (wrong name!) \n```", "```py\n---------------------------------------------------------------------------\nFileNotFoundError  Traceback (most recent call last)\nCell In[5], line 1\n----> 1 df = pd.read_csv('sample_data_cow.csv')\n\nFile C:\\ProgramData\\anaconda3\\envs\\MachineLearningBook\\lib\\site-packages\\pandas\\io\\parsers\\readers.py:912, in read_csv(filepath_or_buffer, sep, delimiter, header, names, index_col, usecols, dtype, engine, converters, true_values, false_values, skipinitialspace, skiprows, skipfooter, nrows, na_values, keep_default_na, na_filter, verbose, skip_blank_lines, parse_dates, infer_datetime_format, keep_date_col, date_parser, date_format, dayfirst, cache_dates, iterator, chunksize, compression, thousands, decimal, lineterminator, quotechar, quoting, doublequote, escapechar, comment, encoding, encoding_errors, dialect, on_bad_lines, delim_whitespace, low_memory, memory_map, float_precision, storage_options, dtype_backend)\n  899 kwds_defaults = _refine_defaults_read(\n  900     dialect,\n  901     delimiter,\n   (...)\n  908     dtype_backend=dtype_backend,\n  909 )\n  910 kwds.update(kwds_defaults)\n--> 912 return _read(filepath_or_buffer, kwds)\n\nFile C:\\ProgramData\\anaconda3\\envs\\MachineLearningBook\\lib\\site-packages\\pandas\\io\\parsers\\readers.py:577, in _read(filepath_or_buffer, kwds)\n  574 _validate_names(kwds.get(\"names\", None))\n  576 # Create the parser.\n--> 577 parser = TextFileReader(filepath_or_buffer, **kwds)\n  579 if chunksize or iterator:\n  580     return parser\n\nFile C:\\ProgramData\\anaconda3\\envs\\MachineLearningBook\\lib\\site-packages\\pandas\\io\\parsers\\readers.py:1407, in TextFileReader.__init__(self, f, engine, **kwds)\n  1404     self.options[\"has_index_names\"] = kwds[\"has_index_names\"]\n  1406 self.handles: IOHandles | None = None\n-> 1407 self._engine = self._make_engine(f, self.engine)\n\nFile C:\\ProgramData\\anaconda3\\envs\\MachineLearningBook\\lib\\site-packages\\pandas\\io\\parsers\\readers.py:1661, in TextFileReader._make_engine(self, f, engine)\n  1659     if \"b\" not in mode:\n  1660         mode += \"b\"\n-> 1661 self.handles = get_handle(\n  1662     f,\n  1663     mode,\n  1664     encoding=self.options.get(\"encoding\", None),\n  1665     compression=self.options.get(\"compression\", None),\n  1666     memory_map=self.options.get(\"memory_map\", False),\n  1667     is_text=is_text,\n  1668     errors=self.options.get(\"encoding_errors\", \"strict\"),\n  1669     storage_options=self.options.get(\"storage_options\", None),\n  1670 )\n  1671 assert self.handles is not None\n  1672 f = self.handles.handle\n\nFile C:\\ProgramData\\anaconda3\\envs\\MachineLearningBook\\lib\\site-packages\\pandas\\io\\common.py:859, in get_handle(path_or_buf, mode, encoding, compression, memory_map, is_text, errors, storage_options)\n  854 elif isinstance(handle, str):\n  855     # Check whether the filename is to be opened in binary mode.\n  856     # Binary mode does not support 'encoding' and 'newline'.\n  857     if ioargs.encoding and \"b\" not in ioargs.mode:\n  858         # Encoding\n--> 859         handle = open(\n  860             handle,\n  861             ioargs.mode,\n  862             encoding=ioargs.encoding,\n  863             errors=errors,\n  864             newline=\"\",\n  865         )\n  866     else:\n  867         # Binary mode\n  868         handle = open(handle, ioargs.mode)\n\nFileNotFoundError: [Errno 2] No such file or directory: 'sample_data_cow.csv' \n```", "```py\ndf = pd.read_csv('https://raw.githubusercontent.com/GeostatsGuy/GeoDataSets/master/sample_data.csv') # load data from Dr. Pyrcz's github repository \n```", "```py\nprint(df.iloc[0:5,:])                                         # display first 4 samples in the table as a preview\ndf.head(n=13)                                                 # we could also use this command for a table preview \n```", "```py\n X      Y  Facies  Porosity       Perm           AI\n0  100.0  900.0     1.0  0.100187   1.363890  5110.699751\n1  100.0  800.0     0.0  0.107947  12.576845  4671.458560\n2  100.0  700.0     0.0  0.085357   5.984520  6127.548006\n3  100.0  600.0     0.0  0.108460   2.446678  5201.637996\n4  100.0  500.0     0.0  0.102468   1.952264  3835.270322 \n```", "```py\ndf.describe()                                                 # summary statistics \n```", "```py\ndf['Porosity']                       # returns an Pandas series\ndf['Porosity'].values                # returns an ndarray \n```", "```py\nprint('The minimum is ' + str(round((df['Porosity'].values).min(),2)) + '.') # print univariate statistics\nprint('The maximum is ' + str(round((df['Porosity'].values).max(),2)) + '.')\nprint('The mean is ' + str(round((df['Porosity'].values).mean(),2)) + '.')\nprint('The standard deviation is ' + str(round((df['Porosity'].values).std(),2)) + '.') \n```", "```py\nThe minimum is 0.06.\nThe maximum is 0.24.\nThe mean is 0.15.\nThe standard deviation is 0.05. \n```", "```py\nprint('The minimum is ' + str(round(np.amin(df['Porosity'].values),2))) # print univariate statistics\nprint('The maximum is ' + str(round(np.amax(df['Porosity'].values),2)))\nprint('The range (maximum - minimum) is ' + str(round(np.ptp(df['Porosity'].values),2)))\nprint('The P10 is ' + str(round(np.percentile(df['Porosity'].values,10),3)))\nprint('The P50 is ' + str(round(np.percentile(df['Porosity'].values,50),3)))\nprint('The P90 is ' + str(round(np.percentile(df['Porosity'].values,90),3)))\nprint('The P13 is ' + str(round(np.percentile(df['Porosity'].values,13),3)))\nprint('The median (P50) is ' + str(round(np.median(df['Porosity'].values),3)))\nprint('The mean is ' + str(round(np.mean(df['Porosity'].values),3))) \n```", "```py\nThe minimum is 0.06\nThe maximum is 0.24\nThe range (maximum - minimum) is 0.18\nThe P10 is 0.092\nThe P50 is 0.137\nThe P90 is 0.212\nThe P13 is 0.095\nThe median (P50) is 0.137\nThe mean is 0.15 \n```", "```py\nvalue = 0.10                                                  # calculate cumulative distribution function for a specified value\ncumul_prob = np.count_nonzero(df['Porosity'].values <= value)/len(df)\nprint('The cumulative probability for porosity = ' + str(value) + ' is ' + str(round(cumul_prob,2))) \n```", "```py\nThe cumulative probability for porosity = 0.1 is 0.18 \n```", "```py\nnd = len(df)                                                  # get the number of data values\nwts = np.ones(nd)                                             # make an array of nd length of 1's\nprint('The equal weighted average is ' + str(round(np.average(df['Porosity'].values,weights = wts),3)) + ', the same as the mean above.') \n```", "```py\nThe equal weighted average is 0.15, the same as the mean above. \n```", "```py\nporosity = df['Porosity'].values     \nwts[porosity > 0.13] *= 0.1                                   # make arbitrary weights for demonstration\nprint('The equal weighted average is ' + str(round(np.average(df['Porosity'].values,weights = wts),3)) + ', lower than the equal weighted average above.') \n```", "```py\nThe equal weighted average is 0.112, lower than the equal weighted average above. \n```", "```py\nprint(stats.describe(df['Porosity'].values))                  # summary statistics\npor_stats = stats.describe(df['Porosity'].values)             # store as an array\nprint('Porosity kurtosis is ' + str(round(por_stats[5],2)))   # extract a statistic \n```", "```py\nDescribeResult(nobs=261, minmax=(0.0588710426408954, 0.2422978845362023), mean=0.15035706160196555, variance=0.0024783238419715933, skewness=0.08071652694567066, kurtosis=-1.5618166076333853)\nPorosity kurtosis is -1.56 \n```", "```py\nGSLIB.hist \n```", "```py\n<function geostatspy.GSLIB.hist(array, xmin, xmax, log, cumul, bins, weights, xlabel, title, fig_name)> \n```", "```py\npormin = 0.05; pormax = 0.25                                  # minimum and maximum feature values\nGSLIB.hist_st(df['Porosity'].values,pormin,pormax,log=False,cumul = False,bins=10,weights = None,\n           xlabel='Porosity (fraction)',title='Porosity Well Data')\nadd_grid()\nplt.subplots_adjust(left=0.0, bottom=0.0, right=1.0, top=1.1, wspace=0.1, hspace=0.2); plt.show() \n```", "```py\nnbin_list = [3,20,100]                                             # number of bins for each histogram\n\nfor i,nbin in enumerate(nbin_list):\n    plt.subplot(1,3,i+1)\n    GSLIB.hist_st(df['Porosity'].values,pormin,pormax,log=False,cumul = False,bins=nbin,weights = None,\n                  xlabel='Porosity (fraction)',title='Histogram with ' + str(nbin) + ' Bins'); add_grid()\n\nplt.subplots_adjust(left=0.0, bottom=0.0, right=3.0, top=1.1, wspace=0.2, hspace=0.2); plt.show() \n```", "```py\nplt.hist(df['Porosity'].values,alpha=0.8,color=\"darkorange\",edgecolor=\"black\",bins=20,range=[pormin,pormax])\nplt.title('Histogram'); plt.xlabel('Porosity (fraction)'); plt.ylabel(\"Frequency\"); add_grid()\nplt.subplots_adjust(left=0.0, bottom=0.0, right=1.0, top=1.1, wspace=0.1, hspace=0.2); plt.show() \n```", "```py\nweights = np.ones(len(df)) / len(df)\nplt.hist(df['Porosity'].values,alpha=0.8,color=\"darkorange\",edgecolor=\"black\",bins=25,range=[pormin,pormax],weights=weights)\nplt.title('Normalized Histogram'); plt.xlabel('Porosity (fraction)'); plt.ylabel(\"Probability\"); add_grid()\nplt.subplots_adjust(left=0.0, bottom=0.0, right=1.0, top=1.1, wspace=0.1, hspace=0.2); plt.show() \n```", "```py\nnums=[2,4,10,20,50,200]\n\nfor i, num in enumerate(nums):\n    plt.subplot(2,3,i+1)\n    sns.kdeplot(x=df['Porosity'].values[:num],color = 'black',alpha = 1.0,linewidth=3,bw_method=0.1,fill=False,zorder=10)\n    sns.kdeplot(x=df['Porosity'].values[:num],color = 'darkorange',alpha = 1.0,linewidth=3,bw_method=0.1,fill=True,zorder=1)\n    plt.xlim([0,0.30]); add_grid()\n    plt.title('KDE PDF for First ' + str(num) + ' Data'); plt.xlabel('Porosity (fraction)'); plt.ylabel(\"Density\")\nplt.subplots_adjust(left=0.0, bottom=0.0, right=3.0, top=2.1, wspace=0.1, hspace=0.2); plt.show() \n```", "```py\nplt.hist(df['Porosity'].values,alpha=0.7,color=\"darkorange\",edgecolor=\"black\",bins=25,range=[pormin,pormax],density=True,\n         label = 'Normalized Histogram')\nsns.kdeplot(x=df['Porosity'].values,color = 'black',alpha = 0.8,linewidth=4.0,bw_method=0.10,label = 'PDF')\nplt.title('Histogram and Kernel Density Estimated PDF'); plt.xlabel('Porosity (fraction)'); plt.ylabel(\"Density\")\nplt.legend(loc='upper left'); add_grid()\nplt.subplots_adjust(left=0.0, bottom=0.0, right=1.0, top=1.0, wspace=0.1, hspace=0.2); plt.show() \n```", "```py\nfor i, bw in enumerate([0.01,0.05,0.1,0.3]):\n    plt.subplot(2,2,i+1)\n    print(r'Band Width = ' + str(bw) + r', bandwidth x standard deviation = ' + str(bw*np.std(df['Porosity'])) )\n    plt.hist(df['Porosity'].values,alpha=0.7,color=\"darkorange\",edgecolor=\"black\",bins=25,range=[pormin,pormax],density=True)\n    sns.kdeplot(x=df['Porosity'].values,color = 'black',alpha = 0.8,linewidth=4.0,bw_method=bw)\n    plt.xlim([0.0,0.3])\n    plt.title('Histogram and Kernel Density Estimated PDF, BW = ' + str(bw)); plt.xlabel('Porosity (fraction)'); plt.ylabel(\"Density\")\n\nplt.subplots_adjust(left=0.0, bottom=0.0, right=2.0, top=2.1, wspace=0.1, hspace=0.2); plt.show() \n```", "```py\nBand Width = 0.01, bandwidth x standard deviation = 0.0004968730570602708\nBand Width = 0.05, bandwidth x standard deviation = 0.0024843652853013543\nBand Width = 0.1, bandwidth x standard deviation = 0.0049687305706027085\nBand Width = 0.3, bandwidth x standard deviation = 0.014906191711808122 \n```", "```py\nGSLIB.hist_st(df['Porosity'].values,pormin,pormax,log=False,cumul = True,bins=1000,weights = None, # CDF with GeostatsPy\n           xlabel='Porosity (fraction)',title='Cumulative Distribution Function with Cumulative Histogram'); add_grid()\nplt.subplots_adjust(left=0.0, bottom=0.0, right=1.0, top=1.1, wspace=0.1, hspace=0.2); plt.show() \n```", "```py\nplt.hist(df['Porosity'].values,density=True, cumulative=True, label='CDF',\n           histtype='stepfilled', alpha=0.8, bins = 100, color='darkorange', edgecolor = 'black', range=[0.0,0.25])\nplt.xlabel('Porosity (fraction)'); plt.title('Porosity CDF'); plt.ylabel('Cumulation Probability'); add_grid()\nplt.subplots_adjust(left=0.0, bottom=0.0, right=1.0, top=1.0, wspace=0.1, hspace=0.2); plt.xlim([pormin,pormax]); plt.ylim([0,1])\n#plt.savefig('cdf_Porosity.tif',dpi=600,bbox_inches=\"tight\")\nplt.show() \n```", "```py\npor = df['Porosity'].copy(deep = True).values                 # make a deep copy of the feature from the DataFrame\nprint('The ndarray has a shape of ' + str(por.shape) + '.')\n\npor = np.sort(por)                                            # sort the data in ascending order\nn = por.shape[0]                                              # get the number of data samples\ncprob = np.zeros(n)\nfor i in range(0,n):\n    index = i + 1\n    cprob[i] = index / n                                      # known upper tail\n    # cprob[i] = (index - 1)/n                                # known lower tail\n    # cprob[i] = (index - 1)/(n - 1)                          # known upper and lower tails\n    # cprob[i] = index/(n+1)                                  # unknown tails \n\nplt.subplot(111)\nplt.plot(por,cprob, alpha = 0.8, c = 'black',zorder=1) # plot piecewise linear interpolation\nplt.scatter(por,cprob,s = 20, alpha = 1.0, c = 'darkorange', edgecolor = 'black',zorder=2) # plot the CDF points\nplt.xlim([pormin,pormax]); plt.ylim([0.0,1.0]); add_grid()\nplt.xlabel(\"Porosity (fraction)\"); plt.ylabel(\"Cumulative Probability\"); plt.title(\"Cumulative Distribution Function\")\n\nplt.subplots_adjust(left=0.0, bottom=0.0, right=1.0, top=1.1, wspace=0.1, hspace=0.2); plt.show() \n```", "```py\nThe ndarray has a shape of (261,). \n```", "```py\npermmin = 0.01; permmax = 3000;                # user specified min and max\nAImin = 1000.0; AImax = 8000\nFmin = 0; Fmax = 1\n\nplt.subplot(221)\nGSLIB.hist_st(df['Facies'].values,Fmin,Fmax,log=False,cumul = False,bins=20,weights = None,xlabel='Facies (1-sand, 0-shale)',\n              title='Facies Well Data'); add_grid()\n\nplt.subplot(222)\nGSLIB.hist_st(df['Porosity'].values,pormin,pormax,log=False,cumul = False,bins=20,weights = None,xlabel='Porosity (fraction)',\n              title='Porosity Well Data'); add_grid()\n\nplt.subplot(223)\nGSLIB.hist_st(df['Perm'].values,permmin,permmax,log=False,cumul = False,bins=20,weights = None,xlabel='Permeability (mD)',\n              title='Permeability Well Data'); add_grid()\n\nplt.subplot(224)\nGSLIB.hist_st(df['AI'].values,AImin,AImax,log=False,cumul = False,bins=20,weights = None,xlabel='Acoustic Impedance (kg/m2s*10^6)',\n              title='Acoustic Impedance Well Data'); add_grid()\n\nplt.subplots_adjust(left=0.0, bottom=0.0, right=2.0, top=2.1, wspace=0.1, hspace=0.2)\n#plt.savefig('hist_Porosity_Multiple_bins.tif',dpi=600,bbox_inches=\"tight\")\nplt.show() \n```", "```py\nimport geostatspy.GSLIB as GSLIB          # GSLIB utilities, visualization and wrapper\nimport geostatspy.geostats as geostats    # GSLIB methods convert to Python \n```", "```py\nimport os                                                     # set working directory, run executables\n\nfrom tqdm import tqdm                                         # suppress the status bar\nfrom functools import partialmethod\ntqdm.__init__ = partialmethod(tqdm.__init__, disable=True)\n\nignore_warnings = True                                        # ignore warnings?\nimport numpy as np                                            # ndarrays for gridded data\nimport pandas as pd                                           # DataFrames for tabular data\nimport matplotlib.pyplot as plt                               # for plotting\nfrom matplotlib.ticker import (MultipleLocator, AutoMinorLocator) # control of axes ticks\nfrom scipy import stats                                       # summary statistics\nimport seaborn as sns                                         # advanced plotting\nplt.rc('axes', axisbelow=True)                                # plot all grids below the plot elements\nif ignore_warnings == True:                                   \n    import warnings\n    warnings.filterwarnings('ignore')\nfrom IPython.utils import io                                  # mute output from simulation\ncmap = plt.cm.inferno                                         # color map \n```", "```py\ndef add_grid():\n    plt.gca().grid(True, which='major',linewidth = 1.0); plt.gca().grid(True, which='minor',linewidth = 0.2) # add y grids\n    plt.gca().tick_params(which='major',length=7); plt.gca().tick_params(which='minor', length=4)\n    plt.gca().xaxis.set_minor_locator(AutoMinorLocator()); plt.gca().yaxis.set_minor_locator(AutoMinorLocator()) # turn on minor ticks \n```", "```py\n#os.chdir(\"c:/PGE383\")                                        # set the working directory \n```", "```py\ndf = pd.read_csv('sample_data_cow.csv')                       # load our data table (wrong name!) \n```", "```py\n---------------------------------------------------------------------------\nFileNotFoundError  Traceback (most recent call last)\nCell In[5], line 1\n----> 1 df = pd.read_csv('sample_data_cow.csv')\n\nFile C:\\ProgramData\\anaconda3\\envs\\MachineLearningBook\\lib\\site-packages\\pandas\\io\\parsers\\readers.py:912, in read_csv(filepath_or_buffer, sep, delimiter, header, names, index_col, usecols, dtype, engine, converters, true_values, false_values, skipinitialspace, skiprows, skipfooter, nrows, na_values, keep_default_na, na_filter, verbose, skip_blank_lines, parse_dates, infer_datetime_format, keep_date_col, date_parser, date_format, dayfirst, cache_dates, iterator, chunksize, compression, thousands, decimal, lineterminator, quotechar, quoting, doublequote, escapechar, comment, encoding, encoding_errors, dialect, on_bad_lines, delim_whitespace, low_memory, memory_map, float_precision, storage_options, dtype_backend)\n  899 kwds_defaults = _refine_defaults_read(\n  900     dialect,\n  901     delimiter,\n   (...)\n  908     dtype_backend=dtype_backend,\n  909 )\n  910 kwds.update(kwds_defaults)\n--> 912 return _read(filepath_or_buffer, kwds)\n\nFile C:\\ProgramData\\anaconda3\\envs\\MachineLearningBook\\lib\\site-packages\\pandas\\io\\parsers\\readers.py:577, in _read(filepath_or_buffer, kwds)\n  574 _validate_names(kwds.get(\"names\", None))\n  576 # Create the parser.\n--> 577 parser = TextFileReader(filepath_or_buffer, **kwds)\n  579 if chunksize or iterator:\n  580     return parser\n\nFile C:\\ProgramData\\anaconda3\\envs\\MachineLearningBook\\lib\\site-packages\\pandas\\io\\parsers\\readers.py:1407, in TextFileReader.__init__(self, f, engine, **kwds)\n  1404     self.options[\"has_index_names\"] = kwds[\"has_index_names\"]\n  1406 self.handles: IOHandles | None = None\n-> 1407 self._engine = self._make_engine(f, self.engine)\n\nFile C:\\ProgramData\\anaconda3\\envs\\MachineLearningBook\\lib\\site-packages\\pandas\\io\\parsers\\readers.py:1661, in TextFileReader._make_engine(self, f, engine)\n  1659     if \"b\" not in mode:\n  1660         mode += \"b\"\n-> 1661 self.handles = get_handle(\n  1662     f,\n  1663     mode,\n  1664     encoding=self.options.get(\"encoding\", None),\n  1665     compression=self.options.get(\"compression\", None),\n  1666     memory_map=self.options.get(\"memory_map\", False),\n  1667     is_text=is_text,\n  1668     errors=self.options.get(\"encoding_errors\", \"strict\"),\n  1669     storage_options=self.options.get(\"storage_options\", None),\n  1670 )\n  1671 assert self.handles is not None\n  1672 f = self.handles.handle\n\nFile C:\\ProgramData\\anaconda3\\envs\\MachineLearningBook\\lib\\site-packages\\pandas\\io\\common.py:859, in get_handle(path_or_buf, mode, encoding, compression, memory_map, is_text, errors, storage_options)\n  854 elif isinstance(handle, str):\n  855     # Check whether the filename is to be opened in binary mode.\n  856     # Binary mode does not support 'encoding' and 'newline'.\n  857     if ioargs.encoding and \"b\" not in ioargs.mode:\n  858         # Encoding\n--> 859         handle = open(\n  860             handle,\n  861             ioargs.mode,\n  862             encoding=ioargs.encoding,\n  863             errors=errors,\n  864             newline=\"\",\n  865         )\n  866     else:\n  867         # Binary mode\n  868         handle = open(handle, ioargs.mode)\n\nFileNotFoundError: [Errno 2] No such file or directory: 'sample_data_cow.csv' \n```", "```py\ndf = pd.read_csv('https://raw.githubusercontent.com/GeostatsGuy/GeoDataSets/master/sample_data.csv') # load data from Dr. Pyrcz's github repository \n```", "```py\nprint(df.iloc[0:5,:])                                         # display first 4 samples in the table as a preview\ndf.head(n=13)                                                 # we could also use this command for a table preview \n```", "```py\n X      Y  Facies  Porosity       Perm           AI\n0  100.0  900.0     1.0  0.100187   1.363890  5110.699751\n1  100.0  800.0     0.0  0.107947  12.576845  4671.458560\n2  100.0  700.0     0.0  0.085357   5.984520  6127.548006\n3  100.0  600.0     0.0  0.108460   2.446678  5201.637996\n4  100.0  500.0     0.0  0.102468   1.952264  3835.270322 \n```", "```py\ndf.describe()                                                 # summary statistics \n```", "```py\ndf['Porosity']                       # returns an Pandas series\ndf['Porosity'].values                # returns an ndarray \n```", "```py\nprint('The minimum is ' + str(round((df['Porosity'].values).min(),2)) + '.') # print univariate statistics\nprint('The maximum is ' + str(round((df['Porosity'].values).max(),2)) + '.')\nprint('The mean is ' + str(round((df['Porosity'].values).mean(),2)) + '.')\nprint('The standard deviation is ' + str(round((df['Porosity'].values).std(),2)) + '.') \n```", "```py\nThe minimum is 0.06.\nThe maximum is 0.24.\nThe mean is 0.15.\nThe standard deviation is 0.05. \n```", "```py\nprint('The minimum is ' + str(round(np.amin(df['Porosity'].values),2))) # print univariate statistics\nprint('The maximum is ' + str(round(np.amax(df['Porosity'].values),2)))\nprint('The range (maximum - minimum) is ' + str(round(np.ptp(df['Porosity'].values),2)))\nprint('The P10 is ' + str(round(np.percentile(df['Porosity'].values,10),3)))\nprint('The P50 is ' + str(round(np.percentile(df['Porosity'].values,50),3)))\nprint('The P90 is ' + str(round(np.percentile(df['Porosity'].values,90),3)))\nprint('The P13 is ' + str(round(np.percentile(df['Porosity'].values,13),3)))\nprint('The median (P50) is ' + str(round(np.median(df['Porosity'].values),3)))\nprint('The mean is ' + str(round(np.mean(df['Porosity'].values),3))) \n```", "```py\nThe minimum is 0.06\nThe maximum is 0.24\nThe range (maximum - minimum) is 0.18\nThe P10 is 0.092\nThe P50 is 0.137\nThe P90 is 0.212\nThe P13 is 0.095\nThe median (P50) is 0.137\nThe mean is 0.15 \n```", "```py\nvalue = 0.10                                                  # calculate cumulative distribution function for a specified value\ncumul_prob = np.count_nonzero(df['Porosity'].values <= value)/len(df)\nprint('The cumulative probability for porosity = ' + str(value) + ' is ' + str(round(cumul_prob,2))) \n```", "```py\nThe cumulative probability for porosity = 0.1 is 0.18 \n```", "```py\nnd = len(df)                                                  # get the number of data values\nwts = np.ones(nd)                                             # make an array of nd length of 1's\nprint('The equal weighted average is ' + str(round(np.average(df['Porosity'].values,weights = wts),3)) + ', the same as the mean above.') \n```", "```py\nThe equal weighted average is 0.15, the same as the mean above. \n```", "```py\nporosity = df['Porosity'].values     \nwts[porosity > 0.13] *= 0.1                                   # make arbitrary weights for demonstration\nprint('The equal weighted average is ' + str(round(np.average(df['Porosity'].values,weights = wts),3)) + ', lower than the equal weighted average above.') \n```", "```py\nThe equal weighted average is 0.112, lower than the equal weighted average above. \n```", "```py\nprint(stats.describe(df['Porosity'].values))                  # summary statistics\npor_stats = stats.describe(df['Porosity'].values)             # store as an array\nprint('Porosity kurtosis is ' + str(round(por_stats[5],2)))   # extract a statistic \n```", "```py\nDescribeResult(nobs=261, minmax=(0.0588710426408954, 0.2422978845362023), mean=0.15035706160196555, variance=0.0024783238419715933, skewness=0.08071652694567066, kurtosis=-1.5618166076333853)\nPorosity kurtosis is -1.56 \n```", "```py\nGSLIB.hist \n```", "```py\n<function geostatspy.GSLIB.hist(array, xmin, xmax, log, cumul, bins, weights, xlabel, title, fig_name)> \n```", "```py\npormin = 0.05; pormax = 0.25                                  # minimum and maximum feature values\nGSLIB.hist_st(df['Porosity'].values,pormin,pormax,log=False,cumul = False,bins=10,weights = None,\n           xlabel='Porosity (fraction)',title='Porosity Well Data')\nadd_grid()\nplt.subplots_adjust(left=0.0, bottom=0.0, right=1.0, top=1.1, wspace=0.1, hspace=0.2); plt.show() \n```", "```py\nnbin_list = [3,20,100]                                             # number of bins for each histogram\n\nfor i,nbin in enumerate(nbin_list):\n    plt.subplot(1,3,i+1)\n    GSLIB.hist_st(df['Porosity'].values,pormin,pormax,log=False,cumul = False,bins=nbin,weights = None,\n                  xlabel='Porosity (fraction)',title='Histogram with ' + str(nbin) + ' Bins'); add_grid()\n\nplt.subplots_adjust(left=0.0, bottom=0.0, right=3.0, top=1.1, wspace=0.2, hspace=0.2); plt.show() \n```", "```py\nplt.hist(df['Porosity'].values,alpha=0.8,color=\"darkorange\",edgecolor=\"black\",bins=20,range=[pormin,pormax])\nplt.title('Histogram'); plt.xlabel('Porosity (fraction)'); plt.ylabel(\"Frequency\"); add_grid()\nplt.subplots_adjust(left=0.0, bottom=0.0, right=1.0, top=1.1, wspace=0.1, hspace=0.2); plt.show() \n```", "```py\nweights = np.ones(len(df)) / len(df)\nplt.hist(df['Porosity'].values,alpha=0.8,color=\"darkorange\",edgecolor=\"black\",bins=25,range=[pormin,pormax],weights=weights)\nplt.title('Normalized Histogram'); plt.xlabel('Porosity (fraction)'); plt.ylabel(\"Probability\"); add_grid()\nplt.subplots_adjust(left=0.0, bottom=0.0, right=1.0, top=1.1, wspace=0.1, hspace=0.2); plt.show() \n```", "```py\nnums=[2,4,10,20,50,200]\n\nfor i, num in enumerate(nums):\n    plt.subplot(2,3,i+1)\n    sns.kdeplot(x=df['Porosity'].values[:num],color = 'black',alpha = 1.0,linewidth=3,bw_method=0.1,fill=False,zorder=10)\n    sns.kdeplot(x=df['Porosity'].values[:num],color = 'darkorange',alpha = 1.0,linewidth=3,bw_method=0.1,fill=True,zorder=1)\n    plt.xlim([0,0.30]); add_grid()\n    plt.title('KDE PDF for First ' + str(num) + ' Data'); plt.xlabel('Porosity (fraction)'); plt.ylabel(\"Density\")\nplt.subplots_adjust(left=0.0, bottom=0.0, right=3.0, top=2.1, wspace=0.1, hspace=0.2); plt.show() \n```", "```py\nplt.hist(df['Porosity'].values,alpha=0.7,color=\"darkorange\",edgecolor=\"black\",bins=25,range=[pormin,pormax],density=True,\n         label = 'Normalized Histogram')\nsns.kdeplot(x=df['Porosity'].values,color = 'black',alpha = 0.8,linewidth=4.0,bw_method=0.10,label = 'PDF')\nplt.title('Histogram and Kernel Density Estimated PDF'); plt.xlabel('Porosity (fraction)'); plt.ylabel(\"Density\")\nplt.legend(loc='upper left'); add_grid()\nplt.subplots_adjust(left=0.0, bottom=0.0, right=1.0, top=1.0, wspace=0.1, hspace=0.2); plt.show() \n```", "```py\nfor i, bw in enumerate([0.01,0.05,0.1,0.3]):\n    plt.subplot(2,2,i+1)\n    print(r'Band Width = ' + str(bw) + r', bandwidth x standard deviation = ' + str(bw*np.std(df['Porosity'])) )\n    plt.hist(df['Porosity'].values,alpha=0.7,color=\"darkorange\",edgecolor=\"black\",bins=25,range=[pormin,pormax],density=True)\n    sns.kdeplot(x=df['Porosity'].values,color = 'black',alpha = 0.8,linewidth=4.0,bw_method=bw)\n    plt.xlim([0.0,0.3])\n    plt.title('Histogram and Kernel Density Estimated PDF, BW = ' + str(bw)); plt.xlabel('Porosity (fraction)'); plt.ylabel(\"Density\")\n\nplt.subplots_adjust(left=0.0, bottom=0.0, right=2.0, top=2.1, wspace=0.1, hspace=0.2); plt.show() \n```", "```py\nBand Width = 0.01, bandwidth x standard deviation = 0.0004968730570602708\nBand Width = 0.05, bandwidth x standard deviation = 0.0024843652853013543\nBand Width = 0.1, bandwidth x standard deviation = 0.0049687305706027085\nBand Width = 0.3, bandwidth x standard deviation = 0.014906191711808122 \n```", "```py\nGSLIB.hist_st(df['Porosity'].values,pormin,pormax,log=False,cumul = True,bins=1000,weights = None, # CDF with GeostatsPy\n           xlabel='Porosity (fraction)',title='Cumulative Distribution Function with Cumulative Histogram'); add_grid()\nplt.subplots_adjust(left=0.0, bottom=0.0, right=1.0, top=1.1, wspace=0.1, hspace=0.2); plt.show() \n```", "```py\nplt.hist(df['Porosity'].values,density=True, cumulative=True, label='CDF',\n           histtype='stepfilled', alpha=0.8, bins = 100, color='darkorange', edgecolor = 'black', range=[0.0,0.25])\nplt.xlabel('Porosity (fraction)'); plt.title('Porosity CDF'); plt.ylabel('Cumulation Probability'); add_grid()\nplt.subplots_adjust(left=0.0, bottom=0.0, right=1.0, top=1.0, wspace=0.1, hspace=0.2); plt.xlim([pormin,pormax]); plt.ylim([0,1])\n#plt.savefig('cdf_Porosity.tif',dpi=600,bbox_inches=\"tight\")\nplt.show() \n```", "```py\npor = df['Porosity'].copy(deep = True).values                 # make a deep copy of the feature from the DataFrame\nprint('The ndarray has a shape of ' + str(por.shape) + '.')\n\npor = np.sort(por)                                            # sort the data in ascending order\nn = por.shape[0]                                              # get the number of data samples\ncprob = np.zeros(n)\nfor i in range(0,n):\n    index = i + 1\n    cprob[i] = index / n                                      # known upper tail\n    # cprob[i] = (index - 1)/n                                # known lower tail\n    # cprob[i] = (index - 1)/(n - 1)                          # known upper and lower tails\n    # cprob[i] = index/(n+1)                                  # unknown tails \n\nplt.subplot(111)\nplt.plot(por,cprob, alpha = 0.8, c = 'black',zorder=1) # plot piecewise linear interpolation\nplt.scatter(por,cprob,s = 20, alpha = 1.0, c = 'darkorange', edgecolor = 'black',zorder=2) # plot the CDF points\nplt.xlim([pormin,pormax]); plt.ylim([0.0,1.0]); add_grid()\nplt.xlabel(\"Porosity (fraction)\"); plt.ylabel(\"Cumulative Probability\"); plt.title(\"Cumulative Distribution Function\")\n\nplt.subplots_adjust(left=0.0, bottom=0.0, right=1.0, top=1.1, wspace=0.1, hspace=0.2); plt.show() \n```", "```py\nThe ndarray has a shape of (261,). \n```", "```py\npermmin = 0.01; permmax = 3000;                # user specified min and max\nAImin = 1000.0; AImax = 8000\nFmin = 0; Fmax = 1\n\nplt.subplot(221)\nGSLIB.hist_st(df['Facies'].values,Fmin,Fmax,log=False,cumul = False,bins=20,weights = None,xlabel='Facies (1-sand, 0-shale)',\n              title='Facies Well Data'); add_grid()\n\nplt.subplot(222)\nGSLIB.hist_st(df['Porosity'].values,pormin,pormax,log=False,cumul = False,bins=20,weights = None,xlabel='Porosity (fraction)',\n              title='Porosity Well Data'); add_grid()\n\nplt.subplot(223)\nGSLIB.hist_st(df['Perm'].values,permmin,permmax,log=False,cumul = False,bins=20,weights = None,xlabel='Permeability (mD)',\n              title='Permeability Well Data'); add_grid()\n\nplt.subplot(224)\nGSLIB.hist_st(df['AI'].values,AImin,AImax,log=False,cumul = False,bins=20,weights = None,xlabel='Acoustic Impedance (kg/m2s*10^6)',\n              title='Acoustic Impedance Well Data'); add_grid()\n\nplt.subplots_adjust(left=0.0, bottom=0.0, right=2.0, top=2.1, wspace=0.1, hspace=0.2)\n#plt.savefig('hist_Porosity_Multiple_bins.tif',dpi=600,bbox_inches=\"tight\")\nplt.show() \n```"]