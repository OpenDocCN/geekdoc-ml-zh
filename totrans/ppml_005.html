<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.1//EN"
  "http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd">

<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<title>Variables</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1>Variables</h1>
<blockquote>原文：<a href="https://rust-exercises.com/100-exercises/02_basic_calculator/02_variables.html">https://rust-exercises.com/100-exercises/02_basic_calculator/02_variables.html</a></blockquote>
                        
<p>In Rust, you can use the <code>let</code> keyword to declare <strong>variables</strong>.<br/>
For example:</p>
<pre><code class="language-rust">let x = 42;</code></pre>
<p>Above we defined a variable <code>x</code> and assigned it the value <code>42</code>.</p>
<h2 id="type"><a class="header" href="#type">Type</a></h2>
<p>Every variable in Rust must have a type. It can either be inferred by the compiler or explicitly specified by the
developer.</p>
<h3 id="explicit-type-annotation"><a class="header" href="#explicit-type-annotation">Explicit type annotation</a></h3>
<p>You can specify the variable type by adding a colon <code>:</code> followed by the type after the variable name. For example:</p>
<pre><code class="language-rust">// let &lt;variable_name&gt;: &lt;type&gt; = &lt;expression&gt;;
let x: u32 = 42;</code></pre>
<p>In the example above, we explicitly constrained the type of <code>x</code> to be <code>u32</code>.</p>
<h3 id="type-inference"><a class="header" href="#type-inference">Type inference</a></h3>
<p>If we don't specify the type of a variable, the compiler will try to infer it based on the context in which the variable
is used.</p>
<pre><code class="language-rust">let x = 42;
let y: u32 = x;</code></pre>
<p>In the example above, we didn't specify the type of <code>x</code>.<br/>
<code>x</code> is later assigned to <code>y</code>, which is explicitly typed as <code>u32</code>. Since Rust doesn't perform automatic type coercion,
the compiler infers the type of <code>x</code> to be <code>u32</code>—the same as <code>y</code> and the only type that will allow the program to compile
without errors.</p>
<h3 id="inference-limitations"><a class="header" href="#inference-limitations">Inference limitations</a></h3>
<p>The compiler sometimes needs a little help to infer the correct variable type based on its usage.<br/>
In those cases you'll get a compilation error and the compiler will ask you to provide an explicit type hint to
disambiguate the situation.</p>
<h2 id="function-arguments-are-variables"><a class="header" href="#function-arguments-are-variables">Function arguments are variables</a></h2>
<p>Not all heroes wear capes, not all variables are declared with <code>let</code>.<br/>
Function arguments are variables too!</p>
<pre><code class="language-rust">fn add_one(x: u32) -&gt; u32 {
    x + 1
}</code></pre>
<p>In the example above, <code>x</code> is a variable of type <code>u32</code>.<br/>
The only difference between <code>x</code> and a variable declared with <code>let</code> is that functions arguments <strong>must</strong> have their type
explicitly declared. The compiler won't infer it for you.<br/>
This constraint allows the Rust compiler (and us humans!) to understand the function's signature without having to look
at its implementation. That's a big boost for compilation speed<sup class="footnote-reference" id="fr-speed-1"><a href="#footnote-speed">1</a></sup>!</p>
<h2 id="initialization"><a class="header" href="#initialization">Initialization</a></h2>
<p>You don't have to initialize a variable when you declare it.<br/>
For example</p>
<pre><code class="language-rust">let x: u32;</code></pre>
<p>is a valid variable declaration.<br/>
However, you must initialize the variable before using it. The compiler will throw an error if you don't:</p>
<pre><code class="language-rust">let x: u32;
let y = x + 1;</code></pre>
<p>will throw a compilation error:</p>
<pre><code class="language-text">error[E0381]: used binding `x` isn't initialized
 --&gt; src/main.rs:3:9
  |
2 | let x: u32;
  |     - binding declared here but left uninitialized
3 | let y = x + 1;
  |         ^ `x` used here but it isn't initialized
  |
help: consider assigning a value
  |
2 | let x: u32 = 0;
  |            +++
</code></pre>
<h2 id="exercise"><a class="header" href="#exercise">Exercise</a></h2>
<p>The exercise for this section is located in <a href="https://github.com/mainmatter/100-exercises-to-learn-rust/tree/main/exercises/02_basic_calculator/02_variables"><code>02_basic_calculator/02_variables</code></a></p>
<hr/>
<ol class="footnote-definition"><li id="footnote-speed">
<p>The Rust compiler needs all the help it can get when it comes to compilation speed. <a href="#fr-speed-1">↩</a></p>
</li>
</ol>
                        
</body>
</html>