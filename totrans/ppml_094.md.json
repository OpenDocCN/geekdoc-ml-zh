["```py\npub fn spawn<F>(future: F) -> JoinHandle<F::Output>\n    where\n        F: Future + Send + 'static,\n        F::Output: Send + 'static,\n{ /* */ }\n```", "```py\nuse std::rc::Rc;\nuse tokio::task::yield_now;\n\nfn spawner() {\n    tokio::spawn(example());\n}\n\nasync fn example() {\n    // A value that's not `Send`,\n    // created _inside_ the async function\n    let non_send = Rc::new(1);\n\n    // A `.await` point that does nothing\n    yield_now().await;\n\n    // The local non-`Send` value is still needed\n    // after the `.await`\n    println!(\"{}\", non_send);\n}\n```", "```py\nerror: future cannot be sent between threads safely\n    |\n5   |     tokio::spawn(example());\n    |                  ^^^^^^^^^ \n    | future returned by `example` is not `Send`\n    |\nnote: future is not `Send` as this value is used across an await\n    |\n11  |     let non_send = Rc::new(1);\n    |         -------- has type `Rc<i32>` which is not `Send`\n12  |     // A `.await` point\n13  |     yield_now().await;\n    |                 ^^^^^ \n    |   await occurs here, with `non_send` maybe used later\nnote: required by a bound in `tokio::spawn`\n    |\n164 |     pub fn spawn<F>(future: F) -> JoinHandle<F::Output>\n    |            ----- required by a bound in this function\n165 |     where\n166 |         F: Future + Send + 'static,\n    |                     ^^^^ required by this bound in `spawn` \n```", "```py\ntrait Future {\n    type Output;\n\n    // Ignore `Pin` and `Context` for now\n    fn poll(\n      self: Pin<&mut Self>, \n      cx: &mut Context<'_>\n    ) -> Poll<Self::Output>;\n}\n```", "```py\nuse std::rc::Rc;\nuse tokio::task::yield_now;\n\nasync fn example() {\n    let non_send = Rc::new(1);\n    yield_now().await;\n    println!(\"{}\", non_send);\n}\n```", "```py\npub enum ExampleFuture {\n    NotStarted,\n    YieldNow(Rc<i32>),\n    Terminated,\n}\n```"]