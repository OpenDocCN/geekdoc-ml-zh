- en: Destructors
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 原文：[https://rust-exercises.com/100-exercises/03_ticket_v1/11_destructor.html](https://rust-exercises.com/100-exercises/03_ticket_v1/11_destructor.html)
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: When introducing the heap, we mentioned that you're responsible for freeing
    the memory you allocate.
  prefs: []
  type: TYPE_NORMAL
- en: When introducing the borrow-checker, we also stated that you rarely have to
    manage memory directly in Rust.
  prefs: []
  type: TYPE_NORMAL
- en: These two statements might seem contradictory at first. Let's see how they fit
    together by introducing **scopes** and **destructors**.
  prefs: []
  type: TYPE_NORMAL
- en: '[Scopes](#scopes)'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The **scope** of a variable is the region of Rust code where that variable is
    valid, or **alive**.
  prefs: []
  type: TYPE_NORMAL
- en: 'The scope of a variable starts with its declaration. It ends when one of the
    following happens:'
  prefs: []
  type: TYPE_NORMAL
- en: the block (i.e. the code between `{}`) where the variable was declared ends
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: ownership of the variable is transferred to someone else (e.g. a function or
    another variable)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[Destructors](#destructors-1)'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: When the owner of a value goes out of scope, Rust invokes its **destructor**.
  prefs: []
  type: TYPE_NORMAL
- en: The destructor tries to clean up the resources used by that value—in particular,
    whatever memory it allocated.
  prefs: []
  type: TYPE_NORMAL
- en: You can manually invoke the destructor of a value by passing it to `std::mem::drop`.
  prefs: []
  type: TYPE_NORMAL
- en: That's why you'll often hear Rust developers saying "that value has been **dropped**"
    as a way to state that a value has gone out of scope and its destructor has been
    invoked.
  prefs: []
  type: TYPE_NORMAL
- en: '[Visualizing drop points](#visualizing-drop-points)'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'We can insert explicit calls to `drop` to "spell out" what the compiler does
    for us. Going back to the previous example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'It''s equivalent to:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s look at the second example instead, where `s`''s ownership is transferred
    to `compute`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'It''s equivalent to this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'Notice the difference: even though `s` is no longer valid after `compute` is
    called in `main`, there is no `drop(s)` in `main`. When you transfer ownership
    of a value to a function, you''re also **transferring the responsibility of cleaning
    it up**.'
  prefs: []
  type: TYPE_NORMAL
- en: This ensures that the destructor for a value is called **at most^([1](#footnote-leak))
    once**, preventing [double free bugs](https://owasp.org/www-community/vulnerabilities/Doubly_freeing_memory)
    by design.
  prefs: []
  type: TYPE_NORMAL
- en: '[Use after drop](#use-after-drop)'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: What happens if you try to use a value after it's been dropped?
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'If you try to compile this code, you''ll get an error:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: Drop **consumes** the value it's called on, meaning that the value is no longer
    valid after the call.
  prefs: []
  type: TYPE_NORMAL
- en: The compiler will therefore prevent you from using it, avoiding [use-after-free
    bugs](https://owasp.org/www-community/vulnerabilities/Using_freed_memory).
  prefs: []
  type: TYPE_NORMAL
- en: '[Dropping references](#dropping-references)'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: What if a variable contains a reference?
  prefs: []
  type: TYPE_NORMAL
- en: 'For example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: When you call `drop(y)`... nothing happens.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you actually try to compile this code, you''ll get a warning:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'It goes back to what we said earlier: we only want to call the destructor once.'
  prefs: []
  type: TYPE_NORMAL
- en: 'You can have multiple references to the same value—if we called the destructor
    for the value they point at when one of them goes out of scope, what would happen
    to the others? They would refer to a memory location that''s no longer valid:
    a so-called [**dangling pointer**](https://en.wikipedia.org/wiki/Dangling_pointer),
    a close relative of [**use-after-free bugs**](https://owasp.org/www-community/vulnerabilities/Using_freed_memory).
    Rust''s ownership system rules out these kinds of bugs by design.'
  prefs: []
  type: TYPE_NORMAL
- en: '[Exercise](#exercise)'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The exercise for this section is located in [`03_ticket_v1/11_destructor`](https://github.com/mainmatter/100-exercises-to-learn-rust/tree/main/exercises/03_ticket_v1/11_destructor)
  prefs: []
  type: TYPE_NORMAL
- en: '* * *'
  prefs: []
  type: TYPE_NORMAL
- en: Rust doesn't guarantee that destructors will run. They won't, for example, if
    you explicitly choose to [leak memory](/100-exercises/07_threads/03_leak). [↩](#fr-leak-1)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
