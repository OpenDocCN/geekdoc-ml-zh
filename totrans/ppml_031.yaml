- en: Derive macros
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 原文：[https://rust-exercises.com/100-exercises/04_traits/04_derive.html](https://rust-exercises.com/100-exercises/04_traits/04_derive.html)
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Implementing `PartialEq` for `Ticket` was a bit tedious, wasn't it? You had
    to manually compare each field of the struct.
  prefs: []
  type: TYPE_NORMAL
- en: '[Destructuring syntax](#destructuring-syntax)'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Furthermore, the implementation is brittle: if the struct definition changes
    (e.g. a new field is added), you have to remember to update the `PartialEq` implementation.'
  prefs: []
  type: TYPE_NORMAL
- en: 'You can mitigate the risk by **destructuring** the struct into its fields:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: If the definition of `Ticket` changes, the compiler will error out, complaining
    that your destructuring is no longer exhaustive.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can also rename struct fields, to avoid variable shadowing:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Destructuring is a useful pattern to have in your toolkit, but there''s an
    even more convenient way to do this: **derive macros**.'
  prefs: []
  type: TYPE_NORMAL
- en: '[Macros](#macros)'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'You''ve already encountered a few macros in past exercises:'
  prefs: []
  type: TYPE_NORMAL
- en: '`assert_eq!` and `assert!`, in the test cases'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`println!`, to print to the console'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Rust macros are **code generators**.
  prefs: []
  type: TYPE_NORMAL
- en: They generate new Rust code based on the input you provide, and that generated
    code is then compiled alongside the rest of your program. Some macros are built
    into Rust's standard library, but you can also write your own. We won't be creating
    our own macro in this course, but you can find some useful pointers in the ["Further
    reading" section](#further-reading).
  prefs: []
  type: TYPE_NORMAL
- en: '[Inspection](#inspection)'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Some IDEs let you expand a macro to inspect the generated code. If that's not
    possible, you can use [`cargo-expand`](https://github.com/dtolnay/cargo-expand).
  prefs: []
  type: TYPE_NORMAL
- en: '[Derive macros](#derive-macros-1)'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: A **derive macro** is a particular flavour of Rust macro. It is specified as
    an **attribute** on top of a struct.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Derive macros are used to automate the implementation of common (and "obvious")
    traits for custom types. In the example above, the `PartialEq` trait is automatically
    implemented for `Ticket`. If you expand the macro, you''ll see that the generated
    code is functionally equivalent to the one you wrote manually, although a bit
    more cumbersome to read:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: The compiler will nudge you to derive traits when possible.
  prefs: []
  type: TYPE_NORMAL
- en: '[Further reading](#further-reading)'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '[The little book of Rust macros](https://veykril.github.io/tlborm/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Proc macro workshop](https://github.com/dtolnay/proc-macro-workshop)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Exercise](#exercise)'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The exercise for this section is located in [`04_traits/04_derive`](https://github.com/mainmatter/100-exercises-to-learn-rust/tree/main/exercises/04_traits/04_derive)
  prefs: []
  type: TYPE_NORMAL
