["```py\nf<-function(x,mu1,mu2,S1i,S2i,p1=0.5) {\n #mixture of normals, density up to constant factor\n c1<-exp(-t(x-mu1)%*%S1i%*%(x-mu1))\n c2<-exp(-t(x-mu2)%*%S2i%*%(x-mu2))\n return(p1*c1+(1-p1)*c2)\n}\n\na=3\nn=2000\nmu1=c(1,1)\nmu2=c(4,4)\nS=diag(2)\nS1i=S2i=solve(S)\nX=matrix(NA,2,n)\nX[,1]=x=mu1\nfor (t in 1:(n-1)) {\ny<-x+(2*runif(2)-1)*a\nMHR<-f(y,mu1,mu2,S1i,S2i)/f(x,mu1,mu2,S1i,S2i)\nif (runif(1)<MHR)\nx<-y\nX[,t+1]<-x\n}\n```", "```py\ndmix2norm =  function(x, mu, Sigma, pi, log = FALSE) {\n\n Omega1 =  MASS::ginv(Sigma[1:2, 1:2])\n Omega2 =  MASS::ginv(Sigma[3:4, 3:4])\n\n elem1 =  exp(-t(x -  mu[1]) %*%  Omega1 %*%  (x -  mu[1]))\n elem2 =  exp(-t(x -  mu[2]) %*%  Omega2 %*%  (x -  mu[2]))\n\n return(pi[1] *  elem1 +  pi[2] *  elem2)\n\n}#DMIX2NORM\n\nmetropolis.hastings =  function(mu, Sigma, pi, iter) {\n\n X =  matrix(NA, 2, iter)\n X[, 1] =  old =  mu[1:2]\n for (t in seq(iter -  1)) {\n\n new =  old +  (2 *  runif(2) -  1) *  a\n acceptance.probability =\n dmix2norm(new, mu = mu, Sigma = Sigma, pi = pi) /\n dmix2norm(old, mu = mu, Sigma = Sigma, pi = pi)\n\n if (runif(1) <  acceptance.probability)\n old =  new\n else\n old =  old\n\n X[, t +  1] =  old\n\n }#FOR\n\n return(X)\n\n}#METROPOLIS.HASTINGS\n\nmu =  c(c(1, 1), c(4, 4))\nSigma =  diag(rep(1, 4))\npi =  c(0.5, 0.5)\nmetropolis.hastings(mu = mu, Sigma = Sigma, pi = pi, iter = 2000)\n```", "```py\ndmix2norm =  function(x, mu, Sigma, pi, log = FALSE) {\n\n nmix =  length(mu)\n mixture.component.density =  function(x, mu, Sigma)\n exp(-t(x -  mu[1]) %*%  MASS::ginv(Sigma) %*%  (x -  mu[1]))\n\n comp =  sapply(seq(nmix), function(i)\n mixture.component.density(x, mu[[i]], Sigma[[i]]))\n\n return(sum(pi *  comp))\n\n}#DMIX2NORM\n\nproposal.update =  function(dim = 2, a) {\n\n return((2 *  runif(dim) -  1) *  a)\n\n}#PROPOSAL.UPDATE\n\nmetropolis.hastings =  function(density, density.args, proposal,\n proposal.args, pi, start, iter) {\n\n X =  matrix(NA, length(start), iter)\n X[, 1] =  old =  start\n for (t in seq(iter -  1)) {\n\n new =  old +\n do.call(proposal, c(list(dim = nrow(X)), proposal.args))\n\n update.threshold =\n do.call(density, c(list(x = new, pi = pi), density.args)) /\n do.call(density, c(list(x = old, pi = pi), density.args))\n\n if (runif(1) <  update.threshold)\n old =  new\n else\n old =  old\n\n X[, t +  1] =  old\n\n }#FOR\n\n return(X)\n\n}#METROPOLIS.HASTINGS\n\nmu =  list(c(1, 1), c(4, 4))\nSigma =  list(diag(2), diag(2))\nmetropolis.hastings(density = dmix2norm,\n density.args = list(mu = mu, Sigma = Sigma),\n proposal = proposal.update, proposal.args = list(a = 3),\n pi = c(0.5, 0.5), start = c(2, 2), iter = 2000)\n```", "```py\nmetropolis.hastings =  function(density, density.args, proposal,\n proposal.args, pi, start, iter) {\n\n [...]\n\n return(structure(list(values = X, call = match.call(),\n density = density, density.args = density.args,\n proposal = proposal, proposal.args = proposal.args,\n start = start), class = \"metropolis.hastings\"))\n\n}#METROPOLIS.HASTINGS\n```", "```py\nRefactoring Metropolis-Hastings mixture of Gaussians.\n\n* Clarify function and variable names, following Bayesian Essentials\n    with R (Marin and Robert, 2014).\n* Switch to a functional implementation that takes arbitrary density\n    functions as arguments, each with separate optional arguments.\n* Store the simulation in an S3 object, to allow for methods.\n```", "```py\n if (missing(density))\n stop(\"missing a 'density' a function, with no default.\")\n if (!is.function(density))\n stop(\"the 'density' argument must be a density function.\")\n```", "```py\nerror =  try(metropolis.hastings(density = dmix2norm, [...])\nstopifnot(!is(error, \"try-error\"))\nerror = try(metropolis.hastings(density = \"not.a.function\", [...])\nstopifnot(is(error, \"try-error\"))\n```", "```py\n if (missing(proposal.args))\n proposal.args =  list()\n if (!is.list(proposal.args))\n stop(\"the 'proposal.args' argument must be a list.\")\n```", "```py\n try.proposal =  try(do.call(proposal, proposal.args))\n if (is(try.proposal, \"try-error\"))\n stop(\"the 'proposal' function fails to run with \",\n \"the arguments in 'proposal.args'.\")\n if (!is.numeric(try.proposal) ||\n (length(try.proposal) !=  length(start)))\n stop(\"the 'proposal' function returns invalid samples.\")\n```", "```py\n if (missing(iter))\n iter =  10\n if (!is.numeric(iter) ||  ((x %/%  1) ==  x))\n stop(\"the 'iter' argument must be a non-negative integer.\")\n```", "```py\nerror =  try(metropolis.hastings([...], iter = 0)\nstopifnot(!is(error, \"try-error\"))\nerror = try(metropolis.hastings([...], iter = 10)\nstopifnot(!is(error, \"try-error\"))\nerror = try(metropolis.hastings([...], iter = Inf)\nstopifnot(is(error, \"try-error\"))\nerror = try(metropolis.hastings([...], iter = NaN)\nstopifnot(is(error, \"try-error\"))\n```"]