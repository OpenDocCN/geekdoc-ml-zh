["```py\nlet mut numbers = Vec::with_capacity(3);\nnumbers.push(1);\nnumbers.push(2);\n```", "```py\n +---------+--------+----------+\nStack | pointer | length | capacity | \n      |  |      |   2    |    3     |\n      +--|------+--------+----------+\n         |\n         |\n         v\n       +---+---+---+\nHeap:  | 1 | 2 | ? |\n       +---+---+---+ \n```", "```py\nlet numbers = vec![1, 2, 3];\n// Via index syntax\nlet slice: &[i32] = &numbers[..];\n// Via a method\nlet slice: &[i32] = numbers.as_slice();\n// Or for a subset of the elements\nlet slice: &[i32] = &numbers[1..];\n```", "```py\nlet numbers = vec![1, 2, 3];\n// Surprise, surprise: `iter` is not a method on `Vec`!\n// It's a method on `&[T]`, but you can call it on a `Vec` \n// thanks to deref coercion.\nlet sum: i32 = numbers.iter().sum();\n```", "```py\nlet numbers = vec![1, 2, 3];\n```", "```py\nlet slice: &[i32] = &numbers[1..];\n```", "```py\n numbers                          slice\n      +---------+--------+----------+      +---------+--------+\nStack | pointer | length | capacity |      | pointer | length |\n      |    |    |   3    |    4     |      |    |    |   2    |\n      +----|----+--------+----------+      +----|----+--------+\n           |                                    |  \n           |                                    |\n           v                                    | \n         +---+---+---+---+                      |\nHeap:    | 1 | 2 | 3 | ? |                      |\n         +---+---+---+---+                      |\n               ^                                |\n               |                                |\n               +--------------------------------+ \n```", "```py\nlet array = [1, 2, 3];\nlet slice: &[i32] = &array;\n```"]