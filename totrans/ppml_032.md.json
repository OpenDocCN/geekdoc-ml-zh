["```py\nfn is_even_i32(n: i32) -> bool {\n    n % 2 == 0\n}\n\nfn is_even_i64(n: i64) -> bool {\n    n % 2 == 0\n}\n\n// Etc.\n```", "```py\ntrait IsEven {\n    fn is_even(&self) -> bool;\n}\n\nimpl IsEven for i32 {\n    fn is_even(&self) -> bool {\n        self % 2 == 0\n    }\n}\n\nimpl IsEven for i64 {\n    fn is_even(&self) -> bool {\n        self % 2 == 0\n    }\n}\n\n// Etc.\n```", "```py\nfn print_if_even<T>(n: T)\nwhere\n    T: IsEven + Debug\n{\n    if n.is_even() {\n        println!(\"{n:?} is even\");\n    }\n}\n```", "```py\nfn print_if_even<T>(n: T) {\n    if n.is_even() {\n        println!(\"{n:?} is even\");\n    }\n}\n```", "```py\nerror[E0599]: no method named `is_even` found for type parameter `T` \n              in the current scope\n --> src/lib.rs:2:10\n  |\n1 | fn print_if_even<T>(n: T) {\n  |                  - method `is_even` not found \n  |                    for this type parameter\n2 |     if n.is_even() {\n  |          ^^^^^^^ method not found in `T`\n\nerror[E0277]: `T` doesn't implement `Debug`\n --> src/lib.rs:3:19\n  |\n3 |         println!(\"{n:?} is even\");\n  |                   ^^^^^ \n  |   `T` cannot be formatted using `{:?}` because \n  |         it doesn't implement `Debug`\n  |\nhelp: consider restricting type parameter `T`\n  |\n1 | fn print_if_even<T: std::fmt::Debug>(n: T) {\n  |                   +++++++++++++++++ \n```", "```py\nfn print_if_even<T>(n: T)\nwhere\n    T: IsEven + Debug\n//  ^^^^^^^^^^^^^^^^^\n//  This is a `where` clause\n{\n    // [...]\n}\n```", "```py\nfn print_if_even<T: IsEven + Debug>(n: T) {\n    //           ^^^^^^^^^^^^^^^^^\n    //           This is an inline trait bound\n    // [...]\n}\n```", "```py\nfn print_if_even<Number: IsEven + Debug>(n: Number) {\n    // [...]\n}\n```"]