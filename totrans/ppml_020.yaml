- en: Ownership
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 原文：[https://rust-exercises.com/100-exercises/03_ticket_v1/06_ownership.html](https://rust-exercises.com/100-exercises/03_ticket_v1/06_ownership.html)
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'If you solved the previous exercise using what this course has taught you so
    far, your accessor methods probably look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Those methods compile and are enough to get tests to pass, but in a real-world
    scenario they won''t get you very far. Consider this snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'If you try to compile it, you''ll get an error:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Congrats, this is your first borrow-checker error!
  prefs: []
  type: TYPE_NORMAL
- en: '[The perks of Rust''s ownership system](#the-perks-of-rusts-ownership-system)'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Rust''s ownership system is designed to ensure that:'
  prefs: []
  type: TYPE_NORMAL
- en: Data is never mutated while it's being read
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Data is never read while it's being mutated
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Data is never accessed after it has been destroyed
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: These constraints are enforced by the **borrow checker**, a subsystem of the
    Rust compiler, often the subject of jokes and memes in the Rust community.
  prefs: []
  type: TYPE_NORMAL
- en: 'Ownership is a key concept in Rust, and it''s what makes the language unique.
    Ownership enables Rust to provide **memory safety without compromising performance**.
    All these things are true at the same time for Rust:'
  prefs: []
  type: TYPE_NORMAL
- en: There is no runtime garbage collector
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: As a developer, you rarely have to manage memory directly
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: You can't cause dangling pointers, double frees, and other memory-related bugs
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Languages like Python, JavaScript, and Java give you 2\. and 3., but not 1.
  prefs: []
  type: TYPE_NORMAL
- en: Language like C or C++ give you 1., but neither 2\. nor 3.
  prefs: []
  type: TYPE_NORMAL
- en: 'Depending on your background, 3\. might sound a bit arcane: what is a "dangling
    pointer"? What is a "double free"? Why are they dangerous?'
  prefs: []
  type: TYPE_NORMAL
- en: 'Don''t worry: we''ll cover these concepts in more details during the rest of
    the course.'
  prefs: []
  type: TYPE_NORMAL
- en: For now, though, let's focus on learning how to work within Rust's ownership
    system.
  prefs: []
  type: TYPE_NORMAL
- en: '[The owner](#the-owner)'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In Rust, each value has an **owner**, statically determined at compile-time.
    There is only one owner for each value at any given time.
  prefs: []
  type: TYPE_NORMAL
- en: '[Move semantics](#move-semantics)'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Ownership can be transferred.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you own a value, for example, you can transfer ownership to another variable:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'Rust''s ownership system is baked into the type system: each function has to
    declare in its signature *how* it wants to interact with its arguments.'
  prefs: []
  type: TYPE_NORMAL
- en: 'So far, all our methods and functions have **consumed** their arguments: they''ve
    taken ownership of them. For example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: '`Ticket::description` takes ownership of the `Ticket` instance it''s called
    on.'
  prefs: []
  type: TYPE_NORMAL
- en: 'This is known as **move semantics**: ownership of the value (`self`) is **moved**
    from the caller to the callee, and the caller can''t use it anymore.'
  prefs: []
  type: TYPE_NORMAL
- en: 'That''s exactly the language used by the compiler in the error message we saw
    earlier:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'In particular, this is the sequence of events that unfold when we call `ticket.status()`:'
  prefs: []
  type: TYPE_NORMAL
- en: '`Ticket::status` takes ownership of the `Ticket` instance'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Ticket::status` extracts `status` from `self` and transfers ownership of `status`
    back to the caller'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The rest of the `Ticket` instance is discarded (`title` and `description`)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'When we try to use `ticket` again via `ticket.title()`, the compiler complains:
    the `ticket` value is gone now, we no longer own it, therefore we can''t use it
    anymore.'
  prefs: []
  type: TYPE_NORMAL
- en: To build *useful* accessor methods we need to start working with **references**.
  prefs: []
  type: TYPE_NORMAL
- en: '[Borrowing](#borrowing)'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: It is desirable to have methods that can read the value of a variable without
    taking ownership of it.
  prefs: []
  type: TYPE_NORMAL
- en: Programming would be quite limited otherwise. In Rust, that's done via **borrowing**.
  prefs: []
  type: TYPE_NORMAL
- en: Whenever you borrow a value, you get a **reference** to it.
  prefs: []
  type: TYPE_NORMAL
- en: 'References are tagged with their privileges^([1](#footnote-refine)):'
  prefs: []
  type: TYPE_NORMAL
- en: Immutable references (`&`) allow you to read the value, but not to mutate it
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Mutable references (`&mut`) allow you to read and mutate the value
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Going back to the goals of Rust''s ownership system:'
  prefs: []
  type: TYPE_NORMAL
- en: Data is never mutated while it's being read
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Data is never read while it's being mutated
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'To ensure these two properties, Rust has to introduce some restrictions on
    references:'
  prefs: []
  type: TYPE_NORMAL
- en: You can't have a mutable reference and an immutable reference to the same value
    at the same time
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You can't have more than one mutable reference to the same value at the same
    time
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The owner can't mutate the value while it's being borrowed
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You can have as many immutable references as you want, as long as there are
    no mutable references
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In a way, you can think of an immutable reference as a "read-only" lock on the
    value, while a mutable reference is like a "read-write" lock.
  prefs: []
  type: TYPE_NORMAL
- en: All these restrictions are enforced at compile-time by the borrow checker.
  prefs: []
  type: TYPE_NORMAL
- en: '[Syntax](#syntax)'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: How do you borrow a value, in practice?
  prefs: []
  type: TYPE_NORMAL
- en: 'By adding `&` or `&mut` **in front a variable**, you''re borrowing its value.
    Careful though! The same symbols (`&` and `&mut`) in **front of a type** have
    a different meaning: they denote a different type, a reference to the original
    type.'
  prefs: []
  type: TYPE_NORMAL
- en: 'For example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'The same concept applies to function arguments and return types:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: '[Breathe in, breathe out](#breathe-in-breathe-out)'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Rust's ownership system can be a bit overwhelming at first.
  prefs: []
  type: TYPE_NORMAL
- en: 'But don''t worry: it''ll become second nature with practice.'
  prefs: []
  type: TYPE_NORMAL
- en: And you're going to get a lot of practice over the rest of this chapter, as
    well as the rest of the course! We'll revisit each concept multiple times to make
    sure you get familiar with them and truly understand how they work.
  prefs: []
  type: TYPE_NORMAL
- en: Towards the end of this chapter we'll explain *why* Rust's ownership system
    is designed the way it is. For the time being, focus on understanding the *how*.
    Take each compiler error as a learning opportunity!
  prefs: []
  type: TYPE_NORMAL
- en: '[Exercise](#exercise)'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The exercise for this section is located in [`03_ticket_v1/06_ownership`](https://github.com/mainmatter/100-exercises-to-learn-rust/tree/main/exercises/03_ticket_v1/06_ownership)
  prefs: []
  type: TYPE_NORMAL
- en: '* * *'
  prefs: []
  type: TYPE_NORMAL
- en: This is a great mental model to start out, but it doesn't capture the *full*
    picture. We'll refine our understanding of references [later in the course](/100-exercises/07_threads/06_interior_mutability).
    [↩](#fr-refine-1)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
