- en: Modules
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 原文：[https://rust-exercises.com/100-exercises/03_ticket_v1/03_modules.html](https://rust-exercises.com/100-exercises/03_ticket_v1/03_modules.html)
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: The `new` method you've just defined is trying to enforce some **constraints**
    on the field values for `Ticket`. But are those invariants really enforced? What
    prevents a developer from creating a `Ticket` without going through `Ticket::new`?
  prefs: []
  type: TYPE_NORMAL
- en: 'To get proper **encapsulation** you need to become familiar with two new concepts:
    **visibility** and **modules**. Let''s start with modules.'
  prefs: []
  type: TYPE_NORMAL
- en: '[What is a module?](#what-is-a-module)'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In Rust a **module** is a way to group related code together, under a common
    namespace (i.e. the module's name).
  prefs: []
  type: TYPE_NORMAL
- en: 'You''ve already seen modules in action: the unit tests that verify the correctness
    of your code are defined in a different module, named `tests`.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: '[Inline modules](#inline-modules)'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The `tests` module above is an example of an **inline module**: the module
    declaration (`mod tests`) and the module contents (the stuff inside `{ ... }`)
    are next to each other.'
  prefs: []
  type: TYPE_NORMAL
- en: '[Module tree](#module-tree)'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Modules can be nested, forming a **tree** structure.
  prefs: []
  type: TYPE_NORMAL
- en: The root of the tree is the **crate** itself, which is the top-level module
    that contains all the other modules. For a library crate, the root module is usually
    `src/lib.rs` (unless its location has been customized). The root module is also
    known as the **crate root**.
  prefs: []
  type: TYPE_NORMAL
- en: The crate root can have submodules, which in turn can have their own submodules,
    and so on.
  prefs: []
  type: TYPE_NORMAL
- en: '[External modules and the filesystem](#external-modules-and-the-filesystem)'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Inline modules are useful for small pieces of code, but as your project grows
    you'll want to split your code into multiple files. In the parent module, you
    declare the existence of a submodule using the `mod` keyword.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: '`cargo`, Rust''s build tool, is then in charge of finding the file that contains
    the module implementation.'
  prefs: []
  type: TYPE_NORMAL
- en: 'If your module is declared in the root of your crate (e.g. `src/lib.rs` or
    `src/main.rs`), `cargo` expects the file to be named either:'
  prefs: []
  type: TYPE_NORMAL
- en: '`src/<module_name>.rs`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`src/<module_name>/mod.rs`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'If your module is a submodule of another module, the file should be named:'
  prefs: []
  type: TYPE_NORMAL
- en: '`[..]/<parent_module>/<module_name>.rs`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`[..]/<parent_module>/<module_name>/mod.rs`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: E.g. `src/animals/dog.rs` or `src/animals/dog/mod.rs` if `dog` is a submodule
    of `animals`.
  prefs: []
  type: TYPE_NORMAL
- en: Your IDE might help you create these files automatically when you declare a
    new module using the `mod` keyword.
  prefs: []
  type: TYPE_NORMAL
- en: '[Item paths and `use` statements](#item-paths-and-use-statements)'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You can access items defined in the same module without any special syntax.
    You just use their name.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: That's not the case if you want to access an entity from a different module.
  prefs: []
  type: TYPE_NORMAL
- en: You have to use a **path** pointing to the entity you want to access.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can compose the path in various ways:'
  prefs: []
  type: TYPE_NORMAL
- en: starting from the root of the current crate, e.g. `crate::module_1::MyStruct`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: starting from the parent module, e.g. `super::my_function`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: starting from the current module, e.g. `sub_module_1::MyStruct`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Both `crate` and `super` are **keywords**.
  prefs: []
  type: TYPE_NORMAL
- en: '`crate` refers to the root of the current crate, while `super` refers to the
    parent of the current module.'
  prefs: []
  type: TYPE_NORMAL
- en: Having to write the full path every time you want to refer to a type can be
    cumbersome. To make your life easier, you can introduce a `use` statement to bring
    the entity into scope.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: '[Star imports](#star-imports)'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: You can also import all the items from a module with a single `use` statement.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: This is known as a **star import**.
  prefs: []
  type: TYPE_NORMAL
- en: It is generally discouraged because it can pollute the current namespace, making
    it hard to understand where each name comes from and potentially introducing name
    conflicts.
  prefs: []
  type: TYPE_NORMAL
- en: Nonetheless, it can be useful in some cases, like when writing unit tests. You
    might have noticed that most of our test modules start with a `use super::*;`
    statement to bring all the items from the parent module (the one being tested)
    into scope.
  prefs: []
  type: TYPE_NORMAL
- en: '[Visualizing the module tree](#visualizing-the-module-tree)'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: If you're struggling to picture the module tree of your project, you can try
    using [`cargo-modules`](https://crates.io/crates/cargo-modules) to visualize it!
  prefs: []
  type: TYPE_NORMAL
- en: Refer to their documentation for installation instructions and usage examples.
  prefs: []
  type: TYPE_NORMAL
- en: '[Exercise](#exercise)'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The exercise for this section is located in [`03_ticket_v1/03_modules`](https://github.com/mainmatter/100-exercises-to-learn-rust/tree/main/exercises/03_ticket_v1/03_modules)
  prefs: []
  type: TYPE_NORMAL
