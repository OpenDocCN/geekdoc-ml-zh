- en: Types, part 1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 原文：[https://rust-exercises.com/100-exercises/02_basic_calculator/01_integers.html](https://rust-exercises.com/100-exercises/02_basic_calculator/01_integers.html)
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: In the ["Syntax" section](/100-exercises/01_intro/01_syntax) `compute`'s input
    parameters were of type `u32`.
  prefs: []
  type: TYPE_NORMAL
- en: Let's unpack what that *means*.
  prefs: []
  type: TYPE_NORMAL
- en: '[Primitive types](#primitive-types)'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '`u32` is one of Rust''s **primitive types**. Primitive types are the most basic
    building blocks of a language. They''re built into the language itself—i.e. they
    are not defined in terms of other types.'
  prefs: []
  type: TYPE_NORMAL
- en: You can combine these primitive types to create more complex types. We'll see
    how soon enough.
  prefs: []
  type: TYPE_NORMAL
- en: '[Integers](#integers)'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '`u32`, in particular, is an **unsigned 32-bit integer**.'
  prefs: []
  type: TYPE_NORMAL
- en: An integer is a number that can be written without a fractional component. E.g.
    `1` is an integer, while `1.2` is not.
  prefs: []
  type: TYPE_NORMAL
- en: '[Signed vs. unsigned](#signed-vs-unsigned)'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: An integer can be **signed** or **unsigned**.
  prefs: []
  type: TYPE_NORMAL
- en: An unsigned integer can only represent non-negative numbers (i.e. `0` or greater).
    A signed integer can represent both positive and negative numbers (e.g. `-1`,
    `12`, etc.).
  prefs: []
  type: TYPE_NORMAL
- en: The `u` in `u32` stands for **unsigned**.
  prefs: []
  type: TYPE_NORMAL
- en: The equivalent type for signed integer is `i32`, where the `i` stands for integer
    (i.e. any integer, positive or negative).
  prefs: []
  type: TYPE_NORMAL
- en: '[Bit width](#bit-width)'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The `32` in `u32` refers to the **number of bits^([1](#footnote-bit))** used
    to represent the number in memory.
  prefs: []
  type: TYPE_NORMAL
- en: The more bits, the larger the range of numbers that can be represented.
  prefs: []
  type: TYPE_NORMAL
- en: 'Rust supports multiple bit widths for integers: `8`, `16`, `32`, `64`, `128`.'
  prefs: []
  type: TYPE_NORMAL
- en: With 32 bits, `u32` can represent numbers from `0` to `2^32 - 1` (a.k.a. [`u32::MAX`](https://doc.rust-lang.org/std/primitive.u32.html#associatedconstant.MAX)).
  prefs: []
  type: TYPE_NORMAL
- en: With the same number of bits, a signed integer (`i32`) can represent numbers
    from `-2^31` to `2^31 - 1` (i.e. from [`i32::MIN`](https://doc.rust-lang.org/std/primitive.i32.html#associatedconstant.MIN)
    to [`i32::MAX`](https://doc.rust-lang.org/std/primitive.i32.html#associatedconstant.MAX)).
  prefs: []
  type: TYPE_NORMAL
- en: The maximum value for `i32` is smaller than the maximum value for `u32` because
    one bit is used to represent the sign of the number. Check out the [two's complement](https://en.wikipedia.org/wiki/Two%27s_complement)
    representation for more details on how signed integers are represented in memory.
  prefs: []
  type: TYPE_NORMAL
- en: '[Summary](#summary)'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Combining the two variables (signed/unsigned and bit width), we get the following
    integer types:'
  prefs: []
  type: TYPE_NORMAL
- en: '| Bit width | Signed | Unsigned |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| 8-bit | `i8` | `u8` |'
  prefs: []
  type: TYPE_TB
- en: '| 16-bit | `i16` | `u16` |'
  prefs: []
  type: TYPE_TB
- en: '| 32-bit | `i32` | `u32` |'
  prefs: []
  type: TYPE_TB
- en: '| 64-bit | `i64` | `u64` |'
  prefs: []
  type: TYPE_TB
- en: '| 128-bit | `i128` | `u128` |'
  prefs: []
  type: TYPE_TB
- en: '[Literals](#literals)'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A **literal** is a notation for representing a fixed value in source code.
  prefs: []
  type: TYPE_NORMAL
- en: For example, `42` is a Rust literal for the number forty-two.
  prefs: []
  type: TYPE_NORMAL
- en: '[Type annotations for literals](#type-annotations-for-literals)'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: But all values in Rust have a type, so... what's the type of `42`?
  prefs: []
  type: TYPE_NORMAL
- en: The Rust compiler will try to infer the type of a literal based on how it's
    used.
  prefs: []
  type: TYPE_NORMAL
- en: If you don't provide any context, the compiler will default to `i32` for integer
    literals.
  prefs: []
  type: TYPE_NORMAL
- en: If you want to use a different type, you can add the desired integer type as
    a suffix—e.g. `2u64` is a 2 that's explicitly typed as a `u64`.
  prefs: []
  type: TYPE_NORMAL
- en: '[Underscores in literals](#underscores-in-literals)'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: You can use underscores `_` to improve the readability of large numbers.
  prefs: []
  type: TYPE_NORMAL
- en: For example, `1_000_000` is the same as `1000000`.
  prefs: []
  type: TYPE_NORMAL
- en: '[Arithmetic operators](#arithmetic-operators)'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Rust supports the following arithmetic operators^([2](#footnote-traits)) for
    integers:'
  prefs: []
  type: TYPE_NORMAL
- en: '`+` for addition'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`-` for subtraction'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`*` for multiplication'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`/` for division'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`%` for remainder'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Precedence and associativity rules for these operators are the same as in mathematics.
  prefs: []
  type: TYPE_NORMAL
- en: You can use parentheses to override the default precedence. E.g. `2 * (3 + 4)`.
  prefs: []
  type: TYPE_NORMAL
- en: ⚠️ **Warning**
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: The division operator `/` performs integer division when used with integer types.
    I.e. the result is truncated towards zero. For example, `5 / 2` is `2`, not `2.5`.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '[No automatic type coercion](#no-automatic-type-coercion)'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As we discussed in the previous exercise, Rust is a statically typed language.
  prefs: []
  type: TYPE_NORMAL
- en: In particular, Rust is quite strict about type coercion. It won't automatically
    convert a value from one type to another^([3](#footnote-coercion)), even if the
    conversion is lossless. You have to do it explicitly.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, you can''t assign a `u8` value to a variable with type `u32`,
    even though all `u8` values are valid `u32` values:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'It''ll throw a compilation error:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: We'll see how to convert between types [later in this course](/100-exercises/04_traits/09_from).
  prefs: []
  type: TYPE_NORMAL
- en: '[Further reading](#further-reading)'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '[The integer types section](https://doc.rust-lang.org/book/ch03-02-data-types.html#integer-types)
    in the official Rust book'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Exercise](#exercise)'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The exercise for this section is located in [`02_basic_calculator/01_integers`](https://github.com/mainmatter/100-exercises-to-learn-rust/tree/main/exercises/02_basic_calculator/01_integers)
  prefs: []
  type: TYPE_NORMAL
- en: '* * *'
  prefs: []
  type: TYPE_NORMAL
- en: 'A bit is the smallest unit of data in a computer. It can only have two values:
    `0` or `1`. [↩](#fr-bit-1)'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Rust doesn't let you define custom operators, but it puts you in control of
    how the built-in operators behave. We'll talk about operator overloading [later
    in the course](/100-exercises/04_traits/03_operator_overloading), after we've
    covered traits. [↩](#fr-traits-1)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: There are some exceptions to this rule, mostly related to references, smart
    pointers and ergonomics. We'll cover those [later on](/100-exercises/04_traits/07_deref).
    A mental model of "all conversions are explicit" will serve you well in the meantime.
    [↩](#fr-coercion-1)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
