- en: Locks, Send and Arc
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 原文：[https://rust-exercises.com/100-exercises/07_threads/11_locks.html](https://rust-exercises.com/100-exercises/07_threads/11_locks.html)
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'The patching strategy you just implemented has a major drawback: it''s racy.'
  prefs: []
  type: TYPE_NORMAL
- en: If two clients send patches for the same ticket roughly at same time, the server
    will apply them in an arbitrary order. Whoever enqueues their patch last will
    overwrite the changes made by the other client.
  prefs: []
  type: TYPE_NORMAL
- en: '[Version numbers](#version-numbers)'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We could try to fix this by using a **version number**.
  prefs: []
  type: TYPE_NORMAL
- en: Each ticket gets assigned a version number upon creation, set to `0`.
  prefs: []
  type: TYPE_NORMAL
- en: Whenever a client sends a patch, they must include the current version number
    of the ticket alongside the desired changes. The server will only apply the patch
    if the version number matches the one it has stored.
  prefs: []
  type: TYPE_NORMAL
- en: In the scenario described above, the server would reject the second patch, because
    the version number would have been incremented by the first patch and thus wouldn't
    match the one sent by the second client.
  prefs: []
  type: TYPE_NORMAL
- en: This approach is fairly common in distributed systems (e.g. when client and
    servers don't share memory), and it is known as **optimistic concurrency control**.
  prefs: []
  type: TYPE_NORMAL
- en: The idea is that most of the time, conflicts won't happen, so we can optimize
    for the common case. You know enough about Rust by now to implement this strategy
    on your own as a bonus exercise, if you want to.
  prefs: []
  type: TYPE_NORMAL
- en: '[Locking](#locking)'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We can also fix the race condition by introducing a **lock**.
  prefs: []
  type: TYPE_NORMAL
- en: Whenever a client wants to update a ticket, they must first acquire a lock on
    it. While the lock is active, no other client can modify the ticket.
  prefs: []
  type: TYPE_NORMAL
- en: 'Rust''s standard library provides two different locking primitives: `Mutex<T>`
    and `RwLock<T>`.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s start with `Mutex<T>`. It stands for **mut**ual **ex**clusion, and it''s
    the simplest kind of lock: it allows only one thread to access the data, no matter
    if it''s for reading or writing.'
  prefs: []
  type: TYPE_NORMAL
- en: '`Mutex<T>` wraps the data it protects, and it''s therefore generic over the
    type of the data.'
  prefs: []
  type: TYPE_NORMAL
- en: 'You can''t access the data directly: the type system forces you to acquire
    a lock first using either `Mutex::lock` or `Mutex::try_lock`. The former blocks
    until the lock is acquired, the latter returns immediately with an error if the
    lock can''t be acquired.'
  prefs: []
  type: TYPE_NORMAL
- en: Both methods return a guard object that dereferences to the data, allowing you
    to modify it. The lock is released when the guard is dropped.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: '[Locking granularity](#locking-granularity)'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: What should our `Mutex` wrap?
  prefs: []
  type: TYPE_NORMAL
- en: The simplest option would be to wrap the entire `TicketStore` in a single `Mutex`.
  prefs: []
  type: TYPE_NORMAL
- en: 'This would work, but it would severely limit the system''s performance: you
    wouldn''t be able to read tickets in parallel, because every read would have to
    wait for the lock to be released.'
  prefs: []
  type: TYPE_NORMAL
- en: This is known as **coarse-grained locking**.
  prefs: []
  type: TYPE_NORMAL
- en: It would be better to use **fine-grained locking**, where each ticket is protected
    by its own lock. This way, clients can keep working with tickets in parallel,
    as long as they aren't trying to access the same ticket.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'This approach is more efficient, but it has a downside: `TicketStore` has to
    become **aware** of the multithreaded nature of the system; up until now, `TicketStore`
    has been blissfully ignoring the existence of threads.'
  prefs: []
  type: TYPE_NORMAL
- en: Let's go for it anyway.
  prefs: []
  type: TYPE_NORMAL
- en: '[Who holds the lock?](#who-holds-the-lock)'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: For the whole scheme to work, the lock must be passed to the client that wants
    to modify the ticket.
  prefs: []
  type: TYPE_NORMAL
- en: The client can then directly modify the ticket (as if they had a `&mut Ticket`)
    and release the lock when they're done.
  prefs: []
  type: TYPE_NORMAL
- en: This is a bit tricky.
  prefs: []
  type: TYPE_NORMAL
- en: We can't send a `Mutex<Ticket>` over a channel, because `Mutex` is not `Clone`
    and we can't move it out of the `TicketStore`. Could we send the `MutexGuard`
    instead?
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s test the idea with a small example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'The compiler is not happy with this code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: '`MutexGuard<''_, i32>` is not `Send`: what does it mean?'
  prefs: []
  type: TYPE_NORMAL
- en: '[`Send`](#send)'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '`Send` is a marker trait that indicates that a type can be safely transferred
    from one thread to another.'
  prefs: []
  type: TYPE_NORMAL
- en: '`Send` is also an auto-trait, just like `Sized`; it''s automatically implemented
    (or not implemented) for your type by the compiler, based on its definition.'
  prefs: []
  type: TYPE_NORMAL
- en: You can also implement `Send` manually for your types, but it requires `unsafe`
    since you have to guarantee that the type is indeed safe to send between threads
    for reasons that the compiler can't automatically verify.
  prefs: []
  type: TYPE_NORMAL
- en: '[Channel requirements](#channel-requirements)'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '`Sender<T>`, `SyncSender<T>` and `Receiver<T>` are `Send` if and only if `T`
    is `Send`.'
  prefs: []
  type: TYPE_NORMAL
- en: That's because they are used to send values between threads, and if the value
    itself is not `Send`, it would be unsafe to send it between threads.
  prefs: []
  type: TYPE_NORMAL
- en: '[`MutexGuard`](#mutexguard)'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '`MutexGuard` is not `Send` because the underlying operating system primitives
    that `Mutex` uses to implement the lock require (on some platforms) that the lock
    must be released by the same thread that acquired it.'
  prefs: []
  type: TYPE_NORMAL
- en: If we were to send a `MutexGuard` to another thread, the lock would be released
    by a different thread, which would lead to undefined behavior.
  prefs: []
  type: TYPE_NORMAL
- en: '[Our challenges](#our-challenges)'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Summing it up:'
  prefs: []
  type: TYPE_NORMAL
- en: We can't send a `MutexGuard` over a channel. So we can't lock on the server-side
    and then modify the ticket on the client-side.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We can send a `Mutex` over a channel because it's `Send` as long as the data
    it protects is `Send`, which is the case for `Ticket`. At the same time, we can't
    move the `Mutex` out of the `TicketStore` nor clone it.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How can we solve this conundrum?
  prefs: []
  type: TYPE_NORMAL
- en: 'We need to look at the problem from a different angle. To lock a `Mutex`, we
    don''t need an owned value. A shared reference is enough, since `Mutex` uses internal
    mutability:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: It is therefore enough to send a shared reference to the client.
  prefs: []
  type: TYPE_NORMAL
- en: We can't do that directly, though, because the reference would have to be `'static`
    and that's not the case.
  prefs: []
  type: TYPE_NORMAL
- en: 'In a way, we need an "owned shared reference". It turns out that Rust has a
    type that fits the bill: `Arc`.'
  prefs: []
  type: TYPE_NORMAL
- en: '[`Arc` to the rescue](#arc-to-the-rescue)'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '`Arc` stands for **atomic reference counting**.'
  prefs: []
  type: TYPE_NORMAL
- en: '`Arc` wraps around a value and keeps track of how many references to the value
    exist. When the last reference is dropped, the value is deallocated.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The value wrapped in an `Arc` is immutable: you can only get shared references
    to it.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'If you''re having a déjà vu moment, you''re right: `Arc` sounds very similar
    to `Rc`, the reference-counted pointer we introduced when talking about interior
    mutability. The difference is thread-safety: `Rc` is not `Send`, while `Arc` is.
    It boils down to the way the reference count is implemented: `Rc` uses a "normal"
    integer, while `Arc` uses an **atomic** integer, which can be safely shared and
    modified across threads.'
  prefs: []
  type: TYPE_NORMAL
- en: '[`Arc<Mutex<T>>`](#arcmutext)'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'If we pair `Arc` with `Mutex`, we finally get a type that:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Can be sent between threads, because:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Arc` is `Send` if `T` is `Send`, and'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Mutex` is `Send` if `T` is `Send`.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`T` is `Ticket`, which is `Send`.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Can be cloned, because `Arc` is `Clone` no matter what `T` is. Cloning an `Arc`
    increments the reference count, the data is not copied.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Can be used to modify the data it wraps, because `Arc` lets you get a shared
    reference to `Mutex<T>` which can in turn be used to acquire a lock.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We have all the pieces we need to implement the locking strategy for our ticket
    store.
  prefs: []
  type: TYPE_NORMAL
- en: '[Further reading](#further-reading)'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We won't be covering the details of atomic operations in this course, but you
    can find more information [in the `std` documentation](https://doc.rust-lang.org/std/sync/atomic/index.html)
    as well as in the ["Rust atomics and locks" book](https://marabos.nl/atomics/).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Exercise](#exercise)'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The exercise for this section is located in [`07_threads/11_locks`](https://github.com/mainmatter/100-exercises-to-learn-rust/tree/main/exercises/07_threads/11_locks)
  prefs: []
  type: TYPE_NORMAL
