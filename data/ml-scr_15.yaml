- en: Implementation
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实现
- en: 原文：[https://dafriedman97.github.io/mlbook/content/c3/code.html](https://dafriedman97.github.io/mlbook/content/c3/code.html)
  id: totrans-1
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 原文：[https://dafriedman97.github.io/mlbook/content/c3/code.html](https://dafriedman97.github.io/mlbook/content/c3/code.html)
- en: This section will demonstrate how to fit the discriminative classifiers discussed
    in this chapter with `scikit-learn`. Note that other libraries are frequently
    used—e.g. `statsmodels` for logistic regresssion and `tensorflow` for the perceptron.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 本节将演示如何使用 `scikit-learn` 来拟合本章讨论的判别分类器。请注意，其他库也经常被使用——例如，`statsmodels` 用于逻辑回归，而
    `tensorflow` 用于感知机。
- en: For binary tasks, we’ll be using the [breast cancer](../appendix/data.html)
    dataset and for multiclass tasks, we’ll be using the [wine](../appendix/data.html)
    dataset.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 对于二元任务，我们将使用 [乳腺癌](../appendix/data.html) 数据集，而对于多类任务，我们将使用 [葡萄酒](../appendix/data.html)
    数据集。
- en: '[PRE0]'
  id: totrans-4
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Logistic Regression
  id: totrans-5
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 逻辑回归
- en: Binary Logistic Regression
  id: totrans-6
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 二元逻辑回归
- en: 'A standard `scikit-learn` implementation of binary logistic regression is shown
    below. Note the two arguments set when instantiating the model: `C` is a regularization
    term where a higher `C` indicates *less* penalty on the magnitude of the coefficients
    and `max_iter` determines the maximum number of iterations the solver will use.
    We set `C` to be arbitrarily high such that there is effectively no regulariation
    and `max_iter` to be 1,000, which is enough for this model to converge.'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 下面展示了 `scikit-learn` 的标准二元逻辑回归实现。请注意在实例化模型时设置的两个参数：`C` 是一个正则化项，其中较高的 `C` 表示对系数幅度的惩罚更少，而
    `max_iter` 决定了求解器将使用的最大迭代次数。我们将 `C` 设置得任意高，以便实际上没有正则化，并将 `max_iter` 设置为 1,000，这对于此模型收敛来说是足够的。
- en: '[PRE1]'
  id: totrans-8
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: '[PRE2]'
  id: totrans-9
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: '`scikit-learn`’s logistic regression model can return two forms of predictions:
    the predicted classes or the predicted probabilities. The `.predict()` method
    predicts an observation for each class while `.predict_proba()` gives the probability
    for all classes included in the training set (in this case, just 0 and 1).'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: '`scikit-learn` 的逻辑回归模型可以返回两种预测形式：预测类别或预测概率。`.predict()` 方法为每个类别预测一个观察值，而 `.predict_proba()`
    则给出训练集中包含的所有类别的概率（在本例中，仅为 0 和 1）。'
- en: '[PRE3]'
  id: totrans-11
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: '[PRE4]'
  id: totrans-12
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Multiclass Logistic Regression
  id: totrans-13
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 多类逻辑回归
- en: Multiclass logistic regression can be fit in `scikit-learn` as below. In fact,
    no arguments need to be changed in order to fit a multiclass model versus a binary
    one. However, the implementation below adds one new argument. Setting `multiclass`
    equal to ‘multinomial’ tells the model explicitly to follow the algorithm introduced
    in the [concept section](s2/logistic_regression.html). This will be done by default
    for non-binary problems unless the `solver` is set to ‘liblinear’. In that case,
    it will fit a “[one-versus-rest](https://www.google.com/search?q=one+versus+rest+classifier&oq=one+versus+rest+classifier&aqs=chrome..69i57j0l4j69i64.3569j0j1&sourceid=chrome&ie=UTF-8)”
    model.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `scikit-learn` 中，多类逻辑回归可以按照以下方式拟合。实际上，为了拟合多类模型而不是二元模型，不需要更改任何参数。然而，下面的实现增加了一个新的参数。将
    `multiclass` 设置为 'multinomial' 明确告诉模型遵循在 [概念部分](s2/logistic_regression.html) 中介绍的算法。对于非二元问题，这将是默认行为，除非将
    `solver` 设置为 'liblinear'。在这种情况下，它将拟合一个 “[一对多](https://www.google.com/search?q=one+versus+rest+classifier&oq=one+versus+rest+classifier&aqs=chrome..69i57j0l4j69i64.3569j0j1&sourceid=chrome&ie=UTF-8)”
    模型。
- en: '[PRE5]'
  id: totrans-15
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: '[PRE6]'
  id: totrans-16
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Again, we can see the predicted classes and predicted probabilities for each
    class, as below.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，我们可以看到每个类别的预测类别和预测概率，如下所示。
- en: '[PRE7]'
  id: totrans-18
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: '[PRE8]'
  id: totrans-19
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: The Perceptron Algorithm
  id: totrans-20
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 感知机算法
- en: The perceptron algorithm is implemented below. This algorithm is rarely used
    in practice but serves as an important part of neural networks, the topic of Chapter
    7.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 下面的代码实现了感知机算法。这个算法在实践中很少使用，但它是神经网络的一个重要组成部分，这是第 7 章的主题。
- en: '[PRE9]'
  id: totrans-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Fisher’s Linear Discriminant
  id: totrans-23
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 费舍尔线性判别
- en: Finally, we fit Fisher’s Linear Discriminant with the `LinearDiscriminantAnalysis`
    class from `scikit-learn`. This class can also be viewed as a generative model,
    which is discussed in the next chapter, but the implementation below reduces to
    the discriminative classifier derived in the concept section. Specifying `n_components
    = 1` tells the model to reduce the data to one dimension. This is the equivalent
    of generating the
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们使用 `scikit-learn` 的 `LinearDiscriminantAnalysis` 类拟合费舍尔线性判别。这个类也可以被视为一个生成模型，这将在下一章中讨论，但下面的实现简化为在概念部分推导出的判别分类器。指定
    `n_components = 1` 告诉模型将数据降低到一维。这相当于生成
- en: \[ f(\bx_n) = \bbeta^\top \bx_n \]
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: \[ f(\bx_n) = \bbeta^\top \bx_n \]
- en: transformations that we saw in the concept section. We can then see if the two
    classes are separated by checking that either 1) \(f(\bx_n) < f(\bx_m)\) for all
    \(n\) in class 0 and \(m\) in class 1 or 2) \(f(\bx_n) > f(\bx_m)\) for all \(n\)
    in class 0 and \(m\) in class 1\. Equivalently, we can see that the two classes
    are not separated in the histogram below.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在概念部分看到的一些转换。然后我们可以通过检查以下两种情况来确定两个类别是否被分离：1) 对于类别 0 中的所有 \(n\) 和类别 1 中的所有
    \(m\)，\(f(\bx_n) < f(\bx_m)\)；或者 2) 对于类别 0 中的所有 \(n\) 和类别 1 中的所有 \(m\)，\(f(\bx_n)
    > f(\bx_m)\)。等价地，我们可以在下面的直方图中看到两个类别没有被分离。
- en: '[PRE10]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: '[PRE11]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: '[PRE12]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: '![../../_images/code_20_0.png](../Images/19e8f02c59c9b29f4ab3056d2d3c0dec.png)'
  id: totrans-30
  prefs: []
  type: TYPE_IMG
  zh: '![../../_images/code_20_0.png](../Images/19e8f02c59c9b29f4ab3056d2d3c0dec.png)'
- en: Logistic Regression
  id: totrans-31
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 逻辑回归
- en: Binary Logistic Regression
  id: totrans-32
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 二元逻辑回归
- en: 'A standard `scikit-learn` implementation of binary logistic regression is shown
    below. Note the two arguments set when instantiating the model: `C` is a regularization
    term where a higher `C` indicates *less* penalty on the magnitude of the coefficients
    and `max_iter` determines the maximum number of iterations the solver will use.
    We set `C` to be arbitrarily high such that there is effectively no regulariation
    and `max_iter` to be 1,000, which is enough for this model to converge.'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 下面展示了 `scikit-learn` 的标准二元逻辑回归实现。注意在实例化模型时设置的两个参数：`C` 是一个正则化项，其中较高的 `C` 表示对系数幅度的惩罚较少，`max_iter`
    决定了求解器将使用的最大迭代次数。我们将 `C` 设置得任意高，以便实际上没有正则化，并将 `max_iter` 设置为 1,000，这对于该模型收敛来说是足够的。
- en: '[PRE13]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: '[PRE14]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: '`scikit-learn`’s logistic regression model can return two forms of predictions:
    the predicted classes or the predicted probabilities. The `.predict()` method
    predicts an observation for each class while `.predict_proba()` gives the probability
    for all classes included in the training set (in this case, just 0 and 1).'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: '`scikit-learn` 的逻辑回归模型可以返回两种预测形式：预测类别或预测概率。`.predict()` 方法预测每个类别的观察值，而 `.predict_proba()`
    则给出训练集中包含的所有类别的概率（在这种情况下，仅为 0 和 1）。'
- en: '[PRE15]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: '[PRE16]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Multiclass Logistic Regression
  id: totrans-39
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 多类逻辑回归
- en: Multiclass logistic regression can be fit in `scikit-learn` as below. In fact,
    no arguments need to be changed in order to fit a multiclass model versus a binary
    one. However, the implementation below adds one new argument. Setting `multiclass`
    equal to ‘multinomial’ tells the model explicitly to follow the algorithm introduced
    in the [concept section](s2/logistic_regression.html). This will be done by default
    for non-binary problems unless the `solver` is set to ‘liblinear’. In that case,
    it will fit a “[one-versus-rest](https://www.google.com/search?q=one+versus+rest+classifier&oq=one+versus+rest+classifier&aqs=chrome..69i57j0l4j69i64.3569j0j1&sourceid=chrome&ie=UTF-8)”
    model.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `scikit-learn` 中，多类逻辑回归可以按照以下方式拟合。实际上，为了拟合多类模型而不是二元模型，不需要更改任何参数。然而，下面的实现增加了一个新的参数。将
    `multiclass` 设置为 'multinomial' 明确告诉模型遵循在 [概念部分](s2/logistic_regression.html) 中介绍的算法。对于非二元问题，这将是默认行为，除非将
    `solver` 设置为 'liblinear'。在这种情况下，它将拟合一个 “[一对多](https://www.google.com/search?q=one+versus+rest+classifier&oq=one+versus+rest+classifier&aqs=chrome..69i57j0l4j69i64.3569j0j1&sourceid=chrome&ie=UTF-8)”
    模型。
- en: '[PRE17]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: '[PRE18]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Again, we can see the predicted classes and predicted probabilities for each
    class, as below.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，我们可以在下面看到每个类别的预测类别和预测概率。
- en: '[PRE19]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: '[PRE20]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Binary Logistic Regression
  id: totrans-46
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 二元逻辑回归
- en: 'A standard `scikit-learn` implementation of binary logistic regression is shown
    below. Note the two arguments set when instantiating the model: `C` is a regularization
    term where a higher `C` indicates *less* penalty on the magnitude of the coefficients
    and `max_iter` determines the maximum number of iterations the solver will use.
    We set `C` to be arbitrarily high such that there is effectively no regulariation
    and `max_iter` to be 1,000, which is enough for this model to converge.'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 下面展示了 `scikit-learn` 的标准二元逻辑回归实现。注意在实例化模型时设置的两个参数：`C` 是一个正则化项，其中较高的 `C` 表示对系数幅度的惩罚较少，`max_iter`
    决定了求解器将使用的最大迭代次数。我们将 `C` 设置得任意高，以便实际上没有正则化，并将 `max_iter` 设置为 1,000，这对于该模型收敛来说是足够的。
- en: '[PRE21]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: '[PRE22]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: '`scikit-learn`’s logistic regression model can return two forms of predictions:
    the predicted classes or the predicted probabilities. The `.predict()` method
    predicts an observation for each class while `.predict_proba()` gives the probability
    for all classes included in the training set (in this case, just 0 and 1).'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: '`scikit-learn` 的逻辑回归模型可以返回两种预测形式：预测类别或预测概率。`.predict()` 方法预测每个类别的观察值，而 `.predict_proba()`
    则给出训练集中包含的所有类别的概率（在这种情况下，仅为 0 和 1）。'
- en: '[PRE23]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: '[PRE24]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: Multiclass Logistic Regression
  id: totrans-53
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 多类逻辑回归
- en: Multiclass logistic regression can be fit in `scikit-learn` as below. In fact,
    no arguments need to be changed in order to fit a multiclass model versus a binary
    one. However, the implementation below adds one new argument. Setting `multiclass`
    equal to ‘multinomial’ tells the model explicitly to follow the algorithm introduced
    in the [concept section](s2/logistic_regression.html). This will be done by default
    for non-binary problems unless the `solver` is set to ‘liblinear’. In that case,
    it will fit a “[one-versus-rest](https://www.google.com/search?q=one+versus+rest+classifier&oq=one+versus+rest+classifier&aqs=chrome..69i57j0l4j69i64.3569j0j1&sourceid=chrome&ie=UTF-8)”
    model.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 多类逻辑回归可以在 `scikit-learn` 中如下拟合。实际上，为了拟合多类模型而不是二类模型，不需要更改任何参数。然而，下面的实现增加了一个新的参数。将
    `multiclass` 设置为 'multinomial' 明确告诉模型遵循在[概念部分](s2/logistic_regression.html)中介绍的算法。对于非二分类问题，这将是默认行为，除非将
    `solver` 设置为 'liblinear'。在这种情况下，它将拟合一个“一对多”(one-versus-rest)模型。
- en: '[PRE25]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: '[PRE26]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: Again, we can see the predicted classes and predicted probabilities for each
    class, as below.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 再次，我们可以看到每个类别的预测类别和预测概率，如下所示。
- en: '[PRE27]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: '[PRE28]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: The Perceptron Algorithm
  id: totrans-60
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 感知器算法
- en: The perceptron algorithm is implemented below. This algorithm is rarely used
    in practice but serves as an important part of neural networks, the topic of Chapter
    7.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 以下实现了感知器算法。这个算法在实际中很少使用，但它是神经网络的重要组成部分，这是第7章的主题。
- en: '[PRE29]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: Fisher’s Linear Discriminant
  id: totrans-63
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 鲍尔斯线性判别
- en: Finally, we fit Fisher’s Linear Discriminant with the `LinearDiscriminantAnalysis`
    class from `scikit-learn`. This class can also be viewed as a generative model,
    which is discussed in the next chapter, but the implementation below reduces to
    the discriminative classifier derived in the concept section. Specifying `n_components
    = 1` tells the model to reduce the data to one dimension. This is the equivalent
    of generating the
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们使用 `scikit-learn` 中的 `LinearDiscriminantAnalysis` 类来拟合鲍尔斯线性判别。这个类也可以被视为一个生成模型，这将在下一章中讨论，但下面的实现简化为概念部分推导出的判别分类器。指定
    `n_components = 1` 告诉模型将数据降低到一维。这相当于生成
- en: \[ f(\bx_n) = \bbeta^\top \bx_n \]
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: \[ f(\bx_n) = \bbeta^\top \bx_n \]
- en: transformations that we saw in the concept section. We can then see if the two
    classes are separated by checking that either 1) \(f(\bx_n) < f(\bx_m)\) for all
    \(n\) in class 0 and \(m\) in class 1 or 2) \(f(\bx_n) > f(\bx_m)\) for all \(n\)
    in class 0 and \(m\) in class 1\. Equivalently, we can see that the two classes
    are not separated in the histogram below.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在概念部分看到的变换。然后我们可以通过检查以下任一条件来查看两个类别是否被分离：1) 对于类别0中的所有 \(n\) 和类别1中的所有 \(m\)，有
    \(f(\bx_n) < f(\bx_m)\)；或者2) 对于类别0中的所有 \(n\) 和类别1中的所有 \(m\)，有 \(f(\bx_n) > f(\bx_m)\)。等价地，我们可以在下面的直方图中看到两个类别没有被分离。
- en: '[PRE30]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: '[PRE31]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: '[PRE32]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: '![../../_images/code_20_0.png](../Images/19e8f02c59c9b29f4ab3056d2d3c0dec.png)'
  id: totrans-70
  prefs: []
  type: TYPE_IMG
  zh: '![../../_images/code_20_0.png](../Images/19e8f02c59c9b29f4ab3056d2d3c0dec.png)'
