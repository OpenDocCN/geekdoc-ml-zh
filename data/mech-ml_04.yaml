- en: 4 Development Tools
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 4 开发工具
- en: 原文：[https://mlbook.explained.ai/tools.html](https://mlbook.explained.ai/tools.html)
  id: totrans-1
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 原文：[https://mlbook.explained.ai/tools.html](https://mlbook.explained.ai/tools.html)
- en: '[Terence Parr](http://parrt.cs.usfca.edu) and [Jeremy Howard](http://www.fast.ai/about/#jeremy)'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: '[Terence Parr](http://parrt.cs.usfca.edu) 和 [Jeremy Howard](http://www.fast.ai/about/#jeremy)'
- en: Copyright © 2018-2019 Terence Parr. All rights reserved.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 版权所有 © 2018-2019 Terence Parr。保留所有权利。
- en: '*Please don''t replicate on web or redistribute in any way.*'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: '*请勿在网络上复制或以任何方式重新分发。*'
- en: This book generated from markup+markdown+python+latex source with [Bookish](https://github.com/parrt/bookish).
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 本书由 markup+markdown+python+latex 源代码生成，使用 [Bookish](https://github.com/parrt/bookish)。
- en: You can make **comments or annotate** this page by going to the annotated version
    of this page. You'll see existing annotated bits highlighted in yellow. They are
    *PUBLICLY VISIBLE*. Or, you can send comments, suggestions, or fixes directly
    to [Terence](mailto:parrt@cs.usfca.edu).
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过访问此页面的注释版本来对页面进行**注释或标注**。你将看到现有的标注部分以黄色突出显示。它们是**公开可见的**。或者，你可以直接向[Terence](mailto:parrt@cs.usfca.edu)发送评论、建议或修正。
- en: Contents
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 目录
- en: '[Your machine learning development environment](#sec:4.1)'
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[你的机器学习开发环境](#sec:4.1)'
- en: '[Dataframe Dojo](#dojo)'
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[数据框道场](#dojo)'
- en: '[Loading and examining data](#sec:4.2.1)'
  id: totrans-10
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[加载数据并检查数据](#sec:4.2.1)'
- en: '[Extracting subsets](#sec:4.2.2)'
  id: totrans-11
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[提取子集](#sec:4.2.2)'
- en: '[Dataframe Indexes](#sec:4.2.3)'
  id: totrans-12
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[数据框索引](#sec:4.2.3)'
- en: '[Dataframe queries](#sec:4.2.4)'
  id: totrans-13
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[数据框查询](#sec:4.2.4)'
- en: '[Injecting new dataframe columns](#newcol)'
  id: totrans-14
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[注入新的数据框列](#newcol)'
- en: '[String and date operations](#sec:4.2.6)'
  id: totrans-15
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[字符串和日期操作](#sec:4.2.6)'
- en: '[Merging dataframes](#sec:4.2.7)'
  id: totrans-16
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[合并数据框](#sec:4.2.7)'
- en: '[Saving and loading data in the feather format](#sec:4.2.8)'
  id: totrans-17
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[以feather格式保存和加载数据](#sec:4.2.8)'
- en: '[Generating plots with matplotlib](#sec:plt)'
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[使用matplotlib生成绘图](#sec:plt)'
- en: '[Representing and processing data with NumPy](#sec:4.4)'
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[使用NumPy表示和处理数据](#sec:4.4)'
- en: 'Before we dig more into machine learning, let''s get familiar with our primary
    development tools. The code samples in this book explicitly or implicitly use
    the following important libraries that form the backbone of machine learning with
    Python for structured data:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们深入机器学习之前，让我们熟悉我们的主要开发工具。本书中的代码示例明确或隐式地使用了以下重要的库，这些库构成了使用Python进行结构化数据机器学习的核心：
- en: '[Pandas](https://pandas.pydata.org/) provides the key data structures we use
    to hold training and validation sets: data frames and series (columns of data).'
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[Pandas](https://pandas.pydata.org/)提供了我们用来存储训练和验证集的关键数据结构：数据框和序列（数据列）。'
- en: '[NumPy](http://www.NumPy.org/) provides an efficient n-dimensional array data
    structure used by the other libraries.'
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[NumPy](http://www.NumPy.org/)提供了一个高效的n维数组数据结构，被其他库使用。'
- en: '[matplotlib](https://matplotlib.org/) provides sophisticated 2D and 3D graphing
    facilities; Pandas delegates graphing to matplotlib.'
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[matplotlib](https://matplotlib.org/)提供了复杂的2D和3D绘图功能；Pandas将绘图委托给matplotlib。'
- en: '[scikit-learn](http://scikit-learn.org/), abbreviated `sklearn`, has the machine
    learning models, validation functions, error metrics, and a wide range of data
    processing facilities.'
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[scikit-learn](http://scikit-learn.org/)，简称`sklearn`，包含机器学习模型、验证函数、错误度量以及广泛的数据处理功能。'
- en: In the last chapter, we got a taste of using sklearn to train models, and so
    this chapter we'll focus on the basics of pandas, NumPy, and matplotlib. The development
    environment we recommend is [Jupyter Lab](http://jupyterlab.readthedocs.io/en/latest/getting_started/overview.html),
    but you're free to use whatever you're comfortable with. You can skip this chapter
    if you're itching to get started building models, but it's a good idea to at least
    scan this chapter to learn what's possible with the libraries before moving on.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，我们尝试了使用sklearn来训练模型，因此在这一章中，我们将重点关注pandas、NumPy和matplotlib的基础知识。我们推荐的开发环境是[Jupyter
    Lab](http://jupyterlab.readthedocs.io/en/latest/getting_started/overview.html)，但你可以自由选择你感到舒适的环境。如果你急于开始构建模型，可以跳过这一章，但至少浏览这一章，了解在继续之前这些库能做什么。
- en: 4.1 Your machine learning development environment
  id: totrans-26
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 4.1 你的机器学习开发环境
- en: Over the last 30 years, there's been remarkable progress in the development
    of IDEs that make programmers very efficient, such as Intellij, Eclipse, VisualStudio,
    etc... Their focus, however, is on creating and navigating large programs, the
    opposite of our small machine learning scripts. More importantly, those IDEs have
    little to no support for interactive programming, but that's exactly what we need
    to be effective in machine learning. While Terence and Jeremy are strong advocates
    of IDEs in general, IDEs are less useful in the special circumstances of machine
    learning.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 在过去的30年里，IDEs（集成开发环境）的发展取得了显著的进步，使得程序员的工作效率大大提高，例如Intellij、Eclipse、VisualStudio等。然而，它们的焦点在于创建和导航大型程序，这与我们的小型机器学习脚本正好相反。更重要的是，这些IDEs对交互式编程的支持很少甚至没有，但这正是我们在机器学习中需要有效利用的。虽然Terence和Jeremy是IDEs的强烈支持者，但在机器学习的特殊情况下，IDEs的作用较小。
- en: 1All of the code snippets you see in this book, even the ones to generate figures,
    can be found in the [notebooks](https://mlbook.explained.ai/notebooks/index.html)
    generated from this book.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 1本书中看到的所有代码片段，即使是生成图形的代码，都可以在从本书生成的[notebooks](https://mlbook.explained.ai/notebooks/index.html)中找到。
- en: Instead, we recommend [Jupyter Notebooks](https://jupyter-notebook.readthedocs.io/en/stable/notebook.html),
    which are web-based documents with embedded code, akin to [literate programming](https://en.wikipedia.org/wiki/Literate_programming),
    that intersperses the generated output with the code.1 Notebooks are well-suited
    to both development and presentation. To access notebooks, we're going to use
    the recently-introduced [Jupyter Lab](http://jupyterlab.readthedocs.io/en/latest/getting_started/overview.html)
    because of its improved user interface. (It should be out of beta by the time
    you're reading this book.) Let's fire up a notebook to appreciate the difference
    between it and a traditional IDE.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 相反，我们推荐[Jupyter Notebooks](https://jupyter-notebook.readthedocs.io/en/stable/notebook.html)，它们是基于网络的文档，具有嵌入的代码，类似于[literate
    programming](https://en.wikipedia.org/wiki/Literate_programming)，生成的输出与代码交织在一起。Notebooks非常适合开发和演示。为了访问notebooks，我们将使用最近引入的[Jupyter
    Lab](http://jupyterlab.readthedocs.io/en/latest/getting_started/overview.html)，因为它具有改进的用户界面。（在你阅读这本书的时候，它应该已经脱离测试阶段了。）让我们启动一个notebook来欣赏它与传统IDE之间的区别。
- en: 'First, let''s make sure that we have the latest version of Jupyter Lab by running
    this from the Mac/Unix command line or Windows “anaconda prompt” (search for “anaconda
    prompt” from the Start menu):'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们确保我们拥有Jupyter Lab的最新版本，通过在Mac/Unix命令行或Windows“anaconda prompt”（从开始菜单搜索“anaconda
    prompt”）中运行以下命令：
- en: '[PRE0]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: The `conda` program is a packaging system like the usual Python `pip` tool,
    but has the advantage that it can also install non-Python files (like C/Fortran
    code often used by scientific packages for performance reasons.)
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: '`conda`程序是一个类似于常规Python `pip`工具的打包系统，但它有一个优点，即它还可以安装非Python文件（例如，出于性能原因，科学包经常使用的C/Fortran代码。）'
- en: 'Before launching jupyter, it''s a good idea to create and jump into a directory
    where you can keep all of your work for this book. For example, you might do something
    like this sequence of commands (or the equivalent with your operating system GUI):'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 在启动jupyter之前，创建并跳转到可以保存这本书所有工作的目录是个好主意。例如，您可能需要执行以下命令序列（或与您的操作系统GUI等效）：
- en: '[PRE1]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: On Windows, your user directory is `C:\Users\YOURID`.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 在Windows上，您的用户目录是`C:\Users\YOURID`。
- en: 'Let''s also make a data directory underneath `/Users/YOURID/mlbook` so that
    our notebooks can access data files easily:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在`/Users/YOURID/mlbook`下也创建一个数据目录，这样我们的笔记本就可以轻松访问数据文件：
- en: '[PRE2]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: So that we have some data to play with, download and unzip the [data/rent-ideal.csv.zip](https://mlbook.explained.ai/data/rent-ideal.csv.zip)
    file into the `/Users/YOURID/mlbook/data` directory.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 为了让我们有一些数据可以操作，请下载并解压[data/rent-ideal.csv.zip](https://mlbook.explained.ai/data/rent-ideal.csv.zip)文件到`/Users/YOURID/mlbook/data`目录。
- en: 'Launch the local Jupyter web server that provides the interface by running
    `jupyter lab` from the command line:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 通过在命令行中运行`jupyter lab`来启动提供界面的本地Jupyter网络服务器：
- en: '[PRE3]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: '![](../Images/d9cb32fb2cd3f064ffb3a456ebc2141b.png)'
  id: totrans-41
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../Images/d9cb32fb2cd3f064ffb3a456ebc2141b.png)'
- en: '**Figure 4.1**. Initial Jupyter Lab screen![](../Images/e3af0a2a3881daafbfbc0e9a54348ff2.png)'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: '**图4.1**. 初始Jupyter Lab屏幕![图片](../Images/e3af0a2a3881daafbfbc0e9a54348ff2.png)'
- en: '**Figure 4.2**. Jupyter Lab after creating Python 3 notebook'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: '**图4.2**. 创建Python 3笔记本后的Jupyter Lab'
- en: Running that command should also open a browser window that looks like **Figure
    4.1**. That notebook communicates with the Jupyter Lab server via good old http,
    the web protocol. Clicking on the “Python 3” icon under the “Notebook” category,
    will create and open a new notebook window that looks like **Figure 4.2**. Cut-and-paste
    the following code into the empty *notebook cell*, replacing the data file name
    as appropriate for your directory structure (our set up has file `rent-ideal.csv`
    in the `mlbook/data` subdirectory).
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 运行该命令还应该打开一个看起来像 **图 4.1** 的浏览器窗口。该笔记本通过古老的 http 协议与 Jupyter Lab 服务器通信。在“笔记本”类别下点击“Python
    3”图标，将创建并打开一个看起来像 **图 4.2** 的新笔记本窗口。将以下代码复制到空白的 *笔记本单元格* 中，并根据您的目录结构适当替换数据文件名（我们的设置中在
    `mlbook/data` 子目录中有文件 `rent-ideal.csv`）。
- en: '[PRE4]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: '![](../Images/0b2e41e2042104f08990f91f337bc88b.png)'
  id: totrans-46
  prefs: []
  type: TYPE_IMG
  zh: '![图 4.3](../Images/0b2e41e2042104f08990f91f337bc88b.png)'
- en: '**Figure 4.3**. Jupyter Lab with one code cell and output'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: '**图 4.3**. 带有一个代码单元格和输出的 Jupyter Lab'
- en: 'After pasting, hit shift-enter in the cell (hold the shift key and then hit
    enter), which will execute and display results like **Figure 4.3**. Of course,
    this would also work from the usual interactive Python shell:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 在单元格中粘贴后，按 shift-enter 键（同时按住 shift 键然后按 enter），这将执行并显示类似于 **图 4.3** 的结果。当然，这也可以从通常的交互式
    Python 命令行中工作：
- en: '[PRE5]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'We could also save that code snippet into a file called `dump.py` and run it,
    either from within a Python development environment like [PyCharm](https://www.jetbrains.com/pycharm/)
    or from the command line:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 我们也可以将这段代码片段保存到一个名为 `dump.py` 的文件中并运行它，无论是从像 [PyCharm](https://www.jetbrains.com/pycharm/)
    这样的 Python 开发环境内部，还是从命令行：
- en: '[PRE6]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: '![](../Images/f6f73bd3f185e62282a11a357c228a07.png)'
  id: totrans-52
  prefs: []
  type: TYPE_IMG
  zh: '![图 4.4](../Images/f6f73bd3f185e62282a11a357c228a07.png)'
- en: '**Figure 4.4**. Jupyter Lab cell with pandas CSV load![](../Images/7256196838f3147e725da2612f6b4d23.png)'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: '**图 4.4**. Jupyter Lab 中的 pandas CSV 加载单元格![图 4.4](../Images/7256196838f3147e725da2612f6b4d23.png)'
- en: '**Figure 4.5**. Notebook with graph output'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: '**图 4.5**. 包含图形输出的笔记本'
- en: Notebooks have some big advantages over the interactive Python shell. Because
    the Python shell is using an old-school terminal, it has very limited display
    options whereas notebooks can nicely display tables and even embed graphs inline.
    For example, **Figure 4.4** shows what pandas dataframes look like in Jupyter
    Lab. **Figure 4.5** illustrates how to generate a histogram of rent prices that
    appears inline right after the code. Click the “+” button on the tab of the notebook
    to get a new cell (if necessary), paste in the following code, then hit shift-enter.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 笔记本相对于交互式 Python 命令行有一些很大的优势。因为 Python 命令行使用的是老式的终端，所以它的显示选项非常有限，而笔记本可以很好地显示表格，甚至可以内嵌图形。例如，**图
    4.4** 展示了 pandas 数据框在 Jupyter Lab 中的样子。**图 4.5** 阐述了如何在代码后面立即生成租金价格的直方图。点击笔记本标签页上的“+”按钮以获取一个新的单元格（如果需要），粘贴以下代码，然后按
    shift-enter。
- en: '[PRE7]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: (We'll learn more about loading dataframes and creating graphs below.)
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: （我们将在下面学习更多关于加载数据框和创建图形的知识。）
- en: The Python shell also has the disadvantage that all of the code we type disappears
    when the shell exits. Notebooks also execute code through Python shells (running
    within Jupyter Lab's web server), but the notebooks themselves are stored as `.ipynb`
    files on the disk. Killing the Python process associated with a notebook does
    not affect or delete the notebook file. Not only that, when you restart the notebook,
    all of the output captured during the last run is cached in the notebook file
    and immediately shown upon Jupyter Lab start up.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: Python 命令行也有一个缺点，那就是当我们退出 shell 时，我们输入的所有代码都会消失。笔记本也通过 Python 命令行（在 Jupyter
    Lab 的网络服务器中运行）执行代码，但笔记本本身是以 `.ipynb` 文件的形式存储在磁盘上的。终止与笔记本关联的 Python 进程不会影响或删除笔记本文件。不仅如此，当你重新启动笔记本时，上一次运行期间捕获的所有输出都会缓存在笔记本文件中，并在
    Jupyter Lab 启动时立即显示。
- en: Programming with traditional Python `.py` files means we don't lose our work
    when Python exits, but we lose interactive programming. Because of its iterative
    nature, creating and testing machine learning models rely heavily on interactive
    programming in order to perform lots of little experiments. If loading the data
    alone takes, say, 5 minutes, we can't restart the entire program for every experiment.
    We need the ability to iterate quickly. Using a Python debugger from within an
    IDE does let us examine the results of each step of a program, but the programming
    part is not interactive; we have to restart the entire program after making changes.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 使用传统的 Python `.py` 文件进行编程意味着当 Python 退出时，我们不会丢失我们的工作，但我们失去了交互式编程。由于其迭代性，创建和测试机器学习模型在很大程度上依赖于交互式编程以执行大量的小实验。如果仅加载数据就需要，比如说，5
    分钟，我们就不能为每个实验重新启动整个程序。我们需要快速迭代的能力。使用 IDE 内的 Python 调试器确实可以让我们检查程序每个步骤的结果，但编程部分不是交互式的；在做出更改后，我们必须重新启动整个程序。
- en: So notebooks combine the important interactive nature of the Python shell with
    the persistence of files. Because notebooks keep graphics and other output within
    the document containing the code, it's very easy to see what a program is doing.
    That's particularly useful for presenting results or continuing someone else's
    work. You're free to use whatever development environment you find comfortable,
    of course, but we strongly recommend Jupyter notebooks. If you follow this recommendation,
    it's a good idea to go through some of the Jupyter tutorials and videos out there
    to get familiar with your tools.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 笔记本结合了 Python 壳的交互式重要性和文件的持久性。因为笔记本将图形和其他输出保留在包含代码的文档中，所以很容易看到程序正在做什么。这对于展示结果或继续他人的工作特别有用。当然，您可以使用您觉得舒适的任何开发环境，但我们强烈推荐
    Jupyter 笔记本。如果您遵循这个建议，查看一些 Jupyter 教程和视频是个好主意，以便熟悉您的工具。
- en: 4.2 Dataframe Dojo
  id: totrans-61
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 4.2 数据分析道场
- en: Before we can use the machine learning models in sklearn, we have to load and
    prepare data, for which we'll use pandas. We recommend that you get a copy of
    Wes McKinney's book, “Python for Data Analysis,” but this section covers a key
    subset of pandas functionality to get you started. (You can also check out the
    [notebooks](https://github.com/wesm/pydata-book) from McKinney's book.) The goal
    here is to get you started with the basics so that you can get the gist of the
    examples in this book and can learn more on your own via stackoverflow and other
    resources.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们可以使用 sklearn 中的机器学习模型之前，我们必须加载和准备数据，我们将使用 pandas 来完成这项工作。我们建议您获取 Wes McKinney
    的书籍《Python for Data Analysis》的副本，但本节涵盖了 pandas 功能的关键子集，以便您开始。（您也可以查看 McKinney
    书籍中的 [notebooks](https://github.com/wesm/pydata-book)。）这里的目的是让您从基础知识开始，以便您能够理解本书中的示例，并且可以通过
    stackoverflow 和其他资源自行学习更多。
- en: 4.2.1 Loading and examining data
  id: totrans-63
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 4.2.1 加载数据和检查
- en: 'The first step in the machine learning pipeline is to load data of interest.
    In many cases, the data is in a comma-separated value (CSV) file and pandas has
    a fast and flexible CSV reader:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 机器学习流程的第一步是加载感兴趣的数据。在许多情况下，数据存储在逗号分隔值（CSV）文件中，pandas 提供了一个快速灵活的 CSV 读取器：
- en: '[PRE8]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: '|   | bedrooms | bathrooms | latitude | longitude | price |'
  id: totrans-66
  prefs: []
  type: TYPE_TB
  zh: '|   | 卧室 | 卫生间 | 纬度 | 经度 | 价格 |'
- en: '| --- | --- | --- | --- | --- | --- |'
  id: totrans-67
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- | --- | --- | --- |'
- en: '|  |'
  id: totrans-68
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '| --- |'
  id: totrans-69
  prefs: []
  type: TYPE_TB
  zh: '| --- |'
- en: '| 0 | 3 | 1.5000 | 40.7145 | -73.9425 | 3000 |'
  id: totrans-70
  prefs: []
  type: TYPE_TB
  zh: '| 0 | 3 | 1.5000 | 40.7145 | -73.9425 | 3000 |'
- en: '| 1 | 2 | 1.0000 | 40.7947 | -73.9667 | 5465 |'
  id: totrans-71
  prefs: []
  type: TYPE_TB
  zh: '| 1 | 2 | 1.0000 | 40.7947 | -73.9667 | 5465 |'
- en: '| 2 | 1 | 1.0000 | 40.7388 | -74.0018 | 2850 |'
  id: totrans-72
  prefs: []
  type: TYPE_TB
  zh: '| 2 | 1 | 1.0000 | 40.7388 | -74.0018 | 2850 |'
- en: '| 3 | 1 | 1.0000 | 40.7539 | -73.9677 | 3275 |'
  id: totrans-73
  prefs: []
  type: TYPE_TB
  zh: '| 3 | 1 | 1.0000 | 40.7539 | -73.9677 | 3275 |'
- en: '| 4 | 4 | 1.0000 | 40.8241 | -73.9493 | 3350 |'
  id: totrans-74
  prefs: []
  type: TYPE_TB
  zh: '| 4 | 4 | 1.0000 | 40.8241 | -73.9493 | 3350 |'
- en: 'The `head()` method shows the first five records in the data frame, but we
    can pass an argument to specify the number of records. Data sets with many columns
    are usually too wide to view on screen without scrolling, which we can overcome
    by transposing (flipping) the data frame using the `T` property:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: '`head()` 方法显示数据框中的前五条记录，但我们可以传递一个参数来指定记录数。具有许多列的数据集通常太宽，无法在屏幕上滚动查看，我们可以通过使用
    `T` 属性翻转数据框来解决这个问题：'
- en: '[PRE9]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: '|   | 0 | 1 |'
  id: totrans-77
  prefs: []
  type: TYPE_TB
  zh: '|   | 0 | 1 |'
- en: '| --- | --- | --- |'
  id: totrans-78
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '|  |'
  id: totrans-79
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '| --- |'
  id: totrans-80
  prefs: []
  type: TYPE_TB
  zh: '| --- |'
- en: '| bedrooms | 3.0000 | 2.0000 |'
  id: totrans-81
  prefs: []
  type: TYPE_TB
  zh: '| 卧室 | 3.0000 | 2.0000 |'
- en: '| bathrooms | 1.5000 | 1.0000 |'
  id: totrans-82
  prefs: []
  type: TYPE_TB
  zh: '| 卫生间 | 1.5000 | 1.0000 |'
- en: '| latitude | 40.7145 | 40.7947 |'
  id: totrans-83
  prefs: []
  type: TYPE_TB
  zh: '| 纬度 | 40.7145 | 40.7947 |'
- en: '| longitude | -73.9425 | -73.9667 |'
  id: totrans-84
  prefs: []
  type: TYPE_TB
  zh: '| 经度 | -73.9425 | -73.9667 |'
- en: '| price | 3000.0000 | 5465.0000 |'
  id: totrans-85
  prefs: []
  type: TYPE_TB
  zh: '| 价格 | 3000.0000 | 5465.0000 |'
- en: 'In this way, the columns become rows and wide data frames become tall instead.
    To get meta-information about the data frame, use method `info()`:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 以这种方式，列变成了行，宽数据框变成了高数据框。要获取数据框的元信息，使用方法 `info()`：
- en: '[PRE10]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: '<class ''pandas.core.frame.DataFrame''> RangeIndex: 48300 entries, 0 to 48299
    Data columns (total 5 columns): bedrooms 48300 non-null int64 bathrooms 48300
    non-null float64 latitude 48300 non-null float64 longitude 48300 non-null float64
    price 48300 non-null int64 dtypes: float64(3), int64(2) memory usage: 1.8 MB'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: <class 'pandas.core.frame.DataFrame'> 范围索引：48300 个条目，0 到 48299 数据列（总计 5 列）：卧室
    48300 个非空 int64 卫生间 48300 个非空 float64 纬度 48300 个非空 float64 经度 48300 个非空 float64
    价格 48300 个非空 int64 数据类型：float64（3），int64（2）内存使用：1.8 MB
- en: 'It''s often useful to get a list of the column names, which we can do easily
    with a dataframe property:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 获取列名列表通常很有用，我们可以通过数据框属性轻松实现：
- en: '[PRE11]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Index(['bedrooms', 'bathrooms', 'latitude', 'longitude', 'price'], dtype='object')
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 索引(['卧室', '卫生间', '纬度', '经度', '价格'], 数据类型='object')
- en: 'And, to learn something about the data itself, use `describe()`:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 要了解数据本身的一些信息，请使用 `describe()`：
- en: '[PRE12]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: '|   | bedrooms | bathrooms | latitude | longitude | price |'
  id: totrans-94
  prefs: []
  type: TYPE_TB
  zh: '|   | 卧室 | 卫生间 | 纬度 | 经度 | 价格 |'
- en: '| --- | --- | --- | --- | --- | --- |'
  id: totrans-95
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- | --- | --- | --- |'
- en: '|  |'
  id: totrans-96
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '| --- |'
  id: totrans-97
  prefs: []
  type: TYPE_TB
  zh: '| --- |'
- en: '| count | 48300.0000 | 48300.0000 | 48300.0000 | 48300.0000 | 48300.0000 |'
  id: totrans-98
  prefs: []
  type: TYPE_TB
  zh: '| 计数 | 48300.0000 | 48300.0000 | 48300.0000 | 48300.0000 | 48300.0000 |'
- en: '| mean | 1.5088 | 1.1783 | 40.7508 | -73.9724 | 3438.2980 |'
  id: totrans-99
  prefs: []
  type: TYPE_TB
  zh: '| 平均值 | 1.5088 | 1.1783 | 40.7508 | -73.9724 | 3438.2980 |'
- en: '| std | 1.0922 | 0.4261 | 0.0396 | 0.0296 | 1401.4222 |'
  id: totrans-100
  prefs: []
  type: TYPE_TB
  zh: '| 标准差 | 1.0922 | 0.4261 | 0.0396 | 0.0296 | 1401.4222 |'
- en: '| min | 0.0000 | 0.0000 | 40.5712 | -74.0940 | 1025.0000 |'
  id: totrans-101
  prefs: []
  type: TYPE_TB
  zh: '| 最小值 | 0.0000 | 0.0000 | 40.5712 | -74.0940 | 1025.0000 |'
- en: '| 25% | 1.0000 | 1.0000 | 40.7281 | -73.9917 | 2495.0000 |'
  id: totrans-102
  prefs: []
  type: TYPE_TB
  zh: '| 25% | 1.0000 | 1.0000 | 40.7281 | -73.9917 | 2495.0000 |'
- en: '| 50% | 1.0000 | 1.0000 | 40.7516 | -73.9779 | 3100.0000 |'
  id: totrans-103
  prefs: []
  type: TYPE_TB
  zh: '| 50% | 1.0000 | 1.0000 | 40.7516 | -73.9779 | 3100.0000 |'
- en: '| 75% | 2.0000 | 1.0000 | 40.7740 | -73.9547 | 4000.0000 |'
  id: totrans-104
  prefs: []
  type: TYPE_TB
  zh: '| 75% | 2.0000 | 1.0000 | 40.7740 | -73.9547 | 4000.0000 |'
- en: '| max | 8.0000 | 10.0000 | 40.9154 | -73.7001 | 9999.0000 |'
  id: totrans-105
  prefs: []
  type: TYPE_TB
  zh: '| 最大值 | 8.0000 | 10.0000 | 40.9154 | -73.7001 | 9999.0000 |'
- en: 'There are also methods to give you a subset of that information, such as the
    average of each column:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 也有方法可以提供该信息的子集，例如每列的平均值：
- en: '[PRE13]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'bedrooms 1.508799 bathrooms 1.178313 latitude 40.750782 longitude -73.972365
    price 3438.297950 dtype: float64'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 卧室 1.508799 卫生间 1.178313 纬度 40.750782 经度 -73.972365 价格 3438.297950 数据类型：float64
- en: 'To get the number of apartments with a specific number of bedrooms, use the
    `value_counts()` method:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 要获取具有特定数量卧室的公寓数量，请使用 `value_counts()` 方法：
- en: '[PRE14]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: '1 15718 2 14451 0 9436 3 6777 4 1710 5 169 6 36 8 2 7 1 Name: bedrooms, dtype:
    int64'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 1 15718 2 14451 0 9436 3 6777 4 1710 5 169 6 36 8 2 7 1 名称：卧室，数据类型：int64
- en: 'We can also easily sort a dataframe by a specific column:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以轻松按特定列对数据框进行排序：
- en: '[PRE15]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: '|   | bedrooms | bathrooms | latitude | longitude | price |'
  id: totrans-114
  prefs: []
  type: TYPE_TB
  zh: '|   | 卧室 | 卫生间 | 纬度 | 经度 | 价格 |'
- en: '| --- | --- | --- | --- | --- | --- |'
  id: totrans-115
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- | --- | --- | --- |'
- en: '|  |'
  id: totrans-116
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '| --- |'
  id: totrans-117
  prefs: []
  type: TYPE_TB
  zh: '| --- |'
- en: '| 47540 | 6 | 3.0000 | 40.7287 | -73.9856 | 9999 |'
  id: totrans-118
  prefs: []
  type: TYPE_TB
  zh: '| 47540 | 6 | 3.0000 | 40.7287 | -73.9856 | 9999 |'
- en: '| 27927 | 3 | 3.0000 | 40.7934 | -73.9743 | 9999 |'
  id: totrans-119
  prefs: []
  type: TYPE_TB
  zh: '| 27927 | 3 | 3.0000 | 40.7934 | -73.9743 | 9999 |'
- en: '| 17956 | 6 | 3.0000 | 40.7287 | -73.9856 | 9999 |'
  id: totrans-120
  prefs: []
  type: TYPE_TB
  zh: '| 17956 | 6 | 3.0000 | 40.7287 | -73.9856 | 9999 |'
- en: '| 2282 | 3 | 2.0000 | 40.7802 | -73.9565 | 9995 |'
  id: totrans-121
  prefs: []
  type: TYPE_TB
  zh: '| 2282 | 3 | 2.0000 | 40.7802 | -73.9565 | 9995 |'
- en: '| 16122 | 5 | 2.5000 | 40.7103 | -74.0060 | 9995 |'
  id: totrans-122
  prefs: []
  type: TYPE_TB
  zh: '| 16122 | 5 | 2.5000 | 40.7103 | -74.0060 | 9995 |'
- en: 4.2.2 Extracting subsets
  id: totrans-123
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 4.2.2 提取子集
- en: 'Preparing data for use in a model often means extracting subsets, such as a
    subset of the columns or a subset of the rows. Getting a single column of data
    is particularly convenient in pandas because each of the columns looks like a
    dataframe object property. For example, here''s how to extract the `price` column
    from data frame `df` as a `Series` object:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 准备数据用于模型通常意味着提取子集，例如列的子集或行的子集。在 pandas 中，获取单个数据列特别方便，因为每个列看起来都像一个数据框对象属性。例如，以下是如何从数据框
    `df` 中提取 `price` 列作为 `Series` 对象：
- en: '[PRE16]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: '<class ''pandas.core.series.Series''> 0 3000 1 5465 2 2850 3 3275 4 3350 Name:
    price, dtype: int64'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: <class 'pandas.core.series.Series'> 0 3000 1 5465 2 2850 3 3275 4 3350 名称：价格，数据类型：int64
- en: '`df.price` is equivalent to the slightly more verbose `df[''price'']`, except
    that `df.price` does not work on the left-hand side of an assignment when trying
    to create a new column (see **Section 4.2.5** *Injecting new dataframe columns*).'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: '`df.price` 等同于稍微冗长的 `df[''price'']`，但 `df.price` 在尝试创建新列时不能用于赋值操作左侧（见**第 4.2.5
    节** *注入新的数据框列*）。'
- en: Once we have a series, there are lots of useful functions we can call, such
    as the following.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们有一个序列，就有很多有用的函数可以调用，例如以下这些。
- en: '[PRE17]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 1025 3438.297950310559 9999
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 1025 3438.297950310559 9999
- en: 'If we need more than one column, we can get a dataframe with a subset of the
    columns (not a list of `Series` objects):'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 'If we need more than one column, we can get a dataframe with a subset of the
    columns (not a list of `Series` objects):'
- en: '[PRE18]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: <class 'pandas.core.frame.DataFrame'>
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: <class 'pandas.core.frame.DataFrame'>
- en: '|   | bathrooms | price |'
  id: totrans-134
  prefs: []
  type: TYPE_TB
  zh: '|   | 卫生间 | 价格 |'
- en: '| --- | --- | --- |'
  id: totrans-135
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '|  |'
  id: totrans-136
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '| --- |'
  id: totrans-137
  prefs: []
  type: TYPE_TB
  zh: '| --- |'
- en: '| 0 | 1.5000 | 3000 |'
  id: totrans-138
  prefs: []
  type: TYPE_TB
  zh: '| 0 | 1.5000 | 3000 |'
- en: '| 1 | 1.0000 | 5465 |'
  id: totrans-139
  prefs: []
  type: TYPE_TB
  zh: '| 1 | 1.0000 | 5465 |'
- en: '| 2 | 1.0000 | 2850 |'
  id: totrans-140
  prefs: []
  type: TYPE_TB
  zh: '| 2 | 1.0000 | 2850 |'
- en: '| 3 | 1.0000 | 3275 |'
  id: totrans-141
  prefs: []
  type: TYPE_TB
  zh: '| 3 | 1.0000 | 3275 |'
- en: '| 4 | 1.0000 | 3350 |'
  id: totrans-142
  prefs: []
  type: TYPE_TB
  zh: '| 4 | 1.0000 | 3350 |'
- en: 'Data sets typically consist of multiple columns of features and a single column
    representing the target variable. To separate these for use in training our model,
    we can explicitly select all future columns or use `drop()`:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 'Data sets typically consist of multiple columns of features and a single column
    representing the target variable. To separate these for use in training our model,
    we can explicitly select all future columns or use `drop()`:'
- en: '[PRE19]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: '|   | bedrooms | bathrooms | latitude | longitude |'
  id: totrans-145
  prefs: []
  type: TYPE_TB
  zh: '|   | 卧室 | 卫生间 | 纬度 | 经度 |'
- en: '| --- | --- | --- | --- | --- |'
  id: totrans-146
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- | --- | --- |'
- en: '|  |'
  id: totrans-147
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '| --- |'
  id: totrans-148
  prefs: []
  type: TYPE_TB
  zh: '| --- |'
- en: '| 0 | 3 | 1.5000 | 40.7145 | -73.9425 |'
  id: totrans-149
  prefs: []
  type: TYPE_TB
  zh: '| 0 | 3 | 1.5000 | 40.7145 | -73.9425 |'
- en: '| 1 | 2 | 1.0000 | 40.7947 | -73.9667 |'
  id: totrans-150
  prefs: []
  type: TYPE_TB
  zh: '| 1 | 2 | 1.0000 | 40.7947 | -73.9667 |'
- en: '| 2 | 1 | 1.0000 | 40.7388 | -74.0018 |'
  id: totrans-151
  prefs: []
  type: TYPE_TB
  zh: '| 2 | 1 | 1.0000 | 40.7388 | -74.0018 |'
- en: The `axis=1` bit is a little inconvenient but it specifies we'd like to drop
    a column and not a row (`axis=0`). The `drop()` method does not alter the dataframe;
    instead it returns a view of the dataframe without the indicated column.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: The `axis=1` bit is a little inconvenient but it specifies we'd like to drop
    a column and not a row (`axis=0`). The `drop()` method does not alter the dataframe;
    instead it returns a view of the dataframe without the indicated column.
- en: 'Getting a specific row or a subset of the rows by row number involves using
    the `iloc` dataframe property. For example, here''s how to get the first row of
    the dataframe as a `Series` object:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 'Getting a specific row or a subset of the rows by row number involves using
    the `iloc` dataframe property. For example, here''s how to get the first row of
    the dataframe as a `Series` object:'
- en: '[PRE20]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: '<class ''pandas.core.series.Series''> bedrooms 3.0000 bathrooms 1.5000 latitude
    40.7145 longitude -73.9425 price 3000.0000 Name: 0, dtype: float64'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: '<class ''pandas.core.series.Series''> 卧室 3.0000 卫生间 1.5000 纬度 40.7145 经度 -73.9425
    价格 3000.0000 名称: 0, 数据类型: float64'
- en: 'and here''s how to get the first two rows as a dataframe:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 'and here''s how to get the first two rows as a dataframe:'
- en: '[PRE21]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: '|   | bedrooms | bathrooms | latitude | longitude | price |'
  id: totrans-158
  prefs: []
  type: TYPE_TB
  zh: '|   | 卧室 | 卫生间 | 纬度 | 经度 | 价格 |'
- en: '| --- | --- | --- | --- | --- | --- |'
  id: totrans-159
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- | --- | --- | --- |'
- en: '|  |'
  id: totrans-160
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '| --- |'
  id: totrans-161
  prefs: []
  type: TYPE_TB
  zh: '| --- |'
- en: '| 0 | 3 | 1.5000 | 40.7145 | -73.9425 | 3000 |'
  id: totrans-162
  prefs: []
  type: TYPE_TB
  zh: '| 0 | 3 | 1.5000 | 40.7145 | -73.9425 | 3000 |'
- en: '| 1 | 2 | 1.0000 | 40.7947 | -73.9667 | 5465 |'
  id: totrans-163
  prefs: []
  type: TYPE_TB
  zh: '| 1 | 2 | 1.0000 | 40.7947 | -73.9667 | 5465 |'
- en: 'Those `iloc` accessors implicitly get all columns, but we can be more explicit
    with the `:` slice operator as the second dimension:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 'Those `iloc` accessors implicitly get all columns, but we can be more explicit
    with the `:` slice operator as the second dimension:'
- en: '[PRE22]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'bedrooms 3.0000 bathrooms 1.5000 latitude 40.7145 longitude -73.9425 price
    3000.0000 Name: 0, dtype: float64'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: '卧室 3.0000 卫生间 1.5000 纬度 40.7145 经度 -73.9425 价格 3000.0000 名称: 0, 数据类型: float64'
- en: 'Or, we can use a list of integer indexes to get specific columns:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 'Or, we can use a list of integer indexes to get specific columns:'
- en: '[PRE23]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'bedrooms 3.0 price 3000.0 Name: 0, dtype: float64'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: '卧室 3.0 价格 3000.0 名称: 0, 数据类型: float64'
- en: 'Generally, though, it''s easier to access columns by name by using `iloc` to
    get the row of interest and then using dataframe column indexing by name:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 'Generally, though, it''s easier to access columns by name by using `iloc` to
    get the row of interest and then using dataframe column indexing by name:'
- en: '[PRE24]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'bedrooms 3.0 price 3000.0 Name: 0, dtype: float64'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: '卧室 3.0 价格 3000.0 名称: 0, 数据类型: float64'
- en: 4.2.3 Dataframe Indexes
  id: totrans-173
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 4.2.3 数据框索引
- en: 'Data frames have indexes that make them behave like dictionaries, where a key
    maps to one or more rows of a dataframe. By default, the index is the row number,
    as shown here as the leftmost column:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 'Data frames have indexes that make them behave like dictionaries, where a key
    maps to one or more rows of a dataframe. By default, the index is the row number,
    as shown here as the leftmost column:'
- en: '[PRE25]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: '|   | bedrooms | bathrooms | latitude | longitude | price |'
  id: totrans-176
  prefs: []
  type: TYPE_TB
  zh: '|   | 卧室 | 卫生间 | 纬度 | 经度 | 价格 |'
- en: '| --- | --- | --- | --- | --- | --- |'
  id: totrans-177
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- | --- | --- | --- |'
- en: '|  |'
  id: totrans-178
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '| --- |'
  id: totrans-179
  prefs: []
  type: TYPE_TB
  zh: '| --- |'
- en: '| 0 | 3 | 1.5000 | 40.7145 | -73.9425 | 3000 |'
  id: totrans-180
  prefs: []
  type: TYPE_TB
  zh: '| 0 | 3 | 1.5000 | 40.7145 | -73.9425 | 3000 |'
- en: '| 1 | 2 | 1.0000 | 40.7947 | -73.9667 | 5465 |'
  id: totrans-181
  prefs: []
  type: TYPE_TB
  zh: '| 1 | 2 | 1.0000 | 40.7947 | -73.9667 | 5465 |'
- en: '| 2 | 1 | 1.0000 | 40.7388 | -74.0018 | 2850 |'
  id: totrans-182
  prefs: []
  type: TYPE_TB
  zh: '| 2 | 1 | 1.0000 | 40.7388 | -74.0018 | 2850 |'
- en: 'The `loc` property performs an index lookup so `df.loc[0]` gets the row with
    key 0 (the first row):'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 'The `loc` property performs an index lookup so `df.loc[0]` gets the row with
    key 0 (the first row):'
- en: '[PRE26]'
  id: totrans-184
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'bedrooms 3.0000 bathrooms 1.5000 latitude 40.7145 longitude -73.9425 price
    3000.0000 Name: 0, dtype: float64'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: '卧室 3.0000 卫生间 1.5000 纬度 40.7145 经度 -73.9425 价格 3000.0000 名称: 0, 数据类型: float64'
- en: 'Because the index is the row number by default, `iloc` and `loc` give the same
    result. But we can set index to a column in our dataframe:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 'Because the index is the row number by default, `iloc` and `loc` give the same
    result. But we can set index to a column in our dataframe:'
- en: '[PRE27]'
  id: totrans-187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: '|   | bathrooms | latitude | longitude | price |'
  id: totrans-188
  prefs: []
  type: TYPE_TB
  zh: '|   | 卫生间 | 纬度 | 经度 | 价格 |'
- en: '| --- | --- | --- | --- | --- |'
  id: totrans-189
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- | --- | --- |'
- en: '| bedrooms |'
  id: totrans-190
  prefs: []
  type: TYPE_TB
  zh: '| 卧室 |'
- en: '| --- |'
  id: totrans-191
  prefs: []
  type: TYPE_TB
  zh: '| --- |'
- en: '| 3 | 1.5000 | 40.7145 | -73.9425 | 3000 |'
  id: totrans-192
  prefs: []
  type: TYPE_TB
  zh: '| 3 | 1.5000 | 40.7145 | -73.9425 | 3000 |'
- en: '| 2 | 1.0000 | 40.7947 | -73.9667 | 5465 |'
  id: totrans-193
  prefs: []
  type: TYPE_TB
  zh: '| 2 | 1.0000 | 40.7947 | -73.9667 | 5465 |'
- en: '| 1 | 1.0000 | 40.7388 | -74.0018 | 2850 |'
  id: totrans-194
  prefs: []
  type: TYPE_TB
  zh: '| 1 | 1.0000 | 40.7388 | -74.0018 | 2850 |'
- en: '| 1 | 1.0000 | 40.7539 | -73.9677 | 3275 |'
  id: totrans-195
  prefs: []
  type: TYPE_TB
  zh: '| 1 | 1.0000 | 40.7539 | -73.9677 | 3275 |'
- en: '| 4 | 1.0000 | 40.8241 | -73.9493 | 3350 |'
  id: totrans-196
  prefs: []
  type: TYPE_TB
  zh: '| 4 | 1.0000 | 40.8241 | -73.9493 | 3350 |'
- en: 'Using the index, we can get all 3-bedroom apartments:'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 使用索引，我们可以获取所有3卧室公寓：
- en: '[PRE28]'
  id: totrans-198
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: '|   | bathrooms | latitude | longitude | price |'
  id: totrans-199
  prefs: []
  type: TYPE_TB
  zh: '|   | 卫生间 | 纬度 | 经度 | 价格 |'
- en: '| --- | --- | --- | --- | --- |'
  id: totrans-200
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- | --- | --- |'
- en: '| bedrooms |'
  id: totrans-201
  prefs: []
  type: TYPE_TB
  zh: '| 卧室 |'
- en: '| --- |'
  id: totrans-202
  prefs: []
  type: TYPE_TB
  zh: '| --- |'
- en: '| 3 | 1.5000 | 40.7145 | -73.9425 | 3000 |'
  id: totrans-203
  prefs: []
  type: TYPE_TB
  zh: '| 3 | 1.5000 | 40.7145 | -73.9425 | 3000 |'
- en: '| 3 | 1.0000 | 40.7454 | -73.9845 | 4395 |'
  id: totrans-204
  prefs: []
  type: TYPE_TB
  zh: '| 3 | 1.0000 | 40.7454 | -73.9845 | 4395 |'
- en: '| 3 | 1.0000 | 40.7231 | -74.0044 | 3733 |'
  id: totrans-205
  prefs: []
  type: TYPE_TB
  zh: '| 3 | 1.0000 | 40.7231 | -74.0044 | 3733 |'
- en: '| 3 | 1.0000 | 40.7660 | -73.9914 | 4500 |'
  id: totrans-206
  prefs: []
  type: TYPE_TB
  zh: '| 3 | 1.0000 | 40.7660 | -73.9914 | 4500 |'
- en: '| 3 | 2.0000 | 40.7196 | -74.0109 | 6320 |'
  id: totrans-207
  prefs: []
  type: TYPE_TB
  zh: '| 3 | 2.0000 | 40.7196 | -74.0109 | 6320 |'
- en: Now that the index differs from the default row number index, `dfi.loc[3]` and
    `dfi.iloc[3]` no longer get the same data; `dfi.iloc[3]` gets 4th row (indexed
    from 0).
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 现在索引与默认行号索引不同，`dfi.loc[3]`和`dfi.iloc[3]`不再获取相同的数据；`dfi.iloc[3]`获取第4行（从0开始索引）。
- en: 'Setting the dataframe index to the `bedrooms` column means that `bedrooms`
    is no longer available as a column, which is inconvenient but a quirk to be aware
    of: `dfi[''bedrooms'']` gets error `KeyError: ''bedrooms''`. By resetting the
    index, `bedrooms` will reappear as a column and the default row number index will
    reappear:'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: '将数据框索引设置为“卧室”列意味着“卧室”不再作为列可用，这虽然不方便，但需要注意的一个特性：`dfi[''bedrooms'']`会得到错误`KeyError:
    ''bedrooms''`。通过重置索引，`bedrooms`将重新作为列出现，默认行号索引也将重新出现：'
- en: '[PRE29]'
  id: totrans-210
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: '|   | bedrooms | bathrooms | latitude | longitude | price |'
  id: totrans-211
  prefs: []
  type: TYPE_TB
  zh: '|   | 卧室 | 卫生间 | 纬度 | 经度 | 价格 |'
- en: '| --- | --- | --- | --- | --- | --- |'
  id: totrans-212
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- | --- | --- | --- |'
- en: '|  |'
  id: totrans-213
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '| --- |'
  id: totrans-214
  prefs: []
  type: TYPE_TB
  zh: '| --- |'
- en: '| 0 | 3 | 1.5000 | 40.7145 | -73.9425 | 3000 |'
  id: totrans-215
  prefs: []
  type: TYPE_TB
  zh: '| 0 | 3 | 1.5000 | 40.7145 | -73.9425 | 3000 |'
- en: '| 1 | 2 | 1.0000 | 40.7947 | -73.9667 | 5465 |'
  id: totrans-216
  prefs: []
  type: TYPE_TB
  zh: '| 1 | 2 | 1.0000 | 40.7947 | -73.9667 | 5465 |'
- en: '| 2 | 1 | 1.0000 | 40.7388 | -74.0018 | 2850 |'
  id: totrans-217
  prefs: []
  type: TYPE_TB
  zh: '| 2 | 1 | 1.0000 | 40.7388 | -74.0018 | 2850 |'
- en: 'Indexing pops up when trying to organize or reduce the data in a data frame.
    For example, grouping the rows by the values in a particular column makes that
    column the index. Here''s how to group the data by the number of bathrooms and
    compute the average value of the other columns:'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 在尝试组织或减少数据框中的数据时，会出现索引。例如，按特定列中的值对行进行分组，则该列成为索引。以下是按浴室数量分组数据并计算其他列平均值的示例：
- en: '[PRE30]'
  id: totrans-219
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: '|   | bedrooms | latitude | longitude | price |'
  id: totrans-220
  prefs: []
  type: TYPE_TB
  zh: '|   | 卧室 | 纬度 | 经度 | 价格 |'
- en: '| --- | --- | --- | --- | --- |'
  id: totrans-221
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- | --- | --- |'
- en: '| bathrooms |'
  id: totrans-222
  prefs: []
  type: TYPE_TB
  zh: '| 卫生间 |'
- en: '| --- |'
  id: totrans-223
  prefs: []
  type: TYPE_TB
  zh: '| --- |'
- en: '| 0.0000 | 0.8300 | 40.7561 | -73.9701 | 3144.8700 |'
  id: totrans-224
  prefs: []
  type: TYPE_TB
  zh: '| 0.0000 | 0.8300 | 40.7561 | -73.9701 | 3144.8700 |'
- en: '| 1.0000 | 1.2522 | 40.7509 | -73.9720 | 3027.0071 |'
  id: totrans-225
  prefs: []
  type: TYPE_TB
  zh: '| 1.0000 | 1.2522 | 40.7509 | -73.9720 | 3027.0071 |'
- en: '| 1.5000 | 2.2773 | 40.7489 | -73.9659 | 4226.3364 |'
  id: totrans-226
  prefs: []
  type: TYPE_TB
  zh: '| 1.5000 | 2.2773 | 40.7489 | -73.9659 | 4226.3364 |'
- en: '| 2.0000 | 2.6874 | 40.7495 | -73.9756 | 5278.5957 |'
  id: totrans-227
  prefs: []
  type: TYPE_TB
  zh: '| 2.0000 | 2.6874 | 40.7495 | -73.9756 | 5278.5957 |'
- en: '| 2.5000 | 2.8632 | 40.7562 | -73.9651 | 6869.0474 |'
  id: totrans-228
  prefs: []
  type: TYPE_TB
  zh: '| 2.5000 | 2.8632 | 40.7562 | -73.9651 | 6869.0474 |'
- en: '| 3.0000 | 3.2966 | 40.7597 | -73.9676 | 6897.9746 |'
  id: totrans-229
  prefs: []
  type: TYPE_TB
  zh: '| 3.0000 | 3.2966 | 40.7597 | -73.9676 | 6897.9746 |'
- en: '| 3.5000 | 3.8571 | 40.7487 | -73.9548 | 7635.3571 |'
  id: totrans-230
  prefs: []
  type: TYPE_TB
  zh: '| 3.5000 | 3.8571 | 40.7487 | -73.9548 | 7635.3571 |'
- en: '| 4.0000 | 4.6222 | 40.7563 | -73.9563 | 7422.8889 |'
  id: totrans-231
  prefs: []
  type: TYPE_TB
  zh: '| 4.0000 | 4.6222 | 40.7563 | -73.9563 | 7422.8889 |'
- en: '| 4.5000 | 1.0000 | 40.8572 | -73.9350 | 2050.0000 |'
  id: totrans-232
  prefs: []
  type: TYPE_TB
  zh: '| 4.5000 | 1.0000 | 40.8572 | -73.9350 | 2050.0000 |'
- en: '| 10.0000 | 2.0000 | 40.7633 | -73.9849 | 3600.0000 |'
  id: totrans-233
  prefs: []
  type: TYPE_TB
  zh: '| 10.0000 | 2.0000 | 40.7633 | -73.9849 | 3600.0000 |'
- en: 'If we want a dataframe that includes `bathrooms` as a column, we have to reset
    the indexCan''t access `bybaths[[''bathrooms'',''price'']]`, must reset first:'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们想要一个包含“卫生间”作为列的数据框，我们必须重置索引。无法访问`bybaths[['bathrooms','price']]`，必须先重置：
- en: '[PRE31]'
  id: totrans-235
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: '|   | bathrooms | bedrooms | latitude | longitude | price |'
  id: totrans-236
  prefs: []
  type: TYPE_TB
  zh: '|   | 卫生间 | 卧室 | 纬度 | 经度 | 价格 |'
- en: '| --- | --- | --- | --- | --- | --- |'
  id: totrans-237
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- | --- | --- | --- |'
- en: '|  |'
  id: totrans-238
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '| --- |'
  id: totrans-239
  prefs: []
  type: TYPE_TB
  zh: '| --- |'
- en: '| 0 | 0.0000 | 0.8300 | 40.7561 | -73.9701 | 3144.8700 |'
  id: totrans-240
  prefs: []
  type: TYPE_TB
  zh: '| 0 | 0.0000 | 0.8300 | 40.7561 | -73.9701 | 3144.8700 |'
- en: '| 1 | 1.0000 | 1.2522 | 40.7509 | -73.9720 | 3027.0071 |'
  id: totrans-241
  prefs: []
  type: TYPE_TB
  zh: '| 1 | 1.0000 | 1.2522 | 40.7509 | -73.9720 | 3027.0071 |'
- en: '| 2 | 1.5000 | 2.2773 | 40.7489 | -73.9659 | 4226.3364 |'
  id: totrans-242
  prefs: []
  type: TYPE_TB
  zh: '| 2 | 1.5000 | 2.2773 | 40.7489 | -73.9659 | 4226.3364 |'
- en: '| 3 | 2.0000 | 2.6874 | 40.7495 | -73.9756 | 5278.5957 |'
  id: totrans-243
  prefs: []
  type: TYPE_TB
  zh: '| 3 | 2.0000 | 2.6874 | 40.7495 | -73.9756 | 5278.5957 |'
- en: '| 4 | 2.5000 | 2.8632 | 40.7562 | -73.9651 | 6869.0474 |'
  id: totrans-244
  prefs: []
  type: TYPE_TB
  zh: '| 4 | 2.5000 | 2.8632 | 40.7562 | -73.9651 | 6869.0474 |'
- en: '| 5 | 3.0000 | 3.2966 | 40.7597 | -73.9676 | 6897.9746 |'
  id: totrans-245
  prefs: []
  type: TYPE_TB
  zh: '| 5 | 3.0000 | 3.2966 | 40.7597 | -73.9676 | 6897.9746 |'
- en: '| 6 | 3.5000 | 3.8571 | 40.7487 | -73.9548 | 7635.3571 |'
  id: totrans-246
  prefs: []
  type: TYPE_TB
  zh: '| 6 | 3.5000 | 3.8571 | 40.7487 | -73.9548 | 7635.3571 |'
- en: '| 7 | 4.0000 | 4.6222 | 40.7563 | -73.9563 | 7422.8889 |'
  id: totrans-247
  prefs: []
  type: TYPE_TB
  zh: '| 7 | 4.0000 | 4.6222 | 40.7563 | -73.9563 | 7422.8889 |'
- en: '| 8 | 4.5000 | 1.0000 | 40.8572 | -73.9350 | 2050.0000 |'
  id: totrans-248
  prefs: []
  type: TYPE_TB
  zh: '| 8 | 4.5000 | 1.0000 | 40.8572 | -73.9350 | 2050.0000 |'
- en: '| 9 | 10.0000 | 2.0000 | 40.7633 | -73.9849 | 3600.0000 |'
  id: totrans-249
  prefs: []
  type: TYPE_TB
  zh: '| 9 | 10.0000 | 2.0000 | 40.7633 | -73.9849 | 3600.0000 |'
- en: 'and then we can access the columns of interest:'
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们可以访问感兴趣的列：
- en: '[PRE32]'
  id: totrans-251
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: '|   | bathrooms | price |'
  id: totrans-252
  prefs: []
  type: TYPE_TB
  zh: '|   | 卫生间 | 价格 |'
- en: '| --- | --- | --- |'
  id: totrans-253
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- | --- | --- | --- |'
- en: '|  |'
  id: totrans-254
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '| --- |'
  id: totrans-255
  prefs: []
  type: TYPE_TB
  zh: '| --- |'
- en: '| 0 | 0.0000 | 3144.8700 |'
  id: totrans-256
  prefs: []
  type: TYPE_TB
  zh: '| 0 | 0.0000 | 3144.8700 |'
- en: '| 1 | 1.0000 | 3027.0071 |'
  id: totrans-257
  prefs: []
  type: TYPE_TB
  zh: '| 1 | 1.0000 | 3027.0071 |'
- en: '| 2 | 1.5000 | 4226.3364 |'
  id: totrans-258
  prefs: []
  type: TYPE_TB
  zh: '| 2 | 1.5000 | 4226.3364 |'
- en: '| 3 | 2.0000 | 5278.5957 |'
  id: totrans-259
  prefs: []
  type: TYPE_TB
  zh: '| 3 | 2.0000 | 5278.5957 |'
- en: '| 4 | 2.5000 | 6869.0474 |'
  id: totrans-260
  prefs: []
  type: TYPE_TB
  zh: '| 4 | 2.5000 | 6869.0474 |'
- en: '| 5 | 3.0000 | 6897.9746 |'
  id: totrans-261
  prefs: []
  type: TYPE_TB
  zh: '| 5 | 3.0000 | 6897.9746 |'
- en: '| 6 | 3.5000 | 7635.3571 |'
  id: totrans-262
  prefs: []
  type: TYPE_TB
  zh: '| 6 | 3.5000 | 7635.3571 |'
- en: '| 7 | 4.0000 | 7422.8889 |'
  id: totrans-263
  prefs: []
  type: TYPE_TB
  zh: '| 7 | 4.0000 | 7422.8889 |'
- en: '| 8 | 4.5000 | 2050.0000 |'
  id: totrans-264
  prefs: []
  type: TYPE_TB
  zh: '| 8 | 4.5000 | 2050.0000 |'
- en: '| 9 | 10.0000 | 3600.0000 |'
  id: totrans-265
  prefs: []
  type: TYPE_TB
  zh: '| 9 | 10.0000 | 3600.0000 |'
- en: (Notice that the average price for an apartment with no bathroom is $3145\.
    Wow. Evaluating `len(df[df.bathrooms==0])` tells us there are 300 apartments with
    no bathrooms!)
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: (注意，没有浴室的公寓的平均价格是 $3145。哇。评估 `len(df[df.bathrooms==0])` 告诉我们，有 300 套没有浴室的公寓！)
- en: Accessing dataframe rows via the index is essentially performing a query for
    all rows whose index key matches a specific value, but we can perform much more
    sophisticated queries.
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 通过索引访问数据帧行本质上是在执行一个查询，以匹配特定值的索引键的所有行，但我们可以执行更复杂的查询。
- en: 4.2.4 Dataframe queries
  id: totrans-268
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 4.2.4 数据帧查询
- en: Pandas dataframes are kind of like combined spreadsheets and database tables
    and this section illustrates some of the basic queries we'll use for cleaning
    up data sets.
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: Pandas 数据帧有点像组合电子表格和数据库表，本节说明了我们将用于清理数据集的一些基本查询。
- en: 'Machine learning models don''t usually accept missing values and so we need
    to deal with any missing values in our data set. The `isnull()` method is a built-in
    query that returns true for each missing element in a series:'
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 机器学习模型通常不接受缺失值，因此我们需要处理数据集中的任何缺失值。`isnull()` 方法是一个内置查询，它对序列中的每个缺失元素返回真：
- en: '[PRE33]'
  id: totrans-271
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: '0 False 1 False 2 False Name: price, dtype: bool'
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 0 False 1 False 2 False 名称：价格，数据类型：布尔值
- en: 'or even an entire dataframe:'
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 或者甚至整个数据帧：
- en: '[PRE34]'
  id: totrans-274
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: '|   | bedrooms | bathrooms | latitude | longitude | price |'
  id: totrans-275
  prefs: []
  type: TYPE_TB
  zh: '|   | 卧室 | 卫生间 | 纬度 | 经度 | 价格 |'
- en: '| --- | --- | --- | --- | --- | --- |'
  id: totrans-276
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- | --- | --- | --- |'
- en: '|  |'
  id: totrans-277
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '| --- |'
  id: totrans-278
  prefs: []
  type: TYPE_TB
  zh: '| --- |'
- en: '| 0 | False | False | False | False | False |'
  id: totrans-279
  prefs: []
  type: TYPE_TB
  zh: '| 0 | False | False | False | False | False |'
- en: '| 1 | False | False | False | False | False |'
  id: totrans-280
  prefs: []
  type: TYPE_TB
  zh: '| 1 | False | False | False | False | False |'
- en: '| 2 | False | False | False | False | False |'
  id: totrans-281
  prefs: []
  type: TYPE_TB
  zh: '| 2 | False | False | False | False | False |'
- en: 'Of course, what we really care about is whether any values are missing and
    `any()` returns true if there is at least one true value in the series or dataframe:'
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，我们真正关心的是是否有任何值缺失，`any()` 如果序列或数据帧中至少有一个真值，则返回真：
- en: '[PRE35]'
  id: totrans-283
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'bedrooms False bathrooms False latitude False longitude False price False dtype:
    bool'
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 卧室 False 卫生间 False 纬度 False 经度 False 价格 False 数据类型：布尔值
- en: 'Like a database `WHERE` clause, pandas supports rich conditional expressions
    to filter for data of interest. Queries return a series of true and false, according
    to the results of a conditional expression:'
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 就像数据库的 `WHERE` 子句一样，pandas 支持丰富的条件表达式来筛选感兴趣的数据。查询返回一系列真和假，根据条件表达式的结果：
- en: '[PRE36]'
  id: totrans-286
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: '0 False 1 True 2 False 3 True 4 True Name: price, dtype: bool'
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 0 False 1 True 2 False 3 True 4 True 名称：价格，数据类型：布尔值
- en: 'That boolean series can then be used as an index into the dataframe and the
    dataframe will return the rows associated with true values. For example, here''s
    how to get all rows whose price is over $3000:'
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，布尔序列可以用作数据帧的索引，数据帧将返回与真值关联的行。例如，以下是如何获取所有价格超过 $3000 的行：
- en: '[PRE37]'
  id: totrans-289
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: '|   | bedrooms | bathrooms | latitude | longitude | price |'
  id: totrans-290
  prefs: []
  type: TYPE_TB
  zh: '|   | 卧室 | 卫生间 | 纬度 | 经度 | 价格 |'
- en: '| --- | --- | --- | --- | --- | --- |'
  id: totrans-291
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- | --- | --- | --- |'
- en: '|  |'
  id: totrans-292
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '| --- |'
  id: totrans-293
  prefs: []
  type: TYPE_TB
  zh: '| --- |'
- en: '| 1 | 2 | 1.0000 | 40.7947 | -73.9667 | 5465 |'
  id: totrans-294
  prefs: []
  type: TYPE_TB
  zh: '| 1 | 2 | 1.0000 | 40.7947 | -73.9667 | 5465 |'
- en: '| 3 | 1 | 1.0000 | 40.7539 | -73.9677 | 3275 |'
  id: totrans-295
  prefs: []
  type: TYPE_TB
  zh: '| 3 | 1 | 1.0000 | 40.7539 | -73.9677 | 3275 |'
- en: '| 4 | 4 | 1.0000 | 40.8241 | -73.9493 | 3350 |'
  id: totrans-296
  prefs: []
  type: TYPE_TB
  zh: '| 4 | 4 | 1.0000 | 40.8241 | -73.9493 | 3350 |'
- en: 'To find a price within a range, we need two comparison operators:'
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 要查找范围内的价格，我们需要两个比较运算符：
- en: '[PRE38]'
  id: totrans-298
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: '|   | bedrooms | bathrooms | latitude | longitude | price |'
  id: totrans-299
  prefs: []
  type: TYPE_TB
  zh: '|   | 卧室 | 卫生间 | 纬度 | 经度 | 价格 |'
- en: '| --- | --- | --- | --- | --- | --- |'
  id: totrans-300
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- | --- | --- | --- |'
- en: '|  |'
  id: totrans-301
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '| --- |'
  id: totrans-302
  prefs: []
  type: TYPE_TB
  zh: '| --- |'
- en: '| 2 | 1 | 1.0000 | 40.7388 | -74.0018 | 2850 |'
  id: totrans-303
  prefs: []
  type: TYPE_TB
  zh: '| 2 | 1 | 1.0000 | 40.7388 | -74.0018 | 2850 |'
- en: '| 8 | 1 | 1.0000 | 40.8234 | -73.9457 | 1725 |'
  id: totrans-304
  prefs: []
  type: TYPE_TB
  zh: '| 8 | 1 | 1.0000 | 40.8234 | -73.9457 | 1725 |'
- en: '| 10 | 0 | 1.0000 | 40.7769 | -73.9467 | 1950 |'
  id: totrans-305
  prefs: []
  type: TYPE_TB
  zh: '| 10 | 0 | 1.0000 | 40.7769 | -73.9467 | 1950 |'
- en: Note that the parentheses are required around the comparison subexpressions
    to override the high precedence of the `&` operator. (Without the parentheses,
    Python would try to evaluate `1000 & df.price`.)
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，比较子表达式周围需要括号来覆盖`&`运算符的高优先级。（如果没有括号，Python将尝试评估`1000 & df.price`。）
- en: 'Compound queries can reference multiple columns. For example here''s how to
    get all apartments with at least two bedrooms that are less than $3000:'
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: 复合查询可以引用多个列。例如，以下是获取至少有两间卧室且价格低于$3000的所有公寓的方法：
- en: '[PRE39]'
  id: totrans-308
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: '|   | bedrooms | bathrooms | latitude | longitude | price |'
  id: totrans-309
  prefs: []
  type: TYPE_TB
  zh: '|   | 卧室 | 卫生间 | 纬度 | 经度 | 价格 |'
- en: '| --- | --- | --- | --- | --- | --- |'
  id: totrans-310
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- | --- | --- |'
- en: '|  |'
  id: totrans-311
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '| --- |'
  id: totrans-312
  prefs: []
  type: TYPE_TB
  zh: '| --- |'
- en: '| 21 | 2 | 1.0000 | 40.7427 | -73.9794 | 2999 |'
  id: totrans-313
  prefs: []
  type: TYPE_TB
  zh: '| 21 | 2 | 1.0000 | 40.7427 | -73.9794 | 2999 |'
- en: '| 34 | 2 | 1.0000 | 40.8440 | -73.9404 | 2300 |'
  id: totrans-314
  prefs: []
  type: TYPE_TB
  zh: '| 34 | 2 | 1.0000 | 40.8440 | -73.9404 | 2300 |'
- en: '| 54 | 2 | 2.0000 | 40.7059 | -73.8339 | 2100 |'
  id: totrans-315
  prefs: []
  type: TYPE_TB
  zh: '| 54 | 2 | 2.0000 | 40.7059 | -73.8339 | 2100 |'
- en: 4.2.5 Injecting new dataframe columns
  id: totrans-316
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 4.2.5 注入新的数据框列
- en: 'After selecting features (columns) and cleaning up a data set using queries,
    data science practitioners often create new columns of data in an effort to improve
    model performance. Creating a new column with pandas is easy, just assign a value
    to the new column name. Here''s how to make a copy of the original `df` and then
    create a column of all zeroes in the new dataframe:'
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: 在使用查询选择特征（列）并清理数据集后，数据科学家通常会创建新的数据列以改善模型性能。使用pandas创建新列很容易，只需为新列名赋值。以下是复制原始`df`并然后在新的数据框中创建一列全零的方法：
- en: '[PRE40]'
  id: totrans-318
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: '|   | bedrooms | bathrooms | latitude | longitude | price | junk |'
  id: totrans-319
  prefs: []
  type: TYPE_TB
  zh: '|   | 卧室 | 卫生间 | 纬度 | 经度 | 价格 | 废物 |'
- en: '| --- | --- | --- | --- | --- | --- | --- |'
  id: totrans-320
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- | --- | --- | --- |'
- en: '|  |'
  id: totrans-321
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '| --- |'
  id: totrans-322
  prefs: []
  type: TYPE_TB
  zh: '| --- |'
- en: '| 0 | 3 | 1.5000 | 40.7145 | -73.9425 | 3000 | 0 |'
  id: totrans-323
  prefs: []
  type: TYPE_TB
  zh: '| 0 | 3 | 1.5000 | 40.7145 | -73.9425 | 3000 | 0 |'
- en: '| 1 | 2 | 1.0000 | 40.7947 | -73.9667 | 5465 | 0 |'
  id: totrans-324
  prefs: []
  type: TYPE_TB
  zh: '| 1 | 2 | 1.0000 | 40.7947 | -73.9667 | 5465 | 0 |'
- en: '| 2 | 1 | 1.0000 | 40.7388 | -74.0018 | 2850 | 0 |'
  id: totrans-325
  prefs: []
  type: TYPE_TB
  zh: '| 2 | 1 | 1.0000 | 40.7388 | -74.0018 | 2850 | 0 |'
- en: 'That example just shows the basic mechanism; we''d rarely find it useful to
    set a column of zeros. On the other hand, we might want a column of random numbers
    to see how it affected model performance. Here''s how to overwrite the `junk`
    column using a NumPy array of random numbers:'
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: 那个例子只是展示了基本机制；我们很少会找到设置零列是有用的。另一方面，我们可能想要一列随机数来查看它如何影响模型性能。以下是使用NumPy数组中的随机数覆盖`junk`列的方法：
- en: '[PRE41]'
  id: totrans-327
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: '|   | bedrooms | bathrooms | latitude | longitude | price | junk |'
  id: totrans-328
  prefs: []
  type: TYPE_TB
  zh: '|   | 卧室 | 卫生间 | 纬度 | 经度 | 价格 | 废物 |'
- en: '| --- | --- | --- | --- | --- | --- | --- |'
  id: totrans-329
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- | --- | --- | --- | --- |'
- en: '|  |'
  id: totrans-330
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '| --- |'
  id: totrans-331
  prefs: []
  type: TYPE_TB
  zh: '| --- |'
- en: '| 0 | 3 | 1.5000 | 40.7145 | -73.9425 | 3000 | 0.7624 |'
  id: totrans-332
  prefs: []
  type: TYPE_TB
  zh: '| 0 | 3 | 1.5000 | 40.7145 | -73.9425 | 3000 | 0.7624 |'
- en: '| 1 | 2 | 1.0000 | 40.7947 | -73.9667 | 5465 | 0.9703 |'
  id: totrans-333
  prefs: []
  type: TYPE_TB
  zh: '| 1 | 2 | 1.0000 | 40.7947 | -73.9667 | 5465 | 0.9703 |'
- en: '| 2 | 1 | 1.0000 | 40.7388 | -74.0018 | 2850 | 0.0397 |'
  id: totrans-334
  prefs: []
  type: TYPE_TB
  zh: '| 2 | 1 | 1.0000 | 40.7388 | -74.0018 | 2850 | 0.0397 |'
- en: A word of warning when injecting new columns into a dataframe subset. Injecting
    a new column into, say, `df` is no problem as long as `df` is the entire data
    frame, and not a subset (sometimes called a view). For example, in the following
    code, `bedsprices` is a subset of the original `df`; pandas returns of view of
    the data rather than inefficiently creating a copy.
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
  zh: 在向数据框子集注入新列时有一个警告。当向整个数据框，例如`df`，注入新列时没有问题，只要`df`不是子集（有时称为视图）。例如，在下面的代码中，`bedsprices`是原始`df`的子集；pandas返回的是数据视图而不是低效地创建副本。
- en: '[PRE42]'
  id: totrans-336
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'Trying to inject a new column yields a warning from pandas:'
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
  zh: 尝试注入新列会导致pandas发出警告：
- en: '[PRE43]'
  id: totrans-338
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'Essentially, pandas does not know whether we intend to alter the original `df`
    or to make `bedsprices` into a copy and alter it but not `df`. The safest route
    is to explicitly make a copy:'
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，pandas不知道我们是否打算修改原始`df`或将`bedsprices`变成副本并修改它但不是`df`。最安全的途径是明确地创建副本：
- en: '[PRE44]'
  id: totrans-340
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: '|   | bedrooms | price | price_to_beds_ratio |'
  id: totrans-341
  prefs: []
  type: TYPE_TB
  zh: '|   | 卧室 | 价格 | 价格与卧室比率 |'
- en: '| --- | --- | --- | --- |'
  id: totrans-342
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- | --- |'
- en: '|  |'
  id: totrans-343
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '| --- |'
  id: totrans-344
  prefs: []
  type: TYPE_TB
  zh: '| --- |'
- en: '| 0 | 3 | 3000 | 1000.0000 |'
  id: totrans-345
  prefs: []
  type: TYPE_TB
  zh: '| 0 | 3 | 3000 | 1000.0000 |'
- en: '| 1 | 2 | 5465 | 2732.5000 |'
  id: totrans-346
  prefs: []
  type: TYPE_TB
  zh: '| 1 | 2 | 5465 | 2732.5000 |'
- en: '| 2 | 1 | 2850 | 2850.0000 |'
  id: totrans-347
  prefs: []
  type: TYPE_TB
  zh: '| 2 | 1 | 2850 | 2850.0000 |'
- en: See [Returning a view versus a copy](https://pandas.pydata.org/pandas-docs/version/0.20/indexing.html#indexing-view-versus-copy)
    from the pandas documentation for more details.
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
  zh: 有关更多详细信息，请参阅pandas文档中的[返回视图与副本](https://pandas.pydata.org/pandas-docs/version/0.20/indexing.html#indexing-view-versus-copy)。
- en: 4.2.6 String and date operations
  id: totrans-349
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 4.2.6 字符串和日期操作
- en: 'Dataframes have string and date-related functions that are useful when deriving
    new columns or cleaning up existing columns. To demonstrate these, we''ll need
    a data set with more columns, so download and unzip [rent.csv.zip](https://mlbook.explained.ai/data/rent.csv.zip)
    into your `mlbook/data` directory. Then use `read_csv` to load the `rent.csv`
    file and display five columns:'
  id: totrans-350
  prefs: []
  type: TYPE_NORMAL
  zh: DataFrame 有字符串和日期相关的函数，这在派生新列或清理现有列时非常有用。为了演示这些功能，我们需要一个包含更多列的数据集，因此请下载并解压 [rent.csv.zip](https://mlbook.explained.ai/data/rent.csv.zip)
    到您的 `mlbook/data` 目录。然后使用 `read_csv` 读取 `rent.csv` 文件并显示五列：
- en: '[PRE45]'
  id: totrans-351
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: '|   | created | features | bedrooms | bathrooms | price |'
  id: totrans-352
  prefs: []
  type: TYPE_TB
  zh: '|   | created | features | bedrooms | bathrooms | price |'
- en: '| --- | --- | --- | --- | --- | --- |'
  id: totrans-353
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- | --- | --- | --- |'
- en: '|  |'
  id: totrans-354
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '| --- |'
  id: totrans-355
  prefs: []
  type: TYPE_TB
  zh: '| --- |'
- en: '| 0 | 2016-06-24 07:54:24 | [] | 3 | 1.5000 | 3000 |'
  id: totrans-356
  prefs: []
  type: TYPE_TB
  zh: '| 0 | 2016-06-24 07:54:24 | [] | 3 | 1.5000 | 3000 |'
- en: '| 1 | 2016-06-12 12:19:27 | [''Doorman'', ''Elevator'', ''... | 2 | 1.0000
    | 5465 |'
  id: totrans-357
  prefs: []
  type: TYPE_TB
  zh: '| 1 | 2016-06-12 12:19:27 | [''Doorman'', ''Elevator'', ''... | 2 | 1.0000
    | 5465 |'
- en: '| 2 | 2016-04-17 03:26:41 | [''Laundry In Building'', ''... | 1 | 1.0000 |
    2850 |'
  id: totrans-358
  prefs: []
  type: TYPE_TB
  zh: '| 2 | 2016-04-17 03:26:41 | [''Laundry In Building'', ''... | 1 | 1.0000 |
    2850 |'
- en: '| 3 | 2016-04-18 02:22:02 | [''Hardwood Floors'', ''No F... | 1 | 1.0000 |
    3275 |'
  id: totrans-359
  prefs: []
  type: TYPE_TB
  zh: '| 3 | 2016-04-18 02:22:02 | [''Hardwood Floors'', ''No F... | 1 | 1.0000 |
    3275 |'
- en: '| 4 | 2016-04-28 01:32:41 | [''Pre-War''] | 4 | 1.0000 | 3350 |'
  id: totrans-360
  prefs: []
  type: TYPE_TB
  zh: '| 4 | 2016-04-28 01:32:41 | [''Pre-War''] | 4 | 1.0000 | 3350 |'
- en: 'The `parse_dates` parameter make sure that the `created` column is parsed as
    a date not a string. Column `features` is a string column (pandas labels them
    as type `object`) whose values are comma-separated lists of features enclosed
    in square brackets, just as Python would display a list of strings. Here''s the
    type information for all columns in `rent.csv`:'
  id: totrans-361
  prefs: []
  type: TYPE_NORMAL
  zh: '`parse_dates` 参数确保 `created` 列被解析为日期而不是字符串。`features` 列是一个字符串列（pandas 将其标记为
    `object` 类型），其值是逗号分隔的、用方括号括起来的特征列表，就像 Python 显示字符串列表的方式一样。以下是 `rent.csv` 中所有列的类型信息：'
- en: '[PRE46]'
  id: totrans-362
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: '<class ''pandas.core.frame.DataFrame''> RangeIndex: 49352 entries, 0 to 49351
    Data columns (total 5 columns): created 49352 non-null datetime64[ns] features
    49352 non-null object bedrooms 49352 non-null int64 bathrooms 49352 non-null float64
    price 49352 non-null int64 dtypes: datetime64[ns](1), float64(1), int64(2), object(1)
    memory usage: 1.9+ MB'
  id: totrans-363
  prefs: []
  type: TYPE_NORMAL
  zh: '<class ''pandas.core.frame.DataFrame''> RangeIndex: 49352 entries, 0 to 49351
    Data columns (total 5 columns): created 49352 non-null datetime64[ns] features
    49352 non-null object bedrooms 49352 non-null int64 bathrooms 49352 non-null float64
    price 49352 non-null int64 dtypes: datetime64[ns](1), float64(1), int64(2), object(1)
    memory usage: 1.9+ MB'
- en: 'The string-related methods are available via *series*`.str.`*method*`()`; the
    `str` object just groups the methods. For example, it''s a good idea to normalize
    features of string type so that `doorman` and `Doorman` are treated as the same
    word:'
  id: totrans-364
  prefs: []
  type: TYPE_NORMAL
  zh: 字符串相关的方法可以通过 *series*`.str.`*method*`()` 获取；`str` 对象只是将方法分组。例如，将字符串类型的特征进行归一化处理是个好主意，这样
    `doorman` 和 `Doorman` 就会被视为同一个单词：
- en: '[PRE47]'
  id: totrans-365
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: '|   | created | features | bedrooms | bathrooms | price |'
  id: totrans-366
  prefs: []
  type: TYPE_TB
  zh: '|   | created | features | bedrooms | bathrooms | price |'
- en: '| --- | --- | --- | --- | --- | --- |'
  id: totrans-367
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- | --- | --- | --- |'
- en: '|  |'
  id: totrans-368
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '| --- |'
  id: totrans-369
  prefs: []
  type: TYPE_TB
  zh: '| --- |'
- en: '| 0 | 2016-06-24 07:54:24 | [] | 3 | 1.5000 | 3000 |'
  id: totrans-370
  prefs: []
  type: TYPE_TB
  zh: '| 0 | 2016-06-24 07:54:24 | [] | 3 | 1.5000 | 3000 |'
- en: '| 1 | 2016-06-12 12:19:27 | [''doorman'', ''elevator'', ''... | 2 | 1.0000
    | 5465 |'
  id: totrans-371
  prefs: []
  type: TYPE_TB
  zh: '| 1 | 2016-06-12 12:19:27 | [''doorman'', ''elevator'', ''... | 2 | 1.0000
    | 5465 |'
- en: '| 2 | 2016-04-17 03:26:41 | [''laundry in building'', ''... | 1 | 1.0000 |
    2850 |'
  id: totrans-372
  prefs: []
  type: TYPE_TB
  zh: '| 2 | 2016-04-17 03:26:41 | [''laundry in building'', ''... | 1 | 1.0000 |
    2850 |'
- en: '| 3 | 2016-04-18 02:22:02 | [''hardwood floors'', ''no f... | 1 | 1.0000 |
    3275 |'
  id: totrans-373
  prefs: []
  type: TYPE_TB
  zh: '| 3 | 2016-04-18 02:22:02 | [''hardwood floors'', ''no f... | 1 | 1.0000 |
    3275 |'
- en: '| 4 | 2016-04-28 01:32:41 | [''pre-war''] | 4 | 1.0000 | 3350 |'
  id: totrans-374
  prefs: []
  type: TYPE_TB
  zh: '| 4 | 2016-04-28 01:32:41 | [''pre-war''] | 4 | 1.0000 | 3350 |'
- en: 'As part of the normalization process, it''s a good idea to replace any missing
    values with a blank and any empty `features` column values, `[]`, with a blank:'
  id: totrans-375
  prefs: []
  type: TYPE_NORMAL
  zh: 作为归一化过程的一部分，将任何缺失值替换为空格，以及将任何空的 `features` 列值 `[]` 替换为空格是个好主意：
- en: '[PRE48]'
  id: totrans-376
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: '|   | created | features | bedrooms | bathrooms | price |'
  id: totrans-377
  prefs: []
  type: TYPE_TB
  zh: '|   | created | features | bedrooms | bathrooms | price |'
- en: '| --- | --- | --- | --- | --- | --- |'
  id: totrans-378
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- | --- | --- | --- |'
- en: '|  |'
  id: totrans-379
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '| --- |'
  id: totrans-380
  prefs: []
  type: TYPE_TB
  zh: '| --- |'
- en: '| 0 | 2016-06-24 07:54:24 |  | 3 | 1.5000 | 3000 |'
  id: totrans-381
  prefs: []
  type: TYPE_TB
  zh: '| 0 | 2016-06-24 07:54:24 |  | 3 | 1.5000 | 3000 |'
- en: '| 1 | 2016-06-12 12:19:27 | [''doorman'', ''elevator'', ''... | 2 | 1.0000
    | 5465 |'
  id: totrans-382
  prefs: []
  type: TYPE_TB
  zh: '| 1 | 2016-06-12 12:19:27 | [''doorman'', ''elevator'', ''... | 2 | 1.0000
    | 5465 |'
- en: '| 2 | 2016-04-17 03:26:41 | [''laundry in building'', ''... | 1 | 1.0000 |
    2850 |'
  id: totrans-383
  prefs: []
  type: TYPE_TB
  zh: '| 2 | 2016-04-17 03:26:41 | [''laundry in building'', ''... | 1 | 1.0000 |
    2850 |'
- en: '| 3 | 2016-04-18 02:22:02 | [''hardwood floors'', ''no f... | 1 | 1.0000 |
    3275 |'
  id: totrans-384
  prefs: []
  type: TYPE_TB
  zh: '| 3 | 2016-04-18 02:22:02 | [''hardwood floors'', ''no f... | 1 | 1.0000 |
    3275 |'
- en: '| 4 | 2016-04-28 01:32:41 | [''pre-war''] | 4 | 1.0000 | 3350 |'
  id: totrans-385
  prefs: []
  type: TYPE_TB
  zh: '| 4 | 2016-04-28 01:32:41 | [''pre-war''] | 4 | 1.0000 | 3350 |'
- en: Pandas uses “not a number”, NumPy's `np.nan`, as a placeholder for unavailable
    values, even for nonnumeric string and date columns. Because `np.nan` is a floating-point
    number, a missing integer flips the entire column to have type `float`. See [Working
    with missing data](https://pandas.pydata.org/pandas-docs/stable/missing_data.html)
    for more details.
  id: totrans-386
  prefs: []
  type: TYPE_NORMAL
  zh: Pandas 使用 "非数字"，NumPy 的 `np.nan` 作为不可用值的占位符，即使是对于非数字字符串和日期列。因为 `np.nan` 是一个浮点数，缺失的整数会将整个列的类型转换为
    `float`。有关更多详细信息，请参阅 [处理缺失数据](https://pandas.pydata.org/pandas-docs/stable/missing_data.html)。
- en: Looking at the string values in the `features` column, there is a good deal
    of information that would potentially improve the model's performance. Models
    would not generally be able to automatically extract useful features and so we
    have to give them a hand. The following code creates two new columns that indicates
    whether or not the apartment has a doorman or laundry (`"laundry|washer"` is a
    regular expression that matches if either laundry or washer is present).
  id: totrans-387
  prefs: []
  type: TYPE_NORMAL
  zh: 查看特征列中的字符串值，有很多信息可能会提高模型的表现。通常模型无法自动提取有用的特征，因此我们需要帮助它们。以下代码创建了两个新列，表示公寓是否有门卫或洗衣（`"laundry|washer"`
    是一个正则表达式，如果存在洗衣或洗衣机，则匹配）。
- en: '[PRE49]'
  id: totrans-388
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: '|   | created | features | bedrooms | bathrooms | price | doorman | laundry
    |'
  id: totrans-389
  prefs: []
  type: TYPE_TB
  zh: '|   | created | features | bedrooms | bathrooms | price | doorman | laundry
    |'
- en: '| --- | --- | --- | --- | --- | --- | --- | --- |'
  id: totrans-390
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- | --- | --- | --- | --- | --- |'
- en: '|  |'
  id: totrans-391
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '| --- |'
  id: totrans-392
  prefs: []
  type: TYPE_TB
  zh: '| --- |'
- en: '| 0 | 2016-06-24 07:54:24 |  | 3 | 1.5000 | 3000 | False | False |'
  id: totrans-393
  prefs: []
  type: TYPE_TB
  zh: '| 0 | 2016-06-24 07:54:24 |  | 3 | 1.5000 | 3000 | False | False |'
- en: '| 1 | 2016-06-12 12:19:27 | [''doorman'', ''elevator'', ''... | 2 | 1.0000
    | 5465 | True | False |'
  id: totrans-394
  prefs: []
  type: TYPE_TB
  zh: '| 1 | 2016-06-12 12:19:27 | [''门卫'', ''电梯'', ''... | 2 | 1.0000 | 5465 | True
    | False |'
- en: '| 2 | 2016-04-17 03:26:41 | [''laundry in building'', ''... | 1 | 1.0000 |
    2850 | False | True |'
  id: totrans-395
  prefs: []
  type: TYPE_TB
  zh: '| 2 | 2016-04-17 03:26:41 | [''building内的洗衣'', ''... | 1 | 1.0000 | 2850 |
    False | True |'
- en: '| 3 | 2016-04-18 02:22:02 | [''hardwood floors'', ''no f... | 1 | 1.0000 |
    3275 | False | False |'
  id: totrans-396
  prefs: []
  type: TYPE_TB
  zh: '| 3 | 2016-04-18 02:22:02 | [''硬木地板'', ''无烟... | 1 | 1.0000 | 3275 | False
    | False |'
- en: '| 4 | 2016-04-28 01:32:41 | [''pre-war''] | 4 | 1.0000 | 3350 | False | False
    |'
  id: totrans-397
  prefs: []
  type: TYPE_TB
  zh: '| 4 | 2016-04-28 01:32:41 | [''pre-war''] | 4 | 1.0000 | 3350 | False | False
    |'
- en: Ultimately, models can only use numeric or boolean data columns, so these conversions
    are very common. Once we've extracted all useful information from the raw string
    column, we would typically delete that `features` column.
  id: totrans-398
  prefs: []
  type: TYPE_NORMAL
  zh: 最终，模型只能使用数值或布尔数据列，因此这些转换非常常见。一旦我们从原始字符串列中提取了所有有用的信息，我们通常会删除该 `features` 列。
- en: 'Instead of creating new columns, sometimes we convert string columns to numeric
    columns. For example, the `interest_level` column in the `rent.csv` data set is
    one of three strings (low, medium, and high):'
  id: totrans-399
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，我们不是创建新列，而是将字符串列转换为数值列。例如，`rent.csv` 数据集中的 `interest_level` 列是三个字符串之一（低、中等和高）：
- en: '[PRE50]'
  id: totrans-400
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: type of interest_level is object
  id: totrans-401
  prefs: []
  type: TYPE_NORMAL
  zh: interest_level 的类型是 object
- en: '|   | created | interest_level |'
  id: totrans-402
  prefs: []
  type: TYPE_TB
  zh: '|   | created | interest_level |'
- en: '| --- | --- | --- |'
  id: totrans-403
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '|  |'
  id: totrans-404
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '| --- |'
  id: totrans-405
  prefs: []
  type: TYPE_TB
  zh: '| --- |'
- en: '| 0 | 2016-06-24 07:54:24 | medium |'
  id: totrans-406
  prefs: []
  type: TYPE_TB
  zh: '| 0 | 2016-06-24 07:54:24 | 中等 |'
- en: '| 1 | 2016-06-12 12:19:27 | low |'
  id: totrans-407
  prefs: []
  type: TYPE_TB
  zh: '| 1 | 2016-06-12 12:19:27 | 低 |'
- en: '| 2 | 2016-04-17 03:26:41 | high |'
  id: totrans-408
  prefs: []
  type: TYPE_TB
  zh: '| 2 | 2016-04-17 03:26:41 | 高 |'
- en: '| 3 | 2016-04-18 02:22:02 | low |'
  id: totrans-409
  prefs: []
  type: TYPE_TB
  zh: '| 3 | 2016-04-18 02:22:02 | 低 |'
- en: '| 4 | 2016-04-28 01:32:41 | low |'
  id: totrans-410
  prefs: []
  type: TYPE_TB
  zh: '| 4 | 2016-04-28 01:32:41 | 低 |'
- en: 'An easy way to convert that to a numeric column is to map each string to a
    unique value:'
  id: totrans-411
  prefs: []
  type: TYPE_NORMAL
  zh: 将其转换为数值列的一个简单方法是将每个字符串映射到一个唯一的值：
- en: '[PRE51]'
  id: totrans-412
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: type of interest_level is int64
  id: totrans-413
  prefs: []
  type: TYPE_NORMAL
  zh: interest_level 的类型是 int64
- en: '|   | created | interest_level |'
  id: totrans-414
  prefs: []
  type: TYPE_TB
  zh: '|   | created | interest_level |'
- en: '| --- | --- | --- |'
  id: totrans-415
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '|  |'
  id: totrans-416
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '| --- |'
  id: totrans-417
  prefs: []
  type: TYPE_TB
  zh: '| --- |'
- en: '| 0 | 2016-06-24 07:54:24 | 2 |'
  id: totrans-418
  prefs: []
  type: TYPE_TB
  zh: '| 0 | 2016-06-24 07:54:24 | 2 |'
- en: '| 1 | 2016-06-12 12:19:27 | 1 |'
  id: totrans-419
  prefs: []
  type: TYPE_TB
  zh: '| 1 | 2016-06-12 12:19:27 | 1 |'
- en: '| 2 | 2016-04-17 03:26:41 | 3 |'
  id: totrans-420
  prefs: []
  type: TYPE_TB
  zh: '| 2 | 2016-04-17 03:26:41 | 3 |'
- en: '| 3 | 2016-04-18 02:22:02 | 1 |'
  id: totrans-421
  prefs: []
  type: TYPE_TB
  zh: '| 3 | 2016-04-18 02:22:02 | 1 |'
- en: '| 4 | 2016-04-28 01:32:41 | 1 |'
  id: totrans-422
  prefs: []
  type: TYPE_TB
  zh: '| 4 | 2016-04-28 01:32:41 | 1 |'
- en: 'For large data sets, sometimes it''s useful to reduce numeric values to the
    smallest entity that will hold all values. In this case, the `interest_level`
    values all fit easily within one byte (8 bits), which means we can save a bunch
    of space if we convert the column to `int8` from `int64`:'
  id: totrans-423
  prefs: []
  type: TYPE_NORMAL
  zh: 对于大型数据集，有时将数值减少到可以包含所有值的最小实体是有用的。在这种情况下，`interest_level` 值可以轻松地适应一个字节（8位），这意味着如果我们将列从
    `int64` 转换为 `int8`，我们可以节省大量空间：
- en: '[PRE52]'
  id: totrans-424
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: type of interest_level is int8
  id: totrans-425
  prefs: []
  type: TYPE_NORMAL
  zh: interest_level 的类型是 int8
- en: 'Like string columns, models cannot directly use date columns, but we can break
    up the date into a number of components and derive new information about that
    date. For example, imagine training a model that predicts sales at a grocery market.
    The day of the week, or even the day of the month, could be predictive of sales.
    People tend to shop more on Saturday and Sunday than during the week and perhaps
    more shopping occurs on monthly paydays. Maybe there are more sales during certain
    months like December (during Christmas time). Pandas provides convenience methods,
    grouped in property `dt`, for extracting various date attributes and we can use
    these to derive new model features:'
  id: totrans-426
  prefs: []
  type: TYPE_NORMAL
  zh: '| `df_prices`:'
- en: '[PRE53]'
  id: totrans-427
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: '|   | created | dayofweek | day | month |'
  id: totrans-428
  prefs: []
  type: TYPE_TB
  zh: '|   | created | dayofweek | day | month |'
- en: '| --- | --- | --- | --- | --- |'
  id: totrans-429
  prefs: []
  type: TYPE_TB
  zh: 想象我们有一个包含大量销售交易特征的 `df_sales` 数据框，但为了讨论的目的，我们将其简化为只有两列。我们面临的问题是价格信息在另一个数据框中，可能是因为我们从不同的来源提取了数据。这两个数据框看起来如下所示。
- en: '|  |'
  id: totrans-430
  prefs: []
  type: TYPE_TB
  zh: '|   | --- | --- | --- |'
- en: '| --- |'
  id: totrans-431
  prefs: []
  type: TYPE_TB
  zh: '| 0 | 1222837 | 1000 |  |'
- en: '| 0 | 2016-06-24 07:54:24 | 4 | 24 | 6 |'
  id: totrans-432
  prefs: []
  type: TYPE_TB
  zh: '| 0 | 2016-06-24 07:54:24 | 4 | 24 | 6 |'
- en: '| 1 | 2016-06-12 12:19:27 | 6 | 12 | 6 |'
  id: totrans-433
  prefs: []
  type: TYPE_TB
  zh: '|   | SalesID | YearMade |  |'
- en: '| 2 | 2016-04-17 03:26:41 | 6 | 17 | 4 |'
  id: totrans-434
  prefs: []
  type: TYPE_TB
  zh: '| 1 | 2016-06-12 12:19:27 | 6 | 12 | 6 |'
- en: '| 3 | 2016-04-18 02:22:02 | 0 | 18 | 4 |'
  id: totrans-435
  prefs: []
  type: TYPE_TB
  zh: '| 2 | 1222839 | 54000 |  |'
- en: '| 4 | 2016-04-28 01:32:41 | 3 | 28 | 4 |'
  id: totrans-436
  prefs: []
  type: TYPE_TB
  zh: '|   | --- | --- | --- |'
- en: Once we've extracted all useful numeric data, we'd drop column `created` before
    training our model on the data set.
  id: totrans-437
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: 4.2.7 Merging dataframes
  id: totrans-438
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '| 6 | 1222849 | 33000 |  |'
- en: Imagine we have a `df_sales` data frame with lots of features about sales transactions,
    but let's simplified to just two columns for discussion purposes. The problem
    we have is that price information is in a different dataframe, possibly because
    we extracted the data from a different source. The two dataframes look like the
    following.
  id: totrans-439
  prefs: []
  type: TYPE_NORMAL
  zh: '| 2 | 2016-04-17 03:26:41 | 6 | 17 | 4 |'
- en: '| `df_sales`'
  id: totrans-440
  prefs: []
  type: TYPE_NORMAL
  zh: '| 0 | 1222836 | 31000 |  |'
- en: '&#124;   &#124; SalesID &#124; YearMade &#124;'
  id: totrans-441
  prefs: []
  type: TYPE_NORMAL
  zh: '| 4 | 1222845 | 35000 |  |'
- en: '&#124; --- &#124; --- &#124; --- &#124;'
  id: totrans-442
  prefs: []
  type: TYPE_NORMAL
  zh: '| 3 | 1222843 | 10000 |  |'
- en: '&#124;  &#124;'
  id: totrans-443
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '&#124; --- &#124;'
  id: totrans-444
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '&#124; 0 &#124; 1222837 &#124; 1000 &#124;'
  id: totrans-445
  prefs: []
  type: TYPE_NORMAL
  zh: '| 2 | 1222841 | 2000 |  |'
- en: '&#124; 1 &#124; 1222839 &#124; 2006 &#124;'
  id: totrans-446
  prefs: []
  type: TYPE_NORMAL
  zh: 类似于字符串列，模型不能直接使用日期列，但我们可以将日期分解成多个组成部分，并从中提取关于该日期的新信息。例如，想象训练一个预测杂货店销售的模型。星期几，甚至月份的某一天，可能对销售有预测作用。人们通常在周六和周日购物比工作日多，也许在每月发薪日购物更多。也许在像十二月（圣诞节期间）这样的月份会有更多的销售。Pandas
    提供了方便的方法，分组在属性 `dt` 中，用于提取各种日期属性，我们可以使用这些属性来推导新的模型特征：
- en: '&#124; 2 &#124; 1222841 &#124; 2000 &#124;'
  id: totrans-447
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们提取了所有有用的数值数据，我们就会在数据集上训练模型之前删除列 `created`。
- en: '&#124; 3 &#124; 1222843 &#124; 1000 &#124;'
  id: totrans-448
  prefs: []
  type: TYPE_NORMAL
  zh: '|   | SalesID | SalePrice |  |'
- en: '&#124; 4 &#124; 1222845 &#124; 2002 &#124;'
  id: totrans-449
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '| `df_prices`:'
  id: totrans-450
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '&#124;   &#124; SalesID &#124; SalePrice &#124;'
  id: totrans-451
  prefs: []
  type: TYPE_NORMAL
  zh: 4.2.7 合并数据框
- en: '&#124; --- &#124; --- &#124; --- &#124;'
  id: totrans-452
  prefs: []
  type: TYPE_NORMAL
  zh: '|   | SalesID | YearMade | SalePrice |'
- en: '&#124;  &#124;'
  id: totrans-453
  prefs: []
  type: TYPE_NORMAL
  zh: '| `df_sales`'
- en: '&#124; --- &#124;'
  id: totrans-454
  prefs: []
  type: TYPE_NORMAL
  zh: '| 4 | 2016-04-28 01:32:41 | 3 | 28 | 4 |'
- en: '&#124; 0 &#124; 1222836 &#124; 31000 &#124;'
  id: totrans-455
  prefs: []
  type: TYPE_NORMAL
  zh: 左数据框中任何没有在右数据框中对应记录的记录都会得到 `np.NaN`（不是一个数字）来表示缺失条目。
- en: '&#124; 1 &#124; 1222837 &#124; 44300 &#124;'
  id: totrans-456
  prefs: []
  type: TYPE_NORMAL
  zh: '| 1 | 1222839 | 2006 |  |'
- en: '&#124; 2 &#124; 1222839 &#124; 54000 &#124;'
  id: totrans-457
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的目标是在 `df_sales` 中创建一个新的列，其中包含每个记录的适当 `SalePrice`。为此，我们需要一个在两个表中都通用的键，在这个例子中是
    `SalesID`。例如，`df_sales` 中 `SalesID` 为 1222843 的记录应该获得一个新的 `SalesPrice` 条目为 10000。在数据库术语中，我们需要一个
    *左连接*，它保留左数据框中的所有记录，并忽略右数据框中不匹配的 `SalesID` 记录：
- en: '&#124; 3 &#124; 1222843 &#124; 10000 &#124;'
  id: totrans-458
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Python 中，合并操作看起来如下：
- en: '&#124; 4 &#124; 1222845 &#124; 35000 &#124;'
  id: totrans-459
  prefs: []
  type: TYPE_NORMAL
  zh: '| 3 | 2016-04-18 02:22:02 | 0 | 18 | 4 |'
- en: '&#124; 5 &#124; 1222847 &#124; 8000 &#124;'
  id: totrans-460
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '&#124; 6 &#124; 1222849 &#124; 33000 &#124;'
  id: totrans-461
  prefs: []
  type: TYPE_NORMAL
  zh: '| --- | --- | --- | --- | --- |'
- en: '|'
  id: totrans-462
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: 'Our goal is to create a new column in `df_sales` that has the appropriate `SalePrice`
    for each record. To do that, we need a key that is common to both tables, which
    is the `SalesID` in this case. For example, the record in `df_sales` with `SalesID`
    of 1222843 should get a new `SalesPrice` entry of 10000\. In database terms, we
    need a *left join*, which keeps all records from the left dataframe and ignores
    records for unmatched `SalesID`s from the right dataframe:'
  id: totrans-463
  prefs: []
  type: TYPE_NORMAL
  zh: '| 1 | 1222837 | 44300 |  |'
- en: '![](../Images/5808be0bbcdf2d2083d7c293014afb10.png)'
  id: totrans-464
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/5808be0bbcdf2d2083d7c293014afb10.png)'
- en: Any record in the left dataframe without a counterpart in right dataframe gets
    `np.NaN` (not a number) to represent a missing entry.
  id: totrans-465
  prefs: []
  type: TYPE_NORMAL
  zh: '| 5 | 1222847 | 8000 |  |'
- en: 'In Python the merge operation looks like:'
  id: totrans-466
  prefs: []
  type: TYPE_NORMAL
  zh: '| 3 | 1222843 | 1000 |  |'
- en: '[PRE54]'
  id: totrans-467
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: '|   | SalesID | YearMade | SalePrice |'
  id: totrans-468
  prefs: []
  type: TYPE_TB
  zh: '| 4 | 1222845 | 2002 |  |'
- en: '| --- | --- | --- | --- |'
  id: totrans-469
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- | --- |'
- en: '|  |'
  id: totrans-470
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '| --- |'
  id: totrans-471
  prefs: []
  type: TYPE_TB
  zh: '| --- |'
- en: '| 0 | 1222837 | 1000 | 44300.0000 |'
  id: totrans-472
  prefs: []
  type: TYPE_TB
  zh: '| 0 | 1222837 | 1000 | 44300.0000 |'
- en: '| 1 | 1222839 | 2006 | 54000.0000 |'
  id: totrans-473
  prefs: []
  type: TYPE_TB
  zh: '| 1 | 1222839 | 2006 | 54000.0000 |'
- en: '| 2 | 1222841 | 2000 |  |'
  id: totrans-474
  prefs: []
  type: TYPE_TB
  zh: '| 2 | 1222841 | 2000 |  |'
- en: '| 3 | 1222843 | 1000 | 10000.0000 |'
  id: totrans-475
  prefs: []
  type: TYPE_TB
  zh: '| 3 | 1222843 | 1000 | 10000.0000 |'
- en: '| 4 | 1222845 | 2002 | 35000.0000 |'
  id: totrans-476
  prefs: []
  type: TYPE_TB
  zh: '| 4 | 1222845 | 2002 | 35000.0000 |'
- en: 'The left join makes a bit more sense sometimes when we see the *right join*.
    A right join keeps all records in the right dataframe, filling in record values
    for unmatched keys with `np.NaN`:'
  id: totrans-477
  prefs: []
  type: TYPE_NORMAL
  zh: 有时当我们看到 *右连接* 时，左连接会更有意义。右连接保留右数据框中的所有记录，对于不匹配的键使用 `np.NaN` 填充记录值：
- en: '[PRE55]'
  id: totrans-478
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: '|   | SalesID | YearMade | SalePrice |'
  id: totrans-479
  prefs: []
  type: TYPE_TB
  zh: '|   | 销售ID | 制造年份 | 销售价格 |'
- en: '| --- | --- | --- | --- |'
  id: totrans-480
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- | --- |'
- en: '|  |'
  id: totrans-481
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '| --- |'
  id: totrans-482
  prefs: []
  type: TYPE_TB
  zh: '| --- |'
- en: '| 4 | 1222836 |  | 31000 |'
  id: totrans-483
  prefs: []
  type: TYPE_TB
  zh: '| 4 | 1222836 |  | 31000 |'
- en: '| 0 | 1222837 | 1000.0000 | 44300 |'
  id: totrans-484
  prefs: []
  type: TYPE_TB
  zh: '| 0 | 1222837 | 1000.0000 | 44300 |'
- en: '| 1 | 1222839 | 2006.0000 | 54000 |'
  id: totrans-485
  prefs: []
  type: TYPE_TB
  zh: '| 1 | 1222839 | 2006.0000 | 54000 |'
- en: '| 2 | 1222843 | 1000.0000 | 10000 |'
  id: totrans-486
  prefs: []
  type: TYPE_TB
  zh: '| 2 | 1222843 | 1000.0000 | 10000 |'
- en: '| 3 | 1222845 | 2002.0000 | 35000 |'
  id: totrans-487
  prefs: []
  type: TYPE_TB
  zh: '| 3 | 1222845 | 2002.0000 | 35000 |'
- en: '| 5 | 1222847 |  | 8000 |'
  id: totrans-488
  prefs: []
  type: TYPE_TB
  zh: '| 5 | 1222847 |  | 8000 |'
- en: '| 6 | 1222849 |  | 33000 |'
  id: totrans-489
  prefs: []
  type: TYPE_TB
  zh: '| 6 | 1222849 |  | 33000 |'
- en: 4.2.8 Saving and loading data in the feather format
  id: totrans-490
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 4.2.8 以 feather 格式保存和加载数据
- en: 'Data files are often in CSV, because it is a universal format and can be read
    by any programming language. But, loading CSV files into dataframes is not very
    efficient, which is a problem for large data sets during the highly iterative
    development process of machine learning models. The author of pandas, Wes McKinney,
    and Hadley Wickham (a well-known statistician and R programmer) recently developed
    a new format called [feather](https://github.com/wesm/feather) that loads large
    data files much faster than CSV files. Given a dataframe, here''s how to save
    it as a feather file and read it back in:'
  id: totrans-491
  prefs: []
  type: TYPE_NORMAL
  zh: 数据文件通常是 CSV 格式，因为它是一种通用格式，可以被任何编程语言读取。但是，将 CSV 文件加载到数据框中并不高效，这在机器学习模型高度迭代的开发过程中是一个问题。pandas
    的作者 Wes McKinney 和知名统计学家、R 语言程序员 Hadley Wickham 最近开发了一种名为 [feather](https://github.com/wesm/feather)
    的新格式，它比 CSV 文件加载大型数据文件要快得多。给定一个数据框，以下是将其保存为 feather 文件并读取回来的方法：
- en: '[PRE56]'
  id: totrans-492
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'We performed a quick experiment, mirroring the one done by McKinney and Wickham
    in their [original blog post from 2016](https://blog.rstudio.com/2016/03/29/feather/).
    Given a data frame with 10 columns each with 10,000,000 floating-point numbers,
    pandas takes about two minutes to write it out as CSV to a fast SSD drive. In
    contrast, it only takes 1.5 seconds to write out the equivalent feather file.
    Also, the CSV file is 1.8G versus only 800M for the feather file. Reading the
    CSV file takes 22s versus 6s for the feather file. Here is the test rig, adapted
    from McKinney and Wickham:'
  id: totrans-493
  prefs: []
  type: TYPE_NORMAL
  zh: 我们进行了一个快速实验，模仿 McKinney 和 Wickham 在他们 2016 年的 [原始博客文章](https://blog.rstudio.com/2016/03/29/feather/)
    中所做的实验。给定一个包含 10 列的数据框，每列有 10,000,000 个浮点数，pandas 将其写入 CSV 格式到快速 SSD 驱动器大约需要两分钟。相比之下，写入等效的
    feather 文件只需要 1.5 秒。此外，CSV 文件大小为 1.8G，而 feather 文件仅为 800M。读取 CSV 文件需要 22 秒，而 feather
    文件只需要 6 秒。以下是测试平台，改编自 McKinney 和 Wickham：
- en: '[PRE57]'
  id: totrans-494
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: Now that we know how load, save, and manipulate dataframes, let's explore the
    basics of visualizing dataFrame data.
  id: totrans-495
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经了解了如何加载、保存和操作数据框，让我们来探索可视化 DataFrame 数据的基本方法。
- en: 4.3 Generating plots with matplotlib
  id: totrans-496
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 4.3 使用 matplotlib 生成图表
- en: '[Matplotlib](https://matplotlib.org/) is a free and widely-used Python plotting
    library. There are lots of other options, but matplotlib is so well supported,
    it''s hard to consider using anything else. For example, there are currently 34,515
    [matplotlib questions on stackoverflow](https://stackoverflow.com/questions/tagged/matplotlib).
    That said, we find it a bit quirky and the learning curve is pretty steep. Getting
    basic plots working is no problem, but highly-customized plots require lots of
    digging in the documentation and with web searches. The goal of this section is
    to show how create the three most common plots: scatter, line, and histogram.'
  id: totrans-497
  prefs: []
  type: TYPE_NORMAL
  zh: '[Matplotlib](https://matplotlib.org/) 是一个免费且广泛使用的 Python 绘图库。虽然有很多其他选择，但 matplotlib
    的支持非常完善，很难考虑使用其他任何东西。例如，目前有 34,515 个关于 matplotlib 的 [stackoverflow 问题](https://stackoverflow.com/questions/tagged/matplotlib)。尽管如此，我们发现它有点古怪，学习曲线相当陡峭。基本图表的制作没有问题，但高度定制的图表需要大量查阅文档和进行网络搜索。本节的目标是展示如何创建三种最常见的图表：散点图、折线图和直方图。'
- en: 'Each matplotlib plot is represented by a `Figure` object, which is just the
    drawing surface. The graphs or charts we draw in a figure are called `Axes` (a
    questionable name due to similarity with “axis”) but it''s best to think of axes
    as subplots. Each figure has one or more subplots. Here is the basic template
    for creating a plot:'
  id: totrans-498
  prefs: []
  type: TYPE_NORMAL
  zh: 每个matplotlib图表都由一个`Figure`对象表示，它只是绘图表面。我们在图中绘制的图表或图形称为`Axes`（由于与“axis”相似，这个名字可能有些令人质疑），但最好将axes视为子图。每个图都有一个或多个子图。以下是创建图表的基本模板：
- en: '[PRE58]'
  id: totrans-499
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: 'Let''s use that template to create a scatterplot using the average apartment
    price for each number of bedrooms. First, we group the rent data in `df` by the
    number of bedrooms and ask for the average (mean). To plot bedrooms versus price,
    we use the `scatter` method of the `ax` subplot object:'
  id: totrans-500
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们使用这个模板来创建一个散点图，使用每个卧室数量的平均公寓价格。首先，我们将`df`中的租金数据按卧室数量分组，并请求平均值（均值）。要绘制卧室与价格的关系图，我们使用`ax`子图对象的`scatter`方法：
- en: » *Generated by code to left*
  id: totrans-501
  prefs: []
  type: TYPE_NORMAL
  zh: » 由代码生成的左侧
- en: '[![](../Images/5715ab1afb48423b0a716984d28a6042.png)](images/tools/tools_plt_2.svg)'
  id: totrans-502
  prefs: []
  type: TYPE_NORMAL
  zh: '[![](../Images/5715ab1afb48423b0a716984d28a6042.png)](images/tools/tools_plt_2.svg)'
- en: '[PRE59]'
  id: totrans-503
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: 'With some self explanatory methods, such as `set_xlabel()`, we can also set
    the X and Y axis labels. Drawing a line in between the points, instead of just
    a scatterplot, is done using method `plot()`:'
  id: totrans-504
  prefs: []
  type: TYPE_NORMAL
  zh: 通过一些自解释的方法，例如`set_xlabel()`，我们还可以设置X轴和Y轴的标签。在点之间画线，而不是仅仅散点图，可以使用`plot()`方法完成：
- en: » *Generated by code to left*
  id: totrans-505
  prefs: []
  type: TYPE_NORMAL
  zh: » 由代码生成的左侧
- en: '[![](../Images/1ecbf893230f7269da52ba3566334cf3.png)](images/tools/tools_plt_3.svg)'
  id: totrans-506
  prefs: []
  type: TYPE_NORMAL
  zh: '[![](../Images/1ecbf893230f7269da52ba3566334cf3.png)](images/tools/tools_plt_3.svg)'
- en: '[PRE60]'
  id: totrans-507
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: 'If we have a function to plot over some range, instead of data, we can still
    use `plot()`. The function provides the Y values, but we need to provide the X
    values. For example, let''s say we''d like to plot the log (base 10) function
    over the range 0.01 to 100\. To make it smooth, we should evaluate the log function
    at, say, 1000 points; NumPy''s `linspace()` works well to create the X values.
    Here''s the code to make the plot and label the axes:'
  id: totrans-508
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们有一个要在某个范围内绘制的函数，而不是数据，我们仍然可以使用`plot()`。函数提供Y值，但我们需要提供X值。例如，假设我们想绘制0.01到100的范围内的对数（以10为底）函数。为了使其平滑，我们应该在1000个点上评估对数函数；NumPy的`linspace()`非常适合创建X值。以下是绘制图表并标注轴的代码：
- en: » *Generated by code to left*
  id: totrans-509
  prefs: []
  type: TYPE_NORMAL
  zh: » 由代码生成的左侧
- en: '[![](../Images/02b01dd11db1f02842ecc46ae23df98a.png)](images/tools/tools_plt_4.svg)'
  id: totrans-510
  prefs: []
  type: TYPE_NORMAL
  zh: '[![](../Images/02b01dd11db1f02842ecc46ae23df98a.png)](images/tools/tools_plt_4.svg)'
- en: '[PRE61]'
  id: totrans-511
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: 'Creating a histogram from a dataFrame column is straightforward using the `hist()`
    method:'
  id: totrans-512
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`hist()`方法从DataFrame列创建直方图非常简单：
- en: » *Generated by code to left*
  id: totrans-513
  prefs: []
  type: TYPE_NORMAL
  zh: » 由代码生成的左侧
- en: '[![](../Images/8aae07f3d7279360d54f5b1372a34ace.png)](images/tools/tools_plt_5.svg)'
  id: totrans-514
  prefs: []
  type: TYPE_NORMAL
  zh: '[![](../Images/8aae07f3d7279360d54f5b1372a34ace.png)](images/tools/tools_plt_5.svg)'
- en: '[PRE62]'
  id: totrans-515
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: Such plots approximate the distribution of a variable and histograms are a very
    useful way to visualize columns with lots of data points. Here, we see that the
    average price is roughly $3000 and that there is a long “right tail” (with a few
    very expensive apartments).
  id: totrans-516
  prefs: []
  type: TYPE_NORMAL
  zh: 这样的图表近似表示变量的分布，直方图是可视化具有大量数据点的列的非常有用方式。在这里，我们看到平均价格大约是$3000，并且存在一个长的“右尾”（一些非常昂贵的公寓）。
- en: 'The last trick we''ll consider here is getting more than one plot into the
    same figure. Let''s take two of the previous graphs and put them side-by-side
    into a single figure. The code to generate the individual graphs is the same,
    except for the `Axes` object we use for plotting. Using the `subplots()` method,
    we can specify how many rows and columns of subplots we want, as well as the width
    and height (in inches) of the figure:'
  id: totrans-517
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在这里要考虑的最后一种技巧是将多个图表放入同一个图中。让我们将前两个图表并排放置到单个图中。生成单个图表的代码是相同的，只是我们用于绘图的`Axes`对象不同。使用`subplots()`方法，我们可以指定我们想要的子图行数和列数，以及图的大小（以英寸为单位）：
- en: '[PRE63]'
  id: totrans-518
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: '[![](../Images/da3916a4ddbf5437ba86795282efafe0.png)](images/tools/tools_plt_6.svg)'
  id: totrans-519
  prefs: []
  type: TYPE_NORMAL
  zh: '[![](../Images/da3916a4ddbf5437ba86795282efafe0.png)](images/tools/tools_plt_6.svg)'
- en: For some reason, matplotlib does not automatically adjust the space between
    subplots and so we generally have to call `plt.tight_layout()`, which tries to
    adjust the padding. Without that call, the plots overlap.
  id: totrans-520
  prefs: []
  type: TYPE_NORMAL
  zh: 由于某种原因，matplotlib不会自动调整子图之间的空间，所以我们通常需要调用`plt.tight_layout()`，它试图调整填充。如果没有这个调用，图表会重叠。
- en: There's one more library that you will encounter frequently in data science
    code, and that is Numpy. We've already used it for such things as creating random
    numbers and representing “not a number” (`np.nan`).
  id: totrans-521
  prefs: []
  type: TYPE_NORMAL
  zh: 在数据科学代码中，你还会遇到一个库，那就是Numpy。我们已经用它来创建随机数和表示“非数字”(`np.nan`)。
- en: 4.4 Representing and processing data with NumPy
  id: totrans-522
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 4.4 使用NumPy表示和处理数据
- en: Pandas dataframes are meant to represent tabular data with heterogeneous types,
    such as strings, dates, and numbers. [NumPy](http://www.NumPy.org/), on the other
    hand, is meant for performing mathematics on n-dimensional arrays of numbers.
    (See [NumPy quickstart](https://docs.scipy.org/doc/NumPy-1.15.1/user/quickstart.html).)
    The boundaries between pandas, matplotlib, NumPy, and sklearn are blurred because
    they have excellent interoperability. We can create dataframes from NumPy arrays
    and we can get arrays from pandas dataframes. Matplotlib and sklearn functions
    accept both pandas and NumPy objects, automatically doing any necessary conversions
    between datatypes.
  id: totrans-523
  prefs: []
  type: TYPE_NORMAL
  zh: Pandas数据框旨在表示具有异构类型的表格数据，例如字符串、日期和数字。[NumPy](http://www.NumPy.org/)另一方面，旨在对数字的n维数组执行数学运算。（见[NumPy快速入门](https://docs.scipy.org/doc/NumPy-1.15.1/user/quickstart.html)。）pandas、matplotlib、NumPy和sklearn之间的界限变得模糊，因为它们具有出色的互操作性。我们可以从NumPy数组创建数据框，也可以从pandas数据框获取数组。Matplotlib和sklearn函数接受pandas和NumPy对象，自动执行任何必要的类型转换。
- en: The fundamental data type in NumPy is the `np.ndarray`, which is an n-dimensional
    array data structure. A 1D `ndarray` is just a vector that looks just like a list
    of numbers. A 2D `ndarray` is a matrix that looks like a list of lists of numbers.
    Naturally, a 3D `ndarray` is a rectangular volume of numbers (list of matrices),
    and so on. The underlying implementation is highly optimized C code and NumPy
    operations are much faster than doing the equivalent loops in Python code. The
    downside is that we have yet more library functions and objects to learn about
    and remember.
  id: totrans-524
  prefs: []
  type: TYPE_NORMAL
  zh: NumPy的基本数据类型是`np.ndarray`，它是一个n维数组数据结构。一个1D `ndarray`就是一个看起来像数字列表的向量。一个2D `ndarray`是一个看起来像数字列表列表的矩阵。自然地，一个3D
    `ndarray`是一个数字的矩形体积（矩阵列表），以此类推。其底层实现是高度优化的C代码，NumPy操作比在Python代码中执行等效循环要快得多。缺点是我们还有更多需要学习和记忆的库函数和对象。
- en: 'Let''s start by creating a one dimensional vector of numbers. While the underlying
    data structure is of type `ndarray`, the constructor is `array()`:'
  id: totrans-525
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从创建一个数字的一维向量开始。虽然底层数据结构是`ndarray`类型，但构造函数是`array()`：
- en: '[PRE64]'
  id: totrans-526
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: type is <class 'numpy.ndarray'> dtype is int64 ndim is 1 [1 2 3 4 5]
  id: totrans-527
  prefs: []
  type: TYPE_NORMAL
  zh: 类型是 <class 'numpy.ndarray'> 数据类型是 int64 维数是 1 [1 2 3 4 5]
- en: 'By default, the array has 64-bit integers, but we can use smaller integers
    if we want:'
  id: totrans-528
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，数组使用64位整数，但如果我们想使用更小的整数，也可以：
- en: '[PRE65]'
  id: totrans-529
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: int8 [1 2 3 4 5]
  id: totrans-530
  prefs: []
  type: TYPE_NORMAL
  zh: int8 [1 2 3 4 5]
- en: 'To initialize a vector of zeros, we call `zeros` with a tuple or list representing
    the shape of the array we want. In this case, let''s say we want five integer
    zeros:'
  id: totrans-531
  prefs: []
  type: TYPE_NORMAL
  zh: 要初始化一个零向量，我们调用`zeros`函数，并传递一个表示我们想要数组的形状的元组或列表。在这种情况下，假设我们想要五个整数零：
- en: '[PRE66]'
  id: totrans-532
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: '[0 0 0 0 0]'
  id: totrans-533
  prefs: []
  type: TYPE_NORMAL
  zh: '[0 0 0 0 0]'
- en: 2We could also use Python tuple syntax, `(5,)`, but that syntax for a tuple
    with a single element is a bit awkward. `(5)` evaluates to just `5` in Python,
    so the Python language designers defined `(5,)` to mean a single-element tuple.
    If you ask for `a.shape` on some 1D array `a`, you'll get `(5,)` not `[5]`.
  id: totrans-534
  prefs: []
  type: TYPE_NORMAL
  zh: 2我们也可以使用Python元组语法，`(5,)`，但这个单元素元组的语法有点尴尬。`(5)`在Python中仅评估为`5`，因此Python语言设计者定义了`(5,)`来表示单元素元组。如果你在某个一维数组`a`上请求`a.shape`，你会得到`(5,)`而不是`[5]`。
- en: Shape information is always a list or a tuple of length n for an n-dimensional
    array. Each element in the shape specification is the number of elements in that
    dimension. In this case, we want a one-dimensional array with five elements so
    we use shape `[5]`.2
  id: totrans-535
  prefs: []
  type: TYPE_NORMAL
  zh: 形状信息对于n维数组始终是一个长度为n的列表或元组。形状规范中的每个元素是该维度的元素数量。在这种情况下，我们想要一个包含五个元素的向量，所以我们使用形状`[5]`。2
- en: 'Similarly, here''s how to initialize an array with ones:'
  id: totrans-536
  prefs: []
  type: TYPE_NORMAL
  zh: 类似地，以下是初始化全为1的数组的方法：
- en: '[PRE67]'
  id: totrans-537
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: '[1\. 1\. 1\. 1\. 1.]'
  id: totrans-538
  prefs: []
  type: TYPE_NORMAL
  zh: '[1. 1. 1. 1. 1.]'
- en: 'The equivalent to Python''s `range` function is `arange()`:'
  id: totrans-539
  prefs: []
  type: TYPE_NORMAL
  zh: Python的`range`函数的等价函数是`arange()`：
- en: '[PRE68]'
  id: totrans-540
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: '[ 1 2 3 4 5 6 7 8 9 10]'
  id: totrans-541
  prefs: []
  type: TYPE_NORMAL
  zh: '[ 1 2 3 4 5 6 7 8 9 10]'
- en: 'When creating a sequence of evenly spaced floating-point numbers, use `linspace`
    (as we did above to create values between 0.1 and 100 to plot the log function).
    Here''s how to create 6 values from 1 to 2, inclusively:'
  id: totrans-542
  prefs: []
  type: TYPE_NORMAL
  zh: 当创建一个等间距的浮点数序列时，使用`linspace`（就像我们上面创建0.1到100之间的值来绘制对数函数那样）。以下是创建从1到2（包括2）的6个值的方法：
- en: '[PRE69]'
  id: totrans-543
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: '[1\. 1.2 1.4 1.6 1.8 2\. ]'
  id: totrans-544
  prefs: []
  type: TYPE_NORMAL
  zh: '[1. 1.2 1.4 1.6 1.8 2. ]'
- en: 'Using raw Python, we can add two lists of numbers together to get a third very
    easily, but for long lists speed could be an issue. Delegating vector addition,
    multiplication, and other arithmetic operators to NumPy gives a massive performance
    boost. Besides, data scientists need to get use to doing arithmetic with vectors
    (and matrices) instead of atomic numbers. Here are a few common vector operations
    performed on 1D arrays:'
  id: totrans-545
  prefs: []
  type: TYPE_NORMAL
  zh: 使用原始 Python，我们可以轻松地将两个数字列表相加以得到第三个列表，但对于长列表，速度可能成为问题。将向量加法、乘法和其他算术运算符委托给 NumPy
    可以大幅提升性能。此外，数据科学家需要习惯于用向量（和矩阵）而不是原子数进行算术运算。以下是在一维数组上执行的一些常见向量操作：
- en: '[PRE70]'
  id: totrans-546
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: '[1 2 3 4 5] + [1 2 3 4 5] = [ 2 4 6 8 10] [1 2 3 4 5] - [1\. 1\. 1\. 1\. 1.]
    = [0\. 1\. 2\. 3\. 4.] [1 2 3 4 5] * [0 0 0 0 0] = [0 0 0 0 0] np.dot([1 2 3 4
    5], [1 2 3 4 5]) = 55'
  id: totrans-547
  prefs: []
  type: TYPE_NORMAL
  zh: '[1 2 3 4 5] + [1 2 3 4 5] = [ 2 4 6 8 10] [1 2 3 4 5] - [1. 1. 1. 1. 1.] =
    [0. 1. 2. 3. 4.] [1 2 3 4 5] * [0 0 0 0 0] = [0 0 0 0 0] np.dot([1 2 3 4 5], [1
    2 3 4 5]) = 55'
- en: '**How operator overloading works**'
  id: totrans-548
  prefs: []
  type: TYPE_NORMAL
  zh: '**操作符重载的工作原理**'
- en: 'Python supports *operator overloading*, which allows libraries to define how
    the standard arithmetic operators (and others) behave when applied to custom objects.
    The basic idea is that Python implements the plus operator, as in `a+b`, by translating
    it to `a.__add__(b)`. If `a` is an instance of a class definition you control,
    you can override the `__add__()` method to implement what addition means for your
    class. Here''s a simple one dimensional vector class definition that illustrates
    how to overload `+` to mean vector addition:'
  id: totrans-549
  prefs: []
  type: TYPE_NORMAL
  zh: Python 支持操作符重载，这允许库定义标准算术运算符（以及其他运算符）在应用于自定义对象时的行为。基本思想是 Python 通过将其转换为 `a.__add__(b)`
    来实现加法运算符，例如 `a+b`。如果 `a` 是你控制的类定义的一个实例，你可以重写 `__add__()` 方法来实现你类中的加法意义。以下是一个简单的一维向量类定义，展示了如何重载
    `+` 来表示向量加法：
- en: '[PRE71]'
  id: totrans-550
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: '[4, 6, 8] [4, 6, 8]'
  id: totrans-551
  prefs: []
  type: TYPE_NORMAL
  zh: '[4, 6, 8] [4, 6, 8]'
- en: 'Aside from the arithmetic operators, there are lots of [common mathematical
    functions](https://docs.scipy.org/doc/numpy-1.15.0/reference/routines.math.html)
    we can apply directly to arrays without resorting to Python loops:'
  id: totrans-552
  prefs: []
  type: TYPE_NORMAL
  zh: 除了算术运算符之外，还有很多[常用数学函数](https://docs.scipy.org/doc/numpy-1.15.0/reference/routines.math.html)，我们可以直接应用于数组，而无需求助于
    Python 循环：
- en: '[PRE72]'
  id: totrans-553
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: '[1.09861229 1.94591015 2.19722458 2.19722458 0.69314718] 6.0 9 30'
  id: totrans-554
  prefs: []
  type: TYPE_NORMAL
  zh: '[1.09861229 1.94591015 2.19722458 2.19722458 0.69314718] 6.0 9 30'
- en: 'The expression `np.log(prices)` is equivalent to the following loop and array
    constructor, but the loop is much slower:'
  id: totrans-555
  prefs: []
  type: TYPE_NORMAL
  zh: 表达式 `np.log(prices)` 等价于以下循环和数组构造器，但循环要慢得多：
- en: '[PRE73]'
  id: totrans-556
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: We ran a simple test to compare the speed of `np.log(prices)` on 50M random
    numbers versus `np.log` on a single number via the Python loop. NumPy takes half
    a second but the Python loop takes over a minute. That's why it's important to
    learn how to use these libraries, because using straightforward loops is usually
    too slow for big data sets.
  id: totrans-557
  prefs: []
  type: TYPE_NORMAL
  zh: 我们进行了一个简单的测试，比较了 `np.log(prices)` 在 50M 随机数上的速度与通过 Python 循环对单个数字进行 `np.log`
    操作的速度。NumPy 需要 0.5 秒，但 Python 循环需要超过 1 分钟。这就是为什么学习如何使用这些库很重要，因为使用简单的循环通常对于大数据集来说太慢了。
- en: 'Now, let''s move on to matrices, two dimensional arrays. Using the same `array()`
    constructor, we can pass in a list of lists of numbers. Here is the code to create
    two 4 row x 5 column matrices, `t` and `u`, and print out information about matrix
    `t`:'
  id: totrans-558
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们转向矩阵，二维数组。使用相同的 `array()` 构造函数，我们可以传入数字的列表的列表。以下是创建两个 4 行 5 列矩阵 `t` 和
    `u` 并打印矩阵 `t` 信息的代码：
- en: '[PRE74]'
  id: totrans-559
  prefs: []
  type: TYPE_PRE
  zh: '[PRE74]'
- en: type is <class 'numpy.ndarray'> dtype is int64 ndim is 2 shape is (4, 5) [[1
    1 1 1 1] [0 0 1 0 0] [0 0 1 0 0] [0 0 1 0 0]]
  id: totrans-560
  prefs: []
  type: TYPE_NORMAL
  zh: 类型是 <class 'numpy.ndarray'> 数据类型是 int64 维数是 2 形状是 (4, 5) [[1 1 1 1 1] [0 0 1
    0 0] [0 0 1 0 0] [0 0 1 0 0]]
- en: 'As another example of matplotlib, let''s treat those matrice as two-dimensional
    images and display them using method `imshow()` (image show):'
  id: totrans-561
  prefs: []
  type: TYPE_NORMAL
  zh: 作为 matplotlib 的另一个例子，让我们将这些矩阵视为二维图像，并使用 `imshow()` 方法（图像显示）来显示它们：
- en: » *Generated by code to left*
  id: totrans-562
  prefs: []
  type: TYPE_NORMAL
  zh: '> *由代码生成左侧内容*'
- en: '[![](../Images/c0d6d9971d9d81abb7346d1758da422c.png)](images/tools/tools_np_11.svg)'
  id: totrans-563
  prefs: []
  type: TYPE_NORMAL
  zh: '![图片](../Images/c0d6d9971d9d81abb7346d1758da422c.png)(images/tools/tools_np_11.svg)'
- en: '[PRE75]'
  id: totrans-564
  prefs: []
  type: TYPE_PRE
  zh: '[PRE75]'
- en: 'There are also built-in functions to create matrices of zeros:'
  id: totrans-565
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，还有一些内置函数可以创建零矩阵：
- en: '[PRE76]'
  id: totrans-566
  prefs: []
  type: TYPE_PRE
  zh: '[PRE76]'
- en: '[[0\. 0\. 0\. 0.] [0\. 0\. 0\. 0.] [0\. 0\. 0\. 0.]]'
  id: totrans-567
  prefs: []
  type: TYPE_NORMAL
  zh: '[[0. 0. 0. 0.] [0. 0. 0. 0.] [0. 0. 0. 0.]]'
- en: 'and random numbers, among others:'
  id: totrans-568
  prefs: []
  type: TYPE_NORMAL
  zh: 以及随机数等：
- en: '[PRE77]'
  id: totrans-569
  prefs: []
  type: TYPE_PRE
  zh: '[PRE77]'
- en: '[[0.51437402 0.46566841 0.20536907] [0.82139522 0.11044102 0.66979215]]'
  id: totrans-570
  prefs: []
  type: TYPE_NORMAL
  zh: '[[0.51437402 0.46566841 0.20536907] [0.82139522 0.11044102 0.66979215]]'
- en: 'Indexing 1D NumPy arrays works like Python array indexing with integer indexes
    and slicing, but NumPy arrays also support queries and list of indices, as we''ll
    seen shortly. Here are some examples of 1D indexing:'
  id: totrans-571
  prefs: []
  type: TYPE_NORMAL
  zh: 1维NumPy数组的索引与Python数组索引的整数索引和切片类似，但NumPy数组还支持查询和索引列表，我们将在稍后看到。以下是一些1维索引的示例：
- en: '[PRE78]'
  id: totrans-572
  prefs: []
  type: TYPE_PRE
  zh: '[PRE78]'
- en: '[1 2 3 4 5] 1 5 [2 3] [3 5]'
  id: totrans-573
  prefs: []
  type: TYPE_NORMAL
  zh: '[1 2 3 4 5] 1 5 [2 3] [3 5]'
- en: 'For matrices, NumPy indexing is very similar to pandas `iloc` indexing. Here
    are some examples:'
  id: totrans-574
  prefs: []
  type: TYPE_NORMAL
  zh: 对于矩阵，NumPy索引与pandas `iloc`索引非常相似。以下是一些示例：
- en: '[PRE79]'
  id: totrans-575
  prefs: []
  type: TYPE_PRE
  zh: '[PRE79]'
- en: '[1 1 1 1 1] [1 1 1 1] 0 [[1 1 1 1 1] [0 0 1 0 0]] [[1 1] [0 1] [0 1] [0 1]]'
  id: totrans-576
  prefs: []
  type: TYPE_NORMAL
  zh: '[1 1 1 1 1] [1 1 1 1] 0 [[1 1 1 1 1] [0 0 1 0 0]] [[1 1] [0 1] [0 1] [0 1]]'
- en: 'As with pandas, we can perform queries to filter NumPy arrays. The comparison
    operators return a list of boolean values, one for each element of the array:'
  id: totrans-577
  prefs: []
  type: TYPE_NORMAL
  zh: 与pandas类似，我们可以对NumPy数组执行查询以进行过滤。比较运算符返回一个布尔值列表，每个值对应数组中的一个元素：
- en: '[PRE80]'
  id: totrans-578
  prefs: []
  type: TYPE_PRE
  zh: '[PRE80]'
- en: '[0.63507935 0.51535146 0.34574814 0.38985047 0.92781766] [ True True True True
    True]'
  id: totrans-579
  prefs: []
  type: TYPE_NORMAL
  zh: '[0.63507935 0.51535146 0.34574814 0.38985047 0.92781766] [ True True True True
    True]'
- en: 'We can then use that array of booleans to index into that array, or even another
    array of the same length:'
  id: totrans-580
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们可以使用布尔数组来索引该数组，甚至另一个相同长度的数组：
- en: '[PRE81]'
  id: totrans-581
  prefs: []
  type: TYPE_PRE
  zh: '[PRE81]'
- en: '[1 2 3 4 5]'
  id: totrans-582
  prefs: []
  type: TYPE_NORMAL
  zh: '[1 2 3 4 5]'
- en: 'As with one dimensional arrays, vectors, the NumPy defines the arithmetic operators
    for matrices. For example, here''s how to add and print out two matrices:'
  id: totrans-583
  prefs: []
  type: TYPE_NORMAL
  zh: 与一维数组、向量类似，NumPy为矩阵定义了算术运算符。例如，以下是添加并打印两个矩阵的方法：
- en: '[PRE82]'
  id: totrans-584
  prefs: []
  type: TYPE_PRE
  zh: '[PRE82]'
- en: '[[2 1 1 1 2] [1 0 1 0 1] [1 0 1 0 1] [1 1 2 1 1]]'
  id: totrans-585
  prefs: []
  type: TYPE_NORMAL
  zh: '[[2 1 1 1 2] [1 0 1 0 1] [1 0 1 0 1] [1 1 2 1 1]]'
- en: 'If we make an array of matrices, we get a 3D array:'
  id: totrans-586
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们创建一个矩阵数组，我们得到一个3维数组：
- en: '[PRE83]'
  id: totrans-587
  prefs: []
  type: TYPE_PRE
  zh: '[PRE83]'
- en: type is <class 'numpy.ndarray'> dtype is int64 ndim is 3 [[[1 1 1 1 1] [0 0
    1 0 0] [0 0 1 0 0] [0 0 1 0 0]] [[1 0 0 0 1] [1 0 0 0 1] [1 0 0 0 1] [1 1 1 1
    1]]]
  id: totrans-588
  prefs: []
  type: TYPE_NORMAL
  zh: 类型是 <class 'numpy.ndarray'>，数据类型是 int64，维度是 3，结构如下：
- en: 'Sometimes, we''d like to go the opposite direction and unravel (ravel is a
    synonym) flatten a multidimensional array. Imagine we''d like to process every
    element of the matrix. We could use nested loops that iterated over the rows and
    columns, but it''s easier to use a single loop over a flattened, 1D version of
    the matrix. For example, here is how to sum up the elements of matrix `u`:'
  id: totrans-589
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，我们可能希望走相反的方向，将多维数组展开（`ravel`是展开的同义词）。想象一下，我们想要处理矩阵中的每个元素。我们可以使用嵌套循环遍历行和列，但使用单个循环遍历矩阵的扁平化、1维版本更容易。例如，以下是计算矩阵`u`元素总和的方法：
- en: '[PRE84]'
  id: totrans-590
  prefs: []
  type: TYPE_PRE
  zh: '[PRE84]'
- en: '11'
  id: totrans-591
  prefs: []
  type: TYPE_NORMAL
  zh: '11'
- en: The `flat` property is an iterator that is more space efficient than iterating
    over `u.ravel()`, which is an actual 1D array of the matrix elements. If you don't
    need a physical list, just iterate using the `flat` iterator.
  id: totrans-592
  prefs: []
  type: TYPE_NORMAL
  zh: '`flat`属性是一个比遍历`u.ravel()`（`u.ravel()`是矩阵元素的1维数组）更节省空间的迭代器。如果你不需要物理列表，只需使用`flat`迭代器进行迭代。'
- en: '[PRE85]'
  id: totrans-593
  prefs: []
  type: TYPE_PRE
  zh: '[PRE85]'
- en: 11 [1 0 0 0 1 1 0 0 0 1 1 0 0 0 1 1 1 1 1 1]
  id: totrans-594
  prefs: []
  type: TYPE_NORMAL
  zh: 11 [1 0 0 0 1 1 0 0 0 1 1 0 0 0 1 1 1 1 1 1]
- en: 'To iterate through the rows of a matrix instead of the individual elements,
    use the matrix itself as an iterator:'
  id: totrans-595
  prefs: []
  type: TYPE_NORMAL
  zh: 要遍历矩阵的行而不是单个元素，可以使用矩阵本身作为迭代器：
- en: '[PRE86]'
  id: totrans-596
  prefs: []
  type: TYPE_PRE
  zh: '[PRE86]'
- en: '0: [1 1 1 1 1] 1: [0 0 1 0 0] 2: [0 0 1 0 0] 3: [0 0 1 0 0]'
  id: totrans-597
  prefs: []
  type: TYPE_NORMAL
  zh: '0: [1 1 1 1 1] 1: [0 0 1 0 0] 2: [0 0 1 0 0] 3: [0 0 1 0 0]'
- en: NumPy has a general method for reshaping n-dimensional arrays. The arguments
    of the method indicate the number of dimensions and how many elements there are
    in each dimension.
  id: totrans-598
  prefs: []
  type: TYPE_NORMAL
  zh: NumPy有一个用于重塑n维数组的通用方法。该方法参数表示维数的数量以及每个维度中的元素数量。
- en: '[PRE87]'
  id: totrans-599
  prefs: []
  type: TYPE_PRE
  zh: '[PRE87]'
- en: 4x3 [[ 1 2 3] [ 4 5 6] [ 7 8 9] [10 11 12]] 3x4 [[ 1 2 3 4] [ 5 6 7 8] [ 9 10
    11 12]] 2x6 [[ 1 2 3 4 5 6] [ 7 8 9 10 11 12]]
  id: totrans-600
  prefs: []
  type: TYPE_NORMAL
  zh: 4x3 [[ 1 2 3] [ 4 5 6] [ 7 8 9] [10 11 12]] 3x4 [[ 1 2 3 4] [ 5 6 7 8] [ 9 10
    11 12]] 2x6 [[ 1 2 3 4 5 6] [ 7 8 9 10 11 12]]
- en: 'One of the dimension arguments can be -1, which is kind of a wildcard. Given
    the total number of values in the array and n-1 dimensions, NumPy can''t figure
    out the ![](../Images/ec8222a98c9d0ccfdb864e5b882f3f4f.png) dimension. It''s very
    convenient when we know how many rows or how many columns we want because we don''t
    have to compute the other dimension size. Here''s how to create a matrix with
    4 rows and a matrix with 2 columns using the same data:'
  id: totrans-601
  prefs: []
  type: TYPE_NORMAL
  zh: 一个维度参数可以是-1，这有点像占位符。给定数组中的总值数和n-1个维度，NumPy无法确定剩余的维度。当我们知道需要多少行或列时，这非常方便，因为我们不需要计算其他维度的尺寸。以下是使用相同数据创建4行矩阵和2列矩阵的方法：
- en: '[PRE88]'
  id: totrans-602
  prefs: []
  type: TYPE_PRE
  zh: '[PRE88]'
- en: 4x? [[ 1 2 3] [ 4 5 6] [ 7 8 9] [10 11 12]] ?x2 [[ 1 2] [ 3 4] [ 5 6] [ 7 8]
    [ 9 10] [11 12]]
  id: totrans-603
  prefs: []
  type: TYPE_NORMAL
  zh: 4x? [[ 1 2 3] [ 4 5 6] [ 7 8 9] [10 11 12]] ?x2 [[ 1 2] [ 3 4] [ 5 6] [ 7 8]
    [ 9 10] [11 12]]
- en: 'The `reshape` method comes in handy when we''d like to run a single test vector
    through a machine learning model. Let''s train a random forest regressor model
    on the `rent-idea.csv` data using `price` as the target variable:'
  id: totrans-604
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们想要将单个测试向量通过机器学习模型时，`reshape`方法就派上用场了。让我们使用`price`作为目标变量，在`rent-idea.csv`数据上训练一个随机森林回归器模型：
- en: '[PRE89]'
  id: totrans-605
  prefs: []
  type: TYPE_PRE
  zh: '[PRE89]'
- en: And, here's a test vector describing an apartment for which we'd like a predicted
    price. The sklearn `predict()` method is expecting a matrix of test vectors, rather
    than a single test vector.
  id: totrans-606
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，这里有一个描述我们想要预测价格的公寓的测试向量。sklearn的`predict()`方法期望一个测试向量矩阵，而不是单个测试向量。
- en: '[PRE90]'
  id: totrans-607
  prefs: []
  type: TYPE_PRE
  zh: '[PRE90]'
- en: 'If we try sending the test vector in, `rf.predict(test_vector)`, we get error:'
  id: totrans-608
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们尝试传入测试向量，`rf.predict(test_vector)`，我们会得到错误：
- en: '[PRE91]'
  id: totrans-609
  prefs: []
  type: TYPE_PRE
  zh: '[PRE91]'
- en: 'There''s a big difference between a 1D vector and 2D matrix with one row (or
    column). Since sklearn is expecting a matrix, we need to send in a matrix with
    a single row and we can conveniently convert the test vector into a matrix with
    one row using `reshape(1,-1)`:'
  id: totrans-610
  prefs: []
  type: TYPE_NORMAL
  zh: 一维向量和一维矩阵（只有一行或一列）之间有很大的区别。由于sklearn期望一个矩阵，我们需要传入一个单行的矩阵，我们可以方便地将测试向量转换为单行矩阵，使用`reshape(1,-1)`：
- en: '[PRE92]'
  id: totrans-611
  prefs: []
  type: TYPE_PRE
  zh: '[PRE92]'
- en: '[[ 2\. 1\. 40.7947 -73.9957]] -> [4873.48418398]'
  id: totrans-612
  prefs: []
  type: TYPE_NORMAL
  zh: '[[ 2\. 1\. 40.7947 -73.9957]] -> [4873.48418398]'
- en: Notice that we also get a vector of predictions (with one element) back because
    `predict()` is designed to map multiple test vectors to multiple predictions.
  id: totrans-613
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，我们同样会得到一个预测向量（只有一个元素），因为`predict()`函数被设计成将多个测试向量映射到多个预测结果。
- en: 'Let''s finish up our discussion of NumPy by looking at how to extract NumPy
    arrays from pandas dataframes. Given a dataframe or column, use the `values` dataframe
    property to obtain the data in a NumPy array. Here are some examples using the
    rent data in `df`:'
  id: totrans-614
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过查看如何从pandas数据框中提取NumPy数组来结束对NumPy的讨论。给定一个数据框或列，使用`values`数据框属性以NumPy数组的形式获取数据。以下是一些使用`df`中的租金数据的示例：
- en: '[PRE93]'
  id: totrans-615
  prefs: []
  type: TYPE_PRE
  zh: '[PRE93]'
- en: '[3000 5465 2850 ... 2595 3350 2200]'
  id: totrans-616
  prefs: []
  type: TYPE_NORMAL
  zh: '[3000 5465 2850 ... 2595 3350 2200]'
- en: '[PRE94]'
  id: totrans-617
  prefs: []
  type: TYPE_PRE
  zh: '[PRE94]'
- en: '[ 3.00000e+00 1.50000e+00 4.07145e+01 -7.39425e+01 3.00000e+03]'
  id: totrans-618
  prefs: []
  type: TYPE_NORMAL
  zh: '[ 3.00000e+00 1.50000e+00 4.07145e+01 -7.39425e+01 3.00000e+03]'
- en: '[PRE95]'
  id: totrans-619
  prefs: []
  type: TYPE_PRE
  zh: '[PRE95]'
- en: '[[3\. 1.5] [2\. 1\. ] [1\. 1\. ] ... [1\. 1\. ] [0\. 1\. ] [2\. 1\. ]]'
  id: totrans-620
  prefs: []
  type: TYPE_NORMAL
  zh: '[[3\. 1.5] [2\. 1\. ] [1\. 1\. ] ... [1\. 1\. ] [0\. 1\. ] [2\. 1\. ]]'
- en: That wraps up our whirlwind tour of the key libraries, pandas, matplotlib, and
    NumPy. Let's apply them to some machine learning problems. In the next chapter,
    we're going to re-examine the apartment data set used in **Chapter 3** *A First
    Taste of Applied Machine Learning* to train a regressor model, but this time using
    the original data set. The original data has a number of issues that prevent us
    from immediately using it to train a model and get good results. We have to explore
    the data and do some preprocessing before training a model.
  id: totrans-621
  prefs: []
  type: TYPE_NORMAL
  zh: 这就结束了我们对关键库的快速浏览，包括pandas、matplotlib和NumPy。让我们将它们应用到一些机器学习问题中。在下一章中，我们将重新审视**第三章**
    *应用机器学习的初尝* 中使用的公寓数据集，以训练一个回归器模型，但这次使用原始数据集。原始数据存在一些问题，阻止我们立即使用它来训练模型并获得良好的结果。在训练模型之前，我们必须探索数据并进行一些预处理。
